"use strict";
(self["webpackJsonp"] = self["webpackJsonp"] || []).push([["vendors-node_modules_taro_h5_prebundle_chunk-WC6TXELB_js"],{

/***/ "./node_modules/.taro/h5/prebundle/chunk-WC6TXELB.js":
/*!***********************************************************!*\
  !*** ./node_modules/.taro/h5/prebundle/chunk-WC6TXELB.js ***!
  \***********************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Behavior: function() { return /* binding */ Behavior2; },
/* harmony export */   Current: function() { return /* binding */ Current2; },
/* harmony export */   ENV_TYPE: function() { return /* binding */ ENV_TYPE2; },
/* harmony export */   Events: function() { return /* binding */ Events2; },
/* harmony export */   Link: function() { return /* binding */ Link3; },
/* harmony export */   NodesRef: function() { return /* binding */ NodesRef; },
/* harmony export */   SocketTask: function() { return /* binding */ SocketTask; },
/* harmony export */   addCard: function() { return /* binding */ addCard; },
/* harmony export */   addFileToFavorites: function() { return /* binding */ addFileToFavorites; },
/* harmony export */   addInterceptor: function() { return /* binding */ addInterceptor; },
/* harmony export */   addPhoneCalendar: function() { return /* binding */ addPhoneCalendar; },
/* harmony export */   addPhoneContact: function() { return /* binding */ addPhoneContact; },
/* harmony export */   addPhoneRepeatCalendar: function() { return /* binding */ addPhoneRepeatCalendar; },
/* harmony export */   addRecentColorSign: function() { return /* binding */ addRecentColorSign; },
/* harmony export */   addVideoToFavorites: function() { return /* binding */ addVideoToFavorites; },
/* harmony export */   advancedGeneralIdentify: function() { return /* binding */ advancedGeneralIdentify; },
/* harmony export */   animalClassify: function() { return /* binding */ animalClassify; },
/* harmony export */   applyAddToMyApps: function() { return /* binding */ applyAddToMyApps; },
/* harmony export */   arrayBufferToBase64: function() { return /* binding */ arrayBufferToBase64; },
/* harmony export */   authPrivateMessage: function() { return /* binding */ authPrivateMessage; },
/* harmony export */   authorize: function() { return /* binding */ authorize; },
/* harmony export */   authorizeForMiniProgram: function() { return /* binding */ authorizeForMiniProgram; },
/* harmony export */   base64ToArrayBuffer: function() { return /* binding */ base64ToArrayBuffer; },
/* harmony export */   batchGetStorage: function() { return /* binding */ batchGetStorage; },
/* harmony export */   batchGetStorageSync: function() { return /* binding */ batchGetStorageSync; },
/* harmony export */   batchSetStorage: function() { return /* binding */ batchSetStorage; },
/* harmony export */   batchSetStorageSync: function() { return /* binding */ batchSetStorageSync; },
/* harmony export */   canIUse: function() { return /* binding */ canIUse; },
/* harmony export */   canIUseWebp: function() { return /* binding */ canIUseWebp; },
/* harmony export */   canvasGetImageData: function() { return /* binding */ canvasGetImageData; },
/* harmony export */   canvasPutImageData: function() { return /* binding */ canvasPutImageData; },
/* harmony export */   canvasToTempFilePath: function() { return /* binding */ canvasToTempFilePath; },
/* harmony export */   carClassify: function() { return /* binding */ carClassify; },
/* harmony export */   checkIsAddedToMyMiniProgram: function() { return /* binding */ checkIsAddedToMyMiniProgram; },
/* harmony export */   checkIsOpenAccessibility: function() { return /* binding */ checkIsOpenAccessibility; },
/* harmony export */   checkIsPictureInPictureActive: function() { return /* binding */ checkIsPictureInPictureActive; },
/* harmony export */   checkIsSoterEnrolledInDevice: function() { return /* binding */ checkIsSoterEnrolledInDevice; },
/* harmony export */   checkIsSupportFacialRecognition: function() { return /* binding */ checkIsSupportFacialRecognition; },
/* harmony export */   checkIsSupportSoterAuthentication: function() { return /* binding */ checkIsSupportSoterAuthentication; },
/* harmony export */   checkSession: function() { return /* binding */ checkSession; },
/* harmony export */   chooseAddress: function() { return /* binding */ chooseAddress; },
/* harmony export */   chooseContact: function() { return /* binding */ chooseContact; },
/* harmony export */   chooseImage: function() { return /* binding */ chooseImage; },
/* harmony export */   chooseInvoice: function() { return /* binding */ chooseInvoice; },
/* harmony export */   chooseInvoiceTitle: function() { return /* binding */ chooseInvoiceTitle; },
/* harmony export */   chooseLicensePlate: function() { return /* binding */ chooseLicensePlate; },
/* harmony export */   chooseLocation: function() { return /* binding */ chooseLocation; },
/* harmony export */   chooseMedia: function() { return /* binding */ chooseMedia; },
/* harmony export */   chooseMessageFile: function() { return /* binding */ chooseMessageFile; },
/* harmony export */   choosePoi: function() { return /* binding */ choosePoi; },
/* harmony export */   chooseVideo: function() { return /* binding */ chooseVideo; },
/* harmony export */   cleanInterceptors: function() { return /* binding */ cleanInterceptors; },
/* harmony export */   clearStorage: function() { return /* binding */ clearStorage; },
/* harmony export */   clearStorageSync: function() { return /* binding */ clearStorageSync; },
/* harmony export */   closeBLEConnection: function() { return /* binding */ closeBLEConnection; },
/* harmony export */   closeBluetoothAdapter: function() { return /* binding */ closeBluetoothAdapter; },
/* harmony export */   closeSocket: function() { return /* binding */ closeSocket; },
/* harmony export */   cloud: function() { return /* binding */ cloud; },
/* harmony export */   compressImage: function() { return /* binding */ compressImage; },
/* harmony export */   compressVideo: function() { return /* binding */ compressVideo; },
/* harmony export */   connectSocket: function() { return /* binding */ connectSocket; },
/* harmony export */   connectWifi: function() { return /* binding */ connectWifi; },
/* harmony export */   createAnimation: function() { return /* binding */ createAnimation; },
/* harmony export */   createAudioContext: function() { return /* binding */ createAudioContext; },
/* harmony export */   createBLEConnection: function() { return /* binding */ createBLEConnection; },
/* harmony export */   createBLEPeripheralServer: function() { return /* binding */ createBLEPeripheralServer; },
/* harmony export */   createBrowserHistory: function() { return /* binding */ createBrowserHistory; },
/* harmony export */   createBufferURL: function() { return /* binding */ createBufferURL; },
/* harmony export */   createCacheManager: function() { return /* binding */ createCacheManager; },
/* harmony export */   createCameraContext: function() { return /* binding */ createCameraContext; },
/* harmony export */   createCanvasContext: function() { return /* binding */ createCanvasContext; },
/* harmony export */   createHashHistory: function() { return /* binding */ createHashHistory; },
/* harmony export */   createInferenceSession: function() { return /* binding */ createInferenceSession; },
/* harmony export */   createInnerAudioContext: function() { return /* binding */ createInnerAudioContext; },
/* harmony export */   createIntersectionObserver: function() { return /* binding */ createIntersectionObserver; },
/* harmony export */   createInterstitialAd: function() { return /* binding */ createInterstitialAd; },
/* harmony export */   createLivePlayerContext: function() { return /* binding */ createLivePlayerContext; },
/* harmony export */   createLivePusherContext: function() { return /* binding */ createLivePusherContext; },
/* harmony export */   createMapContext: function() { return /* binding */ createMapContext; },
/* harmony export */   createMediaAudioPlayer: function() { return /* binding */ createMediaAudioPlayer; },
/* harmony export */   createMediaContainer: function() { return /* binding */ createMediaContainer; },
/* harmony export */   createMediaQueryObserver: function() { return /* binding */ createMediaQueryObserver; },
/* harmony export */   createMediaRecorder: function() { return /* binding */ createMediaRecorder; },
/* harmony export */   createMpaHistory: function() { return /* binding */ createMpaHistory; },
/* harmony export */   createMultiRouter: function() { return /* binding */ createMultiRouter; },
/* harmony export */   createOffscreenCanvas: function() { return /* binding */ createOffscreenCanvas; },
/* harmony export */   createRewardedVideoAd: function() { return /* binding */ createRewardedVideoAd; },
/* harmony export */   createRouter: function() { return /* binding */ createRouter; },
/* harmony export */   createSelectorQuery: function() { return /* binding */ createSelectorQuery; },
/* harmony export */   createTCPSocket: function() { return /* binding */ createTCPSocket; },
/* harmony export */   createUDPSocket: function() { return /* binding */ createUDPSocket; },
/* harmony export */   createVKSession: function() { return /* binding */ createVKSession; },
/* harmony export */   createVideoContext: function() { return /* binding */ createVideoContext; },
/* harmony export */   createVideoDecoder: function() { return /* binding */ createVideoDecoder; },
/* harmony export */   createWebAudioContext: function() { return /* binding */ createWebAudioContext; },
/* harmony export */   createWorker: function() { return /* binding */ createWorker; },
/* harmony export */   cropImage: function() { return /* binding */ cropImage; },
/* harmony export */   defineCustomElement: function() { return /* binding */ defineCustomElement3; },
/* harmony export */   defineCustomElement10: function() { return /* binding */ defineCustomElement12; },
/* harmony export */   defineCustomElement11: function() { return /* binding */ defineCustomElement13; },
/* harmony export */   defineCustomElement12: function() { return /* binding */ defineCustomElement14; },
/* harmony export */   defineCustomElement13: function() { return /* binding */ defineCustomElement15; },
/* harmony export */   defineCustomElement14: function() { return /* binding */ defineCustomElement16; },
/* harmony export */   defineCustomElement15: function() { return /* binding */ defineCustomElement17; },
/* harmony export */   defineCustomElement16: function() { return /* binding */ defineCustomElement18; },
/* harmony export */   defineCustomElement17: function() { return /* binding */ defineCustomElement19; },
/* harmony export */   defineCustomElement18: function() { return /* binding */ defineCustomElement20; },
/* harmony export */   defineCustomElement19: function() { return /* binding */ defineCustomElement21; },
/* harmony export */   defineCustomElement2: function() { return /* binding */ defineCustomElement4; },
/* harmony export */   defineCustomElement20: function() { return /* binding */ defineCustomElement22; },
/* harmony export */   defineCustomElement21: function() { return /* binding */ defineCustomElement23; },
/* harmony export */   defineCustomElement22: function() { return /* binding */ defineCustomElement24; },
/* harmony export */   defineCustomElement23: function() { return /* binding */ defineCustomElement25; },
/* harmony export */   defineCustomElement24: function() { return /* binding */ defineCustomElement26; },
/* harmony export */   defineCustomElement25: function() { return /* binding */ defineCustomElement27; },
/* harmony export */   defineCustomElement26: function() { return /* binding */ defineCustomElement28; },
/* harmony export */   defineCustomElement27: function() { return /* binding */ defineCustomElement29; },
/* harmony export */   defineCustomElement28: function() { return /* binding */ defineCustomElement30; },
/* harmony export */   defineCustomElement29: function() { return /* binding */ defineCustomElement31; },
/* harmony export */   defineCustomElement3: function() { return /* binding */ defineCustomElement5; },
/* harmony export */   defineCustomElement30: function() { return /* binding */ defineCustomElement32; },
/* harmony export */   defineCustomElement31: function() { return /* binding */ defineCustomElement33; },
/* harmony export */   defineCustomElement32: function() { return /* binding */ defineCustomElement34; },
/* harmony export */   defineCustomElement33: function() { return /* binding */ defineCustomElement35; },
/* harmony export */   defineCustomElement34: function() { return /* binding */ defineCustomElement36; },
/* harmony export */   defineCustomElement35: function() { return /* binding */ defineCustomElement37; },
/* harmony export */   defineCustomElement36: function() { return /* binding */ defineCustomElement38; },
/* harmony export */   defineCustomElement37: function() { return /* binding */ defineCustomElement39; },
/* harmony export */   defineCustomElement38: function() { return /* binding */ defineCustomElement40; },
/* harmony export */   defineCustomElement39: function() { return /* binding */ defineCustomElement41; },
/* harmony export */   defineCustomElement4: function() { return /* binding */ defineCustomElement6; },
/* harmony export */   defineCustomElement40: function() { return /* binding */ defineCustomElement42; },
/* harmony export */   defineCustomElement41: function() { return /* binding */ defineCustomElement43; },
/* harmony export */   defineCustomElement42: function() { return /* binding */ defineCustomElement44; },
/* harmony export */   defineCustomElement43: function() { return /* binding */ defineCustomElement45; },
/* harmony export */   defineCustomElement44: function() { return /* binding */ defineCustomElement46; },
/* harmony export */   defineCustomElement45: function() { return /* binding */ defineCustomElement47; },
/* harmony export */   defineCustomElement46: function() { return /* binding */ defineCustomElement48; },
/* harmony export */   defineCustomElement47: function() { return /* binding */ defineCustomElement49; },
/* harmony export */   defineCustomElement48: function() { return /* binding */ defineCustomElement50; },
/* harmony export */   defineCustomElement49: function() { return /* binding */ defineCustomElement51; },
/* harmony export */   defineCustomElement5: function() { return /* binding */ defineCustomElement7; },
/* harmony export */   defineCustomElement50: function() { return /* binding */ defineCustomElement52; },
/* harmony export */   defineCustomElement51: function() { return /* binding */ defineCustomElement53; },
/* harmony export */   defineCustomElement52: function() { return /* binding */ defineCustomElement54; },
/* harmony export */   defineCustomElement53: function() { return /* binding */ defineCustomElement55; },
/* harmony export */   defineCustomElement54: function() { return /* binding */ defineCustomElement56; },
/* harmony export */   defineCustomElement55: function() { return /* binding */ defineCustomElement57; },
/* harmony export */   defineCustomElement56: function() { return /* binding */ defineCustomElement58; },
/* harmony export */   defineCustomElement57: function() { return /* binding */ defineCustomElement59; },
/* harmony export */   defineCustomElement58: function() { return /* binding */ defineCustomElement60; },
/* harmony export */   defineCustomElement59: function() { return /* binding */ defineCustomElement61; },
/* harmony export */   defineCustomElement6: function() { return /* binding */ defineCustomElement8; },
/* harmony export */   defineCustomElement60: function() { return /* binding */ defineCustomElement62; },
/* harmony export */   defineCustomElement61: function() { return /* binding */ defineCustomElement64; },
/* harmony export */   defineCustomElement62: function() { return /* binding */ defineCustomElement65; },
/* harmony export */   defineCustomElement63: function() { return /* binding */ defineCustomElement66; },
/* harmony export */   defineCustomElement64: function() { return /* binding */ defineCustomElement67; },
/* harmony export */   defineCustomElement65: function() { return /* binding */ defineCustomElement68; },
/* harmony export */   defineCustomElement66: function() { return /* binding */ defineCustomElement69; },
/* harmony export */   defineCustomElement67: function() { return /* binding */ defineCustomElement70; },
/* harmony export */   defineCustomElement68: function() { return /* binding */ defineCustomElement71; },
/* harmony export */   defineCustomElement69: function() { return /* binding */ defineCustomElement72; },
/* harmony export */   defineCustomElement7: function() { return /* binding */ defineCustomElement9; },
/* harmony export */   defineCustomElement70: function() { return /* binding */ defineCustomElement73; },
/* harmony export */   defineCustomElement71: function() { return /* binding */ defineCustomElement74; },
/* harmony export */   defineCustomElement72: function() { return /* binding */ defineCustomElement75; },
/* harmony export */   defineCustomElement73: function() { return /* binding */ defineCustomElement76; },
/* harmony export */   defineCustomElement74: function() { return /* binding */ defineCustomElement77; },
/* harmony export */   defineCustomElement75: function() { return /* binding */ defineCustomElement78; },
/* harmony export */   defineCustomElement76: function() { return /* binding */ defineCustomElement79; },
/* harmony export */   defineCustomElement77: function() { return /* binding */ defineCustomElement80; },
/* harmony export */   defineCustomElement78: function() { return /* binding */ defineCustomElement81; },
/* harmony export */   defineCustomElement79: function() { return /* binding */ defineCustomElement82; },
/* harmony export */   defineCustomElement8: function() { return /* binding */ defineCustomElement10; },
/* harmony export */   defineCustomElement80: function() { return /* binding */ defineCustomElement83; },
/* harmony export */   defineCustomElement81: function() { return /* binding */ defineCustomElement84; },
/* harmony export */   defineCustomElement82: function() { return /* binding */ defineCustomElement85; },
/* harmony export */   defineCustomElement83: function() { return /* binding */ defineCustomElement; },
/* harmony export */   defineCustomElement84: function() { return /* binding */ defineCustomElement2; },
/* harmony export */   defineCustomElement85: function() { return /* binding */ defineCustomElement86; },
/* harmony export */   defineCustomElement86: function() { return /* binding */ defineCustomElement87; },
/* harmony export */   defineCustomElement87: function() { return /* binding */ defineCustomElement88; },
/* harmony export */   defineCustomElement88: function() { return /* binding */ defineCustomElement89; },
/* harmony export */   defineCustomElement89: function() { return /* binding */ defineCustomElement90; },
/* harmony export */   defineCustomElement9: function() { return /* binding */ defineCustomElement11; },
/* harmony export */   defineCustomElement90: function() { return /* binding */ defineCustomElement91; },
/* harmony export */   defineCustomElement91: function() { return /* binding */ defineCustomElement92; },
/* harmony export */   defineCustomElement92: function() { return /* binding */ defineCustomElement93; },
/* harmony export */   defineCustomElement93: function() { return /* binding */ defineCustomElement95; },
/* harmony export */   defineCustomElement94: function() { return /* binding */ defineCustomElement97; },
/* harmony export */   defineCustomElement95: function() { return /* binding */ defineCustomElement98; },
/* harmony export */   defineCustomElement96: function() { return /* binding */ defineCustomElement99; },
/* harmony export */   defineCustomElement97: function() { return /* binding */ defineCustomElement100; },
/* harmony export */   defineCustomElement98: function() { return /* binding */ defineCustomElement101; },
/* harmony export */   disableAlertBeforeUnload: function() { return /* binding */ disableAlertBeforeUnload; },
/* harmony export */   dishClassify: function() { return /* binding */ dishClassify; },
/* harmony export */   downloadFile: function() { return /* binding */ downloadFile; },
/* harmony export */   editImage: function() { return /* binding */ editImage; },
/* harmony export */   enableAlertBeforeUnload: function() { return /* binding */ enableAlertBeforeUnload; },
/* harmony export */   env: function() { return /* binding */ env; },
/* harmony export */   eventCenter: function() { return /* binding */ eventCenter2; },
/* harmony export */   exitMiniProgram: function() { return /* binding */ exitMiniProgram; },
/* harmony export */   exitVoIPChat: function() { return /* binding */ exitVoIPChat; },
/* harmony export */   faceDetect: function() { return /* binding */ faceDetect; },
/* harmony export */   faceVerifyForPay: function() { return /* binding */ faceVerifyForPay; },
/* harmony export */   getAccountInfoSync: function() { return /* binding */ getAccountInfoSync; },
/* harmony export */   getApp: function() { return /* binding */ getApp2; },
/* harmony export */   getAppAuthorizeSetting: function() { return /* binding */ getAppAuthorizeSetting; },
/* harmony export */   getAppBaseInfo: function() { return /* binding */ getAppBaseInfo; },
/* harmony export */   getAppInfo: function() { return /* binding */ getAppInfo; },
/* harmony export */   getAvailableAudioSources: function() { return /* binding */ getAvailableAudioSources; },
/* harmony export */   getBLEDeviceCharacteristics: function() { return /* binding */ getBLEDeviceCharacteristics; },
/* harmony export */   getBLEDeviceRSSI: function() { return /* binding */ getBLEDeviceRSSI; },
/* harmony export */   getBLEDeviceServices: function() { return /* binding */ getBLEDeviceServices; },
/* harmony export */   getBLEMTU: function() { return /* binding */ getBLEMTU; },
/* harmony export */   getBackgroundAudioManager: function() { return /* binding */ getBackgroundAudioManager; },
/* harmony export */   getBackgroundAudioPlayerState: function() { return /* binding */ getBackgroundAudioPlayerState; },
/* harmony export */   getBackgroundFetchData: function() { return /* binding */ getBackgroundFetchData; },
/* harmony export */   getBackgroundFetchToken: function() { return /* binding */ getBackgroundFetchToken; },
/* harmony export */   getBatteryInfo: function() { return /* binding */ getBatteryInfo; },
/* harmony export */   getBatteryInfoSync: function() { return /* binding */ getBatteryInfoSync; },
/* harmony export */   getBeacons: function() { return /* binding */ getBeacons; },
/* harmony export */   getBluetoothAdapterState: function() { return /* binding */ getBluetoothAdapterState; },
/* harmony export */   getBluetoothDevices: function() { return /* binding */ getBluetoothDevices; },
/* harmony export */   getChannelsLiveInfo: function() { return /* binding */ getChannelsLiveInfo; },
/* harmony export */   getChannelsLiveNoticeInfo: function() { return /* binding */ getChannelsLiveNoticeInfo; },
/* harmony export */   getChannelsShareKey: function() { return /* binding */ getChannelsShareKey; },
/* harmony export */   getClipboardData: function() { return /* binding */ getClipboardData; },
/* harmony export */   getConnectedBluetoothDevices: function() { return /* binding */ getConnectedBluetoothDevices; },
/* harmony export */   getConnectedWifi: function() { return /* binding */ getConnectedWifi; },
/* harmony export */   getCurrentInstance: function() { return /* binding */ getCurrentInstance2; },
/* harmony export */   getCurrentPages: function() { return /* binding */ getCurrentPages; },
/* harmony export */   getDeviceInfo: function() { return /* binding */ getDeviceInfo; },
/* harmony export */   getDeviceVoIPList: function() { return /* binding */ getDeviceVoIPList; },
/* harmony export */   getEnterOptionsSync: function() { return /* binding */ getEnterOptionsSync; },
/* harmony export */   getEnv: function() { return /* binding */ getEnv2; },
/* harmony export */   getExptInfoSync: function() { return /* binding */ getExptInfoSync; },
/* harmony export */   getExtConfig: function() { return /* binding */ getExtConfig; },
/* harmony export */   getExtConfigSync: function() { return /* binding */ getExtConfigSync; },
/* harmony export */   getFileInfo: function() { return /* binding */ getFileInfo; },
/* harmony export */   getFileSystemManager: function() { return /* binding */ getFileSystemManager; },
/* harmony export */   getFuzzyLocation: function() { return /* binding */ getFuzzyLocation; },
/* harmony export */   getGroupEnterInfo: function() { return /* binding */ getGroupEnterInfo; },
/* harmony export */   getGuildInfo: function() { return /* binding */ getGuildInfo; },
/* harmony export */   getHCEState: function() { return /* binding */ getHCEState; },
/* harmony export */   getImageInfo: function() { return /* binding */ getImageInfo; },
/* harmony export */   getInferenceEnvInfo: function() { return /* binding */ getInferenceEnvInfo; },
/* harmony export */   getLaunchOptionsSync: function() { return /* binding */ getLaunchOptionsSync; },
/* harmony export */   getLocalIPAddress: function() { return /* binding */ getLocalIPAddress; },
/* harmony export */   getLocation: function() { return /* binding */ getLocation; },
/* harmony export */   getLogManager: function() { return /* binding */ getLogManager; },
/* harmony export */   getMenuButtonBoundingClientRect: function() { return /* binding */ getMenuButtonBoundingClientRect; },
/* harmony export */   getNFCAdapter: function() { return /* binding */ getNFCAdapter; },
/* harmony export */   getNetworkType: function() { return /* binding */ getNetworkType; },
/* harmony export */   getOpenUserInfo: function() { return /* binding */ getOpenUserInfo; },
/* harmony export */   getPerformance: function() { return /* binding */ getPerformance; },
/* harmony export */   getPrivacySetting: function() { return /* binding */ getPrivacySetting; },
/* harmony export */   getQQRunData: function() { return /* binding */ getQQRunData; },
/* harmony export */   getRandomValues: function() { return /* binding */ getRandomValues; },
/* harmony export */   getRealtimeLogManager: function() { return /* binding */ getRealtimeLogManager; },
/* harmony export */   getRecorderManager: function() { return /* binding */ getRecorderManager; },
/* harmony export */   getRendererUserAgent: function() { return /* binding */ getRendererUserAgent; },
/* harmony export */   getSavedFileInfo: function() { return /* binding */ getSavedFileInfo; },
/* harmony export */   getSavedFileList: function() { return /* binding */ getSavedFileList; },
/* harmony export */   getScreenBrightness: function() { return /* binding */ getScreenBrightness; },
/* harmony export */   getScreenRecordingState: function() { return /* binding */ getScreenRecordingState; },
/* harmony export */   getSelectedTextRange: function() { return /* binding */ getSelectedTextRange; },
/* harmony export */   getSetting: function() { return /* binding */ getSetting; },
/* harmony export */   getShareInfo: function() { return /* binding */ getShareInfo; },
/* harmony export */   getSkylineInfo: function() { return /* binding */ getSkylineInfo; },
/* harmony export */   getSkylineInfoSync: function() { return /* binding */ getSkylineInfoSync; },
/* harmony export */   getStorage: function() { return /* binding */ getStorage; },
/* harmony export */   getStorageInfo: function() { return /* binding */ getStorageInfo; },
/* harmony export */   getStorageInfoSync: function() { return /* binding */ getStorageInfoSync; },
/* harmony export */   getStorageSync: function() { return /* binding */ getStorageSync; },
/* harmony export */   getSwanId: function() { return /* binding */ getSwanId; },
/* harmony export */   getSystemInfo: function() { return /* binding */ getSystemInfo; },
/* harmony export */   getSystemInfoAsync: function() { return /* binding */ getSystemInfoAsync; },
/* harmony export */   getSystemInfoSync: function() { return /* binding */ getSystemInfoSync; },
/* harmony export */   getSystemSetting: function() { return /* binding */ getSystemSetting; },
/* harmony export */   getUpdateManager: function() { return /* binding */ getUpdateManager; },
/* harmony export */   getUserCryptoManager: function() { return /* binding */ getUserCryptoManager; },
/* harmony export */   getUserInfo: function() { return /* binding */ getUserInfo; },
/* harmony export */   getUserProfile: function() { return /* binding */ getUserProfile; },
/* harmony export */   getVideoInfo: function() { return /* binding */ getVideoInfo; },
/* harmony export */   getWeRunData: function() { return /* binding */ getWeRunData; },
/* harmony export */   getWifiList: function() { return /* binding */ getWifiList; },
/* harmony export */   getWindowInfo: function() { return /* binding */ getWindowInfo; },
/* harmony export */   handleAppMount: function() { return /* binding */ handleAppMount; },
/* harmony export */   handleAppMountWithTabbar: function() { return /* binding */ handleAppMountWithTabbar; },
/* harmony export */   hideHomeButton: function() { return /* binding */ hideHomeButton; },
/* harmony export */   hideKeyboard: function() { return /* binding */ hideKeyboard; },
/* harmony export */   hideLoading: function() { return /* binding */ hideLoading; },
/* harmony export */   hideNavigationBarLoading: function() { return /* binding */ hideNavigationBarLoading; },
/* harmony export */   hideShareMenu: function() { return /* binding */ hideShareMenu; },
/* harmony export */   hideTabBar: function() { return /* binding */ hideTabBar; },
/* harmony export */   hideTabBarRedDot: function() { return /* binding */ hideTabBarRedDot; },
/* harmony export */   hideToast: function() { return /* binding */ hideToast; },
/* harmony export */   history: function() { return /* binding */ history; },
/* harmony export */   imageAudit: function() { return /* binding */ imageAudit; },
/* harmony export */   initFaceDetect: function() { return /* binding */ initFaceDetect; },
/* harmony export */   initPxTransform: function() { return /* binding */ initPxTransform; },
/* harmony export */   initTabBarApis: function() { return /* binding */ initTabBarApis; },
/* harmony export */   interceptorify: function() { return /* binding */ interceptorify2; },
/* harmony export */   interceptors: function() { return /* binding */ interceptors2; },
/* harmony export */   isAddedToMyApps: function() { return /* binding */ isAddedToMyApps; },
/* harmony export */   isBluetoothDevicePaired: function() { return /* binding */ isBluetoothDevicePaired; },
/* harmony export */   isDingTalk: function() { return /* binding */ isDingTalk; },
/* harmony export */   isVKSupport: function() { return /* binding */ isVKSupport; },
/* harmony export */   isWeixin: function() { return /* binding */ isWeixin; },
/* harmony export */   join1v1Chat: function() { return /* binding */ join1v1Chat; },
/* harmony export */   joinVoIPChat: function() { return /* binding */ joinVoIPChat; },
/* harmony export */   loadFontFace: function() { return /* binding */ loadFontFace; },
/* harmony export */   login: function() { return /* binding */ login; },
/* harmony export */   logoClassify: function() { return /* binding */ logoClassify; },
/* harmony export */   makeBluetoothPair: function() { return /* binding */ makeBluetoothPair; },
/* harmony export */   makePhoneCall: function() { return /* binding */ makePhoneCall; },
/* harmony export */   navigateBack: function() { return /* binding */ navigateBack; },
/* harmony export */   navigateBackMiniProgram: function() { return /* binding */ navigateBackMiniProgram; },
/* harmony export */   navigateBackSmartProgram: function() { return /* binding */ navigateBackSmartProgram; },
/* harmony export */   navigateTo: function() { return /* binding */ navigateTo; },
/* harmony export */   navigateToMiniProgram: function() { return /* binding */ navigateToMiniProgram; },
/* harmony export */   navigateToSmartGameProgram: function() { return /* binding */ navigateToSmartGameProgram; },
/* harmony export */   navigateToSmartProgram: function() { return /* binding */ navigateToSmartProgram; },
/* harmony export */   nextTick: function() { return /* binding */ nextTick3; },
/* harmony export */   notifyBLECharacteristicValueChange: function() { return /* binding */ notifyBLECharacteristicValueChange; },
/* harmony export */   objectDetectIdentify: function() { return /* binding */ objectDetectIdentify; },
/* harmony export */   ocrBankCard: function() { return /* binding */ ocrBankCard; },
/* harmony export */   ocrDrivingLicense: function() { return /* binding */ ocrDrivingLicense; },
/* harmony export */   ocrIdCard: function() { return /* binding */ ocrIdCard; },
/* harmony export */   ocrVehicleLicense: function() { return /* binding */ ocrVehicleLicense; },
/* harmony export */   offAccelerometerChange: function() { return /* binding */ offAccelerometerChange; },
/* harmony export */   offAppHide: function() { return /* binding */ offAppHide; },
/* harmony export */   offAppShow: function() { return /* binding */ offAppShow; },
/* harmony export */   offAudioInterruptionBegin: function() { return /* binding */ offAudioInterruptionBegin; },
/* harmony export */   offAudioInterruptionEnd: function() { return /* binding */ offAudioInterruptionEnd; },
/* harmony export */   offBLECharacteristicValueChange: function() { return /* binding */ offBLECharacteristicValueChange; },
/* harmony export */   offBLEConnectionStateChange: function() { return /* binding */ offBLEConnectionStateChange; },
/* harmony export */   offBLEMTUChange: function() { return /* binding */ offBLEMTUChange; },
/* harmony export */   offBLEPeripheralConnectionStateChanged: function() { return /* binding */ offBLEPeripheralConnectionStateChanged; },
/* harmony export */   offBeaconServiceChange: function() { return /* binding */ offBeaconServiceChange; },
/* harmony export */   offBeaconUpdate: function() { return /* binding */ offBeaconUpdate; },
/* harmony export */   offBluetoothAdapterStateChange: function() { return /* binding */ offBluetoothAdapterStateChange; },
/* harmony export */   offBluetoothDeviceFound: function() { return /* binding */ offBluetoothDeviceFound; },
/* harmony export */   offCompassChange: function() { return /* binding */ offCompassChange; },
/* harmony export */   offCopyUrl: function() { return /* binding */ offCopyUrl; },
/* harmony export */   offDeviceMotionChange: function() { return /* binding */ offDeviceMotionChange; },
/* harmony export */   offError: function() { return /* binding */ offError; },
/* harmony export */   offGetWifiList: function() { return /* binding */ offGetWifiList; },
/* harmony export */   offGyroscopeChange: function() { return /* binding */ offGyroscopeChange; },
/* harmony export */   offHCEMessage: function() { return /* binding */ offHCEMessage; },
/* harmony export */   offKeyboardHeightChange: function() { return /* binding */ offKeyboardHeightChange; },
/* harmony export */   offLazyLoadError: function() { return /* binding */ offLazyLoadError; },
/* harmony export */   offLocalServiceDiscoveryStop: function() { return /* binding */ offLocalServiceDiscoveryStop; },
/* harmony export */   offLocalServiceFound: function() { return /* binding */ offLocalServiceFound; },
/* harmony export */   offLocalServiceLost: function() { return /* binding */ offLocalServiceLost; },
/* harmony export */   offLocalServiceResolveFail: function() { return /* binding */ offLocalServiceResolveFail; },
/* harmony export */   offLocationChange: function() { return /* binding */ offLocationChange; },
/* harmony export */   offLocationChangeError: function() { return /* binding */ offLocationChangeError; },
/* harmony export */   offMemoryWarning: function() { return /* binding */ offMemoryWarning; },
/* harmony export */   offNetworkStatusChange: function() { return /* binding */ offNetworkStatusChange; },
/* harmony export */   offNetworkWeakChange: function() { return /* binding */ offNetworkWeakChange; },
/* harmony export */   offPageNotFound: function() { return /* binding */ offPageNotFound; },
/* harmony export */   offScreenRecordingStateChanged: function() { return /* binding */ offScreenRecordingStateChanged; },
/* harmony export */   offThemeChange: function() { return /* binding */ offThemeChange; },
/* harmony export */   offUnhandledRejection: function() { return /* binding */ offUnhandledRejection; },
/* harmony export */   offUserCaptureScreen: function() { return /* binding */ offUserCaptureScreen; },
/* harmony export */   offVoIPChatInterrupted: function() { return /* binding */ offVoIPChatInterrupted; },
/* harmony export */   offVoIPChatMembersChanged: function() { return /* binding */ offVoIPChatMembersChanged; },
/* harmony export */   offVoIPChatSpeakersChanged: function() { return /* binding */ offVoIPChatSpeakersChanged; },
/* harmony export */   offVoIPChatStateChanged: function() { return /* binding */ offVoIPChatStateChanged; },
/* harmony export */   offVoIPVideoMembersChanged: function() { return /* binding */ offVoIPVideoMembersChanged; },
/* harmony export */   offWifiConnected: function() { return /* binding */ offWifiConnected; },
/* harmony export */   offWifiConnectedWithPartialInfo: function() { return /* binding */ offWifiConnectedWithPartialInfo; },
/* harmony export */   offWindowResize: function() { return /* binding */ offWindowResize; },
/* harmony export */   onAccelerometerChange: function() { return /* binding */ onAccelerometerChange; },
/* harmony export */   onAppHide: function() { return /* binding */ onAppHide; },
/* harmony export */   onAppShow: function() { return /* binding */ onAppShow; },
/* harmony export */   onAudioInterruptionBegin: function() { return /* binding */ onAudioInterruptionBegin; },
/* harmony export */   onAudioInterruptionEnd: function() { return /* binding */ onAudioInterruptionEnd; },
/* harmony export */   onBLECharacteristicValueChange: function() { return /* binding */ onBLECharacteristicValueChange; },
/* harmony export */   onBLEConnectionStateChange: function() { return /* binding */ onBLEConnectionStateChange; },
/* harmony export */   onBLEMTUChange: function() { return /* binding */ onBLEMTUChange; },
/* harmony export */   onBLEPeripheralConnectionStateChanged: function() { return /* binding */ onBLEPeripheralConnectionStateChanged; },
/* harmony export */   onBackgroundAudioPause: function() { return /* binding */ onBackgroundAudioPause; },
/* harmony export */   onBackgroundAudioPlay: function() { return /* binding */ onBackgroundAudioPlay; },
/* harmony export */   onBackgroundAudioStop: function() { return /* binding */ onBackgroundAudioStop; },
/* harmony export */   onBackgroundFetchData: function() { return /* binding */ onBackgroundFetchData; },
/* harmony export */   onBeaconServiceChange: function() { return /* binding */ onBeaconServiceChange; },
/* harmony export */   onBeaconUpdate: function() { return /* binding */ onBeaconUpdate; },
/* harmony export */   onBluetoothAdapterStateChange: function() { return /* binding */ onBluetoothAdapterStateChange; },
/* harmony export */   onBluetoothDeviceFound: function() { return /* binding */ onBluetoothDeviceFound; },
/* harmony export */   onCompassChange: function() { return /* binding */ onCompassChange; },
/* harmony export */   onCopyUrl: function() { return /* binding */ onCopyUrl; },
/* harmony export */   onDeviceMotionChange: function() { return /* binding */ onDeviceMotionChange; },
/* harmony export */   onError: function() { return /* binding */ onError; },
/* harmony export */   onGetWifiList: function() { return /* binding */ onGetWifiList; },
/* harmony export */   onGyroscopeChange: function() { return /* binding */ onGyroscopeChange; },
/* harmony export */   onHCEMessage: function() { return /* binding */ onHCEMessage; },
/* harmony export */   onKeyboardHeightChange: function() { return /* binding */ onKeyboardHeightChange; },
/* harmony export */   onLazyLoadError: function() { return /* binding */ onLazyLoadError; },
/* harmony export */   onLocalServiceDiscoveryStop: function() { return /* binding */ onLocalServiceDiscoveryStop; },
/* harmony export */   onLocalServiceFound: function() { return /* binding */ onLocalServiceFound; },
/* harmony export */   onLocalServiceLost: function() { return /* binding */ onLocalServiceLost; },
/* harmony export */   onLocalServiceResolveFail: function() { return /* binding */ onLocalServiceResolveFail; },
/* harmony export */   onLocationChange: function() { return /* binding */ onLocationChange; },
/* harmony export */   onLocationChangeError: function() { return /* binding */ onLocationChangeError; },
/* harmony export */   onMemoryWarning: function() { return /* binding */ onMemoryWarning; },
/* harmony export */   onNeedPrivacyAuthorization: function() { return /* binding */ onNeedPrivacyAuthorization; },
/* harmony export */   onNetworkStatusChange: function() { return /* binding */ onNetworkStatusChange; },
/* harmony export */   onNetworkWeakChange: function() { return /* binding */ onNetworkWeakChange; },
/* harmony export */   onPageNotFound: function() { return /* binding */ onPageNotFound; },
/* harmony export */   onScreenRecordingStateChanged: function() { return /* binding */ onScreenRecordingStateChanged; },
/* harmony export */   onSocketClose: function() { return /* binding */ onSocketClose; },
/* harmony export */   onSocketError: function() { return /* binding */ onSocketError; },
/* harmony export */   onSocketMessage: function() { return /* binding */ onSocketMessage; },
/* harmony export */   onSocketOpen: function() { return /* binding */ onSocketOpen; },
/* harmony export */   onThemeChange: function() { return /* binding */ onThemeChange; },
/* harmony export */   onUnhandledRejection: function() { return /* binding */ onUnhandledRejection; },
/* harmony export */   onUserCaptureScreen: function() { return /* binding */ onUserCaptureScreen; },
/* harmony export */   onVoIPChatInterrupted: function() { return /* binding */ onVoIPChatInterrupted; },
/* harmony export */   onVoIPChatMembersChanged: function() { return /* binding */ onVoIPChatMembersChanged; },
/* harmony export */   onVoIPChatSpeakersChanged: function() { return /* binding */ onVoIPChatSpeakersChanged; },
/* harmony export */   onVoIPChatStateChanged: function() { return /* binding */ onVoIPChatStateChanged; },
/* harmony export */   onVoIPVideoMembersChanged: function() { return /* binding */ onVoIPVideoMembersChanged; },
/* harmony export */   onWifiConnected: function() { return /* binding */ onWifiConnected; },
/* harmony export */   onWifiConnectedWithPartialInfo: function() { return /* binding */ onWifiConnectedWithPartialInfo; },
/* harmony export */   onWindowResize: function() { return /* binding */ onWindowResize; },
/* harmony export */   openAppAuthorizeSetting: function() { return /* binding */ openAppAuthorizeSetting; },
/* harmony export */   openBluetoothAdapter: function() { return /* binding */ openBluetoothAdapter; },
/* harmony export */   openBusinessView: function() { return /* binding */ openBusinessView; },
/* harmony export */   openCard: function() { return /* binding */ openCard; },
/* harmony export */   openChannelsActivity: function() { return /* binding */ openChannelsActivity; },
/* harmony export */   openChannelsEvent: function() { return /* binding */ openChannelsEvent; },
/* harmony export */   openChannelsLive: function() { return /* binding */ openChannelsLive; },
/* harmony export */   openChannelsUserProfile: function() { return /* binding */ openChannelsUserProfile; },
/* harmony export */   openCustomerServiceChat: function() { return /* binding */ openCustomerServiceChat; },
/* harmony export */   openDocument: function() { return /* binding */ openDocument; },
/* harmony export */   openEmbeddedMiniProgram: function() { return /* binding */ openEmbeddedMiniProgram; },
/* harmony export */   openLocation: function() { return /* binding */ openLocation; },
/* harmony export */   openPrivacyContract: function() { return /* binding */ openPrivacyContract; },
/* harmony export */   openQzonePublish: function() { return /* binding */ openQzonePublish; },
/* harmony export */   openSetting: function() { return /* binding */ openSetting; },
/* harmony export */   openSystemBluetoothSetting: function() { return /* binding */ openSystemBluetoothSetting; },
/* harmony export */   openVideoEditor: function() { return /* binding */ openVideoEditor; },
/* harmony export */   options: function() { return /* binding */ options2; },
/* harmony export */   pageScrollTo: function() { return /* binding */ pageScrollTo; },
/* harmony export */   pauseBackgroundAudio: function() { return /* binding */ pauseBackgroundAudio; },
/* harmony export */   pauseVoice: function() { return /* binding */ pauseVoice; },
/* harmony export */   plantClassify: function() { return /* binding */ plantClassify; },
/* harmony export */   playBackgroundAudio: function() { return /* binding */ playBackgroundAudio; },
/* harmony export */   playVoice: function() { return /* binding */ playVoice; },
/* harmony export */   pluginLogin: function() { return /* binding */ pluginLogin; },
/* harmony export */   preload: function() { return /* binding */ preload; },
/* harmony export */   preloadAssets: function() { return /* binding */ preloadAssets; },
/* harmony export */   preloadSkylineView: function() { return /* binding */ preloadSkylineView; },
/* harmony export */   preloadSubPackage: function() { return /* binding */ preloadSubPackage; },
/* harmony export */   preloadWebview: function() { return /* binding */ preloadWebview; },
/* harmony export */   prependBasename: function() { return /* binding */ prependBasename; },
/* harmony export */   previewImage: function() { return /* binding */ previewImage; },
/* harmony export */   previewMedia: function() { return /* binding */ previewMedia; },
/* harmony export */   pxTransform: function() { return /* binding */ pxTransform; },
/* harmony export */   reLaunch: function() { return /* binding */ reLaunch; },
/* harmony export */   readBLECharacteristicValue: function() { return /* binding */ readBLECharacteristicValue; },
/* harmony export */   redirectTo: function() { return /* binding */ redirectTo; },
/* harmony export */   removeSavedFile: function() { return /* binding */ removeSavedFile; },
/* harmony export */   removeStorage: function() { return /* binding */ removeStorage; },
/* harmony export */   removeStorageSync: function() { return /* binding */ removeStorageSync; },
/* harmony export */   removeTabBarBadge: function() { return /* binding */ removeTabBarBadge; },
/* harmony export */   reportAnalytics: function() { return /* binding */ reportAnalytics; },
/* harmony export */   reportEvent: function() { return /* binding */ reportEvent; },
/* harmony export */   reportMonitor: function() { return /* binding */ reportMonitor; },
/* harmony export */   reportPerformance: function() { return /* binding */ reportPerformance; },
/* harmony export */   request: function() { return /* binding */ request; },
/* harmony export */   requestDeviceVoIP: function() { return /* binding */ requestDeviceVoIP; },
/* harmony export */   requestOrderPayment: function() { return /* binding */ requestOrderPayment; },
/* harmony export */   requestPayment: function() { return /* binding */ requestPayment; },
/* harmony export */   requestPluginPayment: function() { return /* binding */ requestPluginPayment; },
/* harmony export */   requestPolymerPayment: function() { return /* binding */ requestPolymerPayment; },
/* harmony export */   requestSubscribeDeviceMessage: function() { return /* binding */ requestSubscribeDeviceMessage; },
/* harmony export */   requestSubscribeMessage: function() { return /* binding */ requestSubscribeMessage; },
/* harmony export */   requirePlugin: function() { return /* binding */ requirePlugin; },
/* harmony export */   requirePrivacyAuthorize: function() { return /* binding */ requirePrivacyAuthorize; },
/* harmony export */   reserveChannelsLive: function() { return /* binding */ reserveChannelsLive; },
/* harmony export */   revokeBufferURL: function() { return /* binding */ revokeBufferURL; },
/* harmony export */   router: function() { return /* binding */ router; },
/* harmony export */   routesAlias: function() { return /* binding */ routesAlias; },
/* harmony export */   saveFile: function() { return /* binding */ saveFile; },
/* harmony export */   saveFileToDisk: function() { return /* binding */ saveFileToDisk; },
/* harmony export */   saveImageToPhotosAlbum: function() { return /* binding */ saveImageToPhotosAlbum; },
/* harmony export */   saveVideoToPhotosAlbum: function() { return /* binding */ saveVideoToPhotosAlbum; },
/* harmony export */   scanCode: function() { return /* binding */ scanCode; },
/* harmony export */   seekBackgroundAudio: function() { return /* binding */ seekBackgroundAudio; },
/* harmony export */   sendHCEMessage: function() { return /* binding */ sendHCEMessage; },
/* harmony export */   sendSms: function() { return /* binding */ sendSms; },
/* harmony export */   sendSocketMessage: function() { return /* binding */ sendSocketMessage; },
/* harmony export */   setBLEMTU: function() { return /* binding */ setBLEMTU; },
/* harmony export */   setBackgroundColor: function() { return /* binding */ setBackgroundColor; },
/* harmony export */   setBackgroundFetchToken: function() { return /* binding */ setBackgroundFetchToken; },
/* harmony export */   setBackgroundTextStyle: function() { return /* binding */ setBackgroundTextStyle; },
/* harmony export */   setClipboardData: function() { return /* binding */ setClipboardData; },
/* harmony export */   setCustomDress: function() { return /* binding */ setCustomDress; },
/* harmony export */   setEnable1v1Chat: function() { return /* binding */ setEnable1v1Chat; },
/* harmony export */   setEnableDebug: function() { return /* binding */ setEnableDebug; },
/* harmony export */   setHistory: function() { return /* binding */ setHistory; },
/* harmony export */   setHistoryMode: function() { return /* binding */ setHistoryMode; },
/* harmony export */   setInnerAudioOption: function() { return /* binding */ setInnerAudioOption; },
/* harmony export */   setKeepScreenOn: function() { return /* binding */ setKeepScreenOn; },
/* harmony export */   setMpaTitle: function() { return /* binding */ setMpaTitle; },
/* harmony export */   setNavigationBarColor: function() { return /* binding */ setNavigationBarColor; },
/* harmony export */   setNavigationBarLoading: function() { return /* binding */ setNavigationBarLoading; },
/* harmony export */   setNavigationBarStyle: function() { return /* binding */ setNavigationBarStyle; },
/* harmony export */   setNavigationBarTitle: function() { return /* binding */ setNavigationBarTitle; },
/* harmony export */   setOfficialDress: function() { return /* binding */ setOfficialDress; },
/* harmony export */   setPageInfo: function() { return /* binding */ setPageInfo; },
/* harmony export */   setScreenBrightness: function() { return /* binding */ setScreenBrightness; },
/* harmony export */   setStorage: function() { return /* binding */ setStorage; },
/* harmony export */   setStorageSync: function() { return /* binding */ setStorageSync; },
/* harmony export */   setTabBarBadge: function() { return /* binding */ setTabBarBadge; },
/* harmony export */   setTabBarItem: function() { return /* binding */ setTabBarItem; },
/* harmony export */   setTabBarStyle: function() { return /* binding */ setTabBarStyle; },
/* harmony export */   setTitle: function() { return /* binding */ setTitle; },
/* harmony export */   setTopBarText: function() { return /* binding */ setTopBarText; },
/* harmony export */   setVisualEffectOnCapture: function() { return /* binding */ setVisualEffectOnCapture; },
/* harmony export */   setWifiList: function() { return /* binding */ setWifiList; },
/* harmony export */   setWindowSize: function() { return /* binding */ setWindowSize; },
/* harmony export */   shareFileMessage: function() { return /* binding */ shareFileMessage; },
/* harmony export */   shareToWeRun: function() { return /* binding */ shareToWeRun; },
/* harmony export */   shareVideoMessage: function() { return /* binding */ shareVideoMessage; },
/* harmony export */   showActionSheet: function() { return /* binding */ showActionSheet; },
/* harmony export */   showLoading: function() { return /* binding */ showLoading; },
/* harmony export */   showModal: function() { return /* binding */ showModal; },
/* harmony export */   showNavigationBarLoading: function() { return /* binding */ showNavigationBarLoading; },
/* harmony export */   showRedPackage: function() { return /* binding */ showRedPackage; },
/* harmony export */   showShareImageMenu: function() { return /* binding */ showShareImageMenu; },
/* harmony export */   showShareMenu: function() { return /* binding */ showShareMenu; },
/* harmony export */   showTabBar: function() { return /* binding */ showTabBar; },
/* harmony export */   showTabBarRedDot: function() { return /* binding */ showTabBarRedDot; },
/* harmony export */   showToast: function() { return /* binding */ showToast; },
/* harmony export */   startAccelerometer: function() { return /* binding */ startAccelerometer; },
/* harmony export */   startBeaconDiscovery: function() { return /* binding */ startBeaconDiscovery; },
/* harmony export */   startBluetoothDevicesDiscovery: function() { return /* binding */ startBluetoothDevicesDiscovery; },
/* harmony export */   startCompass: function() { return /* binding */ startCompass; },
/* harmony export */   startDeviceMotionListening: function() { return /* binding */ startDeviceMotionListening; },
/* harmony export */   startFacialRecognitionVerify: function() { return /* binding */ startFacialRecognitionVerify; },
/* harmony export */   startFacialRecognitionVerifyAndUploadVideo: function() { return /* binding */ startFacialRecognitionVerifyAndUploadVideo; },
/* harmony export */   startGyroscope: function() { return /* binding */ startGyroscope; },
/* harmony export */   startHCE: function() { return /* binding */ startHCE; },
/* harmony export */   startLocalServiceDiscovery: function() { return /* binding */ startLocalServiceDiscovery; },
/* harmony export */   startLocationUpdate: function() { return /* binding */ startLocationUpdate; },
/* harmony export */   startLocationUpdateBackground: function() { return /* binding */ startLocationUpdateBackground; },
/* harmony export */   startPullDownRefresh: function() { return /* binding */ startPullDownRefresh; },
/* harmony export */   startRecord: function() { return /* binding */ startRecord; },
/* harmony export */   startSoterAuthentication: function() { return /* binding */ startSoterAuthentication; },
/* harmony export */   startWifi: function() { return /* binding */ startWifi; },
/* harmony export */   stopAccelerometer: function() { return /* binding */ stopAccelerometer; },
/* harmony export */   stopBackgroundAudio: function() { return /* binding */ stopBackgroundAudio; },
/* harmony export */   stopBeaconDiscovery: function() { return /* binding */ stopBeaconDiscovery; },
/* harmony export */   stopBluetoothDevicesDiscovery: function() { return /* binding */ stopBluetoothDevicesDiscovery; },
/* harmony export */   stopCompass: function() { return /* binding */ stopCompass; },
/* harmony export */   stopDeviceMotionListening: function() { return /* binding */ stopDeviceMotionListening; },
/* harmony export */   stopFaceDetect: function() { return /* binding */ stopFaceDetect; },
/* harmony export */   stopGyroscope: function() { return /* binding */ stopGyroscope; },
/* harmony export */   stopHCE: function() { return /* binding */ stopHCE; },
/* harmony export */   stopLocalServiceDiscovery: function() { return /* binding */ stopLocalServiceDiscovery; },
/* harmony export */   stopLocationUpdate: function() { return /* binding */ stopLocationUpdate; },
/* harmony export */   stopPullDownRefresh: function() { return /* binding */ stopPullDownRefresh; },
/* harmony export */   stopRecord: function() { return /* binding */ stopRecord; },
/* harmony export */   stopVoice: function() { return /* binding */ stopVoice; },
/* harmony export */   stopWifi: function() { return /* binding */ stopWifi; },
/* harmony export */   subscribeVoIPVideoMembers: function() { return /* binding */ subscribeVoIPVideoMembers; },
/* harmony export */   switchTab: function() { return /* binding */ switchTab; },
/* harmony export */   taro: function() { return /* binding */ taro; },
/* harmony export */   textReview: function() { return /* binding */ textReview; },
/* harmony export */   textToAudio: function() { return /* binding */ textToAudio; },
/* harmony export */   tradePay: function() { return /* binding */ tradePay; },
/* harmony export */   updateQQApp: function() { return /* binding */ updateQQApp; },
/* harmony export */   updateShareMenu: function() { return /* binding */ updateShareMenu; },
/* harmony export */   updateVoIPChatMuteConfig: function() { return /* binding */ updateVoIPChatMuteConfig; },
/* harmony export */   updateWeChatApp: function() { return /* binding */ updateWeChatApp; },
/* harmony export */   uploadFile: function() { return /* binding */ uploadFile; },
/* harmony export */   vibrateLong: function() { return /* binding */ vibrateLong; },
/* harmony export */   vibrateShort: function() { return /* binding */ vibrateShort; },
/* harmony export */   worklet: function() { return /* binding */ worklet; },
/* harmony export */   writeBLECharacteristicValue: function() { return /* binding */ writeBLECharacteristicValue; }
/* harmony export */ });
/* harmony import */ var _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-LGX227NH.js */ "./node_modules/.taro/h5/prebundle/chunk-LGX227NH.js");
/* harmony import */ var _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunk-F3ILHP3R.js */ "./node_modules/.taro/h5/prebundle/chunk-F3ILHP3R.js");
/* harmony import */ var _chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunk-KXQ2QJJZ.js */ "./node_modules/.taro/h5/prebundle/chunk-KXQ2QJJZ.js");
/* harmony import */ var _definition_a6aeff58_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./definition-a6aeff58.json */ "./node_modules/.taro/h5/prebundle/definition-a6aeff58.json");
/* module decorator */ module = __webpack_require__.hmd(module);
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self1 = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self1, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _define_property(obj, key, value) {
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
function _object_spread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = arguments[i] != null ? arguments[i] : {};
        var ownKeys = Object.keys(source);
        if (typeof Object.getOwnPropertySymbols === "function") {
            ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
            }));
        }
        ownKeys.forEach(function(key) {
            _define_property(target, key, source[key]);
        });
    }
    return target;
}
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) {
            symbols = symbols.filter(function(sym) {
                return Object.getOwnPropertyDescriptor(object, sym).enumerable;
            });
        }
        keys.push.apply(keys, symbols);
    }
    return keys;
}
function _object_spread_props(target, source) {
    source = source != null ? source : {};
    if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
        ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}



// node_modules/base64-js/index.js
var require_base64_js = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/base64-js/index.js" (exports2) {
        "use strict";
        exports2.byteLength = byteLength;
        exports2.toByteArray = toByteArray2;
        exports2.fromByteArray = fromByteArray2;
        var lookup = [];
        var revLookup = [];
        var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
        var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
        for(i2 = 0, len = code.length; i2 < len; ++i2){
            lookup[i2] = code[i2];
            revLookup[code.charCodeAt(i2)] = i2;
        }
        var i2;
        var len;
        revLookup["-".charCodeAt(0)] = 62;
        revLookup["_".charCodeAt(0)] = 63;
        function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
                throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1) validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [
                validLen,
                placeHoldersLen
            ];
        }
        function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
        }
        function toByteArray2(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i3;
            for(i3 = 0; i3 < len2; i3 += 4){
                tmp = revLookup[b64.charCodeAt(i3)] << 18 | revLookup[b64.charCodeAt(i3 + 1)] << 12 | revLookup[b64.charCodeAt(i3 + 2)] << 6 | revLookup[b64.charCodeAt(i3 + 3)];
                arr[curByte++] = tmp >> 16 & 255;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
                tmp = revLookup[b64.charCodeAt(i3)] << 2 | revLookup[b64.charCodeAt(i3 + 1)] >> 4;
                arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
                tmp = revLookup[b64.charCodeAt(i3)] << 10 | revLookup[b64.charCodeAt(i3 + 1)] << 4 | revLookup[b64.charCodeAt(i3 + 2)] >> 2;
                arr[curByte++] = tmp >> 8 & 255;
                arr[curByte++] = tmp & 255;
            }
            return arr;
        }
        function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
        }
        function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for(var i3 = start; i3 < end; i3 += 3){
                tmp = (uint8[i3] << 16 & 16711680) + (uint8[i3 + 1] << 8 & 65280) + (uint8[i3 + 2] & 255);
                output.push(tripletToBase64(tmp));
            }
            return output.join("");
        }
        function fromByteArray2(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for(var i3 = 0, len22 = len2 - extraBytes; i3 < len22; i3 += maxChunkLength){
                parts.push(encodeChunk(uint8, i3, i3 + maxChunkLength > len22 ? len22 : i3 + maxChunkLength));
            }
            if (extraBytes === 1) {
                tmp = uint8[len2 - 1];
                parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
            } else if (extraBytes === 2) {
                tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
            }
            return parts.join("");
        }
    }
});
// node_modules/platform/platform.js
var require_platform = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/platform/platform.js" (exports2, module2) {
        (function() {
            "use strict";
            var objectTypes = {
                "function": true,
                "object": true
            };
            var root2 = objectTypes[typeof window] && window || this;
            var oldRoot = root2;
            var freeExports3 = objectTypes[typeof exports2] && exports2;
            var freeModule3 = objectTypes[typeof module2] && module2 && !module2.nodeType && module2;
            var freeGlobal2 = freeExports3 && freeModule3 && typeof __webpack_require__.g == "object" && __webpack_require__.g;
            if (freeGlobal2 && (freeGlobal2.global === freeGlobal2 || freeGlobal2.window === freeGlobal2 || freeGlobal2.self === freeGlobal2)) {
                root2 = freeGlobal2;
            }
            var maxSafeInteger = Math.pow(2, 53) - 1;
            var reOpera = /\bOpera/;
            var thisBinding = this;
            var objectProto14 = Object.prototype;
            var hasOwnProperty12 = objectProto14.hasOwnProperty;
            var toString3 = objectProto14.toString;
            function capitalize(string2) {
                string2 = String(string2);
                return string2.charAt(0).toUpperCase() + string2.slice(1);
            }
            function cleanupOS(os, pattern, label) {
                var data = {
                    "10.0": "10",
                    "6.4": "10 Technical Preview",
                    "6.3": "8.1",
                    "6.2": "8",
                    "6.1": "Server 2008 R2 / 7",
                    "6.0": "Server 2008 / Vista",
                    "5.2": "Server 2003 / XP 64-bit",
                    "5.1": "XP",
                    "5.01": "2000 SP1",
                    "5.0": "2000",
                    "4.0": "NT",
                    "4.90": "ME"
                };
                if (pattern && label && /^Win/i.test(os) && !/^Windows Phone /i.test(os) && (data = data[/[\d.]+$/.exec(os)])) {
                    os = "Windows " + data;
                }
                os = String(os);
                if (pattern && label) {
                    os = os.replace(RegExp(pattern, "i"), label);
                }
                os = format(os.replace(/ ce$/i, " CE").replace(/\bhpw/i, "web").replace(/\bMacintosh\b/, "Mac OS").replace(/_PowerPC\b/i, " OS").replace(/\b(OS X) [^ \d]+/i, "$1").replace(/\bMac (OS X)\b/, "$1").replace(/\/(\d)/, " $1").replace(/_/g, ".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i, "").replace(/\bx86\.64\b/gi, "x86_64").replace(/\b(Windows Phone) OS\b/, "$1").replace(/\b(Chrome OS \w+) [\d.]+\b/, "$1").split(" on ")[0]);
                return os;
            }
            function each(object2, callback) {
                var index = -1, length = object2 ? object2.length : 0;
                if (typeof length == "number" && length > -1 && length <= maxSafeInteger) {
                    while(++index < length){
                        callback(object2[index], index, object2);
                    }
                } else {
                    forOwn(object2, callback);
                }
            }
            function format(string2) {
                string2 = trim(string2);
                return /^(?:webOS|i(?:OS|P))/.test(string2) ? string2 : capitalize(string2);
            }
            function forOwn(object2, callback) {
                for(var key in object2){
                    if (hasOwnProperty12.call(object2, key)) {
                        callback(object2[key], key, object2);
                    }
                }
            }
            function getClassOf(value) {
                return value == null ? capitalize(value) : toString3.call(value).slice(8, -1);
            }
            function isHostType(object2, property) {
                var type = object2 != null ? typeof object2[property] : "number";
                return !/^(?:boolean|number|string|undefined)$/.test(type) && (type == "object" ? !!object2[property] : true);
            }
            function qualify(string2) {
                return String(string2).replace(/([ -])(?!$)/g, "$1?");
            }
            function reduce(array2, callback) {
                var accumulator = null;
                each(array2, function(value, index) {
                    accumulator = callback(accumulator, value, index, array2);
                });
                return accumulator;
            }
            function trim(string2) {
                return String(string2).replace(/^ +| +$/g, "");
            }
            function parse4(ua) {
                var context = root2;
                var isCustomContext = ua && typeof ua == "object" && getClassOf(ua) != "String";
                if (isCustomContext) {
                    context = ua;
                    ua = null;
                }
                var nav = context.navigator || {};
                var userAgent = nav.userAgent || "";
                ua || (ua = userAgent);
                var isModuleScope = isCustomContext || thisBinding == oldRoot;
                var likeChrome = isCustomContext ? !!nav.likeChrome : /\bChrome\b/.test(ua) && !/internal|\n/i.test(toString3.toString());
                var objectClass = "Object", airRuntimeClass = isCustomContext ? objectClass : "ScriptBridgingProxyObject", enviroClass = isCustomContext ? objectClass : "Environment", javaClass = isCustomContext && context.java ? "JavaPackage" : getClassOf(context.java), phantomClass = isCustomContext ? objectClass : "RuntimeObject";
                var java = /\bJava/.test(javaClass) && context.java;
                var rhino = java && getClassOf(context.environment) == enviroClass;
                var alpha = java ? "a" : "\u03B1";
                var beta = java ? "b" : "\u03B2";
                var doc3 = context.document || {};
                var opera = context.operamini || context.opera;
                var operaClass = reOpera.test(operaClass = isCustomContext && opera ? opera["[[Class]]"] : getClassOf(opera)) ? operaClass : opera = null;
                var data;
                var arch = ua;
                var description = [];
                var prerelease = null;
                var useFeatures = ua == userAgent;
                var version = useFeatures && opera && typeof opera.version == "function" && opera.version();
                var isSpecialCasedOS;
                var layout = getLayout([
                    {
                        "label": "EdgeHTML",
                        "pattern": "Edge"
                    },
                    "Trident",
                    {
                        "label": "WebKit",
                        "pattern": "AppleWebKit"
                    },
                    "iCab",
                    "Presto",
                    "NetFront",
                    "Tasman",
                    "KHTML",
                    "Gecko"
                ]);
                var name = getName([
                    "Adobe AIR",
                    "Arora",
                    "Avant Browser",
                    "Breach",
                    "Camino",
                    "Electron",
                    "Epiphany",
                    "Fennec",
                    "Flock",
                    "Galeon",
                    "GreenBrowser",
                    "iCab",
                    "Iceweasel",
                    "K-Meleon",
                    "Konqueror",
                    "Lunascape",
                    "Maxthon",
                    {
                        "label": "Microsoft Edge",
                        "pattern": "(?:Edge|Edg|EdgA|EdgiOS)"
                    },
                    "Midori",
                    "Nook Browser",
                    "PaleMoon",
                    "PhantomJS",
                    "Raven",
                    "Rekonq",
                    "RockMelt",
                    {
                        "label": "Samsung Internet",
                        "pattern": "SamsungBrowser"
                    },
                    "SeaMonkey",
                    {
                        "label": "Silk",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    },
                    "Sleipnir",
                    "SlimBrowser",
                    {
                        "label": "SRWare Iron",
                        "pattern": "Iron"
                    },
                    "Sunrise",
                    "Swiftfox",
                    "Vivaldi",
                    "Waterfox",
                    "WebPositive",
                    {
                        "label": "Yandex Browser",
                        "pattern": "YaBrowser"
                    },
                    {
                        "label": "UC Browser",
                        "pattern": "UCBrowser"
                    },
                    "Opera Mini",
                    {
                        "label": "Opera Mini",
                        "pattern": "OPiOS"
                    },
                    "Opera",
                    {
                        "label": "Opera",
                        "pattern": "OPR"
                    },
                    "Chromium",
                    "Chrome",
                    {
                        "label": "Chrome",
                        "pattern": "(?:HeadlessChrome)"
                    },
                    {
                        "label": "Chrome Mobile",
                        "pattern": "(?:CriOS|CrMo)"
                    },
                    {
                        "label": "Firefox",
                        "pattern": "(?:Firefox|Minefield)"
                    },
                    {
                        "label": "Firefox for iOS",
                        "pattern": "FxiOS"
                    },
                    {
                        "label": "IE",
                        "pattern": "IEMobile"
                    },
                    {
                        "label": "IE",
                        "pattern": "MSIE"
                    },
                    "Safari"
                ]);
                var product = getProduct([
                    {
                        "label": "BlackBerry",
                        "pattern": "BB10"
                    },
                    "BlackBerry",
                    {
                        "label": "Galaxy S",
                        "pattern": "GT-I9000"
                    },
                    {
                        "label": "Galaxy S2",
                        "pattern": "GT-I9100"
                    },
                    {
                        "label": "Galaxy S3",
                        "pattern": "GT-I9300"
                    },
                    {
                        "label": "Galaxy S4",
                        "pattern": "GT-I9500"
                    },
                    {
                        "label": "Galaxy S5",
                        "pattern": "SM-G900"
                    },
                    {
                        "label": "Galaxy S6",
                        "pattern": "SM-G920"
                    },
                    {
                        "label": "Galaxy S6 Edge",
                        "pattern": "SM-G925"
                    },
                    {
                        "label": "Galaxy S7",
                        "pattern": "SM-G930"
                    },
                    {
                        "label": "Galaxy S7 Edge",
                        "pattern": "SM-G935"
                    },
                    "Google TV",
                    "Lumia",
                    "iPad",
                    "iPod",
                    "iPhone",
                    "Kindle",
                    {
                        "label": "Kindle Fire",
                        "pattern": "(?:Cloud9|Silk-Accelerated)"
                    },
                    "Nexus",
                    "Nook",
                    "PlayBook",
                    "PlayStation Vita",
                    "PlayStation",
                    "TouchPad",
                    "Transformer",
                    {
                        "label": "Wii U",
                        "pattern": "WiiU"
                    },
                    "Wii",
                    "Xbox One",
                    {
                        "label": "Xbox 360",
                        "pattern": "Xbox"
                    },
                    "Xoom"
                ]);
                var manufacturer = getManufacturer({
                    "Apple": {
                        "iPad": 1,
                        "iPhone": 1,
                        "iPod": 1
                    },
                    "Alcatel": {},
                    "Archos": {},
                    "Amazon": {
                        "Kindle": 1,
                        "Kindle Fire": 1
                    },
                    "Asus": {
                        "Transformer": 1
                    },
                    "Barnes & Noble": {
                        "Nook": 1
                    },
                    "BlackBerry": {
                        "PlayBook": 1
                    },
                    "Google": {
                        "Google TV": 1,
                        "Nexus": 1
                    },
                    "HP": {
                        "TouchPad": 1
                    },
                    "HTC": {},
                    "Huawei": {},
                    "Lenovo": {},
                    "LG": {},
                    "Microsoft": {
                        "Xbox": 1,
                        "Xbox One": 1
                    },
                    "Motorola": {
                        "Xoom": 1
                    },
                    "Nintendo": {
                        "Wii U": 1,
                        "Wii": 1
                    },
                    "Nokia": {
                        "Lumia": 1
                    },
                    "Oppo": {},
                    "Samsung": {
                        "Galaxy S": 1,
                        "Galaxy S2": 1,
                        "Galaxy S3": 1,
                        "Galaxy S4": 1
                    },
                    "Sony": {
                        "PlayStation": 1,
                        "PlayStation Vita": 1
                    },
                    "Xiaomi": {
                        "Mi": 1,
                        "Redmi": 1
                    }
                });
                var os = getOS([
                    "Windows Phone",
                    "KaiOS",
                    "Android",
                    "CentOS",
                    {
                        "label": "Chrome OS",
                        "pattern": "CrOS"
                    },
                    "Debian",
                    {
                        "label": "DragonFly BSD",
                        "pattern": "DragonFly"
                    },
                    "Fedora",
                    "FreeBSD",
                    "Gentoo",
                    "Haiku",
                    "Kubuntu",
                    "Linux Mint",
                    "OpenBSD",
                    "Red Hat",
                    "SuSE",
                    "Ubuntu",
                    "Xubuntu",
                    "Cygwin",
                    "Symbian OS",
                    "hpwOS",
                    "webOS ",
                    "webOS",
                    "Tablet OS",
                    "Tizen",
                    "Linux",
                    "Mac OS X",
                    "Macintosh",
                    "Mac",
                    "Windows 98;",
                    "Windows "
                ]);
                function getLayout(guesses) {
                    return reduce(guesses, function(result, guess) {
                        return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                    });
                }
                function getManufacturer(guesses) {
                    return reduce(guesses, function(result, value, key) {
                        return result || (value[product] || value[/^[a-z]+(?: +[a-z]+\b)*/i.exec(product)] || RegExp("\\b" + qualify(key) + "(?:\\b|\\w*\\d)", "i").exec(ua)) && key;
                    });
                }
                function getName(guesses) {
                    return reduce(guesses, function(result, guess) {
                        return result || RegExp("\\b" + (guess.pattern || qualify(guess)) + "\\b", "i").exec(ua) && (guess.label || guess);
                    });
                }
                function getOS(guesses) {
                    return reduce(guesses, function(result, guess) {
                        var pattern = guess.pattern || qualify(guess);
                        if (!result && (result = RegExp("\\b" + pattern + "(?:/[\\d.]+|[ \\w.]*)", "i").exec(ua))) {
                            result = cleanupOS(result, pattern, guess.label || guess);
                        }
                        return result;
                    });
                }
                function getProduct(guesses) {
                    return reduce(guesses, function(result, guess) {
                        var pattern = guess.pattern || qualify(guess);
                        if (!result && (result = RegExp("\\b" + pattern + " *\\d+[.\\w_]*", "i").exec(ua) || RegExp("\\b" + pattern + " *\\w+-[\\w]*", "i").exec(ua) || RegExp("\\b" + pattern + "(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)", "i").exec(ua))) {
                            if ((result = String(guess.label && !RegExp(pattern, "i").test(guess.label) ? guess.label : result).split("/"))[1] && !/[\d.]+/.test(result[0])) {
                                result[0] += " " + result[1];
                            }
                            guess = guess.label || guess;
                            result = format(result[0].replace(RegExp(pattern, "i"), guess).replace(RegExp("; *(?:" + guess + "[_-])?", "i"), " ").replace(RegExp("(" + guess + ")[-_.]?(\\w)", "i"), "$1 $2"));
                        }
                        return result;
                    });
                }
                function getVersion(patterns) {
                    return reduce(patterns, function(result, pattern) {
                        return result || (RegExp(pattern + "(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)", "i").exec(ua) || 0)[1] || null;
                    });
                }
                function toStringPlatform() {
                    return this.description || "";
                }
                layout && (layout = [
                    layout
                ]);
                if (/\bAndroid\b/.test(os) && !product && (data = /\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(ua))) {
                    product = trim(data[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i, "") || null;
                }
                if (manufacturer && !product) {
                    product = getProduct([
                        manufacturer
                    ]);
                } else if (manufacturer && product) {
                    product = product.replace(RegExp("^(" + qualify(manufacturer) + ")[-_.\\s]", "i"), manufacturer + " ").replace(RegExp("^(" + qualify(manufacturer) + ")[-_.]?(\\w)", "i"), manufacturer + " $2");
                }
                if (data = /\bGoogle TV\b/.exec(product)) {
                    product = data[0];
                }
                if (/\bSimulator\b/i.test(ua)) {
                    product = (product ? product + " " : "") + "Simulator";
                }
                if (name == "Opera Mini" && /\bOPiOS\b/.test(ua)) {
                    description.push("running in Turbo/Uncompressed mode");
                }
                if (name == "IE" && /\blike iPhone OS\b/.test(ua)) {
                    data = parse4(ua.replace(/like iPhone OS/, ""));
                    manufacturer = data.manufacturer;
                    product = data.product;
                } else if (/^iP/.test(product)) {
                    name || (name = "Safari");
                    os = "iOS" + ((data = / OS ([\d_]+)/i.exec(ua)) ? " " + data[1].replace(/_/g, ".") : "");
                } else if (name == "Konqueror" && /^Linux\b/i.test(os)) {
                    os = "Kubuntu";
                } else if (manufacturer && manufacturer != "Google" && (/Chrome/.test(name) && !/\bMobile Safari\b/i.test(ua) || /\bVita\b/.test(product)) || /\bAndroid\b/.test(os) && /^Chrome/.test(name) && /\bVersion\//i.test(ua)) {
                    name = "Android Browser";
                    os = /\bAndroid\b/.test(os) ? os : "Android";
                } else if (name == "Silk") {
                    if (!/\bMobi/i.test(ua)) {
                        os = "Android";
                        description.unshift("desktop mode");
                    }
                    if (/Accelerated *= *true/i.test(ua)) {
                        description.unshift("accelerated");
                    }
                } else if (name == "UC Browser" && /\bUCWEB\b/.test(ua)) {
                    description.push("speed mode");
                } else if (name == "PaleMoon" && (data = /\bFirefox\/([\d.]+)\b/.exec(ua))) {
                    description.push("identifying as Firefox " + data[1]);
                } else if (name == "Firefox" && (data = /\b(Mobile|Tablet|TV)\b/i.exec(ua))) {
                    os || (os = "Firefox OS");
                    product || (product = data[1]);
                } else if (!name || (data = !/\bMinefield\b/i.test(ua) && /\b(?:Firefox|Safari)\b/.exec(name))) {
                    if (name && !product && /[\/,]|^[^(]+?\)/.test(ua.slice(ua.indexOf(data + "/") + 8))) {
                        name = null;
                    }
                    if ((data = product || manufacturer || os) && (product || manufacturer || /\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(os))) {
                        name = /[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(os) ? os : data) + " Browser";
                    }
                } else if (name == "Electron" && (data = (/\bChrome\/([\d.]+)\b/.exec(ua) || 0)[1])) {
                    description.push("Chromium " + data);
                }
                if (!version) {
                    version = getVersion([
                        "(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)",
                        "Version",
                        qualify(name),
                        "(?:Firefox|Minefield|NetFront)"
                    ]);
                }
                if (data = layout == "iCab" && parseFloat(version) > 3 && "WebKit" || /\bOpera\b/.test(name) && (/\bOPR\b/.test(ua) ? "Blink" : "Presto") || /\b(?:Midori|Nook|Safari)\b/i.test(ua) && !/^(?:Trident|EdgeHTML)$/.test(layout) && "WebKit" || !layout && /\bMSIE\b/i.test(ua) && (os == "Mac OS" ? "Tasman" : "Trident") || layout == "WebKit" && /\bPlayStation\b(?! Vita\b)/i.test(name) && "NetFront") {
                    layout = [
                        data
                    ];
                }
                if (name == "IE" && (data = (/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(ua) || 0)[1])) {
                    name += " Mobile";
                    os = "Windows Phone " + (/\+$/.test(data) ? data : data + ".x");
                    description.unshift("desktop mode");
                } else if (/\bWPDesktop\b/i.test(ua)) {
                    name = "IE Mobile";
                    os = "Windows Phone 8.x";
                    description.unshift("desktop mode");
                    version || (version = (/\brv:([\d.]+)/.exec(ua) || 0)[1]);
                } else if (name != "IE" && layout == "Trident" && (data = /\brv:([\d.]+)/.exec(ua))) {
                    if (name) {
                        description.push("identifying as " + name + (version ? " " + version : ""));
                    }
                    name = "IE";
                    version = data[1];
                }
                if (useFeatures) {
                    if (isHostType(context, "global")) {
                        if (java) {
                            data = java.lang.System;
                            arch = data.getProperty("os.arch");
                            os = os || data.getProperty("os.name") + " " + data.getProperty("os.version");
                        }
                        if (rhino) {
                            try {
                                version = context.require("ringo/engine").version.join(".");
                                name = "RingoJS";
                            } catch (e) {
                                if ((data = context.system) && data.global.system == context.system) {
                                    name = "Narwhal";
                                    os || (os = data[0].os || null);
                                }
                            }
                            if (!name) {
                                name = "Rhino";
                            }
                        } else if (typeof context.process == "object" && !context.process.browser && (data = context.process)) {
                            if (typeof data.versions == "object") {
                                if (typeof data.versions.electron == "string") {
                                    description.push("Node " + data.versions.node);
                                    name = "Electron";
                                    version = data.versions.electron;
                                } else if (typeof data.versions.nw == "string") {
                                    description.push("Chromium " + version, "Node " + data.versions.node);
                                    name = "NW.js";
                                    version = data.versions.nw;
                                }
                            }
                            if (!name) {
                                name = "Node.js";
                                arch = data.arch;
                                os = data.platform;
                                version = /[\d.]+/.exec(data.version);
                                version = version ? version[0] : null;
                            }
                        }
                    } else if (getClassOf(data = context.runtime) == airRuntimeClass) {
                        name = "Adobe AIR";
                        os = data.flash.system.Capabilities.os;
                    } else if (getClassOf(data = context.phantom) == phantomClass) {
                        name = "PhantomJS";
                        version = (data = data.version || null) && data.major + "." + data.minor + "." + data.patch;
                    } else if (typeof doc3.documentMode == "number" && (data = /\bTrident\/(\d+)/i.exec(ua))) {
                        version = [
                            version,
                            doc3.documentMode
                        ];
                        if ((data = +data[1] + 4) != version[1]) {
                            description.push("IE " + version[1] + " mode");
                            layout && (layout[1] = "");
                            version[1] = data;
                        }
                        version = name == "IE" ? String(version[1].toFixed(1)) : version[0];
                    } else if (typeof doc3.documentMode == "number" && /^(?:Chrome|Firefox)\b/.test(name)) {
                        description.push("masking as " + name + " " + version);
                        name = "IE";
                        version = "11.0";
                        layout = [
                            "Trident"
                        ];
                        os = "Windows";
                    }
                    os = os && format(os);
                }
                if (version && (data = /(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(version) || /(?:alpha|beta)(?: ?\d)?/i.exec(ua + ";" + (useFeatures && nav.appMinorVersion)) || /\bMinefield\b/i.test(ua) && "a")) {
                    prerelease = /b/i.test(data) ? "beta" : "alpha";
                    version = version.replace(RegExp(data + "\\+?$"), "") + (prerelease == "beta" ? beta : alpha) + (/\d+\+?/.exec(data) || "");
                }
                if (name == "Fennec" || name == "Firefox" && /\b(?:Android|Firefox OS|KaiOS)\b/.test(os)) {
                    name = "Firefox Mobile";
                } else if (name == "Maxthon" && version) {
                    version = version.replace(/\.[\d.]+/, ".x");
                } else if (/\bXbox\b/i.test(product)) {
                    if (product == "Xbox 360") {
                        os = null;
                    }
                    if (product == "Xbox 360" && /\bIEMobile\b/.test(ua)) {
                        description.unshift("mobile mode");
                    }
                } else if ((/^(?:Chrome|IE|Opera)$/.test(name) || name && !product && !/Browser|Mobi/.test(name)) && (os == "Windows CE" || /Mobi/i.test(ua))) {
                    name += " Mobile";
                } else if (name == "IE" && useFeatures) {
                    try {
                        if (context.external === null) {
                            description.unshift("platform preview");
                        }
                    } catch (e) {
                        description.unshift("embedded");
                    }
                } else if ((/\bBlackBerry\b/.test(product) || /\bBB10\b/.test(ua)) && (data = (RegExp(product.replace(/ +/g, " *") + "/([.\\d]+)", "i").exec(ua) || 0)[1] || version)) {
                    data = [
                        data,
                        /BB10/.test(ua)
                    ];
                    os = (data[1] ? (product = null, manufacturer = "BlackBerry") : "Device Software") + " " + data[0];
                    version = null;
                } else if (this != forOwn && product != "Wii" && (useFeatures && opera || /Opera/.test(name) && /\b(?:MSIE|Firefox)\b/i.test(ua) || name == "Firefox" && /\bOS X (?:\d+\.){2,}/.test(os) || name == "IE" && (os && !/^Win/.test(os) && version > 5.5 || /\bWindows XP\b/.test(os) && version > 8 || version == 8 && !/\bTrident\b/.test(ua))) && !reOpera.test(data = parse4.call(forOwn, ua.replace(reOpera, "") + ";")) && data.name) {
                    data = "ing as " + data.name + ((data = data.version) ? " " + data : "");
                    if (reOpera.test(name)) {
                        if (/\bIE\b/.test(data) && os == "Mac OS") {
                            os = null;
                        }
                        data = "identify" + data;
                    } else {
                        data = "mask" + data;
                        if (operaClass) {
                            name = format(operaClass.replace(/([a-z])([A-Z])/g, "$1 $2"));
                        } else {
                            name = "Opera";
                        }
                        if (/\bIE\b/.test(data)) {
                            os = null;
                        }
                        if (!useFeatures) {
                            version = null;
                        }
                    }
                    layout = [
                        "Presto"
                    ];
                    description.push(data);
                }
                if (data = (/\bAppleWebKit\/([\d.]+\+?)/i.exec(ua) || 0)[1]) {
                    data = [
                        parseFloat(data.replace(/\.(\d)$/, ".0$1")),
                        data
                    ];
                    if (name == "Safari" && data[1].slice(-1) == "+") {
                        name = "WebKit Nightly";
                        prerelease = "alpha";
                        version = data[1].slice(0, -1);
                    } else if (version == data[1] || version == (data[2] = (/\bSafari\/([\d.]+\+?)/i.exec(ua) || 0)[1])) {
                        version = null;
                    }
                    data[1] = (/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(ua) || 0)[1];
                    if (data[0] == 537.36 && data[2] == 537.36 && parseFloat(data[1]) >= 28 && layout == "WebKit") {
                        layout = [
                            "Blink"
                        ];
                    }
                    if (!useFeatures || !likeChrome && !data[1]) {
                        layout && (layout[1] = "like Safari");
                        data = (data = data[0], data < 400 ? 1 : data < 500 ? 2 : data < 526 ? 3 : data < 533 ? 4 : data < 534 ? "4+" : data < 535 ? 5 : data < 537 ? 6 : data < 538 ? 7 : data < 601 ? 8 : data < 602 ? 9 : data < 604 ? 10 : data < 606 ? 11 : data < 608 ? 12 : "12");
                    } else {
                        layout && (layout[1] = "like Chrome");
                        data = data[1] || (data = data[0], data < 530 ? 1 : data < 532 ? 2 : data < 532.05 ? 3 : data < 533 ? 4 : data < 534.03 ? 5 : data < 534.07 ? 6 : data < 534.1 ? 7 : data < 534.13 ? 8 : data < 534.16 ? 9 : data < 534.24 ? 10 : data < 534.3 ? 11 : data < 535.01 ? 12 : data < 535.02 ? "13+" : data < 535.07 ? 15 : data < 535.11 ? 16 : data < 535.19 ? 17 : data < 536.05 ? 18 : data < 536.1 ? 19 : data < 537.01 ? 20 : data < 537.11 ? "21+" : data < 537.13 ? 23 : data < 537.18 ? 24 : data < 537.24 ? 25 : data < 537.36 ? 26 : layout != "Blink" ? "27" : "28");
                    }
                    layout && (layout[1] += " " + (data += typeof data == "number" ? ".x" : /[.+]/.test(data) ? "" : "+"));
                    if (name == "Safari" && (!version || parseInt(version) > 45)) {
                        version = data;
                    } else if (name == "Chrome" && /\bHeadlessChrome/i.test(ua)) {
                        description.unshift("headless");
                    }
                }
                if (name == "Opera" && (data = /\bzbov|zvav$/.exec(os))) {
                    name += " ";
                    description.unshift("desktop mode");
                    if (data == "zvav") {
                        name += "Mini";
                        version = null;
                    } else {
                        name += "Mobile";
                    }
                    os = os.replace(RegExp(" *" + data + "$"), "");
                } else if (name == "Safari" && /\bChrome\b/.exec(layout && layout[1])) {
                    description.unshift("desktop mode");
                    name = "Chrome Mobile";
                    version = null;
                    if (/\bOS X\b/.test(os)) {
                        manufacturer = "Apple";
                        os = "iOS 4.3+";
                    } else {
                        os = null;
                    }
                } else if (/\bSRWare Iron\b/.test(name) && !version) {
                    version = getVersion("Chrome");
                }
                if (version && version.indexOf(data = /[\d.]+$/.exec(os)) == 0 && ua.indexOf("/" + data + "-") > -1) {
                    os = trim(os.replace(data, ""));
                }
                if (os && os.indexOf(name) != -1 && !RegExp(name + " OS").test(os)) {
                    os = os.replace(RegExp(" *" + qualify(name) + " *"), "");
                }
                if (layout && !/\b(?:Avant|Nook)\b/.test(name) && (/Browser|Lunascape|Maxthon/.test(name) || name != "Safari" && /^iOS/.test(os) && /\bSafari\b/.test(layout[1]) || /^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(name) && layout[1])) {
                    (data = layout[layout.length - 1]) && description.push(data);
                }
                if (description.length) {
                    description = [
                        "(" + description.join("; ") + ")"
                    ];
                }
                if (manufacturer && product && product.indexOf(manufacturer) < 0) {
                    description.push("on " + manufacturer);
                }
                if (product) {
                    description.push((/^on /.test(description[description.length - 1]) ? "" : "on ") + product);
                }
                if (os) {
                    data = / ([\d.+]+)$/.exec(os);
                    isSpecialCasedOS = data && os.charAt(os.length - data[0].length - 1) == "/";
                    os = {
                        "architecture": 32,
                        "family": data && !isSpecialCasedOS ? os.replace(data[0], "") : os,
                        "version": data ? data[1] : null,
                        "toString": function() {
                            var version2 = this.version;
                            return this.family + (version2 && !isSpecialCasedOS ? " " + version2 : "") + (this.architecture == 64 ? " 64-bit" : "");
                        }
                    };
                }
                if ((data = /\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(arch)) && !/\bi686\b/i.test(arch)) {
                    if (os) {
                        os.architecture = 64;
                        os.family = os.family.replace(RegExp(" *" + data), "");
                    }
                    if (name && (/\bWOW64\b/i.test(ua) || useFeatures && /\w(?:86|32)$/.test(nav.cpuClass || nav.platform) && !/\bWin64; x64\b/i.test(ua))) {
                        description.unshift("32-bit");
                    }
                } else if (os && /^OS X/.test(os.family) && name == "Chrome" && parseFloat(version) >= 39) {
                    os.architecture = 64;
                }
                ua || (ua = null);
                var platform3 = {};
                platform3.description = ua;
                platform3.layout = layout && layout[0];
                platform3.manufacturer = manufacturer;
                platform3.name = name;
                platform3.prerelease = prerelease;
                platform3.product = product;
                platform3.ua = ua;
                platform3.version = name && version;
                platform3.os = os || {
                    /**
           * The CPU architecture the OS is built for.
           *
           * @memberOf platform.os
           * @type number|null
           */ "architecture": null,
                    /**
           * The family of the OS.
           *
           * Common values include:
           * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
           * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
           * "SuSE", "Android", "iOS" and "Windows Phone"
           *
           * @memberOf platform.os
           * @type string|null
           */ "family": null,
                    /**
           * The version of the OS.
           *
           * @memberOf platform.os
           * @type string|null
           */ "version": null,
                    /**
           * Returns the OS string.
           *
           * @memberOf platform.os
           * @returns {string} The OS string.
           */ "toString": function() {
                        return "null";
                    }
                };
                platform3.parse = parse4;
                platform3.toString = toStringPlatform;
                if (platform3.version) {
                    description.unshift(version);
                }
                if (platform3.name) {
                    description.unshift(name);
                }
                if (os && name && !(os == String(os).split(" ")[0] && (os == name.split(" ")[0] || product))) {
                    description.push(product ? "(" + os + ")" : "on " + os);
                }
                if (description.length) {
                    platform3.description = description.join(" ");
                }
                return platform3;
            }
            var platform2 = parse4();
            if (false) // removed by dead control flow
{} else if (freeExports3 && freeModule3) {
                forOwn(platform2, function(value, key) {
                    freeExports3[key] = value;
                });
            } else {
                root2.platform = platform2;
            }
        }).call(exports2);
    }
});
// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__esm)({
    "node_modules/nanoid/url-alphabet/index.js" () {
        urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
    }
});
// node_modules/nanoid/index.browser.js
var index_browser_exports = {};
(0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__export)(index_browser_exports, {
    customAlphabet: ()=>customAlphabet,
    customRandom: ()=>customRandom,
    nanoid: ()=>nanoid,
    random: ()=>random,
    urlAlphabet: ()=>urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_browser = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__esm)({
    "node_modules/nanoid/index.browser.js" () {
        init_url_alphabet();
        random = (bytes)=>crypto.getRandomValues(new Uint8Array(bytes));
        customRandom = (alphabet, defaultSize, getRandom)=>{
            let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
            let step = -~(1.6 * mask * defaultSize / alphabet.length);
            return (size = defaultSize)=>{
                let id = "";
                while(true){
                    let bytes = getRandom(step);
                    let j = step | 0;
                    while(j--){
                        id += alphabet[bytes[j] & mask] || "";
                        if (id.length === size) return id;
                    }
                }
            };
        };
        customAlphabet = (alphabet, size = 21)=>customRandom(alphabet, size, random);
        nanoid = (size = 21)=>crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte)=>{
                byte &= 63;
                if (byte < 36) {
                    id += byte.toString(36);
                } else if (byte < 62) {
                    id += (byte - 26).toString(36).toUpperCase();
                } else if (byte > 62) {
                    id += "-";
                } else {
                    id += "_";
                }
                return id;
            }, "");
    }
});
// node_modules/ics/dist/defaults.js
var require_defaults = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/defaults.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.headerDefaults = exports2.eventDefaults = void 0;
        var _nanoid = (init_index_browser(), (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toCommonJS)(index_browser_exports));
        var headerDefaults = exports2.headerDefaults = function headerDefaults2() {
            return {
                productId: "adamgibbons/ics",
                method: "PUBLISH"
            };
        };
        var eventDefaults = exports2.eventDefaults = function eventDefaults2() {
            return {
                title: "Untitled event",
                uid: (0, _nanoid.nanoid)(),
                timestamp: Date.now()
            };
        };
    }
});
// node_modules/ics/dist/pipeline/build.js
var require_build = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/pipeline/build.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.buildEvent = buildEvent;
        exports2.buildHeader = buildHeader;
        var _defaults = require_defaults();
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        function removeUndefined(input) {
            return Object.entries(input).reduce(function(clean, entry) {
                return typeof entry[1] !== "undefined" ? Object.assign(clean, _defineProperty({}, entry[0], entry[1])) : clean;
            }, {});
        }
        function buildHeader() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var output = Object.assign({}, (0, _defaults.headerDefaults)(), attributes);
            return removeUndefined(output);
        }
        function buildEvent() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var output = Object.assign({}, (0, _defaults.eventDefaults)(), attributes);
            return removeUndefined(output);
        }
    }
});
// node_modules/ics/dist/utils/format-date.js
var require_format_date = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/format-date.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatDate;
        function _slicedToArray(arr, i2) {
            return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _unsupportedIterableToArray(o, minLen) {
            if (!o) return;
            if (typeof o === "string") return _arrayLikeToArray(o, minLen);
            var n = Object.prototype.toString.call(o).slice(8, -1);
            if (n === "Object" && o.constructor) n = o.constructor.name;
            if (n === "Map" || n === "Set") return Array.from(o);
            if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
        }
        function _arrayLikeToArray(arr, len) {
            if (len == null || len > arr.length) len = arr.length;
            for(var i2 = 0, arr2 = new Array(len); i2 < len; i2++)arr2[i2] = arr[i2];
            return arr2;
        }
        function _iterableToArrayLimit(arr, i2) {
            var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
            if (null != _i) {
                var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
                try {
                    if (_x = (_i = _i.call(arr)).next, 0 === i2) {
                        if (Object(_i) !== _i) return;
                        _n = false;
                    } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i2); _n = true);
                } catch (err) {
                    _d = true, _e = err;
                } finally{
                    try {
                        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r)) return;
                    } finally{
                        if (_d) throw _e;
                    }
                }
                return _arr;
            }
        }
        function _arrayWithHoles(arr) {
            if (Array.isArray(arr)) return arr;
        }
        var pad = function pad2(n) {
            return n < 10 ? "0".concat(n) : "".concat(n);
        };
        function formatDate() {
            var args = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
            var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utc";
            var inputType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "local";
            if (typeof args === "string") {
                return args;
            }
            if (Array.isArray(args) && args.length === 3) {
                var _args = _slicedToArray(args, 3), year = _args[0], month = _args[1], date2 = _args[2];
                return "".concat(year).concat(pad(month)).concat(pad(date2));
            }
            var outDate = /* @__PURE__ */ new Date();
            if (Array.isArray(args) && args.length > 0 && args[0]) {
                var _args2 = _slicedToArray(args, 6), _year = _args2[0], _month = _args2[1], _date = _args2[2], _args2$ = _args2[3], hours = _args2$ === void 0 ? 0 : _args2$, _args2$2 = _args2[4], minutes = _args2$2 === void 0 ? 0 : _args2$2, _args2$3 = _args2[5], seconds = _args2$3 === void 0 ? 0 : _args2$3;
                if (inputType === "local") {
                    outDate = new Date(_year, _month - 1, _date, hours, minutes, seconds);
                } else {
                    outDate = new Date(Date.UTC(_year, _month - 1, _date, hours, minutes, seconds));
                }
            } else if (!Array.isArray(args)) {
                outDate = new Date(args);
            }
            if (outputType === "local") {
                return [
                    outDate.getFullYear(),
                    pad(outDate.getMonth() + 1),
                    pad(outDate.getDate()),
                    "T",
                    pad(outDate.getHours()),
                    pad(outDate.getMinutes()),
                    pad(outDate.getSeconds())
                ].join("");
            }
            return [
                outDate.getUTCFullYear(),
                pad(outDate.getUTCMonth() + 1),
                pad(outDate.getUTCDate()),
                "T",
                pad(outDate.getUTCHours()),
                pad(outDate.getUTCMinutes()),
                pad(outDate.getUTCSeconds()),
                "Z"
            ].join("");
        }
    }
});
// node_modules/ics/dist/utils/set-geolocation.js
var require_set_geolocation = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-geolocation.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setGeolocation;
        function setGeolocation(_ref) {
            var lat = _ref.lat, lon = _ref.lon;
            return "".concat(lat, ";").concat(lon);
        }
    }
});
// node_modules/ics/dist/utils/encode-param-value.js
var require_encode_param_value = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/encode-param-value.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = encodeParamValue;
        function encodeParamValue(value) {
            return '"'.concat(value.replaceAll('"', '\\"'), '"');
        }
    }
});
// node_modules/ics/dist/utils/set-contact.js
var require_set_contact = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-contact.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setContact;
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setContact(_ref) {
            var name = _ref.name, email = _ref.email, rsvp = _ref.rsvp, dir = _ref.dir, partstat = _ref.partstat, role = _ref.role, cutype = _ref.cutype, xNumGuests = _ref.xNumGuests;
            var formattedParts = [];
            if (rsvp !== void 0) {
                formattedParts.push(rsvp ? "RSVP=TRUE" : "RSVP=FALSE");
            }
            if (cutype) {
                formattedParts.push("CUTYPE=".concat((0, _encodeParamValue["default"])(cutype)));
            }
            if (xNumGuests !== void 0) {
                formattedParts.push("X-NUM-GUESTS=".concat(xNumGuests));
            }
            if (role) {
                formattedParts.push("ROLE=".concat((0, _encodeParamValue["default"])(role)));
            }
            if (partstat) {
                formattedParts.push("PARTSTAT=".concat((0, _encodeParamValue["default"])(partstat)));
            }
            if (dir) {
                formattedParts.push("DIR=".concat((0, _encodeParamValue["default"])(dir)));
            }
            formattedParts.push("CN=".concat((0, _encodeParamValue["default"])(name || "Unnamed attendee")));
            var formattedAttendee = formattedParts.join(";").concat(email ? ":mailto:".concat(email) : "");
            return formattedAttendee;
        }
    }
});
// node_modules/ics/dist/utils/set-organizer.js
var require_set_organizer = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-organizer.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setOrganizer;
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setOrganizer(_ref) {
            var name = _ref.name, email = _ref.email, dir = _ref.dir, sentBy = _ref.sentBy;
            var formattedOrganizer = "";
            formattedOrganizer += dir ? "DIR=".concat((0, _encodeParamValue["default"])(dir), ";") : "";
            formattedOrganizer += sentBy ? "SENT-BY=".concat((0, _encodeParamValue["default"])("MAILTO:".concat(sentBy)), ";") : "";
            formattedOrganizer += "CN=";
            formattedOrganizer += (0, _encodeParamValue["default"])(name || "Organizer");
            formattedOrganizer += email ? ":MAILTO:".concat(email) : "";
            return formattedOrganizer;
        }
    }
});
// node_modules/runes2/dist/index.cjs.development.cjs
var require_index_cjs_development = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/runes2/dist/index.cjs.development.cjs" (exports2, module2) {
        "use strict";
        var EnumRunesCode;
        (function(EnumRunesCode2) {
            EnumRunesCode2[EnumRunesCode2["HIGH_SURROGATE_START"] = 55296] = "HIGH_SURROGATE_START";
            EnumRunesCode2[EnumRunesCode2["HIGH_SURROGATE_END"] = 56319] = "HIGH_SURROGATE_END";
            EnumRunesCode2[EnumRunesCode2["LOW_SURROGATE_START"] = 56320] = "LOW_SURROGATE_START";
            EnumRunesCode2[EnumRunesCode2["REGIONAL_INDICATOR_START"] = 127462] = "REGIONAL_INDICATOR_START";
            EnumRunesCode2[EnumRunesCode2["REGIONAL_INDICATOR_END"] = 127487] = "REGIONAL_INDICATOR_END";
            EnumRunesCode2[EnumRunesCode2["FITZPATRICK_MODIFIER_START"] = 127995] = "FITZPATRICK_MODIFIER_START";
            EnumRunesCode2[EnumRunesCode2["FITZPATRICK_MODIFIER_END"] = 127999] = "FITZPATRICK_MODIFIER_END";
            EnumRunesCode2[EnumRunesCode2["VARIATION_MODIFIER_START"] = 65024] = "VARIATION_MODIFIER_START";
            EnumRunesCode2[EnumRunesCode2["VARIATION_MODIFIER_END"] = 65039] = "VARIATION_MODIFIER_END";
            EnumRunesCode2[EnumRunesCode2["DIACRITICAL_MARKS_START"] = 8400] = "DIACRITICAL_MARKS_START";
            EnumRunesCode2[EnumRunesCode2["DIACRITICAL_MARKS_END"] = 8447] = "DIACRITICAL_MARKS_END";
            EnumRunesCode2[EnumRunesCode2["SUBDIVISION_INDICATOR_START"] = 127988] = "SUBDIVISION_INDICATOR_START";
            EnumRunesCode2[EnumRunesCode2["TAGS_START"] = 917504] = "TAGS_START";
            EnumRunesCode2[EnumRunesCode2["TAGS_END"] = 917631] = "TAGS_END";
            EnumRunesCode2[EnumRunesCode2["ZWJ"] = 8205] = "ZWJ";
        })(EnumRunesCode || (EnumRunesCode = {}));
        var GRAPHEMES = Object.freeze([
            776,
            2359,
            2367,
            2984,
            3007,
            3021,
            3633,
            3635,
            3648,
            3657,
            4352,
            4449,
            4520
        ]);
        var EnumCodeUnits;
        (function(EnumCodeUnits2) {
            EnumCodeUnits2[EnumCodeUnits2["unit_1"] = 1] = "unit_1";
            EnumCodeUnits2[EnumCodeUnits2["unit_2"] = 2] = "unit_2";
            EnumCodeUnits2[EnumCodeUnits2["unit_4"] = 4] = "unit_4";
        })(EnumCodeUnits || (EnumCodeUnits = {}));
        function runes(string2) {
            if (typeof string2 !== "string") {
                throw new TypeError("string cannot be undefined or null");
            }
            const result = [];
            let i2 = 0;
            let increment = 0;
            while(i2 < string2.length){
                increment += nextUnits(i2 + increment, string2);
                if (isGrapheme(string2[i2 + increment])) {
                    increment++;
                }
                if (isVariationSelector(string2[i2 + increment])) {
                    increment++;
                }
                if (isDiacriticalMark(string2[i2 + increment])) {
                    increment++;
                }
                if (isZeroWidthJoiner(string2[i2 + increment])) {
                    increment++;
                    continue;
                }
                result.push(string2.substring(i2, i2 + increment));
                i2 += increment;
                increment = 0;
            }
            return result;
        }
        function nextUnits(i2, string2) {
            const current = string2[i2];
            if (!isFirstOfSurrogatePair(current) || i2 === string2.length - 1) {
                return 1;
            }
            const currentPair = current + string2[i2 + 1];
            let nextPair = string2.substring(i2 + 2, i2 + 5);
            if (isRegionalIndicator(currentPair) && isRegionalIndicator(nextPair)) {
                return 4;
            }
            if (isSubdivisionFlag(currentPair) && isSupplementarySpecialpurposePlane(nextPair)) {
                return string2.slice(i2).indexOf(String.fromCodePoint(917631)) + 2;
            }
            if (isFitzpatrickModifier(nextPair)) {
                return 4;
            }
            return 2;
        }
        function isFirstOfSurrogatePair(string2) {
            return string2 && betweenInclusive(string2[0].charCodeAt(0), 55296, 56319);
        }
        function isRegionalIndicator(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127462, 127487);
        }
        function isSubdivisionFlag(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127988, 127988);
        }
        function isFitzpatrickModifier(string2) {
            return betweenInclusive(codePointFromSurrogatePair(string2), 127995, 127999);
        }
        function isVariationSelector(string2) {
            return typeof string2 === "string" && betweenInclusive(string2.charCodeAt(0), 65024, 65039);
        }
        function isDiacriticalMark(string2) {
            return typeof string2 === "string" && betweenInclusive(string2.charCodeAt(0), 8400, 8447);
        }
        function isSupplementarySpecialpurposePlane(string2) {
            const codePoint = string2.codePointAt(0);
            return typeof string2 === "string" && typeof codePoint === "number" && betweenInclusive(codePoint, 917504, 917631);
        }
        function isGrapheme(string2) {
            return typeof string2 === "string" && GRAPHEMES.includes(string2.charCodeAt(0));
        }
        function isZeroWidthJoiner(string2) {
            return typeof string2 === "string" && string2.charCodeAt(0) === 8205;
        }
        function codePointFromSurrogatePair(pair) {
            const highOffset = pair.charCodeAt(0) - 55296;
            const lowOffset = pair.charCodeAt(1) - 56320;
            return (highOffset << 10) + lowOffset + 65536;
        }
        function betweenInclusive(value, lower, upper) {
            return value >= lower && value <= upper;
        }
        function substring(string2, start, width) {
            const chars = runes(string2);
            if (start === void 0) {
                return string2;
            }
            if (start >= chars.length) {
                return "";
            }
            const rest = chars.length - start;
            const stringWidth = width === void 0 ? rest : width;
            let endIndex = start + stringWidth;
            if (endIndex > start + rest) {
                endIndex = void 0;
            }
            return chars.slice(start, endIndex).join("");
        }
        {
            Object.defineProperty(runes, "runes", {
                value: runes
            });
            Object.defineProperty(runes, "default", {
                value: runes
            });
            Object.defineProperty(runes, "__esModule", {
                value: true
            });
            Object.defineProperty(runes, "substr", {
                value: substring
            });
            Object.defineProperty(runes, "substring", {
                value: substring
            });
            Object.defineProperty(runes, "EnumRunesCode", {
                value: EnumRunesCode
            });
            Object.defineProperty(runes, "EnumCodeUnits", {
                value: EnumCodeUnits
            });
            Object.defineProperty(runes, "GRAPHEMES", {
                value: GRAPHEMES
            });
        }
        module2.exports = runes;
    }
});
// node_modules/runes2/dist/index.cjs.production.min.cjs
var require_index_cjs_production_min = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/runes2/dist/index.cjs.production.min.cjs" (exports2, module2) {
        "use strict";
        var e;
        !function(e2) {
            e2[e2.HIGH_SURROGATE_START = 55296] = "HIGH_SURROGATE_START", e2[e2.HIGH_SURROGATE_END = 56319] = "HIGH_SURROGATE_END", e2[e2.LOW_SURROGATE_START = 56320] = "LOW_SURROGATE_START", e2[e2.REGIONAL_INDICATOR_START = 127462] = "REGIONAL_INDICATOR_START", e2[e2.REGIONAL_INDICATOR_END = 127487] = "REGIONAL_INDICATOR_END", e2[e2.FITZPATRICK_MODIFIER_START = 127995] = "FITZPATRICK_MODIFIER_START", e2[e2.FITZPATRICK_MODIFIER_END = 127999] = "FITZPATRICK_MODIFIER_END", e2[e2.VARIATION_MODIFIER_START = 65024] = "VARIATION_MODIFIER_START", e2[e2.VARIATION_MODIFIER_END = 65039] = "VARIATION_MODIFIER_END", e2[e2.DIACRITICAL_MARKS_START = 8400] = "DIACRITICAL_MARKS_START", e2[e2.DIACRITICAL_MARKS_END = 8447] = "DIACRITICAL_MARKS_END", e2[e2.SUBDIVISION_INDICATOR_START = 127988] = "SUBDIVISION_INDICATOR_START", e2[e2.TAGS_START = 917504] = "TAGS_START", e2[e2.TAGS_END = 917631] = "TAGS_END", e2[e2.ZWJ = 8205] = "ZWJ";
        }(e || (e = {}));
        var n = Object.freeze([
            776,
            2359,
            2367,
            2984,
            3007,
            3021,
            3633,
            3635,
            3648,
            3657,
            4352,
            4449,
            4520
        ]);
        var t;
        function runes(e2) {
            if ("string" != typeof e2) throw new TypeError("string cannot be undefined or null");
            const n2 = [];
            let t2 = 0, r = 0;
            for(; t2 < e2.length;)r += nextUnits(t2 + r, e2), isGrapheme(e2[t2 + r]) && r++, isVariationSelector(e2[t2 + r]) && r++, isDiacriticalMark(e2[t2 + r]) && r++, isZeroWidthJoiner(e2[t2 + r]) ? r++ : (n2.push(e2.substring(t2, t2 + r)), t2 += r, r = 0);
            return n2;
        }
        function nextUnits(e2, n2) {
            const t2 = n2[e2];
            if (!function isFirstOfSurrogatePair(e3) {
                return e3 && betweenInclusive(e3[0].charCodeAt(0), 55296, 56319);
            }(t2) || e2 === n2.length - 1) return 1;
            const r = t2 + n2[e2 + 1];
            let i2 = n2.substring(e2 + 2, e2 + 5);
            return isRegionalIndicator(r) && isRegionalIndicator(i2) ? 4 : function isSubdivisionFlag(e3) {
                return betweenInclusive(codePointFromSurrogatePair(e3), 127988, 127988);
            }(r) && function isSupplementarySpecialpurposePlane(e3) {
                const n3 = e3.codePointAt(0);
                return "string" == typeof e3 && "number" == typeof n3 && betweenInclusive(n3, 917504, 917631);
            }(i2) ? n2.slice(e2).indexOf(String.fromCodePoint(917631)) + 2 : function isFitzpatrickModifier(e3) {
                return betweenInclusive(codePointFromSurrogatePair(e3), 127995, 127999);
            }(i2) ? 4 : 2;
        }
        function isRegionalIndicator(e2) {
            return betweenInclusive(codePointFromSurrogatePair(e2), 127462, 127487);
        }
        function isVariationSelector(e2) {
            return "string" == typeof e2 && betweenInclusive(e2.charCodeAt(0), 65024, 65039);
        }
        function isDiacriticalMark(e2) {
            return "string" == typeof e2 && betweenInclusive(e2.charCodeAt(0), 8400, 8447);
        }
        function isGrapheme(e2) {
            return "string" == typeof e2 && n.includes(e2.charCodeAt(0));
        }
        function isZeroWidthJoiner(e2) {
            return "string" == typeof e2 && 8205 === e2.charCodeAt(0);
        }
        function codePointFromSurrogatePair(e2) {
            return (e2.charCodeAt(0) - 55296 << 10) + (e2.charCodeAt(1) - 56320) + 65536;
        }
        function betweenInclusive(e2, n2, t2) {
            return e2 >= n2 && e2 <= t2;
        }
        function substring(e2, n2, t2) {
            const r = runes(e2);
            if (void 0 === n2) return e2;
            if (n2 >= r.length) return "";
            const i2 = r.length - n2;
            let o = n2 + (void 0 === t2 ? i2 : t2);
            return o > n2 + i2 && (o = void 0), r.slice(n2, o).join("");
        }
        !function(e2) {
            e2[e2.unit_1 = 1] = "unit_1", e2[e2.unit_2 = 2] = "unit_2", e2[e2.unit_4 = 4] = "unit_4";
        }(t || (t = {})), Object.defineProperty(runes, "runes", {
            value: runes
        }), Object.defineProperty(runes, "default", {
            value: runes
        }), Object.defineProperty(runes, "__esModule", {
            value: true
        }), Object.defineProperty(runes, "substr", {
            value: substring
        }), Object.defineProperty(runes, "substring", {
            value: substring
        }), Object.defineProperty(runes, "EnumRunesCode", {
            value: e
        }), Object.defineProperty(runes, "EnumCodeUnits", {
            value: t
        }), Object.defineProperty(runes, "GRAPHEMES", {
            value: n
        }), module2.exports = runes;
    }
});
// node_modules/runes2/dist/index.cjs
var require_dist = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/runes2/dist/index.cjs" (exports2, module2) {
        "use strict";
        if (typeof process !== "undefined" && true) {
            module2.exports = require_index_cjs_development();
        } else {
            module2.exports = require_index_cjs_production_min();
        }
    }
});
// node_modules/ics/dist/utils/fold-line.js
var require_fold_line = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/fold-line.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = foldLine;
        var _runes = require_dist();
        function foldLine(line) {
            var parts = [];
            var length = 75;
            while((0, _runes.runes)(line).length > length){
                parts.push((0, _runes.substring)(line, 0, length));
                line = (0, _runes.substring)(line, length);
                length = 74;
            }
            parts.push(line);
            return parts.join("\r\n	");
        }
    }
});
// node_modules/ics/dist/utils/encode-new-lines.js
var require_encode_new_lines = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/encode-new-lines.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = encodeNewLines;
        function encodeNewLines(text) {
            return text.replace(/\r?\n/gm, "\\n");
        }
    }
});
// node_modules/ics/dist/utils/set-alarm.js
var require_set_alarm = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-alarm.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setAlarm;
        var _formatDate = _interopRequireDefault(require_format_date());
        var _foldLine = _interopRequireDefault(require_fold_line());
        var _encodeNewLines = _interopRequireDefault(require_encode_new_lines());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setDuration(_ref) {
            var weeks = _ref.weeks, days = _ref.days, hours = _ref.hours, minutes = _ref.minutes, seconds = _ref.seconds;
            var formattedString = "P";
            formattedString += weeks ? "".concat(weeks, "W") : "";
            formattedString += days ? "".concat(days, "D") : "";
            formattedString += "T";
            formattedString += hours ? "".concat(hours, "H") : "";
            formattedString += minutes ? "".concat(minutes, "M") : "";
            formattedString += seconds ? "".concat(seconds, "S") : "";
            return formattedString;
        }
        function setTrigger(trigger) {
            var formattedString = "";
            if (Array.isArray(trigger) || typeof trigger === "number" || typeof trigger === "string") {
                formattedString = "TRIGGER;VALUE=DATE-TIME:".concat((0, _encodeNewLines["default"])((0, _formatDate["default"])(trigger)), "\r\n");
            } else {
                var alert = trigger.before ? "-" : "";
                formattedString = "TRIGGER:".concat((0, _encodeNewLines["default"])(alert + setDuration(trigger)), "\r\n");
            }
            return formattedString;
        }
        function setAction(action) {
            return action.toUpperCase();
        }
        function setAlarm() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var action = attributes.action, repeat = attributes.repeat, description = attributes.description, duration = attributes.duration, attach = attributes.attach, attachType = attributes.attachType, trigger = attributes.trigger, summary = attributes.summary;
            var formattedString = "BEGIN:VALARM\r\n";
            formattedString += (0, _foldLine["default"])("ACTION:".concat((0, _encodeNewLines["default"])(setAction(action)))) + "\r\n";
            formattedString += repeat ? (0, _foldLine["default"])("REPEAT:".concat(repeat)) + "\r\n" : "";
            formattedString += description ? (0, _foldLine["default"])("DESCRIPTION:".concat((0, _encodeNewLines["default"])(description))) + "\r\n" : "";
            formattedString += duration ? (0, _foldLine["default"])("DURATION:".concat(setDuration(duration))) + "\r\n" : "";
            var attachInfo = attachType ? attachType : "FMTTYPE=audio/basic";
            formattedString += attach ? (0, _foldLine["default"])((0, _encodeNewLines["default"])("ATTACH;".concat(attachInfo, ":").concat(attach))) + "\r\n" : "";
            formattedString += trigger ? setTrigger(trigger) : "";
            formattedString += summary ? (0, _foldLine["default"])("SUMMARY:".concat((0, _encodeNewLines["default"])(summary))) + "\r\n" : "";
            formattedString += "END:VALARM\r\n";
            return formattedString;
        }
    }
});
// node_modules/ics/dist/utils/format-text.js
var require_format_text = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/format-text.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatText;
        function formatText(text) {
            return text.replace(/\\/gm, "\\\\").replace(/\r?\n/gm, "\\n").replace(/;/gm, "\\;").replace(/,/gm, "\\,");
        }
    }
});
// node_modules/ics/dist/utils/set-description.js
var require_set_description = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-description.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setDescription;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setDescription(description) {
            return (0, _formatText["default"])(description);
        }
    }
});
// node_modules/ics/dist/utils/set-summary.js
var require_set_summary = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-summary.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setSummary;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setSummary(summary) {
            return (0, _formatText["default"])(summary);
        }
    }
});
// node_modules/ics/dist/utils/format-duration.js
var require_format_duration = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/format-duration.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = formatDuration;
        function formatDuration() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var weeks = attributes.weeks, days = attributes.days, hours = attributes.hours, minutes = attributes.minutes, seconds = attributes.seconds;
            var formattedDuration = "P";
            formattedDuration += weeks ? "".concat(weeks, "W") : "";
            formattedDuration += days ? "".concat(days, "D") : "";
            formattedDuration += "T";
            formattedDuration += hours ? "".concat(hours, "H") : "";
            formattedDuration += minutes ? "".concat(minutes, "M") : "";
            formattedDuration += seconds ? "".concat(seconds, "S") : "";
            return formattedDuration;
        }
    }
});
// node_modules/ics/dist/utils/set-location.js
var require_set_location = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/set-location.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2["default"] = setLocation;
        var _formatText = _interopRequireDefault(require_format_text());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function setLocation(location2) {
            return (0, _formatText["default"])(location2);
        }
    }
});
// node_modules/ics/dist/utils/index.js
var require_utils = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/utils/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        Object.defineProperty(exports2, "encodeParamValue", {
            enumerable: true,
            get: function get2() {
                return _encodeParamValue["default"];
            }
        });
        Object.defineProperty(exports2, "foldLine", {
            enumerable: true,
            get: function get2() {
                return _foldLine["default"];
            }
        });
        Object.defineProperty(exports2, "formatDate", {
            enumerable: true,
            get: function get2() {
                return _formatDate["default"];
            }
        });
        Object.defineProperty(exports2, "formatDuration", {
            enumerable: true,
            get: function get2() {
                return _formatDuration["default"];
            }
        });
        Object.defineProperty(exports2, "setAlarm", {
            enumerable: true,
            get: function get2() {
                return _setAlarm["default"];
            }
        });
        Object.defineProperty(exports2, "setContact", {
            enumerable: true,
            get: function get2() {
                return _setContact["default"];
            }
        });
        Object.defineProperty(exports2, "setDescription", {
            enumerable: true,
            get: function get2() {
                return _setDescription["default"];
            }
        });
        Object.defineProperty(exports2, "setGeolocation", {
            enumerable: true,
            get: function get2() {
                return _setGeolocation["default"];
            }
        });
        Object.defineProperty(exports2, "setLocation", {
            enumerable: true,
            get: function get2() {
                return _setLocation["default"];
            }
        });
        Object.defineProperty(exports2, "setOrganizer", {
            enumerable: true,
            get: function get2() {
                return _setOrganizer["default"];
            }
        });
        Object.defineProperty(exports2, "setSummary", {
            enumerable: true,
            get: function get2() {
                return _setSummary["default"];
            }
        });
        var _formatDate = _interopRequireDefault(require_format_date());
        var _setGeolocation = _interopRequireDefault(require_set_geolocation());
        var _setContact = _interopRequireDefault(require_set_contact());
        var _setOrganizer = _interopRequireDefault(require_set_organizer());
        var _setAlarm = _interopRequireDefault(require_set_alarm());
        var _setDescription = _interopRequireDefault(require_set_description());
        var _setSummary = _interopRequireDefault(require_set_summary());
        var _formatDuration = _interopRequireDefault(require_format_duration());
        var _foldLine = _interopRequireDefault(require_fold_line());
        var _setLocation = _interopRequireDefault(require_set_location());
        var _encodeParamValue = _interopRequireDefault(require_encode_param_value());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
    }
});
// node_modules/ics/dist/pipeline/format.js
var require_format = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/pipeline/format.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.formatEvent = formatEvent;
        exports2.formatFooter = formatFooter;
        exports2.formatHeader = formatHeader;
        var _utils = require_utils();
        var _encodeNewLines = _interopRequireDefault(require_encode_new_lines());
        function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : {
                "default": obj
            };
        }
        function formatHeader() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var productId = attributes.productId, method = attributes.method, calName = attributes.calName;
            var icsFormat = "";
            icsFormat += "BEGIN:VCALENDAR\r\n";
            icsFormat += "VERSION:2.0\r\n";
            icsFormat += "CALSCALE:GREGORIAN\r\n";
            icsFormat += (0, _utils.foldLine)("PRODID:".concat((0, _encodeNewLines["default"])(productId))) + "\r\n";
            icsFormat += (0, _utils.foldLine)("METHOD:".concat((0, _encodeNewLines["default"])(method))) + "\r\n";
            icsFormat += calName ? (0, _utils.foldLine)("X-WR-CALNAME:".concat((0, _encodeNewLines["default"])(calName))) + "\r\n" : "";
            icsFormat += "X-PUBLISHED-TTL:PT1H\r\n";
            return icsFormat;
        }
        function formatFooter() {
            return "END:VCALENDAR\r\n";
        }
        function formatEvent() {
            var attributes = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var title = attributes.title, uid = attributes.uid, sequence = attributes.sequence, timestamp2 = attributes.timestamp, start = attributes.start, startType = attributes.startType, startInputType = attributes.startInputType, startOutputType = attributes.startOutputType, duration = attributes.duration, end = attributes.end, endInputType = attributes.endInputType, endOutputType = attributes.endOutputType, description = attributes.description, url = attributes.url, geo = attributes.geo, location2 = attributes.location, status2 = attributes.status, categories = attributes.categories, organizer = attributes.organizer, attendees = attributes.attendees, alarms = attributes.alarms, recurrenceRule = attributes.recurrenceRule, exclusionDates = attributes.exclusionDates, busyStatus = attributes.busyStatus, transp = attributes.transp, classification = attributes.classification, created = attributes.created, lastModified = attributes.lastModified, htmlContent = attributes.htmlContent;
            var icsFormat = "";
            icsFormat += "BEGIN:VEVENT\r\n";
            icsFormat += (0, _utils.foldLine)("UID:".concat((0, _encodeNewLines["default"])(uid))) + "\r\n";
            icsFormat += title ? (0, _utils.foldLine)("SUMMARY:".concat((0, _encodeNewLines["default"])((0, _utils.setSummary)(title)))) + "\r\n" : "";
            icsFormat += (0, _utils.foldLine)("DTSTAMP:".concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(timestamp2)))) + "\r\n";
            icsFormat += (0, _utils.foldLine)("DTSTART".concat(start && start.length == 3 ? ";VALUE=DATE" : "", ":").concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(start, startOutputType || startType, startInputType)))) + "\r\n";
            if (!end || end.length !== 3 || start.length !== end.length || start.some(function(val, i2) {
                return val !== end[i2];
            })) {
                if (end) {
                    icsFormat += (0, _utils.foldLine)("DTEND".concat(end.length === 3 ? ";VALUE=DATE" : "", ":").concat((0, _encodeNewLines["default"])((0, _utils.formatDate)(end, endOutputType || startOutputType || startType, endInputType || startInputType)))) + "\r\n";
                }
            }
            icsFormat += typeof sequence !== "undefined" ? "SEQUENCE:".concat(sequence, "\r\n") : "";
            icsFormat += description ? (0, _utils.foldLine)("DESCRIPTION:".concat((0, _encodeNewLines["default"])((0, _utils.setDescription)(description)))) + "\r\n" : "";
            icsFormat += url ? (0, _utils.foldLine)("URL:".concat((0, _encodeNewLines["default"])(url))) + "\r\n" : "";
            icsFormat += geo ? (0, _utils.foldLine)("GEO:".concat((0, _utils.setGeolocation)(geo))) + "\r\n" : "";
            icsFormat += location2 ? (0, _utils.foldLine)("LOCATION:".concat((0, _encodeNewLines["default"])((0, _utils.setLocation)(location2)))) + "\r\n" : "";
            icsFormat += status2 ? (0, _utils.foldLine)("STATUS:".concat((0, _encodeNewLines["default"])(status2))) + "\r\n" : "";
            icsFormat += categories ? (0, _utils.foldLine)("CATEGORIES:".concat((0, _encodeNewLines["default"])(categories.join(",")))) + "\r\n" : "";
            icsFormat += organizer ? (0, _utils.foldLine)("ORGANIZER;".concat((0, _utils.setOrganizer)(organizer))) + "\r\n" : "";
            icsFormat += busyStatus ? (0, _utils.foldLine)("X-MICROSOFT-CDO-BUSYSTATUS:".concat((0, _encodeNewLines["default"])(busyStatus))) + "\r\n" : "";
            icsFormat += transp ? (0, _utils.foldLine)("TRANSP:".concat((0, _encodeNewLines["default"])(transp))) + "\r\n" : "";
            icsFormat += classification ? (0, _utils.foldLine)("CLASS:".concat((0, _encodeNewLines["default"])(classification))) + "\r\n" : "";
            icsFormat += created ? "CREATED:" + (0, _encodeNewLines["default"])((0, _utils.formatDate)(created)) + "\r\n" : "";
            icsFormat += lastModified ? "LAST-MODIFIED:" + (0, _encodeNewLines["default"])((0, _utils.formatDate)(lastModified)) + "\r\n" : "";
            icsFormat += htmlContent ? (0, _utils.foldLine)("X-ALT-DESC;FMTTYPE=text/html:".concat((0, _encodeNewLines["default"])(htmlContent))) + "\r\n" : "";
            if (attendees) {
                attendees.forEach(function(attendee) {
                    icsFormat += (0, _utils.foldLine)("ATTENDEE;".concat((0, _encodeNewLines["default"])((0, _utils.setContact)(attendee)))) + "\r\n";
                });
            }
            icsFormat += recurrenceRule ? (0, _utils.foldLine)("RRULE:".concat((0, _encodeNewLines["default"])(recurrenceRule))) + "\r\n" : "";
            icsFormat += exclusionDates ? (0, _utils.foldLine)("EXDATE:".concat((0, _encodeNewLines["default"])(exclusionDates.map(function(a) {
                return (0, _utils.formatDate)(a);
            }).join(",")))) + "\r\n" : "";
            icsFormat += duration ? (0, _utils.foldLine)("DURATION:".concat((0, _utils.formatDuration)(duration))) + "\r\n" : "";
            if (alarms) {
                alarms.forEach(function(alarm) {
                    icsFormat += (0, _utils.setAlarm)(alarm);
                });
            }
            icsFormat += "END:VEVENT\r\n";
            return icsFormat;
        }
    }
});
// node_modules/property-expr/index.js
var require_property_expr = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/property-expr/index.js" (exports2, module2) {
        "use strict";
        function Cache(maxSize) {
            this._maxSize = maxSize;
            this.clear();
        }
        Cache.prototype.clear = function() {
            this._size = 0;
            this._values = /* @__PURE__ */ Object.create(null);
        };
        Cache.prototype.get = function(key) {
            return this._values[key];
        };
        Cache.prototype.set = function(key, value) {
            this._size >= this._maxSize && this.clear();
            if (!(key in this._values)) this._size++;
            return this._values[key] = value;
        };
        var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
        var DIGIT_REGEX = /^\d+$/;
        var LEAD_DIGIT_REGEX = /^\d/;
        var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
        var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
        var MAX_CACHE_SIZE = 512;
        var pathCache = new Cache(MAX_CACHE_SIZE);
        var setCache = new Cache(MAX_CACHE_SIZE);
        var getCache = new Cache(MAX_CACHE_SIZE);
        module2.exports = {
            Cache,
            split: split2,
            normalizePath: normalizePath2,
            setter: function(path) {
                var parts = normalizePath2(path);
                return setCache.get(path) || setCache.set(path, function setter(obj, value) {
                    var index = 0;
                    var len = parts.length;
                    var data = obj;
                    while(index < len - 1){
                        var part = parts[index];
                        if (part === "__proto__" || part === "constructor" || part === "prototype") {
                            return obj;
                        }
                        data = data[parts[index++]];
                    }
                    data[parts[index]] = value;
                });
            },
            getter: function(path, safe) {
                var parts = normalizePath2(path);
                return getCache.get(path) || getCache.set(path, function getter2(data) {
                    var index = 0, len = parts.length;
                    while(index < len){
                        if (data != null || !safe) data = data[parts[index++]];
                        else return;
                    }
                    return data;
                });
            },
            join: function(segments) {
                return segments.reduce(function(path, part) {
                    return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
                }, "");
            },
            forEach: function(path, cb, thisArg) {
                forEach3(Array.isArray(path) ? path : split2(path), cb, thisArg);
            }
        };
        function normalizePath2(path) {
            return pathCache.get(path) || pathCache.set(path, split2(path).map(function(part) {
                return part.replace(CLEAN_QUOTES_REGEX, "$2");
            }));
        }
        function split2(path) {
            return path.match(SPLIT_REGEX) || [
                ""
            ];
        }
        function forEach3(parts, iter, thisArg) {
            var len = parts.length, part, idx, isArray2, isBracket;
            for(idx = 0; idx < len; idx++){
                part = parts[idx];
                if (part) {
                    if (shouldBeQuoted(part)) {
                        part = '"' + part + '"';
                    }
                    isBracket = isQuoted(part);
                    isArray2 = !isBracket && /^\d+$/.test(part);
                    iter.call(thisArg, part, isBracket, isArray2, idx, parts);
                }
            }
        }
        function isQuoted(str) {
            return typeof str === "string" && str && [
                "'",
                '"'
            ].indexOf(str.charAt(0)) !== -1;
        }
        function hasLeadingNumber(part) {
            return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
        }
        function hasSpecialChars(part) {
            return SPEC_CHAR_REGEX.test(part);
        }
        function shouldBeQuoted(part) {
            return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
        }
    }
});
// node_modules/tiny-case/index.js
var require_tiny_case = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/tiny-case/index.js" (exports2, module2) {
        var reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g;
        var words = (str)=>str.match(reWords) || [];
        var upperFirst = (str)=>str[0].toUpperCase() + str.slice(1);
        var join2 = (str, d)=>words(str).join(d).toLowerCase();
        var camelCase2 = (str)=>words(str).reduce((acc, next)=>`${acc}${!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()}`, "");
        var pascalCase = (str)=>upperFirst(camelCase2(str));
        var snakeCase2 = (str)=>join2(str, "_");
        var kebabCase = (str)=>join2(str, "-");
        var sentenceCase = (str)=>upperFirst(join2(str, " "));
        var titleCase = (str)=>words(str).map(upperFirst).join(" ");
        module2.exports = {
            words,
            upperFirst,
            camelCase: camelCase2,
            pascalCase,
            snakeCase: snakeCase2,
            kebabCase,
            sentenceCase,
            titleCase
        };
    }
});
// node_modules/toposort/index.js
var require_toposort = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/toposort/index.js" (exports2, module2) {
        module2.exports = function(edges) {
            return toposort2(uniqueNodes(edges), edges);
        };
        module2.exports.array = toposort2;
        function toposort2(nodes, edges) {
            var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i2 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
            edges.forEach(function(edge) {
                if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
                    throw new Error("Unknown node. There is an unknown node in the supplied edges.");
                }
            });
            while(i2--){
                if (!visited[i2]) visit(nodes[i2], i2, /* @__PURE__ */ new Set());
            }
            return sorted;
            function visit(node, i3, predecessors) {
                if (predecessors.has(node)) {
                    var nodeRep;
                    try {
                        nodeRep = ", node was:" + JSON.stringify(node);
                    } catch (e) {
                        nodeRep = "";
                    }
                    throw new Error("Cyclic dependency" + nodeRep);
                }
                if (!nodesHash.has(node)) {
                    throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
                }
                if (visited[i3]) return;
                visited[i3] = true;
                var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
                outgoing = Array.from(outgoing);
                if (i3 = outgoing.length) {
                    predecessors.add(node);
                    do {
                        var child = outgoing[--i3];
                        visit(child, nodesHash.get(child), predecessors);
                    }while (i3)
                    predecessors.delete(node);
                }
                sorted[--cursor] = node;
            }
        }
        function uniqueNodes(arr) {
            var res = /* @__PURE__ */ new Set();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                var edge = arr[i2];
                res.add(edge[0]);
                res.add(edge[1]);
            }
            return Array.from(res);
        }
        function makeOutgoingEdges(arr) {
            var edges = /* @__PURE__ */ new Map();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                var edge = arr[i2];
                if (!edges.has(edge[0])) edges.set(edge[0], /* @__PURE__ */ new Set());
                if (!edges.has(edge[1])) edges.set(edge[1], /* @__PURE__ */ new Set());
                edges.get(edge[0]).add(edge[1]);
            }
            return edges;
        }
        function makeNodesHash(arr) {
            var res = /* @__PURE__ */ new Map();
            for(var i2 = 0, len = arr.length; i2 < len; i2++){
                res.set(arr[i2], i2);
            }
            return res;
        }
    }
});
// node_modules/yup/index.esm.js
var index_esm_exports = {};
(0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__export)(index_esm_exports, {
    ArraySchema: ()=>ArraySchema,
    BooleanSchema: ()=>BooleanSchema,
    DateSchema: ()=>DateSchema,
    LazySchema: ()=>Lazy,
    MixedSchema: ()=>MixedSchema,
    NumberSchema: ()=>NumberSchema,
    ObjectSchema: ()=>ObjectSchema,
    Schema: ()=>Schema,
    StringSchema: ()=>StringSchema,
    TupleSchema: ()=>TupleSchema,
    ValidationError: ()=>ValidationError,
    addMethod: ()=>addMethod,
    array: ()=>create$2,
    bool: ()=>create$7,
    boolean: ()=>create$7,
    date: ()=>create$4,
    defaultLocale: ()=>locale,
    getIn: ()=>getIn,
    isSchema: ()=>isSchema,
    lazy: ()=>create,
    mixed: ()=>create$8,
    number: ()=>create$5,
    object: ()=>create$3,
    printValue: ()=>printValue,
    reach: ()=>reach,
    ref: ()=>create$9,
    setLocale: ()=>setLocale,
    string: ()=>create$6,
    tuple: ()=>create$1
});
function printNumber(val) {
    if (val != +val) return "NaN";
    const isNegativeZero = val === 0 && 1 / val < 0;
    return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
    if (val == null || val === true || val === false) return "" + val;
    const typeOf = typeof val;
    if (typeOf === "number") return printNumber(val);
    if (typeOf === "string") return quoteStrings ? `"${val}"` : val;
    if (typeOf === "function") return "[Function " + (val.name || "anonymous") + "]";
    if (typeOf === "symbol") return symbolToString2.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tag = toString2.call(val).slice(8, -1);
    if (tag === "Date") return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
    if (tag === "Error" || val instanceof Error) return "[" + errorToString.call(val) + "]";
    if (tag === "RegExp") return regExpToString.call(val);
    return null;
}
function printValue(value, quoteStrings) {
    let result = printSimpleValue(value, quoteStrings);
    if (result !== null) return result;
    return JSON.stringify(value, function(key, value2) {
        let result2 = printSimpleValue(this[key], quoteStrings);
        if (result2 !== null) return result2;
        return value2;
    }, 2);
}
function toArray(value) {
    return value == null ? [] : [].concat(value);
}
function create$9(key, options3) {
    return new Reference(key, options3);
}
function createValidation(config) {
    function validate({ value, path = "", options: options3, originalValue, schema }, panic, next) {
        const { name, test, params, message, skipAbsent } = config;
        let { parent, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options3;
        const resolveOptions = {
            value,
            parent,
            context
        };
        function createError(overrides = {}) {
            const nextParams = resolveParams(Object.assign({
                value,
                originalValue,
                label: schema.spec.label,
                path: overrides.path || path,
                spec: schema.spec,
                disableStackTrace: overrides.disableStackTrace || disableStackTrace
            }, params, overrides.params), resolveOptions);
            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);
            error.params = nextParams;
            return error;
        }
        const invalid = abortEarly ? panic : next;
        let ctx = {
            path,
            parent,
            type: name,
            from: options3.from,
            createError,
            resolve (item) {
                return resolveMaybeRef(item, resolveOptions);
            },
            options: options3,
            originalValue,
            schema
        };
        const handleResult = (validOrError)=>{
            if (ValidationError.isError(validOrError)) invalid(validOrError);
            else if (!validOrError) invalid(createError());
            else next(null);
        };
        const handleError = (err)=>{
            if (ValidationError.isError(err)) invalid(err);
            else panic(err);
        };
        const shouldSkip = skipAbsent && isAbsent(value);
        if (shouldSkip) {
            return handleResult(true);
        }
        let result;
        try {
            var _result;
            result = test.call(ctx, value, ctx);
            if (typeof ((_result = result) == null ? void 0 : _result.then) === "function") {
                if (options3.sync) {
                    throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                }
                return Promise.resolve(result).then(handleResult, handleError);
            }
        } catch (err) {
            handleError(err);
            return;
        }
        handleResult(result);
    }
    validate.OPTIONS = config;
    return validate;
}
function resolveParams(params, options3) {
    if (!params) return params;
    for (const key of Object.keys(params)){
        params[key] = resolveMaybeRef(params[key], options3);
    }
    return params;
}
function resolveMaybeRef(item, options3) {
    return Reference.isRef(item) ? item.getValue(options3.value, options3.parent, options3.context) : item;
}
function getIn(schema, path, value, context = value) {
    let parent, lastPart, lastPartDebug;
    if (!path) return {
        parent,
        parentPath: path,
        schema
    };
    (0, import_property_expr.forEach)(path, (_part, isBracket, isArray2)=>{
        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;
        schema = schema.resolve({
            context,
            parent,
            value
        });
        let isTuple = schema.type === "tuple";
        let idx = isArray2 ? parseInt(part, 10) : 0;
        if (schema.innerType || isTuple) {
            if (isTuple && !isArray2) throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${lastPartDebug}" must contain an index to the tuple element, e.g. "${lastPartDebug}[0]"`);
            if (value && idx >= value.length) {
                throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
            }
            parent = value;
            value = value && value[idx];
            schema = isTuple ? schema.spec.types[idx] : schema.innerType;
        }
        if (!isArray2) {
            if (!schema.fields || !schema.fields[part]) throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema.type}")`);
            parent = value;
            value = value && value[part];
            schema = schema.fields[part];
        }
        lastPart = part;
        lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
    });
    return {
        schema,
        parent,
        parentPath: lastPart
    };
}
function reach(obj, path, value, context) {
    return getIn(obj, path, value, context).schema;
}
function clone(src, seen = /* @__PURE__ */ new Map()) {
    if (isSchema(src) || !src || typeof src !== "object") return src;
    if (seen.has(src)) return seen.get(src);
    let copy;
    if (src instanceof Date) {
        copy = new Date(src.getTime());
        seen.set(src, copy);
    } else if (src instanceof RegExp) {
        copy = new RegExp(src);
        seen.set(src, copy);
    } else if (Array.isArray(src)) {
        copy = new Array(src.length);
        seen.set(src, copy);
        for(let i2 = 0; i2 < src.length; i2++)copy[i2] = clone(src[i2], seen);
    } else if (src instanceof Map) {
        copy = /* @__PURE__ */ new Map();
        seen.set(src, copy);
        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));
    } else if (src instanceof Set) {
        copy = /* @__PURE__ */ new Set();
        seen.set(src, copy);
        for (const v of src)copy.add(clone(v, seen));
    } else if (src instanceof Object) {
        copy = {};
        seen.set(src, copy);
        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);
    } else {
        throw Error(`Unable to clone ${src}`);
    }
    return copy;
}
function createStandardPath(path) {
    if (!(path != null && path.length)) {
        return void 0;
    }
    const segments = [];
    let currentSegment = "";
    let inBrackets = false;
    let inQuotes = false;
    for(let i2 = 0; i2 < path.length; i2++){
        const char = path[i2];
        if (char === "[" && !inQuotes) {
            if (currentSegment) {
                segments.push(...currentSegment.split(".").filter(Boolean));
                currentSegment = "";
            }
            inBrackets = true;
            continue;
        }
        if (char === "]" && !inQuotes) {
            if (currentSegment) {
                if (/^\d+$/.test(currentSegment)) {
                    segments.push(currentSegment);
                } else {
                    segments.push(currentSegment.replace(/^"|"$/g, ""));
                }
                currentSegment = "";
            }
            inBrackets = false;
            continue;
        }
        if (char === '"') {
            inQuotes = !inQuotes;
            continue;
        }
        if (char === "." && !inBrackets && !inQuotes) {
            if (currentSegment) {
                segments.push(currentSegment);
                currentSegment = "";
            }
            continue;
        }
        currentSegment += char;
    }
    if (currentSegment) {
        segments.push(...currentSegment.split(".").filter(Boolean));
    }
    return segments;
}
function createStandardIssues(error, parentPath) {
    const path = parentPath ? `${parentPath}.${error.path}` : error.path;
    return error.errors.map((err)=>({
            message: err,
            path: createStandardPath(path)
        }));
}
function issuesFromValidationError(error, parentPath) {
    var _error$inner;
    if (!((_error$inner = error.inner) != null && _error$inner.length) && error.errors.length) {
        return createStandardIssues(error, parentPath);
    }
    const path = parentPath ? `${parentPath}.${error.path}` : error.path;
    return error.inner.flatMap((err)=>issuesFromValidationError(err, path));
}
function create$8(spec) {
    return new MixedSchema(spec);
}
function create$7() {
    return new BooleanSchema();
}
function parseIsoDate(date2) {
    const struct = parseDateStruct(date2);
    if (!struct) return Date.parse ? Date.parse(date2) : Number.NaN;
    if (struct.z === void 0 && struct.plusMinus === void 0) {
        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();
    }
    let totalMinutesOffset = 0;
    if (struct.z !== "Z" && struct.plusMinus !== void 0) {
        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;
        if (struct.plusMinus === "+") totalMinutesOffset = 0 - totalMinutesOffset;
    }
    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);
}
function parseDateStruct(date2) {
    var _regexResult$7$length, _regexResult$;
    const regexResult = isoReg.exec(date2);
    if (!regexResult) return null;
    return {
        year: toNumber2(regexResult[1]),
        month: toNumber2(regexResult[2], 1) - 1,
        day: toNumber2(regexResult[3], 1),
        hour: toNumber2(regexResult[4]),
        minute: toNumber2(regexResult[5]),
        second: toNumber2(regexResult[6]),
        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds
        toNumber2(regexResult[7].substring(0, 3)) : 0,
        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : void 0,
        z: regexResult[8] || void 0,
        plusMinus: regexResult[9] || void 0,
        hourOffset: toNumber2(regexResult[10]),
        minuteOffset: toNumber2(regexResult[11])
    };
}
function toNumber2(str, defaultValue = 0) {
    return Number(str) || defaultValue;
}
function create$6() {
    return new StringSchema();
}
function create$5() {
    return new NumberSchema();
}
function create$4() {
    return new DateSchema();
}
function sortFields(fields, excludedEdges = []) {
    let edges = [];
    let nodes = /* @__PURE__ */ new Set();
    let excludes = new Set(excludedEdges.map(([a, b])=>`${a}-${b}`));
    function addNode(depPath, key) {
        let node = (0, import_property_expr.split)(depPath)[0];
        nodes.add(node);
        if (!excludes.has(`${key}-${node}`)) edges.push([
            key,
            node
        ]);
    }
    for (const key of Object.keys(fields)){
        let value = fields[key];
        nodes.add(key);
        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);
        else if (isSchema(value) && "deps" in value) value.deps.forEach((path)=>addNode(path, key));
    }
    return import_toposort.default.array(Array.from(nodes), edges).reverse();
}
function findIndex(arr, err) {
    let idx = Infinity;
    arr.some((key, ii)=>{
        var _err$path;
        if ((_err$path = err.path) != null && _err$path.includes(key)) {
            idx = ii;
            return true;
        }
    });
    return idx;
}
function sortByKeyOrder(keys2) {
    return (a, b)=>{
        return findIndex(keys2, a) - findIndex(keys2, b);
    };
}
function deepPartial(schema) {
    if ("fields" in schema) {
        const partial = {};
        for (const [key, fieldSchema] of Object.entries(schema.fields)){
            partial[key] = deepPartial(fieldSchema);
        }
        return schema.setFields(partial);
    }
    if (schema.type === "array") {
        const nextArray = schema.optional();
        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);
        return nextArray;
    }
    if (schema.type === "tuple") {
        return schema.optional().clone({
            types: schema.spec.types.map(deepPartial)
        });
    }
    if ("optional" in schema) {
        return schema.optional();
    }
    return schema;
}
function unknown(ctx, value) {
    let known = Object.keys(ctx.fields);
    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);
}
function create$3(spec) {
    return new ObjectSchema(spec);
}
function create$2(type) {
    return new ArraySchema(type);
}
function create$1(schemas) {
    return new TupleSchema(schemas);
}
function create(builder) {
    return new Lazy(builder);
}
function catchValidationError(fn) {
    try {
        return fn();
    } catch (err) {
        if (ValidationError.isError(err)) return Promise.reject(err);
        throw err;
    }
}
function setLocale(custom) {
    Object.keys(custom).forEach((type)=>{
        Object.keys(custom[type]).forEach((method)=>{
            locale[type][method] = custom[type][method];
        });
    });
}
function addMethod(schemaType, name, fn) {
    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError("You must provide a yup schema constructor function");
    if (typeof name !== "string") throw new TypeError("A Method name must be provided");
    if (typeof fn !== "function") throw new TypeError("Method function must be provided");
    schemaType.prototype[name] = fn;
}
var import_property_expr, import_tiny_case, import_toposort, toString2, errorToString, regExpToString, symbolToString2, SYMBOL_REGEXP, _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2, strReg, ValidationErrorNoStack, ValidationError, mixed, string, number, date, boolean, object, array, tuple, locale, isSchema, Condition, prefixes, Reference, isAbsent, ReferenceSet, Schema, returnsTrue, MixedSchema, BooleanSchema, isoReg, rEmail, rUrl, rUUID, yearMonthDay, hourMinuteSecond, zOrOffset, rIsoDateTime, isTrimmed, objStringTag, StringSchema, isNaN$1, NumberSchema, invalidDate, isDate, DateSchema, parseJson, deepHas, isObject3, defaultSort, ObjectSchema, ArraySchema, TupleSchema, Lazy;
var init_index_esm = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__esm)({
    "node_modules/yup/index.esm.js" () {
        import_property_expr = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_property_expr());
        import_tiny_case = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_tiny_case());
        import_toposort = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_toposort());
        toString2 = Object.prototype.toString;
        errorToString = Error.prototype.toString;
        regExpToString = RegExp.prototype.toString;
        symbolToString2 = typeof Symbol !== "undefined" ? Symbol.prototype.toString : ()=>"";
        SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
        strReg = /\$\{\s*(\w+)\s*\}/g;
        _Symbol$toStringTag = Symbol.toStringTag;
        ValidationErrorNoStack = class {
            constructor(errorOrErrors, value, field, type){
                this.name = void 0;
                this.message = void 0;
                this.value = void 0;
                this.path = void 0;
                this.type = void 0;
                this.params = void 0;
                this.errors = void 0;
                this.inner = void 0;
                this[_Symbol$toStringTag] = "Error";
                this.name = "ValidationError";
                this.value = value;
                this.path = field;
                this.type = type;
                this.errors = [];
                this.inner = [];
                toArray(errorOrErrors).forEach((err)=>{
                    if (ValidationError.isError(err)) {
                        this.errors.push(...err.errors);
                        const innerErrors = err.inner.length ? err.inner : [
                            err
                        ];
                        this.inner.push(...innerErrors);
                    } else {
                        this.errors.push(err);
                    }
                });
                this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
            }
        };
        _Symbol$hasInstance = Symbol.hasInstance;
        _Symbol$toStringTag2 = Symbol.toStringTag;
        ValidationError = class _ValidationError extends Error {
            static formatError(message, params) {
                const path = params.label || params.path || "this";
                params = Object.assign({}, params, {
                    path,
                    originalPath: params.path
                });
                if (typeof message === "string") return message.replace(strReg, (_, key)=>printValue(params[key]));
                if (typeof message === "function") return message(params);
                return message;
            }
            static isError(err) {
                return err && err.name === "ValidationError";
            }
            static [_Symbol$hasInstance](inst) {
                return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);
            }
            constructor(errorOrErrors, value, field, type, disableStack){
                const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);
                if (disableStack) {
                    return errorNoStack;
                }
                super();
                this.value = void 0;
                this.path = void 0;
                this.type = void 0;
                this.params = void 0;
                this.errors = [];
                this.inner = [];
                this[_Symbol$toStringTag2] = "Error";
                this.name = errorNoStack.name;
                this.message = errorNoStack.message;
                this.type = errorNoStack.type;
                this.value = errorNoStack.value;
                this.path = errorNoStack.path;
                this.errors = errorNoStack.errors;
                this.inner = errorNoStack.inner;
                if (Error.captureStackTrace) {
                    Error.captureStackTrace(this, _ValidationError);
                }
            }
        };
        mixed = {
            default: "${path} is invalid",
            required: "${path} is a required field",
            defined: "${path} must be defined",
            notNull: "${path} cannot be null",
            oneOf: "${path} must be one of the following values: ${values}",
            notOneOf: "${path} must not be one of the following values: ${values}",
            notType: ({ path, type, value, originalValue })=>{
                const castMsg = originalValue != null && originalValue !== value ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".";
                return type !== "mixed" ? `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + castMsg : `${path} must match the configured type. The validated value was: \`${printValue(value, true)}\`` + castMsg;
            }
        };
        string = {
            length: "${path} must be exactly ${length} characters",
            min: "${path} must be at least ${min} characters",
            max: "${path} must be at most ${max} characters",
            matches: '${path} must match the following: "${regex}"',
            email: "${path} must be a valid email",
            url: "${path} must be a valid URL",
            uuid: "${path} must be a valid UUID",
            datetime: "${path} must be a valid ISO date-time",
            datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
            datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
            trim: "${path} must be a trimmed string",
            lowercase: "${path} must be a lowercase string",
            uppercase: "${path} must be a upper case string"
        };
        number = {
            min: "${path} must be greater than or equal to ${min}",
            max: "${path} must be less than or equal to ${max}",
            lessThan: "${path} must be less than ${less}",
            moreThan: "${path} must be greater than ${more}",
            positive: "${path} must be a positive number",
            negative: "${path} must be a negative number",
            integer: "${path} must be an integer"
        };
        date = {
            min: "${path} field must be later than ${min}",
            max: "${path} field must be at earlier than ${max}"
        };
        boolean = {
            isValue: "${path} field must be ${value}"
        };
        object = {
            noUnknown: "${path} field has unspecified keys: ${unknown}",
            exact: "${path} object contains unknown properties: ${properties}"
        };
        array = {
            min: "${path} field must have at least ${min} items",
            max: "${path} field must have less than or equal to ${max} items",
            length: "${path} must have ${length} items"
        };
        tuple = {
            notType: (params)=>{
                const { path, value, spec } = params;
                const typeLen = spec.types.length;
                if (Array.isArray(value)) {
                    if (value.length < typeLen) return `${path} tuple value has too few items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
                    if (value.length > typeLen) return `${path} tuple value has too many items, expected a length of ${typeLen} but got ${value.length} for value: \`${printValue(value, true)}\``;
                }
                return ValidationError.formatError(mixed.notType, params);
            }
        };
        locale = Object.assign(/* @__PURE__ */ Object.create(null), {
            mixed,
            string,
            number,
            date,
            object,
            array,
            boolean,
            tuple
        });
        isSchema = (obj)=>obj && obj.__isYupSchema__;
        Condition = class _Condition {
            static fromOptions(refs, config) {
                if (!config.then && !config.otherwise) throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
                let { is, then: then2, otherwise } = config;
                let check = typeof is === "function" ? is : (...values)=>values.every((value)=>value === is);
                return new _Condition(refs, (values, schema)=>{
                    var _branch;
                    let branch = check(...values) ? then2 : otherwise;
                    return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;
                });
            }
            resolve(base, options3) {
                let values = this.refs.map((ref)=>// TODO: ? operator here?
                    ref.getValue(options3 == null ? void 0 : options3.value, options3 == null ? void 0 : options3.parent, options3 == null ? void 0 : options3.context));
                let schema = this.fn(values, base, options3);
                if (schema === void 0 || // @ts-ignore this can be base
                schema === base) {
                    return base;
                }
                if (!isSchema(schema)) throw new TypeError("conditions must return a schema object");
                return schema.resolve(options3);
            }
            constructor(refs, builder){
                this.fn = void 0;
                this.refs = refs;
                this.refs = refs;
                this.fn = builder;
            }
        };
        prefixes = {
            context: "$",
            value: "."
        };
        Reference = class {
            getValue(value, parent, context) {
                let result = this.isContext ? context : this.isValue ? value : parent;
                if (this.getter) result = this.getter(result || {});
                if (this.map) result = this.map(result);
                return result;
            }
            /**
       *
       * @param {*} value
       * @param {Object} options
       * @param {Object=} options.context
       * @param {Object=} options.parent
       */ cast(value, options3) {
                return this.getValue(value, options3 == null ? void 0 : options3.parent, options3 == null ? void 0 : options3.context);
            }
            resolve() {
                return this;
            }
            describe() {
                return {
                    type: "ref",
                    key: this.key
                };
            }
            toString() {
                return `Ref(${this.key})`;
            }
            static isRef(value) {
                return value && value.__isYupRef;
            }
            constructor(key, options3 = {}){
                this.key = void 0;
                this.isContext = void 0;
                this.isValue = void 0;
                this.isSibling = void 0;
                this.path = void 0;
                this.getter = void 0;
                this.map = void 0;
                if (typeof key !== "string") throw new TypeError("ref must be a string, got: " + key);
                this.key = key.trim();
                if (key === "") throw new TypeError("ref must be a non-empty string");
                this.isContext = this.key[0] === prefixes.context;
                this.isValue = this.key[0] === prefixes.value;
                this.isSibling = !this.isContext && !this.isValue;
                let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
                this.path = this.key.slice(prefix.length);
                this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
                this.map = options3.map;
            }
        };
        Reference.prototype.__isYupRef = true;
        isAbsent = (value)=>value == null;
        ReferenceSet = class _ReferenceSet extends Set {
            describe() {
                const description = [];
                for (const item of this.values()){
                    description.push(Reference.isRef(item) ? item.describe() : item);
                }
                return description;
            }
            resolveAll(resolve) {
                let result = [];
                for (const item of this.values()){
                    result.push(resolve(item));
                }
                return result;
            }
            clone() {
                return new _ReferenceSet(this.values());
            }
            merge(newItems, removeItems) {
                const next = this.clone();
                newItems.forEach((value)=>next.add(value));
                removeItems.forEach((value)=>next.delete(value));
                return next;
            }
        };
        Schema = class {
            // TODO: remove
            get _type() {
                return this.type;
            }
            clone(spec) {
                if (this._mutate) {
                    if (spec) Object.assign(this.spec, spec);
                    return this;
                }
                const next = Object.create(Object.getPrototypeOf(this));
                next.type = this.type;
                next._typeCheck = this._typeCheck;
                next._whitelist = this._whitelist.clone();
                next._blacklist = this._blacklist.clone();
                next.internalTests = Object.assign({}, this.internalTests);
                next.exclusiveTests = Object.assign({}, this.exclusiveTests);
                next.deps = [
                    ...this.deps
                ];
                next.conditions = [
                    ...this.conditions
                ];
                next.tests = [
                    ...this.tests
                ];
                next.transforms = [
                    ...this.transforms
                ];
                next.spec = clone(Object.assign({}, this.spec, spec));
                return next;
            }
            label(label) {
                let next = this.clone();
                next.spec.label = label;
                return next;
            }
            meta(...args) {
                if (args.length === 0) return this.spec.meta;
                let next = this.clone();
                next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
                return next;
            }
            withMutation(fn) {
                let before = this._mutate;
                this._mutate = true;
                let result = fn(this);
                this._mutate = before;
                return result;
            }
            concat(schema) {
                if (!schema || schema === this) return this;
                if (schema.type !== this.type && this.type !== "mixed") throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
                let base = this;
                let combined = schema.clone();
                const mergedSpec = Object.assign({}, base.spec, combined.spec);
                combined.spec = mergedSpec;
                combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);
                combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
                combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
                combined.tests = base.tests;
                combined.exclusiveTests = base.exclusiveTests;
                combined.withMutation((next)=>{
                    schema.tests.forEach((fn)=>{
                        next.test(fn.OPTIONS);
                    });
                });
                combined.transforms = [
                    ...base.transforms,
                    ...combined.transforms
                ];
                return combined;
            }
            isType(v) {
                if (v == null) {
                    if (this.spec.nullable && v === null) return true;
                    if (this.spec.optional && v === void 0) return true;
                    return false;
                }
                return this._typeCheck(v);
            }
            resolve(options3) {
                let schema = this;
                if (schema.conditions.length) {
                    let conditions = schema.conditions;
                    schema = schema.clone();
                    schema.conditions = [];
                    schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options3), schema);
                    schema = schema.resolve(options3);
                }
                return schema;
            }
            resolveOptions(options3) {
                var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;
                return Object.assign({}, options3, {
                    from: options3.from || [],
                    strict: (_options$strict = options3.strict) != null ? _options$strict : this.spec.strict,
                    abortEarly: (_options$abortEarly = options3.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,
                    recursive: (_options$recursive = options3.recursive) != null ? _options$recursive : this.spec.recursive,
                    disableStackTrace: (_options$disableStack = options3.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace
                });
            }
            /**
       * Run the configured transform pipeline over an input value.
       */ cast(value, options3 = {}) {
                let resolvedSchema = this.resolve(Object.assign({}, options3, {
                    value
                }));
                let allowOptionality = options3.assert === "ignore-optionality";
                let result = resolvedSchema._cast(value, options3);
                if (options3.assert !== false && !resolvedSchema.isType(result)) {
                    if (allowOptionality && isAbsent(result)) {
                        return result;
                    }
                    let formattedValue = printValue(value);
                    let formattedResult = printValue(result);
                    throw new TypeError(`The value of ${options3.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema.type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
                }
                return result;
            }
            _cast(rawValue, options3) {
                let value = rawValue === void 0 ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this, options3), rawValue);
                if (value === void 0) {
                    value = this.getDefault(options3);
                }
                return value;
            }
            _validate(_value, options3 = {}, panic, next) {
                let { path, originalValue = _value, strict = this.spec.strict } = options3;
                let value = _value;
                if (!strict) {
                    value = this._cast(value, Object.assign({
                        assert: false
                    }, options3));
                }
                let initialTests = [];
                for (let test of Object.values(this.internalTests)){
                    if (test) initialTests.push(test);
                }
                this.runTests({
                    path,
                    value,
                    originalValue,
                    options: options3,
                    tests: initialTests
                }, panic, (initialErrors)=>{
                    if (initialErrors.length) {
                        return next(initialErrors, value);
                    }
                    this.runTests({
                        path,
                        value,
                        originalValue,
                        options: options3,
                        tests: this.tests
                    }, panic, next);
                });
            }
            /**
       * Executes a set of validations, either schema, produced Tests or a nested
       * schema validate result.
       */ runTests(runOptions, panic, next) {
                let fired = false;
                let { tests, value, originalValue, path, options: options3 } = runOptions;
                let panicOnce = (arg)=>{
                    if (fired) return;
                    fired = true;
                    panic(arg, value);
                };
                let nextOnce = (arg)=>{
                    if (fired) return;
                    fired = true;
                    next(arg, value);
                };
                let count = tests.length;
                let nestedErrors = [];
                if (!count) return nextOnce([]);
                let args = {
                    value,
                    originalValue,
                    path,
                    options: options3,
                    schema: this
                };
                for(let i2 = 0; i2 < tests.length; i2++){
                    const test = tests[i2];
                    test(args, panicOnce, function finishTestRun(err) {
                        if (err) {
                            Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);
                        }
                        if (--count <= 0) {
                            nextOnce(nestedErrors);
                        }
                    });
                }
            }
            asNestedTest({ key, index, parent, parentPath, originalParent, options: options3 }) {
                const k = key != null ? key : index;
                if (k == null) {
                    throw TypeError("Must include `key` or `index` for nested validations");
                }
                const isIndex2 = typeof k === "number";
                let value = parent[k];
                const testOptions = Object.assign({}, options3, {
                    // Nested validations fields are always strict:
                    //    1. parent isn't strict so the casting will also have cast inner values
                    //    2. parent is strict in which case the nested values weren't cast either
                    strict: true,
                    parent,
                    value,
                    originalValue: originalParent[k],
                    // FIXME: tests depend on `index` being passed around deeply,
                    //   we should not let the options.key/index bleed through
                    key: void 0,
                    // index: undefined,
                    [isIndex2 ? "index" : "key"]: k,
                    path: isIndex2 || k.includes(".") ? `${parentPath || ""}[${isIndex2 ? k : `"${k}"`}]` : (parentPath ? `${parentPath}.` : "") + key
                });
                return (_, panic, next)=>this.resolve(testOptions)._validate(value, testOptions, panic, next);
            }
            validate(value, options3) {
                var _options$disableStack2;
                let schema = this.resolve(Object.assign({}, options3, {
                    value
                }));
                let disableStackTrace = (_options$disableStack2 = options3 == null ? void 0 : options3.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;
                return new Promise((resolve, reject)=>schema._validate(value, options3, (error, parsed)=>{
                        if (ValidationError.isError(error)) error.value = parsed;
                        reject(error);
                    }, (errors, validated)=>{
                        if (errors.length) reject(new ValidationError(errors, validated, void 0, void 0, disableStackTrace));
                        else resolve(validated);
                    }));
            }
            validateSync(value, options3) {
                var _options$disableStack3;
                let schema = this.resolve(Object.assign({}, options3, {
                    value
                }));
                let result;
                let disableStackTrace = (_options$disableStack3 = options3 == null ? void 0 : options3.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;
                schema._validate(value, Object.assign({}, options3, {
                    sync: true
                }), (error, parsed)=>{
                    if (ValidationError.isError(error)) error.value = parsed;
                    throw error;
                }, (errors, validated)=>{
                    if (errors.length) throw new ValidationError(errors, value, void 0, void 0, disableStackTrace);
                    result = validated;
                });
                return result;
            }
            isValid(value, options3) {
                return this.validate(value, options3).then(()=>true, (err)=>{
                    if (ValidationError.isError(err)) return false;
                    throw err;
                });
            }
            isValidSync(value, options3) {
                try {
                    this.validateSync(value, options3);
                    return true;
                } catch (err) {
                    if (ValidationError.isError(err)) return false;
                    throw err;
                }
            }
            _getDefault(options3) {
                let defaultValue = this.spec.default;
                if (defaultValue == null) {
                    return defaultValue;
                }
                return typeof defaultValue === "function" ? defaultValue.call(this, options3) : clone(defaultValue);
            }
            getDefault(options3) {
                let schema = this.resolve(options3 || {});
                return schema._getDefault(options3);
            }
            default(def) {
                if (arguments.length === 0) {
                    return this._getDefault();
                }
                let next = this.clone({
                    default: def
                });
                return next;
            }
            strict(isStrict = true) {
                return this.clone({
                    strict: isStrict
                });
            }
            nullability(nullable, message) {
                const next = this.clone({
                    nullable
                });
                next.internalTests.nullable = createValidation({
                    message,
                    name: "nullable",
                    test (value) {
                        return value === null ? this.schema.spec.nullable : true;
                    }
                });
                return next;
            }
            optionality(optional, message) {
                const next = this.clone({
                    optional
                });
                next.internalTests.optionality = createValidation({
                    message,
                    name: "optionality",
                    test (value) {
                        return value === void 0 ? this.schema.spec.optional : true;
                    }
                });
                return next;
            }
            optional() {
                return this.optionality(true);
            }
            defined(message = mixed.defined) {
                return this.optionality(false, message);
            }
            nullable() {
                return this.nullability(true);
            }
            nonNullable(message = mixed.notNull) {
                return this.nullability(false, message);
            }
            required(message = mixed.required) {
                return this.clone().withMutation((next)=>next.nonNullable(message).defined(message));
            }
            notRequired() {
                return this.clone().withMutation((next)=>next.nullable().optional());
            }
            transform(fn) {
                let next = this.clone();
                next.transforms.push(fn);
                return next;
            }
            /**
       * Adds a test function to the schema's queue of tests.
       * tests can be exclusive or non-exclusive.
       *
       * - exclusive tests, will replace any existing tests of the same name.
       * - non-exclusive: can be stacked
       *
       * If a non-exclusive test is added to a schema with an exclusive test of the same name
       * the exclusive test is removed and further tests of the same name will be stacked.
       *
       * If an exclusive test is added to a schema with non-exclusive tests of the same name
       * the previous tests are removed and further tests of the same name will replace each other.
       */ test(...args) {
                let opts;
                if (args.length === 1) {
                    if (typeof args[0] === "function") {
                        opts = {
                            test: args[0]
                        };
                    } else {
                        opts = args[0];
                    }
                } else if (args.length === 2) {
                    opts = {
                        name: args[0],
                        test: args[1]
                    };
                } else {
                    opts = {
                        name: args[0],
                        message: args[1],
                        test: args[2]
                    };
                }
                if (opts.message === void 0) opts.message = mixed.default;
                if (typeof opts.test !== "function") throw new TypeError("`test` is a required parameters");
                let next = this.clone();
                let validate = createValidation(opts);
                let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
                if (opts.exclusive) {
                    if (!opts.name) throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
                }
                if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;
                next.tests = next.tests.filter((fn)=>{
                    if (fn.OPTIONS.name === opts.name) {
                        if (isExclusive) return false;
                        if (fn.OPTIONS.test === validate.OPTIONS.test) return false;
                    }
                    return true;
                });
                next.tests.push(validate);
                return next;
            }
            when(keys2, options3) {
                if (!Array.isArray(keys2) && typeof keys2 !== "string") {
                    options3 = keys2;
                    keys2 = ".";
                }
                let next = this.clone();
                let deps = toArray(keys2).map((key)=>new Reference(key));
                deps.forEach((dep)=>{
                    if (dep.isSibling) next.deps.push(dep.key);
                });
                next.conditions.push(typeof options3 === "function" ? new Condition(deps, options3) : Condition.fromOptions(deps, options3));
                return next;
            }
            typeError(message) {
                let next = this.clone();
                next.internalTests.typeError = createValidation({
                    message,
                    name: "typeError",
                    skipAbsent: true,
                    test (value) {
                        if (!this.schema._typeCheck(value)) return this.createError({
                            params: {
                                type: this.schema.type
                            }
                        });
                        return true;
                    }
                });
                return next;
            }
            oneOf(enums, message = mixed.oneOf) {
                let next = this.clone();
                enums.forEach((val)=>{
                    next._whitelist.add(val);
                    next._blacklist.delete(val);
                });
                next.internalTests.whiteList = createValidation({
                    message,
                    name: "oneOf",
                    skipAbsent: true,
                    test (value) {
                        let valids = this.schema._whitelist;
                        let resolved = valids.resolveAll(this.resolve);
                        return resolved.includes(value) ? true : this.createError({
                            params: {
                                values: Array.from(valids).join(", "),
                                resolved
                            }
                        });
                    }
                });
                return next;
            }
            notOneOf(enums, message = mixed.notOneOf) {
                let next = this.clone();
                enums.forEach((val)=>{
                    next._blacklist.add(val);
                    next._whitelist.delete(val);
                });
                next.internalTests.blacklist = createValidation({
                    message,
                    name: "notOneOf",
                    test (value) {
                        let invalids = this.schema._blacklist;
                        let resolved = invalids.resolveAll(this.resolve);
                        if (resolved.includes(value)) return this.createError({
                            params: {
                                values: Array.from(invalids).join(", "),
                                resolved
                            }
                        });
                        return true;
                    }
                });
                return next;
            }
            strip(strip = true) {
                let next = this.clone();
                next.spec.strip = strip;
                return next;
            }
            /**
       * Return a serialized description of the schema including validations, flags, types etc.
       *
       * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).
       */ describe(options3) {
                const next = (options3 ? this.resolve(options3) : this).clone();
                const { label, meta, optional, nullable } = next.spec;
                const description = {
                    meta,
                    label,
                    optional,
                    nullable,
                    default: next.getDefault(options3),
                    type: next.type,
                    oneOf: next._whitelist.describe(),
                    notOneOf: next._blacklist.describe(),
                    tests: next.tests.filter((n, idx, list2)=>list2.findIndex((c)=>c.OPTIONS.name === n.OPTIONS.name) === idx).map((fn)=>{
                        const params = fn.OPTIONS.params && options3 ? resolveParams(Object.assign({}, fn.OPTIONS.params), options3) : fn.OPTIONS.params;
                        return {
                            name: fn.OPTIONS.name,
                            params
                        };
                    })
                };
                return description;
            }
            get ["~standard"]() {
                const schema = this;
                const standard = {
                    version: 1,
                    vendor: "yup",
                    validate (value) {
                        return _async_to_generator(function*() {
                            try {
                                const result = yield schema.validate(value, {
                                    abortEarly: false
                                });
                                return {
                                    value: result
                                };
                            } catch (err) {
                                if (err instanceof ValidationError) {
                                    return {
                                        issues: issuesFromValidationError(err)
                                    };
                                }
                                throw err;
                            }
                        })();
                    }
                };
                return standard;
            }
            constructor(options3){
                this.type = void 0;
                this.deps = [];
                this.tests = void 0;
                this.transforms = void 0;
                this.conditions = [];
                this._mutate = void 0;
                this.internalTests = {};
                this._whitelist = new ReferenceSet();
                this._blacklist = new ReferenceSet();
                this.exclusiveTests = /* @__PURE__ */ Object.create(null);
                this._typeCheck = void 0;
                this.spec = void 0;
                this.tests = [];
                this.transforms = [];
                this.withMutation(()=>{
                    this.typeError(mixed.notType);
                });
                this.type = options3.type;
                this._typeCheck = options3.check;
                this.spec = Object.assign({
                    strip: false,
                    strict: false,
                    abortEarly: true,
                    recursive: true,
                    disableStackTrace: false,
                    nullable: false,
                    optional: true,
                    coerce: true
                }, options3 == null ? void 0 : options3.spec);
                this.withMutation((s)=>{
                    s.nonNullable();
                });
            }
        };
        Schema.prototype.__isYupSchema__ = true;
        for (const method of [
            "validate",
            "validateSync"
        ])Schema.prototype[`${method}At`] = function(path, value, options3 = {}) {
            const { parent, parentPath, schema } = getIn(this, path, value, options3.context);
            return schema[method](parent && parent[parentPath], Object.assign({}, options3, {
                parent,
                path
            }));
        };
        for (const alias of [
            "equals",
            "is"
        ])Schema.prototype[alias] = Schema.prototype.oneOf;
        for (const alias of [
            "not",
            "nope"
        ])Schema.prototype[alias] = Schema.prototype.notOneOf;
        returnsTrue = ()=>true;
        MixedSchema = class extends Schema {
            constructor(spec){
                super(typeof spec === "function" ? {
                    type: "mixed",
                    check: spec
                } : Object.assign({
                    type: "mixed",
                    check: returnsTrue
                }, spec));
            }
        };
        create$8.prototype = MixedSchema.prototype;
        BooleanSchema = class extends Schema {
            isTrue(message = boolean.isValue) {
                return this.test({
                    message,
                    name: "is-value",
                    exclusive: true,
                    params: {
                        value: "true"
                    },
                    test (value) {
                        return isAbsent(value) || value === true;
                    }
                });
            }
            isFalse(message = boolean.isValue) {
                return this.test({
                    message,
                    name: "is-value",
                    exclusive: true,
                    params: {
                        value: "false"
                    },
                    test (value) {
                        return isAbsent(value) || value === false;
                    }
                });
            }
            default(def) {
                return super.default(def);
            }
            defined(msg) {
                return super.defined(msg);
            }
            optional() {
                return super.optional();
            }
            required(msg) {
                return super.required(msg);
            }
            notRequired() {
                return super.notRequired();
            }
            nullable() {
                return super.nullable();
            }
            nonNullable(msg) {
                return super.nonNullable(msg);
            }
            strip(v) {
                return super.strip(v);
            }
            constructor(){
                super({
                    type: "boolean",
                    check (v) {
                        if (v instanceof Boolean) v = v.valueOf();
                        return typeof v === "boolean";
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw)=>{
                        if (this.spec.coerce && !this.isType(value)) {
                            if (/^(true|1)$/i.test(String(value))) return true;
                            if (/^(false|0)$/i.test(String(value))) return false;
                        }
                        return value;
                    });
                });
            }
        };
        create$7.prototype = BooleanSchema.prototype;
        isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
        rEmail = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
        rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
        rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
        yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}";
        hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}";
        zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)";
        rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`);
        isTrimmed = (value)=>isAbsent(value) || value === value.trim();
        objStringTag = ({}).toString();
        StringSchema = class extends Schema {
            required(message) {
                return super.required(message).withMutation((schema)=>schema.test({
                        message: message || mixed.required,
                        name: "required",
                        skipAbsent: true,
                        test: (value)=>!!value.length
                    }));
            }
            notRequired() {
                return super.notRequired().withMutation((schema)=>{
                    schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== "required");
                    return schema;
                });
            }
            length(length, message = string.length) {
                return this.test({
                    message,
                    name: "length",
                    exclusive: true,
                    params: {
                        length
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length === this.resolve(length);
                    }
                });
            }
            min(min, message = string.min) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length >= this.resolve(min);
                    }
                });
            }
            max(max, message = string.max) {
                return this.test({
                    name: "max",
                    exclusive: true,
                    message,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length <= this.resolve(max);
                    }
                });
            }
            matches(regex, options3) {
                let excludeEmptyString = false;
                let message;
                let name;
                if (options3) {
                    if (typeof options3 === "object") {
                        ({ excludeEmptyString = false, message, name } = options3);
                    } else {
                        message = options3;
                    }
                }
                return this.test({
                    name: name || "matches",
                    message: message || string.matches,
                    params: {
                        regex
                    },
                    skipAbsent: true,
                    test: (value)=>value === "" && excludeEmptyString || value.search(regex) !== -1
                });
            }
            email(message = string.email) {
                return this.matches(rEmail, {
                    name: "email",
                    message,
                    excludeEmptyString: true
                });
            }
            url(message = string.url) {
                return this.matches(rUrl, {
                    name: "url",
                    message,
                    excludeEmptyString: true
                });
            }
            uuid(message = string.uuid) {
                return this.matches(rUUID, {
                    name: "uuid",
                    message,
                    excludeEmptyString: false
                });
            }
            datetime(options3) {
                let message = "";
                let allowOffset;
                let precision;
                if (options3) {
                    if (typeof options3 === "object") {
                        ({ message = "", allowOffset = false, precision = void 0 } = options3);
                    } else {
                        message = options3;
                    }
                }
                return this.matches(rIsoDateTime, {
                    name: "datetime",
                    message: message || string.datetime,
                    excludeEmptyString: true
                }).test({
                    name: "datetime_offset",
                    message: message || string.datetime_offset,
                    params: {
                        allowOffset
                    },
                    skipAbsent: true,
                    test: (value)=>{
                        if (!value || allowOffset) return true;
                        const struct = parseDateStruct(value);
                        if (!struct) return false;
                        return !!struct.z;
                    }
                }).test({
                    name: "datetime_precision",
                    message: message || string.datetime_precision,
                    params: {
                        precision
                    },
                    skipAbsent: true,
                    test: (value)=>{
                        if (!value || precision == void 0) return true;
                        const struct = parseDateStruct(value);
                        if (!struct) return false;
                        return struct.precision === precision;
                    }
                });
            }
            //-- transforms --
            ensure() {
                return this.default("").transform((val)=>val === null ? "" : val);
            }
            trim(message = string.trim) {
                return this.transform((val)=>val != null ? val.trim() : val).test({
                    message,
                    name: "trim",
                    test: isTrimmed
                });
            }
            lowercase(message = string.lowercase) {
                return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({
                    message,
                    name: "string_case",
                    exclusive: true,
                    skipAbsent: true,
                    test: (value)=>isAbsent(value) || value === value.toLowerCase()
                });
            }
            uppercase(message = string.uppercase) {
                return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({
                    message,
                    name: "string_case",
                    exclusive: true,
                    skipAbsent: true,
                    test: (value)=>isAbsent(value) || value === value.toUpperCase()
                });
            }
            constructor(){
                super({
                    type: "string",
                    check (value) {
                        if (value instanceof String) value = value.valueOf();
                        return typeof value === "string";
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw)=>{
                        if (!this.spec.coerce || this.isType(value)) return value;
                        if (Array.isArray(value)) return value;
                        const strValue = value != null && value.toString ? value.toString() : value;
                        if (strValue === objStringTag) return value;
                        return strValue;
                    });
                });
            }
        };
        create$6.prototype = StringSchema.prototype;
        isNaN$1 = (value)=>value != +value;
        NumberSchema = class extends Schema {
            min(min, message = number.min) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value >= this.resolve(min);
                    }
                });
            }
            max(max, message = number.max) {
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value <= this.resolve(max);
                    }
                });
            }
            lessThan(less, message = number.lessThan) {
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        less
                    },
                    skipAbsent: true,
                    test (value) {
                        return value < this.resolve(less);
                    }
                });
            }
            moreThan(more, message = number.moreThan) {
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        more
                    },
                    skipAbsent: true,
                    test (value) {
                        return value > this.resolve(more);
                    }
                });
            }
            positive(msg = number.positive) {
                return this.moreThan(0, msg);
            }
            negative(msg = number.negative) {
                return this.lessThan(0, msg);
            }
            integer(message = number.integer) {
                return this.test({
                    name: "integer",
                    message,
                    skipAbsent: true,
                    test: (val)=>Number.isInteger(val)
                });
            }
            truncate() {
                return this.transform((value)=>!isAbsent(value) ? value | 0 : value);
            }
            round(method) {
                var _method;
                let avail = [
                    "ceil",
                    "floor",
                    "round",
                    "trunc"
                ];
                method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
                if (method === "trunc") return this.truncate();
                if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError("Only valid options for round() are: " + avail.join(", "));
                return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);
            }
            constructor(){
                super({
                    type: "number",
                    check (value) {
                        if (value instanceof Number) value = value.valueOf();
                        return typeof value === "number" && !isNaN$1(value);
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw)=>{
                        if (!this.spec.coerce) return value;
                        let parsed = value;
                        if (typeof parsed === "string") {
                            parsed = parsed.replace(/\s/g, "");
                            if (parsed === "") return NaN;
                            parsed = +parsed;
                        }
                        if (this.isType(parsed) || parsed === null) return parsed;
                        return parseFloat(parsed);
                    });
                });
            }
        };
        create$5.prototype = NumberSchema.prototype;
        invalidDate = /* @__PURE__ */ new Date("");
        isDate = (obj)=>Object.prototype.toString.call(obj) === "[object Date]";
        DateSchema = class _DateSchema extends Schema {
            prepareParam(ref, name) {
                let param;
                if (!Reference.isRef(ref)) {
                    let cast = this.cast(ref);
                    if (!this._typeCheck(cast)) throw new TypeError(`\`${name}\` must be a Date or a value that can be \`cast()\` to a Date`);
                    param = cast;
                } else {
                    param = ref;
                }
                return param;
            }
            min(min, message = date.min) {
                let limit = this.prepareParam(min, "min");
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    test (value) {
                        return value >= this.resolve(limit);
                    }
                });
            }
            max(max, message = date.max) {
                let limit = this.prepareParam(max, "max");
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value <= this.resolve(limit);
                    }
                });
            }
            constructor(){
                super({
                    type: "date",
                    check (v) {
                        return isDate(v) && !isNaN(v.getTime());
                    }
                });
                this.withMutation(()=>{
                    this.transform((value, _raw)=>{
                        if (!this.spec.coerce || this.isType(value) || value === null) return value;
                        value = parseIsoDate(value);
                        return !isNaN(value) ? new Date(value) : _DateSchema.INVALID_DATE;
                    });
                });
            }
        };
        DateSchema.INVALID_DATE = invalidDate;
        create$4.prototype = DateSchema.prototype;
        create$4.INVALID_DATE = invalidDate;
        parseJson = (value, _, schema)=>{
            if (typeof value !== "string") {
                return value;
            }
            let parsed = value;
            try {
                parsed = JSON.parse(value);
            } catch (err) {}
            return schema.isType(parsed) ? parsed : value;
        };
        deepHas = (obj, p)=>{
            const path = [
                ...(0, import_property_expr.normalizePath)(p)
            ];
            if (path.length === 1) return path[0] in obj;
            let last = path.pop();
            let parent = (0, import_property_expr.getter)((0, import_property_expr.join)(path), true)(obj);
            return !!(parent && last in parent);
        };
        isObject3 = (obj)=>Object.prototype.toString.call(obj) === "[object Object]";
        defaultSort = sortByKeyOrder([]);
        ObjectSchema = class extends Schema {
            _cast(_value, options3 = {}) {
                var _options$stripUnknown;
                let value = super._cast(_value, options3);
                if (value === void 0) return this.getDefault(options3);
                if (!this._typeCheck(value)) return value;
                let fields = this.fields;
                let strip = (_options$stripUnknown = options3.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
                let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));
                let intermediateValue = {};
                let innerOptions = Object.assign({}, options3, {
                    parent: intermediateValue,
                    __validating: options3.__validating || false
                });
                let isChanged = false;
                for (const prop of props){
                    let field = fields[prop];
                    let exists = prop in value;
                    let inputValue = value[prop];
                    if (field) {
                        let fieldValue;
                        innerOptions.path = (options3.path ? `${options3.path}.` : "") + prop;
                        field = field.resolve({
                            value: inputValue,
                            context: options3.context,
                            parent: intermediateValue
                        });
                        let fieldSpec = field instanceof Schema ? field.spec : void 0;
                        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
                        if (fieldSpec != null && fieldSpec.strip) {
                            isChanged = isChanged || prop in value;
                            continue;
                        }
                        fieldValue = !options3.__validating || !strict ? field.cast(inputValue, innerOptions) : inputValue;
                        if (fieldValue !== void 0) {
                            intermediateValue[prop] = fieldValue;
                        }
                    } else if (exists && !strip) {
                        intermediateValue[prop] = inputValue;
                    }
                    if (exists !== prop in intermediateValue || intermediateValue[prop] !== inputValue) {
                        isChanged = true;
                    }
                }
                return isChanged ? intermediateValue : value;
            }
            _validate(_value, options3 = {}, panic, next) {
                let { from = [], originalValue = _value, recursive = this.spec.recursive } = options3;
                options3.from = [
                    {
                        schema: this,
                        value: originalValue
                    },
                    ...from
                ];
                options3.__validating = true;
                options3.originalValue = originalValue;
                super._validate(_value, options3, panic, (objectErrors, value)=>{
                    if (!recursive || !isObject3(value)) {
                        next(objectErrors, value);
                        return;
                    }
                    originalValue = originalValue || value;
                    let tests = [];
                    for (let key of this._nodes){
                        let field = this.fields[key];
                        if (!field || Reference.isRef(field)) {
                            continue;
                        }
                        tests.push(field.asNestedTest({
                            options: options3,
                            key,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: originalValue
                        }));
                    }
                    this.runTests({
                        tests,
                        value,
                        originalValue,
                        options: options3
                    }, panic, (fieldErrors)=>{
                        next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);
                    });
                });
            }
            clone(spec) {
                const next = super.clone(spec);
                next.fields = Object.assign({}, this.fields);
                next._nodes = this._nodes;
                next._excludedEdges = this._excludedEdges;
                next._sortErrors = this._sortErrors;
                return next;
            }
            concat(schema) {
                let next = super.concat(schema);
                let nextFields = next.fields;
                for (let [field, schemaOrRef] of Object.entries(this.fields)){
                    const target = nextFields[field];
                    nextFields[field] = target === void 0 ? schemaOrRef : target;
                }
                return next.withMutation((s)=>// XXX: excludes here is wrong
                    s.setFields(nextFields, [
                        ...this._excludedEdges,
                        ...schema._excludedEdges
                    ]));
            }
            _getDefault(options3) {
                if ("default" in this.spec) {
                    return super._getDefault(options3);
                }
                if (!this._nodes.length) {
                    return void 0;
                }
                let dft = {};
                this._nodes.forEach((key)=>{
                    var _innerOptions;
                    const field = this.fields[key];
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[key]
                        });
                    }
                    dft[key] = field && "getDefault" in field ? field.getDefault(innerOptions) : void 0;
                });
                return dft;
            }
            setFields(shape, excludedEdges) {
                let next = this.clone();
                next.fields = shape;
                next._nodes = sortFields(shape, excludedEdges);
                next._sortErrors = sortByKeyOrder(Object.keys(shape));
                if (excludedEdges) next._excludedEdges = excludedEdges;
                return next;
            }
            shape(additions, excludes = []) {
                return this.clone().withMutation((next)=>{
                    let edges = next._excludedEdges;
                    if (excludes.length) {
                        if (!Array.isArray(excludes[0])) excludes = [
                            excludes
                        ];
                        edges = [
                            ...next._excludedEdges,
                            ...excludes
                        ];
                    }
                    return next.setFields(Object.assign(next.fields, additions), edges);
                });
            }
            partial() {
                const partial = {};
                for (const [key, schema] of Object.entries(this.fields)){
                    partial[key] = "optional" in schema && schema.optional instanceof Function ? schema.optional() : schema;
                }
                return this.setFields(partial);
            }
            deepPartial() {
                const next = deepPartial(this);
                return next;
            }
            pick(keys2) {
                const picked = {};
                for (const key of keys2){
                    if (this.fields[key]) picked[key] = this.fields[key];
                }
                return this.setFields(picked, this._excludedEdges.filter(([a, b])=>keys2.includes(a) && keys2.includes(b)));
            }
            omit(keys2) {
                const remaining = [];
                for (const key of Object.keys(this.fields)){
                    if (keys2.includes(key)) continue;
                    remaining.push(key);
                }
                return this.pick(remaining);
            }
            from(from, to, alias) {
                let fromGetter = (0, import_property_expr.getter)(from, true);
                return this.transform((obj)=>{
                    if (!obj) return obj;
                    let newObj = obj;
                    if (deepHas(obj, from)) {
                        newObj = Object.assign({}, obj);
                        if (!alias) delete newObj[from];
                        newObj[to] = fromGetter(obj);
                    }
                    return newObj;
                });
            }
            /** Parse an input JSON string to an object */ json() {
                return this.transform(parseJson);
            }
            /**
       * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys
       */ exact(message) {
                return this.test({
                    name: "exact",
                    exclusive: true,
                    message: message || object.exact,
                    test (value) {
                        if (value == null) return true;
                        const unknownKeys = unknown(this.schema, value);
                        return unknownKeys.length === 0 || this.createError({
                            params: {
                                properties: unknownKeys.join(", ")
                            }
                        });
                    }
                });
            }
            stripUnknown() {
                return this.clone({
                    noUnknown: true
                });
            }
            noUnknown(noAllow = true, message = object.noUnknown) {
                if (typeof noAllow !== "boolean") {
                    message = noAllow;
                    noAllow = true;
                }
                let next = this.test({
                    name: "noUnknown",
                    exclusive: true,
                    message,
                    test (value) {
                        if (value == null) return true;
                        const unknownKeys = unknown(this.schema, value);
                        return !noAllow || unknownKeys.length === 0 || this.createError({
                            params: {
                                unknown: unknownKeys.join(", ")
                            }
                        });
                    }
                });
                next.spec.noUnknown = noAllow;
                return next;
            }
            unknown(allow = true, message = object.noUnknown) {
                return this.noUnknown(!allow, message);
            }
            transformKeys(fn) {
                return this.transform((obj)=>{
                    if (!obj) return obj;
                    const result = {};
                    for (const key of Object.keys(obj))result[fn(key)] = obj[key];
                    return result;
                });
            }
            camelCase() {
                return this.transformKeys(import_tiny_case.camelCase);
            }
            snakeCase() {
                return this.transformKeys(import_tiny_case.snakeCase);
            }
            constantCase() {
                return this.transformKeys((key)=>(0, import_tiny_case.snakeCase)(key).toUpperCase());
            }
            describe(options3) {
                const next = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                base.fields = {};
                for (const [key, value] of Object.entries(next.fields)){
                    var _innerOptions2;
                    let innerOptions = options3;
                    if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[key]
                        });
                    }
                    base.fields[key] = value.describe(innerOptions);
                }
                return base;
            }
            constructor(spec){
                super({
                    type: "object",
                    check (value) {
                        return isObject3(value) || typeof value === "function";
                    }
                });
                this.fields = /* @__PURE__ */ Object.create(null);
                this._sortErrors = defaultSort;
                this._nodes = [];
                this._excludedEdges = [];
                this.withMutation(()=>{
                    if (spec) {
                        this.shape(spec);
                    }
                });
            }
        };
        create$3.prototype = ObjectSchema.prototype;
        ArraySchema = class extends Schema {
            _cast(_value, _opts) {
                const value = super._cast(_value, _opts);
                if (!this._typeCheck(value) || !this.innerType) {
                    return value;
                }
                let isChanged = false;
                const castArray = value.map((v, idx)=>{
                    const castElement = this.innerType.cast(v, Object.assign({}, _opts, {
                        path: `${_opts.path || ""}[${idx}]`,
                        parent: value,
                        originalValue: v,
                        value: v,
                        index: idx
                    }));
                    if (castElement !== v) {
                        isChanged = true;
                    }
                    return castElement;
                });
                return isChanged ? castArray : value;
            }
            _validate(_value, options3 = {}, panic, next) {
                var _options$recursive;
                let innerType = this.innerType;
                let recursive = (_options$recursive = options3.recursive) != null ? _options$recursive : this.spec.recursive;
                options3.originalValue != null ? options3.originalValue : _value;
                super._validate(_value, options3, panic, (arrayErrors, value)=>{
                    var _options$originalValu2;
                    if (!recursive || !innerType || !this._typeCheck(value)) {
                        next(arrayErrors, value);
                        return;
                    }
                    let tests = new Array(value.length);
                    for(let index = 0; index < value.length; index++){
                        var _options$originalValu;
                        tests[index] = innerType.asNestedTest({
                            options: options3,
                            index,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: (_options$originalValu = options3.originalValue) != null ? _options$originalValu : _value
                        });
                    }
                    this.runTests({
                        value,
                        tests,
                        originalValue: (_options$originalValu2 = options3.originalValue) != null ? _options$originalValu2 : _value,
                        options: options3
                    }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(arrayErrors), value));
                });
            }
            clone(spec) {
                const next = super.clone(spec);
                next.innerType = this.innerType;
                return next;
            }
            /** Parse an input JSON string to an object */ json() {
                return this.transform(parseJson);
            }
            concat(schema) {
                let next = super.concat(schema);
                next.innerType = this.innerType;
                if (schema.innerType) next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat and will break
                next.innerType.concat(schema.innerType) : schema.innerType;
                return next;
            }
            of(schema) {
                let next = this.clone();
                if (!isSchema(schema)) throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
                next.innerType = schema;
                next.spec = Object.assign({}, next.spec, {
                    types: schema
                });
                return next;
            }
            length(length, message = array.length) {
                return this.test({
                    message,
                    name: "length",
                    exclusive: true,
                    params: {
                        length
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length === this.resolve(length);
                    }
                });
            }
            min(min, message) {
                message = message || array.min;
                return this.test({
                    message,
                    name: "min",
                    exclusive: true,
                    params: {
                        min
                    },
                    skipAbsent: true,
                    // FIXME(ts): Array<typeof T>
                    test (value) {
                        return value.length >= this.resolve(min);
                    }
                });
            }
            max(max, message) {
                message = message || array.max;
                return this.test({
                    message,
                    name: "max",
                    exclusive: true,
                    params: {
                        max
                    },
                    skipAbsent: true,
                    test (value) {
                        return value.length <= this.resolve(max);
                    }
                });
            }
            ensure() {
                return this.default(()=>[]).transform((val, original)=>{
                    if (this._typeCheck(val)) return val;
                    return original == null ? [] : [].concat(original);
                });
            }
            compact(rejector) {
                let reject = !rejector ? (v)=>!!v : (v, i2, a)=>!rejector(v, i2, a);
                return this.transform((values)=>values != null ? values.filter(reject) : values);
            }
            describe(options3) {
                const next = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                if (next.innerType) {
                    var _innerOptions;
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[0]
                        });
                    }
                    base.innerType = next.innerType.describe(innerOptions);
                }
                return base;
            }
            constructor(type){
                super({
                    type: "array",
                    spec: {
                        types: type
                    },
                    check (v) {
                        return Array.isArray(v);
                    }
                });
                this.innerType = void 0;
                this.innerType = type;
            }
        };
        create$2.prototype = ArraySchema.prototype;
        TupleSchema = class extends Schema {
            _cast(inputValue, options3) {
                const { types } = this.spec;
                const value = super._cast(inputValue, options3);
                if (!this._typeCheck(value)) {
                    return value;
                }
                let isChanged = false;
                const castArray = types.map((type, idx)=>{
                    const castElement = type.cast(value[idx], Object.assign({}, options3, {
                        path: `${options3.path || ""}[${idx}]`,
                        parent: value,
                        originalValue: value[idx],
                        value: value[idx],
                        index: idx
                    }));
                    if (castElement !== value[idx]) isChanged = true;
                    return castElement;
                });
                return isChanged ? castArray : value;
            }
            _validate(_value, options3 = {}, panic, next) {
                let itemTypes = this.spec.types;
                super._validate(_value, options3, panic, (tupleErrors, value)=>{
                    var _options$originalValu2;
                    if (!this._typeCheck(value)) {
                        next(tupleErrors, value);
                        return;
                    }
                    let tests = [];
                    for (let [index, itemSchema] of itemTypes.entries()){
                        var _options$originalValu;
                        tests[index] = itemSchema.asNestedTest({
                            options: options3,
                            index,
                            parent: value,
                            parentPath: options3.path,
                            originalParent: (_options$originalValu = options3.originalValue) != null ? _options$originalValu : _value
                        });
                    }
                    this.runTests({
                        value,
                        tests,
                        originalValue: (_options$originalValu2 = options3.originalValue) != null ? _options$originalValu2 : _value,
                        options: options3
                    }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(tupleErrors), value));
                });
            }
            describe(options3) {
                const next = (options3 ? this.resolve(options3) : this).clone();
                const base = super.describe(options3);
                base.innerType = next.spec.types.map((schema, index)=>{
                    var _innerOptions;
                    let innerOptions = options3;
                    if ((_innerOptions = innerOptions) != null && _innerOptions.value) {
                        innerOptions = Object.assign({}, innerOptions, {
                            parent: innerOptions.value,
                            value: innerOptions.value[index]
                        });
                    }
                    return schema.describe(innerOptions);
                });
                return base;
            }
            constructor(schemas){
                super({
                    type: "tuple",
                    spec: {
                        types: schemas
                    },
                    check (v) {
                        const types = this.spec.types;
                        return Array.isArray(v) && v.length === types.length;
                    }
                });
                this.withMutation(()=>{
                    this.typeError(tuple.notType);
                });
            }
        };
        create$1.prototype = TupleSchema.prototype;
        Lazy = class _Lazy {
            clone(spec) {
                const next = new _Lazy(this.builder);
                next.spec = Object.assign({}, this.spec, spec);
                return next;
            }
            optionality(optional) {
                const next = this.clone({
                    optional
                });
                return next;
            }
            optional() {
                return this.optionality(true);
            }
            resolve(options3) {
                return this._resolve(options3.value, options3);
            }
            cast(value, options3) {
                return this._resolve(value, options3).cast(value, options3);
            }
            asNestedTest(config) {
                let { key, index, parent, options: options3 } = config;
                let value = parent[index != null ? index : key];
                return this._resolve(value, Object.assign({}, options3, {
                    value,
                    parent
                })).asNestedTest(config);
            }
            validate(value, options3) {
                return catchValidationError(()=>this._resolve(value, options3).validate(value, options3));
            }
            validateSync(value, options3) {
                return this._resolve(value, options3).validateSync(value, options3);
            }
            validateAt(path, value, options3) {
                return catchValidationError(()=>this._resolve(value, options3).validateAt(path, value, options3));
            }
            validateSyncAt(path, value, options3) {
                return this._resolve(value, options3).validateSyncAt(path, value, options3);
            }
            isValid(value, options3) {
                try {
                    return this._resolve(value, options3).isValid(value, options3);
                } catch (err) {
                    if (ValidationError.isError(err)) {
                        return Promise.resolve(false);
                    }
                    throw err;
                }
            }
            isValidSync(value, options3) {
                return this._resolve(value, options3).isValidSync(value, options3);
            }
            describe(options3) {
                return options3 ? this.resolve(options3).describe(options3) : {
                    type: "lazy",
                    meta: this.spec.meta,
                    label: void 0
                };
            }
            meta(...args) {
                if (args.length === 0) return this.spec.meta;
                let next = this.clone();
                next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
                return next;
            }
            get ["~standard"]() {
                const schema = this;
                const standard = {
                    version: 1,
                    vendor: "yup",
                    validate (value) {
                        return _async_to_generator(function*() {
                            try {
                                const result = yield schema.validate(value, {
                                    abortEarly: false
                                });
                                return {
                                    value: result
                                };
                            } catch (err) {
                                if (ValidationError.isError(err)) {
                                    return {
                                        issues: issuesFromValidationError(err)
                                    };
                                }
                                throw err;
                            }
                        })();
                    }
                };
                return standard;
            }
            constructor(builder){
                this.type = "lazy";
                this.__isYupSchema__ = true;
                this.spec = void 0;
                this._resolve = (value, options3 = {})=>{
                    let schema = this.builder(value, options3);
                    if (!isSchema(schema)) throw new TypeError("lazy() functions must return a valid schema");
                    if (this.spec.optional) schema = schema.optional();
                    return schema.resolve(options3);
                };
                this.builder = builder;
                this.spec = {
                    meta: void 0,
                    optional: false
                };
            }
        };
    }
});
// node_modules/ics/dist/schema/index.js
var require_schema = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/schema/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.urlRegex = void 0;
        exports2.validateHeader = validateHeader;
        exports2.validateHeaderAndEvent = validateHeaderAndEvent;
        var yup = _interopRequireWildcard((init_index_esm(), (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toCommonJS)(index_esm_exports)));
        function _getRequireWildcardCache(nodeInterop) {
            if (typeof WeakMap !== "function") return null;
            var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
            var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
            return (_getRequireWildcardCache = function _getRequireWildcardCache2(nodeInterop2) {
                return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
            })(nodeInterop);
        }
        function _interopRequireWildcard(obj, nodeInterop) {
            if (!nodeInterop && obj && obj.__esModule) {
                return obj;
            }
            if (obj === null || _typeof2(obj) !== "object" && typeof obj !== "function") {
                return {
                    "default": obj
                };
            }
            var cache = _getRequireWildcardCache(nodeInterop);
            if (cache && cache.has(obj)) {
                return cache.get(obj);
            }
            var newObj = {};
            var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
            for(var key in obj){
                if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    if (desc && (desc.get || desc.set)) {
                        Object.defineProperty(newObj, key, desc);
                    } else {
                        newObj[key] = obj[key];
                    }
                }
            }
            newObj["default"] = obj;
            if (cache) {
                cache.set(obj, newObj);
            }
            return newObj;
        }
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function ownKeys(object2, enumerableOnly) {
            var keys2 = Object.keys(object2);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object2);
                enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                })), keys2.push.apply(keys2, symbols);
            }
            return keys2;
        }
        function _objectSpread(target) {
            for(var i2 = 1; i2 < arguments.length; i2++){
                var source = null != arguments[i2] ? arguments[i2] : {};
                i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
            }
            return target;
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        var urlRegex = exports2.urlRegex = /^(?:([a-z0-9+.-]+):\/\/)(?:\S+(?::\S*)?@)?(?:(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*\.?)(?::\d{2,5})?(?:[/?#]\S*)?$/;
        var dateTimeSchema = function dateTimeSchema2(_ref) {
            var required = _ref.required;
            return yup.lazy(function(value) {
                if (typeof value === "number") {
                    return yup.number().integer().min(0);
                }
                if (typeof value === "string") {
                    return yup.string().required();
                }
                if (!required && typeof value === "undefined") {
                    return yup.mixed().oneOf([
                        void 0
                    ]);
                }
                return yup.array().required().min(3).max(7).of(yup.lazy(function(item, options3) {
                    var itemIndex = options3.parent.indexOf(options3.value);
                    return [
                        yup.number().integer(),
                        yup.number().integer().min(1).max(12),
                        yup.number().integer().min(1).max(31),
                        yup.number().integer().min(0).max(23),
                        yup.number().integer().min(0).max(60),
                        yup.number().integer().min(0).max(60)
                    ][itemIndex];
                }));
            });
        };
        var durationSchema = yup.object().shape({
            before: yup["boolean"](),
            //option to set before alaram
            weeks: yup.number(),
            days: yup.number(),
            hours: yup.number(),
            minutes: yup.number(),
            seconds: yup.number()
        }).noUnknown();
        var contactSchema = yup.object().shape({
            name: yup.string(),
            email: yup.string().email(),
            rsvp: yup["boolean"](),
            dir: yup.string().matches(urlRegex),
            partstat: yup.string(),
            role: yup.string(),
            cutype: yup.string(),
            xNumGuests: yup.number()
        }).noUnknown();
        var organizerSchema = yup.object().shape({
            name: yup.string(),
            email: yup.string().email(),
            dir: yup.string(),
            sentBy: yup.string()
        }).noUnknown();
        var alarmSchema = yup.object().shape({
            action: yup.string().matches(/^(audio|display|email)$/).required(),
            trigger: yup.mixed().required(),
            description: yup.string(),
            duration: durationSchema,
            repeat: yup.number(),
            attach: yup.string(),
            attachType: yup.string(),
            summary: yup.string(),
            attendee: contactSchema,
            "x-prop": yup.mixed(),
            "iana-prop": yup.mixed()
        }).noUnknown();
        var headerShape = {
            productId: yup.string(),
            method: yup.string(),
            calName: yup.string()
        };
        var headerSchema = yup.object().shape(headerShape).noUnknown();
        var eventShape = {
            summary: yup.string(),
            timestamp: dateTimeSchema({
                required: false
            }),
            title: yup.string(),
            uid: yup.string(),
            sequence: yup.number().integer().max(2147483647),
            start: dateTimeSchema({
                required: true
            }),
            duration: durationSchema,
            startType: yup.string().matches(/^(utc|local)$/),
            startInputType: yup.string().matches(/^(utc|local)$/),
            startOutputType: yup.string().matches(/^(utc|local)$/),
            end: dateTimeSchema({
                required: false
            }),
            endInputType: yup.string().matches(/^(utc|local)$/),
            endOutputType: yup.string().matches(/^(utc|local)$/),
            description: yup.string(),
            url: yup.string().matches(urlRegex),
            geo: yup.object().shape({
                lat: yup.number(),
                lon: yup.number()
            }),
            location: yup.string(),
            status: yup.string().matches(/^(TENTATIVE|CANCELLED|CONFIRMED)$/i),
            categories: yup.array().of(yup.string()),
            organizer: organizerSchema,
            attendees: yup.array().of(contactSchema),
            alarms: yup.array().of(alarmSchema),
            recurrenceRule: yup.string(),
            busyStatus: yup.string().matches(/^(TENTATIVE|FREE|BUSY|OOF)$/i),
            transp: yup.string().matches(/^(TRANSPARENT|OPAQUE)$/i),
            classification: yup.string(),
            created: dateTimeSchema({
                required: false
            }),
            lastModified: dateTimeSchema({
                required: false
            }),
            exclusionDates: yup.array().of(dateTimeSchema({
                required: true
            })),
            htmlContent: yup.string()
        };
        var headerAndEventSchema = yup.object().shape(_objectSpread(_objectSpread({}, headerShape), eventShape)).test("xor", "object should have end or duration (but not both)", function(val) {
            var hasEnd = !!val.end;
            var hasDuration = !!val.duration;
            return hasEnd && !hasDuration || !hasEnd && hasDuration || !hasEnd && !hasDuration;
        }).noUnknown();
        function validateHeader(candidate) {
            try {
                var value = headerSchema.validateSync(candidate, {
                    abortEarly: false,
                    strict: true
                });
                return {
                    error: null,
                    value
                };
            } catch (error) {
                return {
                    error: Object.assign({}, error),
                    value: void 0
                };
            }
        }
        function validateHeaderAndEvent(candidate) {
            try {
                var value = headerAndEventSchema.validateSync(candidate, {
                    abortEarly: false,
                    strict: true
                });
                return {
                    error: null,
                    value
                };
            } catch (error) {
                return {
                    error: Object.assign({}, error),
                    value: void 0
                };
            }
        }
    }
});
// node_modules/ics/dist/pipeline/validate.js
var require_validate = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/pipeline/validate.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        var _schema = require_schema();
        Object.keys(_schema).forEach(function(key) {
            if (key === "default" || key === "__esModule") return;
            if (key in exports2 && exports2[key] === _schema[key]) return;
            Object.defineProperty(exports2, key, {
                enumerable: true,
                get: function get2() {
                    return _schema[key];
                }
            });
        });
    }
});
// node_modules/ics/dist/pipeline/index.js
var require_pipeline = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/pipeline/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        Object.defineProperty(exports2, "buildEvent", {
            enumerable: true,
            get: function get2() {
                return _build.buildEvent;
            }
        });
        Object.defineProperty(exports2, "buildHeader", {
            enumerable: true,
            get: function get2() {
                return _build.buildHeader;
            }
        });
        Object.defineProperty(exports2, "formatEvent", {
            enumerable: true,
            get: function get2() {
                return _format.formatEvent;
            }
        });
        Object.defineProperty(exports2, "formatFooter", {
            enumerable: true,
            get: function get2() {
                return _format.formatFooter;
            }
        });
        Object.defineProperty(exports2, "formatHeader", {
            enumerable: true,
            get: function get2() {
                return _format.formatHeader;
            }
        });
        Object.defineProperty(exports2, "urlRegex", {
            enumerable: true,
            get: function get2() {
                return _validate.urlRegex;
            }
        });
        Object.defineProperty(exports2, "validateHeader", {
            enumerable: true,
            get: function get2() {
                return _validate.validateHeader;
            }
        });
        Object.defineProperty(exports2, "validateHeaderAndEvent", {
            enumerable: true,
            get: function get2() {
                return _validate.validateHeaderAndEvent;
            }
        });
        var _build = require_build();
        var _format = require_format();
        var _validate = require_validate();
    }
});
// node_modules/ics/dist/index.js
var require_dist2 = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/ics/dist/index.js" (exports2) {
        "use strict";
        Object.defineProperty(exports2, "__esModule", {
            value: true
        });
        exports2.convertTimestampToArray = convertTimestampToArray;
        exports2.createEvent = createEvent3;
        exports2.createEvents = createEvents2;
        exports2.isValidURL = isValidURL;
        var _pipeline = require_pipeline();
        function _typeof2(obj) {
            "@babel/helpers - typeof";
            return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
                return typeof obj2;
            } : function(obj2) {
                return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
            }, _typeof2(obj);
        }
        function ownKeys(object2, enumerableOnly) {
            var keys2 = Object.keys(object2);
            if (Object.getOwnPropertySymbols) {
                var symbols = Object.getOwnPropertySymbols(object2);
                enumerableOnly && (symbols = symbols.filter(function(sym) {
                    return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
                })), keys2.push.apply(keys2, symbols);
            }
            return keys2;
        }
        function _objectSpread(target) {
            for(var i2 = 1; i2 < arguments.length; i2++){
                var source = null != arguments[i2] ? arguments[i2] : {};
                i2 % 2 ? ownKeys(Object(source), true).forEach(function(key) {
                    _defineProperty(target, key, source[key]);
                }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
                    Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                });
            }
            return target;
        }
        function _defineProperty(obj, key, value) {
            key = _toPropertyKey(key);
            if (key in obj) {
                Object.defineProperty(obj, key, {
                    value,
                    enumerable: true,
                    configurable: true,
                    writable: true
                });
            } else {
                obj[key] = value;
            }
            return obj;
        }
        function _toPropertyKey(arg) {
            var key = _toPrimitive(arg, "string");
            return _typeof2(key) === "symbol" ? key : String(key);
        }
        function _toPrimitive(input, hint) {
            if (_typeof2(input) !== "object" || input === null) return input;
            var prim = input[Symbol.toPrimitive];
            if (prim !== void 0) {
                var res = prim.call(input, hint || "default");
                if (_typeof2(res) !== "object") return res;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return (hint === "string" ? String : Number)(input);
        }
        function buildHeaderAndValidate(header) {
            return (0, _pipeline.validateHeader)((0, _pipeline.buildHeader)(header));
        }
        function buildHeaderAndEventAndValidate(event2) {
            return (0, _pipeline.validateHeaderAndEvent)(_objectSpread(_objectSpread({}, (0, _pipeline.buildHeader)(event2)), (0, _pipeline.buildEvent)(event2)));
        }
        function convertTimestampToArray(timestamp2) {
            var inputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "local";
            var dateArray = [];
            var d = new Date(timestamp2);
            dateArray.push(inputType === "local" ? d.getFullYear() : d.getUTCFullYear());
            dateArray.push((inputType === "local" ? d.getMonth() : d.getUTCMonth()) + 1);
            dateArray.push(inputType === "local" ? d.getDate() : d.getUTCDate());
            dateArray.push(inputType === "local" ? d.getHours() : d.getUTCHours());
            dateArray.push(inputType === "local" ? d.getMinutes() : d.getUTCMinutes());
            return dateArray;
        }
        function createEvent3(attributes, cb) {
            return createEvents2([
                attributes
            ], cb);
        }
        function createEvents2(events2, headerAttributesOrCb, cb) {
            var resolvedHeaderAttributes = _typeof2(headerAttributesOrCb) === "object" ? headerAttributesOrCb : {};
            var resolvedCb = arguments.length === 3 ? cb : typeof headerAttributesOrCb === "function" ? headerAttributesOrCb : null;
            var run = function run2() {
                if (!events2) {
                    return {
                        error: new Error("one argument is required"),
                        value: null
                    };
                }
                var _ref = events2.length === 0 ? buildHeaderAndValidate(resolvedHeaderAttributes) : buildHeaderAndEventAndValidate(_objectSpread(_objectSpread({}, events2[0]), resolvedHeaderAttributes)), headerError = _ref.error, headerValue = _ref.value;
                if (headerError) {
                    return {
                        error: headerError,
                        value: null
                    };
                }
                var value = "";
                value += (0, _pipeline.formatHeader)(headerValue);
                for(var i2 = 0; i2 < events2.length; i2++){
                    var _buildHeaderAndEventA = buildHeaderAndEventAndValidate(events2[i2]), eventError = _buildHeaderAndEventA.error, eventValue = _buildHeaderAndEventA.value;
                    if (eventError) return {
                        error: eventError,
                        value: null
                    };
                    value += (0, _pipeline.formatEvent)(eventValue);
                }
                value += (0, _pipeline.formatFooter)();
                return {
                    error: null,
                    value
                };
            };
            var returnValue;
            try {
                returnValue = run();
            } catch (e) {
                returnValue = {
                    error: e,
                    value: null
                };
            }
            if (!resolvedCb) {
                return returnValue;
            }
            return resolvedCb(returnValue.error, returnValue.value);
        }
        function isValidURL(url) {
            return _pipeline.urlRegex.test(url);
        }
    }
});
// node_modules/is-mobile/index.js
var require_is_mobile = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/is-mobile/index.js" (exports2, module2) {
        "use strict";
        module2.exports = isMobile2;
        module2.exports.isMobile = isMobile2;
        module2.exports.default = isMobile2;
        var mobileRE = /(android|bb\d+|meego).+mobile|armv7l|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series[46]0|samsungbrowser.*mobile|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i;
        var notMobileRE = /CrOS/;
        var tabletRE = /android|ipad|playbook|silk/i;
        function isMobile2(opts) {
            if (!opts) opts = {};
            let ua = opts.ua;
            if (!ua && typeof navigator !== "undefined") ua = navigator.userAgent;
            if (ua && ua.headers && typeof ua.headers["user-agent"] === "string") {
                ua = ua.headers["user-agent"];
            }
            if (typeof ua !== "string") return false;
            let result = mobileRE.test(ua) && !notMobileRE.test(ua) || !!opts.tablet && tabletRE.test(ua);
            if (!result && opts.tablet && opts.featureDetect && navigator && navigator.maxTouchPoints > 1 && ua.indexOf("Macintosh") !== -1 && ua.indexOf("Safari") !== -1) {
                result = true;
            }
            return result;
        }
    }
});
// node_modules/hammerjs/hammer.js
var require_hammer = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__commonJS)({
    "node_modules/hammerjs/hammer.js" (exports2, module2) {
        (function(window2, document2, exportName, undefined2) {
            "use strict";
            var VENDOR_PREFIXES = [
                "",
                "webkit",
                "Moz",
                "MS",
                "ms",
                "o"
            ];
            var TEST_ELEMENT = document2.createElement("div");
            var TYPE_FUNCTION = "function";
            var round = Math.round;
            var abs = Math.abs;
            var now3 = Date.now;
            function setTimeoutContext(fn, timeout, context) {
                return setTimeout(bindFn(fn, context), timeout);
            }
            function invokeArrayArg(arg, fn, context) {
                if (Array.isArray(arg)) {
                    each(arg, context[fn], context);
                    return true;
                }
                return false;
            }
            function each(obj, iterator, context) {
                var i2;
                if (!obj) {
                    return;
                }
                if (obj.forEach) {
                    obj.forEach(iterator, context);
                } else if (obj.length !== undefined2) {
                    i2 = 0;
                    while(i2 < obj.length){
                        iterator.call(context, obj[i2], i2, obj);
                        i2++;
                    }
                } else {
                    for(i2 in obj){
                        obj.hasOwnProperty(i2) && iterator.call(context, obj[i2], i2, obj);
                    }
                }
            }
            function deprecate(method, name, message) {
                var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
                return function() {
                    var e = new Error("get-stack-trace");
                    var stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
                    var log = window2.console && (window2.console.warn || window2.console.log);
                    if (log) {
                        log.call(window2.console, deprecationMessage, stack);
                    }
                    return method.apply(this, arguments);
                };
            }
            var assign;
            if (typeof Object.assign !== "function") {
                assign = function assign2(target) {
                    if (target === undefined2 || target === null) {
                        throw new TypeError("Cannot convert undefined or null to object");
                    }
                    var output = Object(target);
                    for(var index = 1; index < arguments.length; index++){
                        var source = arguments[index];
                        if (source !== undefined2 && source !== null) {
                            for(var nextKey in source){
                                if (source.hasOwnProperty(nextKey)) {
                                    output[nextKey] = source[nextKey];
                                }
                            }
                        }
                    }
                    return output;
                };
            } else {
                assign = Object.assign;
            }
            var extend3 = deprecate(function extend4(dest, src, merge2) {
                var keys2 = Object.keys(src);
                var i2 = 0;
                while(i2 < keys2.length){
                    if (!merge2 || merge2 && dest[keys2[i2]] === undefined2) {
                        dest[keys2[i2]] = src[keys2[i2]];
                    }
                    i2++;
                }
                return dest;
            }, "extend", "Use `assign`.");
            var merge = deprecate(function merge2(dest, src) {
                return extend3(dest, src, true);
            }, "merge", "Use `assign`.");
            function inherit(child, base, properties) {
                var baseP = base.prototype, childP;
                childP = child.prototype = Object.create(baseP);
                childP.constructor = child;
                childP._super = baseP;
                if (properties) {
                    assign(childP, properties);
                }
            }
            function bindFn(fn, context) {
                return function boundFn() {
                    return fn.apply(context, arguments);
                };
            }
            function boolOrFn(val, args) {
                if (typeof val == TYPE_FUNCTION) {
                    return val.apply(args ? args[0] || undefined2 : undefined2, args);
                }
                return val;
            }
            function ifUndefined(val1, val2) {
                return val1 === undefined2 ? val2 : val1;
            }
            function addEventListeners(target, types, handler) {
                each(splitStr(types), function(type) {
                    target.addEventListener(type, handler, false);
                });
            }
            function removeEventListeners(target, types, handler) {
                each(splitStr(types), function(type) {
                    target.removeEventListener(type, handler, false);
                });
            }
            function hasParent(node, parent) {
                while(node){
                    if (node == parent) {
                        return true;
                    }
                    node = node.parentNode;
                }
                return false;
            }
            function inStr(str, find) {
                return str.indexOf(find) > -1;
            }
            function splitStr(str) {
                return str.trim().split(/\s+/g);
            }
            function inArray(src, find, findByKey) {
                if (src.indexOf && !findByKey) {
                    return src.indexOf(find);
                } else {
                    var i2 = 0;
                    while(i2 < src.length){
                        if (findByKey && src[i2][findByKey] == find || !findByKey && src[i2] === find) {
                            return i2;
                        }
                        i2++;
                    }
                    return -1;
                }
            }
            function toArray2(obj) {
                return Array.prototype.slice.call(obj, 0);
            }
            function uniqueArray(src, key, sort) {
                var results = [];
                var values = [];
                var i2 = 0;
                while(i2 < src.length){
                    var val = key ? src[i2][key] : src[i2];
                    if (inArray(values, val) < 0) {
                        results.push(src[i2]);
                    }
                    values[i2] = val;
                    i2++;
                }
                if (sort) {
                    if (!key) {
                        results = results.sort();
                    } else {
                        results = results.sort(function sortUniqueArray(a, b) {
                            return a[key] > b[key];
                        });
                    }
                }
                return results;
            }
            function prefixed(obj, property) {
                var prefix, prop;
                var camelProp = property[0].toUpperCase() + property.slice(1);
                var i2 = 0;
                while(i2 < VENDOR_PREFIXES.length){
                    prefix = VENDOR_PREFIXES[i2];
                    prop = prefix ? prefix + camelProp : property;
                    if (prop in obj) {
                        return prop;
                    }
                    i2++;
                }
                return undefined2;
            }
            var _uniqueId = 1;
            function uniqueId() {
                return _uniqueId++;
            }
            function getWindowForElement(element) {
                var doc3 = element.ownerDocument || element;
                return doc3.defaultView || doc3.parentWindow || window2;
            }
            var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
            var SUPPORT_TOUCH = "ontouchstart" in window2;
            var SUPPORT_POINTER_EVENTS = prefixed(window2, "PointerEvent") !== undefined2;
            var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent);
            var INPUT_TYPE_TOUCH = "touch";
            var INPUT_TYPE_PEN = "pen";
            var INPUT_TYPE_MOUSE = "mouse";
            var INPUT_TYPE_KINECT = "kinect";
            var COMPUTE_INTERVAL = 25;
            var INPUT_START = 1;
            var INPUT_MOVE = 2;
            var INPUT_END = 4;
            var INPUT_CANCEL = 8;
            var DIRECTION_NONE = 1;
            var DIRECTION_LEFT = 2;
            var DIRECTION_RIGHT = 4;
            var DIRECTION_UP = 8;
            var DIRECTION_DOWN = 16;
            var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
            var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
            var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
            var PROPS_XY = [
                "x",
                "y"
            ];
            var PROPS_CLIENT_XY = [
                "clientX",
                "clientY"
            ];
            function Input2(manager, callback) {
                var self2 = this;
                this.manager = manager;
                this.callback = callback;
                this.element = manager.element;
                this.target = manager.options.inputTarget;
                this.domHandler = function(ev) {
                    if (boolOrFn(manager.options.enable, [
                        manager
                    ])) {
                        self2.handler(ev);
                    }
                };
                this.init();
            }
            Input2.prototype = {
                /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */ handler: function() {},
                /**
         * bind the events
         */ init: function() {
                    this.evEl && addEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                },
                /**
         * unbind the events
         */ destroy: function() {
                    this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler);
                    this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler);
                    this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler);
                }
            };
            function createInputInstance(manager) {
                var Type;
                var inputClass = manager.options.inputClass;
                if (inputClass) {
                    Type = inputClass;
                } else if (SUPPORT_POINTER_EVENTS) {
                    Type = PointerEventInput;
                } else if (SUPPORT_ONLY_TOUCH) {
                    Type = TouchInput;
                } else if (!SUPPORT_TOUCH) {
                    Type = MouseInput;
                } else {
                    Type = TouchMouseInput;
                }
                return new Type(manager, inputHandler);
            }
            function inputHandler(manager, eventType, input) {
                var pointersLen = input.pointers.length;
                var changedPointersLen = input.changedPointers.length;
                var isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0;
                var isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
                input.isFirst = !!isFirst;
                input.isFinal = !!isFinal;
                if (isFirst) {
                    manager.session = {};
                }
                input.eventType = eventType;
                computeInputData(manager, input);
                manager.emit("hammer.input", input);
                manager.recognize(input);
                manager.session.prevInput = input;
            }
            function computeInputData(manager, input) {
                var session = manager.session;
                var pointers = input.pointers;
                var pointersLength = pointers.length;
                if (!session.firstInput) {
                    session.firstInput = simpleCloneInputData(input);
                }
                if (pointersLength > 1 && !session.firstMultiple) {
                    session.firstMultiple = simpleCloneInputData(input);
                } else if (pointersLength === 1) {
                    session.firstMultiple = false;
                }
                var firstInput = session.firstInput;
                var firstMultiple = session.firstMultiple;
                var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
                var center = input.center = getCenter(pointers);
                input.timeStamp = now3();
                input.deltaTime = input.timeStamp - firstInput.timeStamp;
                input.angle = getAngle(offsetCenter, center);
                input.distance = getDistance(offsetCenter, center);
                computeDeltaXY(session, input);
                input.offsetDirection = getDirection(input.deltaX, input.deltaY);
                var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
                input.overallVelocityX = overallVelocity.x;
                input.overallVelocityY = overallVelocity.y;
                input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y;
                input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1;
                input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0;
                input.maxPointers = !session.prevInput ? input.pointers.length : input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers;
                computeIntervalInputData(session, input);
                var target = manager.element;
                if (hasParent(input.srcEvent.target, target)) {
                    target = input.srcEvent.target;
                }
                input.target = target;
            }
            function computeDeltaXY(session, input) {
                var center = input.center;
                var offset = session.offsetDelta || {};
                var prevDelta = session.prevDelta || {};
                var prevInput = session.prevInput || {};
                if (input.eventType === INPUT_START || prevInput.eventType === INPUT_END) {
                    prevDelta = session.prevDelta = {
                        x: prevInput.deltaX || 0,
                        y: prevInput.deltaY || 0
                    };
                    offset = session.offsetDelta = {
                        x: center.x,
                        y: center.y
                    };
                }
                input.deltaX = prevDelta.x + (center.x - offset.x);
                input.deltaY = prevDelta.y + (center.y - offset.y);
            }
            function computeIntervalInputData(session, input) {
                var last = session.lastInterval || input, deltaTime = input.timeStamp - last.timeStamp, velocity, velocityX, velocityY, direction;
                if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined2)) {
                    var deltaX = input.deltaX - last.deltaX;
                    var deltaY = input.deltaY - last.deltaY;
                    var v = getVelocity(deltaTime, deltaX, deltaY);
                    velocityX = v.x;
                    velocityY = v.y;
                    velocity = abs(v.x) > abs(v.y) ? v.x : v.y;
                    direction = getDirection(deltaX, deltaY);
                    session.lastInterval = input;
                } else {
                    velocity = last.velocity;
                    velocityX = last.velocityX;
                    velocityY = last.velocityY;
                    direction = last.direction;
                }
                input.velocity = velocity;
                input.velocityX = velocityX;
                input.velocityY = velocityY;
                input.direction = direction;
            }
            function simpleCloneInputData(input) {
                var pointers = [];
                var i2 = 0;
                while(i2 < input.pointers.length){
                    pointers[i2] = {
                        clientX: round(input.pointers[i2].clientX),
                        clientY: round(input.pointers[i2].clientY)
                    };
                    i2++;
                }
                return {
                    timeStamp: now3(),
                    pointers,
                    center: getCenter(pointers),
                    deltaX: input.deltaX,
                    deltaY: input.deltaY
                };
            }
            function getCenter(pointers) {
                var pointersLength = pointers.length;
                if (pointersLength === 1) {
                    return {
                        x: round(pointers[0].clientX),
                        y: round(pointers[0].clientY)
                    };
                }
                var x = 0, y = 0, i2 = 0;
                while(i2 < pointersLength){
                    x += pointers[i2].clientX;
                    y += pointers[i2].clientY;
                    i2++;
                }
                return {
                    x: round(x / pointersLength),
                    y: round(y / pointersLength)
                };
            }
            function getVelocity(deltaTime, x, y) {
                return {
                    x: x / deltaTime || 0,
                    y: y / deltaTime || 0
                };
            }
            function getDirection(x, y) {
                if (x === y) {
                    return DIRECTION_NONE;
                }
                if (abs(x) >= abs(y)) {
                    return x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                }
                return y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
            }
            function getDistance(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.sqrt(x * x + y * y);
            }
            function getAngle(p1, p2, props) {
                if (!props) {
                    props = PROPS_XY;
                }
                var x = p2[props[0]] - p1[props[0]], y = p2[props[1]] - p1[props[1]];
                return Math.atan2(y, x) * 180 / Math.PI;
            }
            function getRotation(start, end) {
                return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY);
            }
            function getScale(start, end) {
                return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY);
            }
            var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            };
            var MOUSE_ELEMENT_EVENTS = "mousedown";
            var MOUSE_WINDOW_EVENTS = "mousemove mouseup";
            function MouseInput() {
                this.evEl = MOUSE_ELEMENT_EVENTS;
                this.evWin = MOUSE_WINDOW_EVENTS;
                this.pressed = false;
                Input2.apply(this, arguments);
            }
            inherit(MouseInput, Input2, {
                /**
         * handle mouse events
         * @param {Object} ev
         */ handler: function MEhandler(ev) {
                    var eventType = MOUSE_INPUT_MAP[ev.type];
                    if (eventType & INPUT_START && ev.button === 0) {
                        this.pressed = true;
                    }
                    if (eventType & INPUT_MOVE && ev.which !== 1) {
                        eventType = INPUT_END;
                    }
                    if (!this.pressed) {
                        return;
                    }
                    if (eventType & INPUT_END) {
                        this.pressed = false;
                    }
                    this.callback(this.manager, eventType, {
                        pointers: [
                            ev
                        ],
                        changedPointers: [
                            ev
                        ],
                        pointerType: INPUT_TYPE_MOUSE,
                        srcEvent: ev
                    });
                }
            });
            var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            };
            var IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT
            };
            var POINTER_ELEMENT_EVENTS = "pointerdown";
            var POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
            if (window2.MSPointerEvent && !window2.PointerEvent) {
                POINTER_ELEMENT_EVENTS = "MSPointerDown";
                POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel";
            }
            function PointerEventInput() {
                this.evEl = POINTER_ELEMENT_EVENTS;
                this.evWin = POINTER_WINDOW_EVENTS;
                Input2.apply(this, arguments);
                this.store = this.manager.session.pointerEvents = [];
            }
            inherit(PointerEventInput, Input2, {
                /**
         * handle mouse events
         * @param {Object} ev
         */ handler: function PEhandler(ev) {
                    var store2 = this.store;
                    var removePointer = false;
                    var eventTypeNormalized = ev.type.toLowerCase().replace("ms", "");
                    var eventType = POINTER_INPUT_MAP[eventTypeNormalized];
                    var pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType;
                    var isTouch = pointerType == INPUT_TYPE_TOUCH;
                    var storeIndex = inArray(store2, ev.pointerId, "pointerId");
                    if (eventType & INPUT_START && (ev.button === 0 || isTouch)) {
                        if (storeIndex < 0) {
                            store2.push(ev);
                            storeIndex = store2.length - 1;
                        }
                    } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                        removePointer = true;
                    }
                    if (storeIndex < 0) {
                        return;
                    }
                    store2[storeIndex] = ev;
                    this.callback(this.manager, eventType, {
                        pointers: store2,
                        changedPointers: [
                            ev
                        ],
                        pointerType,
                        srcEvent: ev
                    });
                    if (removePointer) {
                        store2.splice(storeIndex, 1);
                    }
                }
            });
            var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            var SINGLE_TOUCH_TARGET_EVENTS = "touchstart";
            var SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
            function SingleTouchInput() {
                this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
                this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
                this.started = false;
                Input2.apply(this, arguments);
            }
            inherit(SingleTouchInput, Input2, {
                handler: function TEhandler(ev) {
                    var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                    if (type === INPUT_START) {
                        this.started = true;
                    }
                    if (!this.started) {
                        return;
                    }
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    if (type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0) {
                        this.started = false;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });
            function normalizeSingleTouches(ev, type) {
                var all = toArray2(ev.touches);
                var changed = toArray2(ev.changedTouches);
                if (type & (INPUT_END | INPUT_CANCEL)) {
                    all = uniqueArray(all.concat(changed), "identifier", true);
                }
                return [
                    all,
                    changed
                ];
            }
            var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            };
            var TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
            function TouchInput() {
                this.evTarget = TOUCH_TARGET_EVENTS;
                this.targetIds = {};
                Input2.apply(this, arguments);
            }
            inherit(TouchInput, Input2, {
                handler: function MTEhandler(ev) {
                    var type = TOUCH_INPUT_MAP[ev.type];
                    var touches = getTouches.call(this, ev, type);
                    if (!touches) {
                        return;
                    }
                    this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    });
                }
            });
            function getTouches(ev, type) {
                var allTouches = toArray2(ev.touches);
                var targetIds = this.targetIds;
                if (type & (INPUT_START | INPUT_MOVE) && allTouches.length === 1) {
                    targetIds[allTouches[0].identifier] = true;
                    return [
                        allTouches,
                        allTouches
                    ];
                }
                var i2, targetTouches, changedTouches = toArray2(ev.changedTouches), changedTargetTouches = [], target = this.target;
                targetTouches = allTouches.filter(function(touch) {
                    return hasParent(touch.target, target);
                });
                if (type === INPUT_START) {
                    i2 = 0;
                    while(i2 < targetTouches.length){
                        targetIds[targetTouches[i2].identifier] = true;
                        i2++;
                    }
                }
                i2 = 0;
                while(i2 < changedTouches.length){
                    if (targetIds[changedTouches[i2].identifier]) {
                        changedTargetTouches.push(changedTouches[i2]);
                    }
                    if (type & (INPUT_END | INPUT_CANCEL)) {
                        delete targetIds[changedTouches[i2].identifier];
                    }
                    i2++;
                }
                if (!changedTargetTouches.length) {
                    return;
                }
                return [
                    // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                    uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", true),
                    changedTargetTouches
                ];
            }
            var DEDUP_TIMEOUT = 2500;
            var DEDUP_DISTANCE = 25;
            function TouchMouseInput() {
                Input2.apply(this, arguments);
                var handler = bindFn(this.handler, this);
                this.touch = new TouchInput(this.manager, handler);
                this.mouse = new MouseInput(this.manager, handler);
                this.primaryTouch = null;
                this.lastTouches = [];
            }
            inherit(TouchMouseInput, Input2, {
                /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */ handler: function TMEhandler(manager, inputEvent, inputData) {
                    var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH, isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                    if (isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents) {
                        return;
                    }
                    if (isTouch) {
                        recordTouches.call(this, inputEvent, inputData);
                    } else if (isMouse && isSyntheticEvent.call(this, inputData)) {
                        return;
                    }
                    this.callback(manager, inputEvent, inputData);
                },
                /**
         * remove the event listeners
         */ destroy: function destroy() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            function recordTouches(eventType, eventData) {
                if (eventType & INPUT_START) {
                    this.primaryTouch = eventData.changedPointers[0].identifier;
                    setLastTouch.call(this, eventData);
                } else if (eventType & (INPUT_END | INPUT_CANCEL)) {
                    setLastTouch.call(this, eventData);
                }
            }
            function setLastTouch(eventData) {
                var touch = eventData.changedPointers[0];
                if (touch.identifier === this.primaryTouch) {
                    var lastTouch = {
                        x: touch.clientX,
                        y: touch.clientY
                    };
                    this.lastTouches.push(lastTouch);
                    var lts = this.lastTouches;
                    var removeLastTouch = function() {
                        var i2 = lts.indexOf(lastTouch);
                        if (i2 > -1) {
                            lts.splice(i2, 1);
                        }
                    };
                    setTimeout(removeLastTouch, DEDUP_TIMEOUT);
                }
            }
            function isSyntheticEvent(eventData) {
                var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY;
                for(var i2 = 0; i2 < this.lastTouches.length; i2++){
                    var t = this.lastTouches[i2];
                    var dx = Math.abs(x - t.x), dy = Math.abs(y - t.y);
                    if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) {
                        return true;
                    }
                }
                return false;
            }
            var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction");
            var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined2;
            var TOUCH_ACTION_COMPUTE = "compute";
            var TOUCH_ACTION_AUTO = "auto";
            var TOUCH_ACTION_MANIPULATION = "manipulation";
            var TOUCH_ACTION_NONE = "none";
            var TOUCH_ACTION_PAN_X = "pan-x";
            var TOUCH_ACTION_PAN_Y = "pan-y";
            var TOUCH_ACTION_MAP = getTouchActionProps();
            function TouchAction(manager, value) {
                this.manager = manager;
                this.set(value);
            }
            TouchAction.prototype = {
                /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */ set: function(value) {
                    if (value == TOUCH_ACTION_COMPUTE) {
                        value = this.compute();
                    }
                    if (NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value]) {
                        this.manager.element.style[PREFIXED_TOUCH_ACTION] = value;
                    }
                    this.actions = value.toLowerCase().trim();
                },
                /**
         * just re-set the touchAction value
         */ update: function() {
                    this.set(this.manager.options.touchAction);
                },
                /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */ compute: function() {
                    var actions = [];
                    each(this.manager.recognizers, function(recognizer) {
                        if (boolOrFn(recognizer.options.enable, [
                            recognizer
                        ])) {
                            actions = actions.concat(recognizer.getTouchAction());
                        }
                    });
                    return cleanTouchActions(actions.join(" "));
                },
                /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */ preventDefaults: function(input) {
                    var srcEvent = input.srcEvent;
                    var direction = input.offsetDirection;
                    if (this.manager.session.prevented) {
                        srcEvent.preventDefault();
                        return;
                    }
                    var actions = this.actions;
                    var hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE];
                    var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y];
                    var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
                    if (hasNone) {
                        var isTapPointer = input.pointers.length === 1;
                        var isTapMovement = input.distance < 2;
                        var isTapTouchTime = input.deltaTime < 250;
                        if (isTapPointer && isTapMovement && isTapTouchTime) {
                            return;
                        }
                    }
                    if (hasPanX && hasPanY) {
                        return;
                    }
                    if (hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL) {
                        return this.preventSrc(srcEvent);
                    }
                },
                /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */ preventSrc: function(srcEvent) {
                    this.manager.session.prevented = true;
                    srcEvent.preventDefault();
                }
            };
            function cleanTouchActions(actions) {
                if (inStr(actions, TOUCH_ACTION_NONE)) {
                    return TOUCH_ACTION_NONE;
                }
                var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X);
                var hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
                if (hasPanX && hasPanY) {
                    return TOUCH_ACTION_NONE;
                }
                if (hasPanX || hasPanY) {
                    return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
                }
                if (inStr(actions, TOUCH_ACTION_MANIPULATION)) {
                    return TOUCH_ACTION_MANIPULATION;
                }
                return TOUCH_ACTION_AUTO;
            }
            function getTouchActionProps() {
                if (!NATIVE_TOUCH_ACTION) {
                    return false;
                }
                var touchMap = {};
                var cssSupports = window2.CSS && window2.CSS.supports;
                [
                    "auto",
                    "manipulation",
                    "pan-y",
                    "pan-x",
                    "pan-x pan-y",
                    "none"
                ].forEach(function(val) {
                    touchMap[val] = cssSupports ? window2.CSS.supports("touch-action", val) : true;
                });
                return touchMap;
            }
            var STATE_POSSIBLE = 1;
            var STATE_BEGAN = 2;
            var STATE_CHANGED = 4;
            var STATE_ENDED = 8;
            var STATE_RECOGNIZED = STATE_ENDED;
            var STATE_CANCELLED = 16;
            var STATE_FAILED = 32;
            function Recognizer(options3) {
                this.options = assign({}, this.defaults, options3 || {});
                this.id = uniqueId();
                this.manager = null;
                this.options.enable = ifUndefined(this.options.enable, true);
                this.state = STATE_POSSIBLE;
                this.simultaneous = {};
                this.requireFail = [];
            }
            Recognizer.prototype = {
                /**
         * @virtual
         * @type {Object}
         */ defaults: {},
                /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */ set: function(options3) {
                    assign(this.options, options3);
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */ recognizeWith: function(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) {
                        return this;
                    }
                    var simultaneous = this.simultaneous;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (!simultaneous[otherRecognizer.id]) {
                        simultaneous[otherRecognizer.id] = otherRecognizer;
                        otherRecognizer.recognizeWith(this);
                    }
                    return this;
                },
                /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */ dropRecognizeWith: function(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, "dropRecognizeWith", this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    delete this.simultaneous[otherRecognizer.id];
                    return this;
                },
                /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */ requireFailure: function(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, "requireFailure", this)) {
                        return this;
                    }
                    var requireFail = this.requireFail;
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    if (inArray(requireFail, otherRecognizer) === -1) {
                        requireFail.push(otherRecognizer);
                        otherRecognizer.requireFailure(this);
                    }
                    return this;
                },
                /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */ dropRequireFailure: function(otherRecognizer) {
                    if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) {
                        return this;
                    }
                    otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                    var index = inArray(this.requireFail, otherRecognizer);
                    if (index > -1) {
                        this.requireFail.splice(index, 1);
                    }
                    return this;
                },
                /**
         * has require failures boolean
         * @returns {boolean}
         */ hasRequireFailures: function() {
                    return this.requireFail.length > 0;
                },
                /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */ canRecognizeWith: function(otherRecognizer) {
                    return !!this.simultaneous[otherRecognizer.id];
                },
                /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */ emit: function(input) {
                    var self2 = this;
                    var state = this.state;
                    function emit(event2) {
                        self2.manager.emit(event2, input);
                    }
                    if (state < STATE_ENDED) {
                        emit(self2.options.event + stateStr(state));
                    }
                    emit(self2.options.event);
                    if (input.additionalEvent) {
                        emit(input.additionalEvent);
                    }
                    if (state >= STATE_ENDED) {
                        emit(self2.options.event + stateStr(state));
                    }
                },
                /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */ tryEmit: function(input) {
                    if (this.canEmit()) {
                        return this.emit(input);
                    }
                    this.state = STATE_FAILED;
                },
                /**
         * can we emit?
         * @returns {boolean}
         */ canEmit: function() {
                    var i2 = 0;
                    while(i2 < this.requireFail.length){
                        if (!(this.requireFail[i2].state & (STATE_FAILED | STATE_POSSIBLE))) {
                            return false;
                        }
                        i2++;
                    }
                    return true;
                },
                /**
         * update the recognizer
         * @param {Object} inputData
         */ recognize: function(inputData) {
                    var inputDataClone = assign({}, inputData);
                    if (!boolOrFn(this.options.enable, [
                        this,
                        inputDataClone
                    ])) {
                        this.reset();
                        this.state = STATE_FAILED;
                        return;
                    }
                    if (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED)) {
                        this.state = STATE_POSSIBLE;
                    }
                    this.state = this.process(inputDataClone);
                    if (this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED)) {
                        this.tryEmit(inputDataClone);
                    }
                },
                /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */ process: function(inputData) {},
                // jshint ignore:line
                /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */ getTouchAction: function() {},
                /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */ reset: function() {}
            };
            function stateStr(state) {
                if (state & STATE_CANCELLED) {
                    return "cancel";
                } else if (state & STATE_ENDED) {
                    return "end";
                } else if (state & STATE_CHANGED) {
                    return "move";
                } else if (state & STATE_BEGAN) {
                    return "start";
                }
                return "";
            }
            function directionStr(direction) {
                if (direction == DIRECTION_DOWN) {
                    return "down";
                } else if (direction == DIRECTION_UP) {
                    return "up";
                } else if (direction == DIRECTION_LEFT) {
                    return "left";
                } else if (direction == DIRECTION_RIGHT) {
                    return "right";
                }
                return "";
            }
            function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
                var manager = recognizer.manager;
                if (manager) {
                    return manager.get(otherRecognizer);
                }
                return otherRecognizer;
            }
            function AttrRecognizer() {
                Recognizer.apply(this, arguments);
            }
            inherit(AttrRecognizer, Recognizer, {
                /**
         * @namespace
         * @memberof AttrRecognizer
         */ defaults: {
                    /**
           * @type {Number}
           * @default 1
           */ pointers: 1
                },
                /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */ attrTest: function(input) {
                    var optionPointers = this.options.pointers;
                    return optionPointers === 0 || input.pointers.length === optionPointers;
                },
                /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */ process: function(input) {
                    var state = this.state;
                    var eventType = input.eventType;
                    var isRecognized = state & (STATE_BEGAN | STATE_CHANGED);
                    var isValid = this.attrTest(input);
                    if (isRecognized && (eventType & INPUT_CANCEL || !isValid)) {
                        return state | STATE_CANCELLED;
                    } else if (isRecognized || isValid) {
                        if (eventType & INPUT_END) {
                            return state | STATE_ENDED;
                        } else if (!(state & STATE_BEGAN)) {
                            return STATE_BEGAN;
                        }
                        return state | STATE_CHANGED;
                    }
                    return STATE_FAILED;
                }
            });
            function PanRecognizer() {
                AttrRecognizer.apply(this, arguments);
                this.pX = null;
                this.pY = null;
            }
            inherit(PanRecognizer, AttrRecognizer, {
                /**
         * @namespace
         * @memberof PanRecognizer
         */ defaults: {
                    event: "pan",
                    threshold: 10,
                    pointers: 1,
                    direction: DIRECTION_ALL
                },
                getTouchAction: function() {
                    var direction = this.options.direction;
                    var actions = [];
                    if (direction & DIRECTION_HORIZONTAL) {
                        actions.push(TOUCH_ACTION_PAN_Y);
                    }
                    if (direction & DIRECTION_VERTICAL) {
                        actions.push(TOUCH_ACTION_PAN_X);
                    }
                    return actions;
                },
                directionTest: function(input) {
                    var options3 = this.options;
                    var hasMoved = true;
                    var distance = input.distance;
                    var direction = input.direction;
                    var x = input.deltaX;
                    var y = input.deltaY;
                    if (!(direction & options3.direction)) {
                        if (options3.direction & DIRECTION_HORIZONTAL) {
                            direction = x === 0 ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
                            hasMoved = x != this.pX;
                            distance = Math.abs(input.deltaX);
                        } else {
                            direction = y === 0 ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN;
                            hasMoved = y != this.pY;
                            distance = Math.abs(input.deltaY);
                        }
                    }
                    input.direction = direction;
                    return hasMoved && distance > options3.threshold && direction & options3.direction;
                },
                attrTest: function(input) {
                    return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input));
                },
                emit: function(input) {
                    this.pX = input.deltaX;
                    this.pY = input.deltaY;
                    var direction = directionStr(input.direction);
                    if (direction) {
                        input.additionalEvent = this.options.event + direction;
                    }
                    this._super.emit.call(this, input);
                }
            });
            function PinchRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }
            inherit(PinchRecognizer, AttrRecognizer, {
                /**
         * @namespace
         * @memberof PinchRecognizer
         */ defaults: {
                    event: "pinch",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [
                        TOUCH_ACTION_NONE
                    ];
                },
                attrTest: function(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN);
                },
                emit: function(input) {
                    if (input.scale !== 1) {
                        var inOut = input.scale < 1 ? "in" : "out";
                        input.additionalEvent = this.options.event + inOut;
                    }
                    this._super.emit.call(this, input);
                }
            });
            function PressRecognizer() {
                Recognizer.apply(this, arguments);
                this._timer = null;
                this._input = null;
            }
            inherit(PressRecognizer, Recognizer, {
                /**
         * @namespace
         * @memberof PressRecognizer
         */ defaults: {
                    event: "press",
                    pointers: 1,
                    time: 251,
                    // minimal time of the pointer to be pressed
                    threshold: 9
                },
                getTouchAction: function() {
                    return [
                        TOUCH_ACTION_AUTO
                    ];
                },
                process: function(input) {
                    var options3 = this.options;
                    var validPointers = input.pointers.length === options3.pointers;
                    var validMovement = input.distance < options3.threshold;
                    var validTime = input.deltaTime > options3.time;
                    this._input = input;
                    if (!validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) {
                        this.reset();
                    } else if (input.eventType & INPUT_START) {
                        this.reset();
                        this._timer = setTimeoutContext(function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options3.time, this);
                    } else if (input.eventType & INPUT_END) {
                        return STATE_RECOGNIZED;
                    }
                    return STATE_FAILED;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function(input) {
                    if (this.state !== STATE_RECOGNIZED) {
                        return;
                    }
                    if (input && input.eventType & INPUT_END) {
                        this.manager.emit(this.options.event + "up", input);
                    } else {
                        this._input.timeStamp = now3();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });
            function RotateRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }
            inherit(RotateRecognizer, AttrRecognizer, {
                /**
         * @namespace
         * @memberof RotateRecognizer
         */ defaults: {
                    event: "rotate",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [
                        TOUCH_ACTION_NONE
                    ];
                },
                attrTest: function(input) {
                    return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN);
                }
            });
            function SwipeRecognizer() {
                AttrRecognizer.apply(this, arguments);
            }
            inherit(SwipeRecognizer, AttrRecognizer, {
                /**
         * @namespace
         * @memberof SwipeRecognizer
         */ defaults: {
                    event: "swipe",
                    threshold: 10,
                    velocity: 0.3,
                    direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                    pointers: 1
                },
                getTouchAction: function() {
                    return PanRecognizer.prototype.getTouchAction.call(this);
                },
                attrTest: function(input) {
                    var direction = this.options.direction;
                    var velocity;
                    if (direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL)) {
                        velocity = input.overallVelocity;
                    } else if (direction & DIRECTION_HORIZONTAL) {
                        velocity = input.overallVelocityX;
                    } else if (direction & DIRECTION_VERTICAL) {
                        velocity = input.overallVelocityY;
                    }
                    return this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END;
                },
                emit: function(input) {
                    var direction = directionStr(input.offsetDirection);
                    if (direction) {
                        this.manager.emit(this.options.event + direction, input);
                    }
                    this.manager.emit(this.options.event, input);
                }
            });
            function TapRecognizer() {
                Recognizer.apply(this, arguments);
                this.pTime = false;
                this.pCenter = false;
                this._timer = null;
                this._input = null;
                this.count = 0;
            }
            inherit(TapRecognizer, Recognizer, {
                /**
         * @namespace
         * @memberof PinchRecognizer
         */ defaults: {
                    event: "tap",
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    // max time between the multi-tap taps
                    time: 250,
                    // max time of the pointer to be down (like finger on the screen)
                    threshold: 9,
                    // a minimal movement is ok, but keep it low
                    posThreshold: 10
                },
                getTouchAction: function() {
                    return [
                        TOUCH_ACTION_MANIPULATION
                    ];
                },
                process: function(input) {
                    var options3 = this.options;
                    var validPointers = input.pointers.length === options3.pointers;
                    var validMovement = input.distance < options3.threshold;
                    var validTouchTime = input.deltaTime < options3.time;
                    this.reset();
                    if (input.eventType & INPUT_START && this.count === 0) {
                        return this.failTimeout();
                    }
                    if (validMovement && validTouchTime && validPointers) {
                        if (input.eventType != INPUT_END) {
                            return this.failTimeout();
                        }
                        var validInterval = this.pTime ? input.timeStamp - this.pTime < options3.interval : true;
                        var validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options3.posThreshold;
                        this.pTime = input.timeStamp;
                        this.pCenter = input.center;
                        if (!validMultiTap || !validInterval) {
                            this.count = 1;
                        } else {
                            this.count += 1;
                        }
                        this._input = input;
                        var tapCount = this.count % options3.taps;
                        if (tapCount === 0) {
                            if (!this.hasRequireFailures()) {
                                return STATE_RECOGNIZED;
                            } else {
                                this._timer = setTimeoutContext(function() {
                                    this.state = STATE_RECOGNIZED;
                                    this.tryEmit();
                                }, options3.interval, this);
                                return STATE_BEGAN;
                            }
                        }
                    }
                    return STATE_FAILED;
                },
                failTimeout: function() {
                    this._timer = setTimeoutContext(function() {
                        this.state = STATE_FAILED;
                    }, this.options.interval, this);
                    return STATE_FAILED;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function() {
                    if (this.state == STATE_RECOGNIZED) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });
            function Hammer2(element, options3) {
                options3 = options3 || {};
                options3.recognizers = ifUndefined(options3.recognizers, Hammer2.defaults.preset);
                return new Manager(element, options3);
            }
            Hammer2.VERSION = "2.0.7";
            Hammer2.defaults = {
                /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */ domEvents: false,
                /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */ touchAction: TOUCH_ACTION_COMPUTE,
                /**
         * @type {Boolean}
         * @default true
         */ enable: true,
                /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */ inputTarget: null,
                /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */ inputClass: null,
                /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */ preset: [
                    // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                    [
                        RotateRecognizer,
                        {
                            enable: false
                        }
                    ],
                    [
                        PinchRecognizer,
                        {
                            enable: false
                        },
                        [
                            "rotate"
                        ]
                    ],
                    [
                        SwipeRecognizer,
                        {
                            direction: DIRECTION_HORIZONTAL
                        }
                    ],
                    [
                        PanRecognizer,
                        {
                            direction: DIRECTION_HORIZONTAL
                        },
                        [
                            "swipe"
                        ]
                    ],
                    [
                        TapRecognizer
                    ],
                    [
                        TapRecognizer,
                        {
                            event: "doubletap",
                            taps: 2
                        },
                        [
                            "tap"
                        ]
                    ],
                    [
                        PressRecognizer
                    ]
                ],
                /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */ cssProps: {
                    /**
           * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */ userSelect: "none",
                    /**
           * Disable the Windows Phone grippers when pressing an element.
           * @type {String}
           * @default 'none'
           */ touchSelect: "none",
                    /**
           * Disables the default callout shown when you touch and hold a touch target.
           * On iOS, when you touch and hold a touch target such as a link, Safari displays
           * a callout containing information about the link. This property allows you to disable that callout.
           * @type {String}
           * @default 'none'
           */ touchCallout: "none",
                    /**
           * Specifies whether zooming is enabled. Used by IE10>
           * @type {String}
           * @default 'none'
           */ contentZooming: "none",
                    /**
           * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
           * @type {String}
           * @default 'none'
           */ userDrag: "none",
                    /**
           * Overrides the highlight color shown when the user taps a link or a JavaScript
           * clickable element in iOS. This property obeys the alpha value, if specified.
           * @type {String}
           * @default 'rgba(0,0,0,0)'
           */ tapHighlightColor: "rgba(0,0,0,0)"
                }
            };
            var STOP = 1;
            var FORCED_STOP = 2;
            function Manager(element, options3) {
                this.options = assign({}, Hammer2.defaults, options3 || {});
                this.options.inputTarget = this.options.inputTarget || element;
                this.handlers = {};
                this.session = {};
                this.recognizers = [];
                this.oldCssProps = {};
                this.element = element;
                this.input = createInputInstance(this);
                this.touchAction = new TouchAction(this, this.options.touchAction);
                toggleCssProps(this, true);
                each(this.options.recognizers, function(item) {
                    var recognizer = this.add(new item[0](item[1]));
                    item[2] && recognizer.recognizeWith(item[2]);
                    item[3] && recognizer.requireFailure(item[3]);
                }, this);
            }
            Manager.prototype = {
                /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */ set: function(options3) {
                    assign(this.options, options3);
                    if (options3.touchAction) {
                        this.touchAction.update();
                    }
                    if (options3.inputTarget) {
                        this.input.destroy();
                        this.input.target = options3.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */ stop: function(force) {
                    this.session.stopped = force ? FORCED_STOP : STOP;
                },
                /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */ recognize: function(inputData) {
                    var session = this.session;
                    if (session.stopped) {
                        return;
                    }
                    this.touchAction.preventDefaults(inputData);
                    var recognizer;
                    var recognizers = this.recognizers;
                    var curRecognizer = session.curRecognizer;
                    if (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) {
                        curRecognizer = session.curRecognizer = null;
                    }
                    var i2 = 0;
                    while(i2 < recognizers.length){
                        recognizer = recognizers[i2];
                        if (session.stopped !== FORCED_STOP && // 1
                        (!curRecognizer || recognizer == curRecognizer || // 2
                        recognizer.canRecognizeWith(curRecognizer))) {
                            recognizer.recognize(inputData);
                        } else {
                            recognizer.reset();
                        }
                        if (!curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED)) {
                            curRecognizer = session.curRecognizer = recognizer;
                        }
                        i2++;
                    }
                },
                /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */ get: function(recognizer) {
                    if (recognizer instanceof Recognizer) {
                        return recognizer;
                    }
                    var recognizers = this.recognizers;
                    for(var i2 = 0; i2 < recognizers.length; i2++){
                        if (recognizers[i2].options.event == recognizer) {
                            return recognizers[i2];
                        }
                    }
                    return null;
                },
                /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */ add: function(recognizer) {
                    if (invokeArrayArg(recognizer, "add", this)) {
                        return this;
                    }
                    var existing = this.get(recognizer.options.event);
                    if (existing) {
                        this.remove(existing);
                    }
                    this.recognizers.push(recognizer);
                    recognizer.manager = this;
                    this.touchAction.update();
                    return recognizer;
                },
                /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */ remove: function(recognizer) {
                    if (invokeArrayArg(recognizer, "remove", this)) {
                        return this;
                    }
                    recognizer = this.get(recognizer);
                    if (recognizer) {
                        var recognizers = this.recognizers;
                        var index = inArray(recognizers, recognizer);
                        if (index !== -1) {
                            recognizers.splice(index, 1);
                            this.touchAction.update();
                        }
                    }
                    return this;
                },
                /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */ on: function(events2, handler) {
                    if (events2 === undefined2) {
                        return;
                    }
                    if (handler === undefined2) {
                        return;
                    }
                    var handlers = this.handlers;
                    each(splitStr(events2), function(event2) {
                        handlers[event2] = handlers[event2] || [];
                        handlers[event2].push(handler);
                    });
                    return this;
                },
                /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */ off: function(events2, handler) {
                    if (events2 === undefined2) {
                        return;
                    }
                    var handlers = this.handlers;
                    each(splitStr(events2), function(event2) {
                        if (!handler) {
                            delete handlers[event2];
                        } else {
                            handlers[event2] && handlers[event2].splice(inArray(handlers[event2], handler), 1);
                        }
                    });
                    return this;
                },
                /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */ emit: function(event2, data) {
                    if (this.options.domEvents) {
                        triggerDomEvent(event2, data);
                    }
                    var handlers = this.handlers[event2] && this.handlers[event2].slice();
                    if (!handlers || !handlers.length) {
                        return;
                    }
                    data.type = event2;
                    data.preventDefault = function() {
                        data.srcEvent.preventDefault();
                    };
                    var i2 = 0;
                    while(i2 < handlers.length){
                        handlers[i2](data);
                        i2++;
                    }
                },
                /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */ destroy: function() {
                    this.element && toggleCssProps(this, false);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };
            function toggleCssProps(manager, add) {
                var element = manager.element;
                if (!element.style) {
                    return;
                }
                var prop;
                each(manager.options.cssProps, function(value, name) {
                    prop = prefixed(element.style, name);
                    if (add) {
                        manager.oldCssProps[prop] = element.style[prop];
                        element.style[prop] = value;
                    } else {
                        element.style[prop] = manager.oldCssProps[prop] || "";
                    }
                });
                if (!add) {
                    manager.oldCssProps = {};
                }
            }
            function triggerDomEvent(event2, data) {
                var gestureEvent = document2.createEvent("Event");
                gestureEvent.initEvent(event2, true, true);
                gestureEvent.gesture = data;
                data.target.dispatchEvent(gestureEvent);
            }
            assign(Hammer2, {
                INPUT_START,
                INPUT_MOVE,
                INPUT_END,
                INPUT_CANCEL,
                STATE_POSSIBLE,
                STATE_BEGAN,
                STATE_CHANGED,
                STATE_ENDED,
                STATE_RECOGNIZED,
                STATE_CANCELLED,
                STATE_FAILED,
                DIRECTION_NONE,
                DIRECTION_LEFT,
                DIRECTION_RIGHT,
                DIRECTION_UP,
                DIRECTION_DOWN,
                DIRECTION_HORIZONTAL,
                DIRECTION_VERTICAL,
                DIRECTION_ALL,
                Manager,
                Input: Input2,
                TouchAction,
                TouchInput,
                MouseInput,
                PointerEventInput,
                TouchMouseInput,
                SingleTouchInput,
                Recognizer,
                AttrRecognizer,
                Tap: TapRecognizer,
                Pan: PanRecognizer,
                Swipe: SwipeRecognizer,
                Pinch: PinchRecognizer,
                Rotate: RotateRecognizer,
                Press: PressRecognizer,
                on: addEventListeners,
                off: removeEventListeners,
                each,
                merge,
                extend: extend3,
                assign,
                inherit,
                bindFn,
                prefixed
            });
            var freeGlobal2 = typeof window2 !== "undefined" ? window2 : typeof self !== "undefined" ? self : {};
            freeGlobal2.Hammer = Hammer2;
            if (false) // removed by dead control flow
{} else if (typeof module2 != "undefined" && module2.exports) {
                module2.exports = Hammer2;
            } else {
                window2[exportName] = Hammer2;
            }
        })(window, document, "Hammer");
    }
});
// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(n) {
        for(var e = 1; e < arguments.length; e++){
            var t = arguments[e];
            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
    }, _extends.apply(null, arguments);
}
// node_modules/history/index.js
var Action;
(function(Action2) {
    Action2["Pop"] = "POP";
    Action2["Push"] = "PUSH";
    Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var readOnly =  true ? function(obj) {
    return Object.freeze(obj);
} : 0;
function warning(cond, message) {
    if (!cond) {
        if (typeof console !== "undefined") console.warn(message);
        try {
            throw new Error(message);
        } catch (e) {}
    }
}
var BeforeUnloadEventType = "beforeunload";
var HashChangeEventType = "hashchange";
var PopStateEventType = "popstate";
function createBrowserHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options = options3, _options$window = _options.window, window2 = _options$window === void 0 ? document.defaultView : _options$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _window$location = window2.location, pathname = _window$location.pathname, search = _window$location.search, hash = _window$location.hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation = getIndexAndLocation(), nextIndex = _getIndexAndLocation[0], nextLocation = _getIndexAndLocation[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                     true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
                    // detail and link to it here so people can understand better what
                    // is going on and how to avoid it.
                    "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    var action = Action.Pop;
    var _getIndexAndLocation2 = getIndexAndLocation(), index = _getIndexAndLocation2[0], location2 = _getIndexAndLocation2[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index == null) {
        index = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index
        }), "");
    }
    function createHref(to) {
        return typeof to === "string" ? to : createPath(to);
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index2) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index2
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation3 = getIndexAndLocation();
        index = _getIndexAndLocation3[0];
        location2 = _getIndexAndLocation3[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr[0], url = _getHistoryStateAndUr[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr2[0], url = _getHistoryStateAndUr2[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function createHashHistory(options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _options2 = options3, _options2$window = _options2.window, window2 = _options2$window === void 0 ? document.defaultView : _options2$window;
    var globalHistory = window2.history;
    function getIndexAndLocation() {
        var _parsePath = parsePath(window2.location.hash.substr(1)), _parsePath$pathname = _parsePath.pathname, pathname = _parsePath$pathname === void 0 ? "/" : _parsePath$pathname, _parsePath$search = _parsePath.search, search = _parsePath$search === void 0 ? "" : _parsePath$search, _parsePath$hash = _parsePath.hash, hash = _parsePath$hash === void 0 ? "" : _parsePath$hash;
        var state = globalHistory.state || {};
        return [
            state.idx,
            readOnly({
                pathname,
                search,
                hash,
                state: state.usr || null,
                key: state.key || "default"
            })
        ];
    }
    var blockedPopTx = null;
    function handlePop() {
        if (blockedPopTx) {
            blockers.call(blockedPopTx);
            blockedPopTx = null;
        } else {
            var nextAction = Action.Pop;
            var _getIndexAndLocation4 = getIndexAndLocation(), nextIndex = _getIndexAndLocation4[0], nextLocation = _getIndexAndLocation4[1];
            if (blockers.length) {
                if (nextIndex != null) {
                    var delta = index - nextIndex;
                    if (delta) {
                        blockedPopTx = {
                            action: nextAction,
                            location: nextLocation,
                            retry: function retry() {
                                go(delta * -1);
                            }
                        };
                        go(delta);
                    }
                } else {
                     true ? warning(false, // TODO: Write up a doc that explains our blocking strategy in
                    // detail and link to it here so people can understand better
                    // what is going on and how to avoid it.
                    "You are trying to block a POP navigation to a location that was not created by the history library. The block will fail silently in production, but in general you should do all navigation with the history library (instead of using window.history.pushState directly) to avoid this situation.") : 0;
                }
            } else {
                applyTx(nextAction);
            }
        }
    }
    window2.addEventListener(PopStateEventType, handlePop);
    window2.addEventListener(HashChangeEventType, function() {
        var _getIndexAndLocation5 = getIndexAndLocation(), nextLocation = _getIndexAndLocation5[1];
        if (createPath(nextLocation) !== createPath(location2)) {
            handlePop();
        }
    });
    var action = Action.Pop;
    var _getIndexAndLocation6 = getIndexAndLocation(), index = _getIndexAndLocation6[0], location2 = _getIndexAndLocation6[1];
    var listeners = createEvents();
    var blockers = createEvents();
    if (index == null) {
        index = 0;
        globalHistory.replaceState(_extends({}, globalHistory.state, {
            idx: index
        }), "");
    }
    function getBaseHref() {
        var base = document.querySelector("base");
        var href = "";
        if (base && base.getAttribute("href")) {
            var url = window2.location.href;
            var hashIndex = url.indexOf("#");
            href = hashIndex === -1 ? url : url.slice(0, hashIndex);
        }
        return href;
    }
    function createHref(to) {
        return getBaseHref() + "#" + (typeof to === "string" ? to : createPath(to));
    }
    function getNextLocation(to, state) {
        if (state === void 0) {
            state = null;
        }
        return readOnly(_extends({
            pathname: location2.pathname,
            hash: "",
            search: ""
        }, typeof to === "string" ? parsePath(to) : to, {
            state,
            key: createKey()
        }));
    }
    function getHistoryStateAndUrl(nextLocation, index2) {
        return [
            {
                usr: nextLocation.state,
                key: nextLocation.key,
                idx: index2
            },
            createHref(nextLocation)
        ];
    }
    function allowTx(action2, location3, retry) {
        return !blockers.length || (blockers.call({
            action: action2,
            location: location3,
            retry
        }), false);
    }
    function applyTx(nextAction) {
        action = nextAction;
        var _getIndexAndLocation7 = getIndexAndLocation();
        index = _getIndexAndLocation7[0];
        location2 = _getIndexAndLocation7[1];
        listeners.call({
            action,
            location: location2
        });
    }
    function push(to, state) {
        var nextAction = Action.Push;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            push(to, state);
        }
         true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.push(" + JSON.stringify(to) + ")") : 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1), historyState = _getHistoryStateAndUr3[0], url = _getHistoryStateAndUr3[1];
            try {
                globalHistory.pushState(historyState, "", url);
            } catch (error) {
                window2.location.assign(url);
            }
            applyTx(nextAction);
        }
    }
    function replace(to, state) {
        var nextAction = Action.Replace;
        var nextLocation = getNextLocation(to, state);
        function retry() {
            replace(to, state);
        }
         true ? warning(nextLocation.pathname.charAt(0) === "/", "Relative pathnames are not supported in hash history.replace(" + JSON.stringify(to) + ")") : 0;
        if (allowTx(nextAction, nextLocation, retry)) {
            var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index), historyState = _getHistoryStateAndUr4[0], url = _getHistoryStateAndUr4[1];
            globalHistory.replaceState(historyState, "", url);
            applyTx(nextAction);
        }
    }
    function go(delta) {
        globalHistory.go(delta);
    }
    var history2 = {
        get action () {
            return action;
        },
        get location () {
            return location2;
        },
        createHref,
        push,
        replace,
        go,
        back: function back() {
            go(-1);
        },
        forward: function forward() {
            go(1);
        },
        listen: function listen(listener) {
            return listeners.push(listener);
        },
        block: function block(blocker) {
            var unblock = blockers.push(blocker);
            if (blockers.length === 1) {
                window2.addEventListener(BeforeUnloadEventType, promptBeforeUnload);
            }
            return function() {
                unblock();
                if (!blockers.length) {
                    window2.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);
                }
            };
        }
    };
    return history2;
}
function promptBeforeUnload(event2) {
    event2.preventDefault();
    event2.returnValue = "";
}
function createEvents() {
    var handlers = [];
    return {
        get length () {
            return handlers.length;
        },
        push: function push(fn) {
            handlers.push(fn);
            return function() {
                handlers = handlers.filter(function(handler) {
                    return handler !== fn;
                });
            };
        },
        call: function call(arg) {
            handlers.forEach(function(fn) {
                return fn && fn(arg);
            });
        }
    };
}
function createKey() {
    return Math.random().toString(36).substr(2, 8);
}
function createPath(_ref) {
    var _ref$pathname = _ref.pathname, pathname = _ref$pathname === void 0 ? "/" : _ref$pathname, _ref$search = _ref.search, search = _ref$search === void 0 ? "" : _ref$search, _ref$hash = _ref.hash, hash = _ref$hash === void 0 ? "" : _ref$hash;
    if (search && search !== "?") pathname += search.charAt(0) === "?" ? search : "?" + search;
    if (hash && hash !== "#") pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
    return pathname;
}
function parsePath(path) {
    var parsedPath = {};
    if (path) {
        var hashIndex = path.indexOf("#");
        if (hashIndex >= 0) {
            parsedPath.hash = path.substr(hashIndex);
            path = path.substr(0, hashIndex);
        }
        var searchIndex = path.indexOf("?");
        if (searchIndex >= 0) {
            parsedPath.search = path.substr(searchIndex);
            path = path.substr(0, searchIndex);
        }
        if (path) {
            parsedPath.pathname = path;
        }
    }
    return parsedPath;
}
// node_modules/@stencil/core/internal/app-data/index.js
var BUILD = {
    allRenderFn: false,
    cmpDidLoad: true,
    cmpDidUnload: false,
    cmpDidUpdate: true,
    cmpDidRender: true,
    cmpWillLoad: true,
    cmpWillUpdate: true,
    cmpWillRender: true,
    connectedCallback: true,
    disconnectedCallback: true,
    element: true,
    event: true,
    hasRenderFn: true,
    lifecycle: true,
    hostListener: true,
    hostListenerTargetWindow: true,
    hostListenerTargetDocument: true,
    hostListenerTargetBody: true,
    hostListenerTargetParent: false,
    hostListenerTarget: true,
    member: true,
    method: true,
    mode: true,
    observeAttribute: true,
    prop: true,
    propMutable: true,
    reflect: true,
    scoped: true,
    shadowDom: true,
    slot: true,
    cssAnnotations: true,
    state: true,
    style: true,
    svg: true,
    updatable: true,
    vdomAttribute: true,
    vdomXlink: true,
    vdomClass: true,
    vdomFunctional: true,
    vdomKey: true,
    vdomListener: true,
    vdomRef: true,
    vdomPropOrAttr: true,
    vdomRender: true,
    vdomStyle: true,
    vdomText: true,
    watchCallback: true,
    taskQueue: true,
    hotModuleReplacement: false,
    isDebug: false,
    isDev: false,
    isTesting: false,
    hydrateServerSide: false,
    hydrateClientSide: false,
    lifecycleDOMEvents: false,
    lazyLoad: false,
    profile: false,
    slotRelocation: true,
    appendChildSlotFix: false,
    cloneNodeFix: false,
    hydratedAttribute: false,
    hydratedClass: true,
    safari10: false,
    scriptDataOpts: false,
    scopedSlotTextContentFix: false,
    shadowDomShim: false,
    slotChildNodesFix: false,
    invisiblePrehydration: true,
    propBoolean: true,
    propNumber: true,
    propString: true,
    cssVarShim: false,
    constructableCSS: true,
    cmpShouldUpdate: true,
    devTools: false,
    dynamicImportShim: false,
    shadowDelegatesFocus: true,
    initializeNextTick: false,
    asyncLoading: false,
    asyncQueue: false,
    transformTagName: false,
    attachStyles: true
};
var NAMESPACE = /* default */ "app";
// import("./**/*.entry.js*") in node_modules/@stencil/core/internal/client/index.js
var globImport_entry_js = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__glob)({});
// node_modules/@stencil/core/internal/client/index.js
var scopeId;
var contentRef;
var hostTagName;
var customError;
var i = 0;
var useNativeShadowDom = false;
var checkSlotFallbackVisibility = false;
var checkSlotRelocate = false;
var isSvgMode = false;
var renderingRef = null;
var queueCongestion = 0;
var queuePending = false;
var Build = {
    isDev: BUILD.isDev ? true : false,
    isBrowser: true,
    isServer: false,
    isTesting: BUILD.isTesting ? true : false
};
var createTime = (fnName, tagName = "")=>{
    if (BUILD.profile && performance.mark) {
        const key = `st:${fnName}:${tagName}:${i++}`;
        performance.mark(key);
        return ()=>performance.measure(`[Stencil] ${fnName}() <${tagName}>`, key);
    } else {
        return ()=>{
            return;
        };
    }
};
var uniqueTime = (key, measureText)=>{
    if (BUILD.profile && performance.mark) {
        if (performance.getEntriesByName(key, "mark").length === 0) {
            performance.mark(key);
        }
        return ()=>{
            if (performance.getEntriesByName(measureText, "measure").length === 0) {
                performance.measure(measureText, key);
            }
        };
    } else {
        return ()=>{
            return;
        };
    }
};
var CONTENT_REF_ID = "r";
var ORG_LOCATION_ID = "o";
var SLOT_NODE_ID = "s";
var TEXT_NODE_ID = "t";
var HYDRATE_ID = "s-id";
var HYDRATED_STYLE_ID = "sty-id";
var HYDRATE_CHILD_ID = "c-id";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var EMPTY_OBJ = {};
var SVG_NS = "http://www.w3.org/2000/svg";
var HTML_NS = "http://www.w3.org/1999/xhtml";
var isDef = (v)=>v != null;
var isComplexType = (o)=>{
    o = typeof o;
    return o === "object" || o === "function";
};
function queryNonceMetaTagContent(doc3) {
    var _a, _b, _c;
    return (_c = (_b = (_a = doc3.head) === null || _a === void 0 ? void 0 : _a.querySelector('meta[name="csp-nonce"]')) === null || _b === void 0 ? void 0 : _b.getAttribute("content")) !== null && _c !== void 0 ? _c : void 0;
}
var h = (nodeName, vnodeData, ...children)=>{
    let child = null;
    let key = null;
    let slotName = null;
    let simple = false;
    let lastSimple = false;
    const vNodeChildren = [];
    const walk = (c)=>{
        for(let i2 = 0; i2 < c.length; i2++){
            child = c[i2];
            if (Array.isArray(child)) {
                walk(child);
            } else if (child != null && typeof child !== "boolean") {
                if (simple = typeof nodeName !== "function" && !isComplexType(child)) {
                    child = String(child);
                } else if (BUILD.isDev && typeof nodeName !== "function" && child.$flags$ === void 0) {
                    consoleDevError(`vNode passed as children has unexpected type.
Make sure it's using the correct h() function.
Empty objects can also be the cause, look for JSX comments that became objects.`);
                }
                if (simple && lastSimple) {
                    vNodeChildren[vNodeChildren.length - 1].$text$ += child;
                } else {
                    vNodeChildren.push(simple ? newVNode(null, child) : child);
                }
                lastSimple = simple;
            }
        }
    };
    walk(children);
    if (vnodeData) {
        if (BUILD.isDev && nodeName === "input") {
            validateInputProperties(vnodeData);
        }
        if (BUILD.vdomKey && vnodeData.key) {
            key = vnodeData.key;
        }
        if (BUILD.slotRelocation && vnodeData.name) {
            slotName = vnodeData.name;
        }
        if (BUILD.vdomClass) {
            const classData = vnodeData.className || vnodeData.class;
            if (classData) {
                vnodeData.class = typeof classData !== "object" ? classData : Object.keys(classData).filter((k)=>classData[k]).join(" ");
            }
        }
    }
    if (BUILD.isDev && vNodeChildren.some(isHost)) {
        consoleDevError(`The <Host> must be the single root component. Make sure:
- You are NOT using hostData() and <Host> in the same component.
- <Host> is used once, and it's the single root component of the render() function.`);
    }
    if (BUILD.vdomFunctional && typeof nodeName === "function") {
        return nodeName(vnodeData === null ? {} : vnodeData, vNodeChildren, vdomFnUtils);
    }
    const vnode = newVNode(nodeName, null);
    vnode.$attrs$ = vnodeData;
    if (vNodeChildren.length > 0) {
        vnode.$children$ = vNodeChildren;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = key;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = slotName;
    }
    return vnode;
};
var newVNode = (tag, text)=>{
    const vnode = {
        $flags$: 0,
        $tag$: tag,
        $text$: text,
        $elm$: null,
        $children$: null
    };
    if (BUILD.vdomAttribute) {
        vnode.$attrs$ = null;
    }
    if (BUILD.vdomKey) {
        vnode.$key$ = null;
    }
    if (BUILD.slotRelocation) {
        vnode.$name$ = null;
    }
    return vnode;
};
var Host = {};
var isHost = (node)=>node && node.$tag$ === Host;
var vdomFnUtils = {
    forEach: (children, cb)=>children.map(convertToPublic).forEach(cb),
    map: (children, cb)=>children.map(convertToPublic).map(cb).map(convertToPrivate)
};
var convertToPublic = (node)=>({
        vattrs: node.$attrs$,
        vchildren: node.$children$,
        vkey: node.$key$,
        vname: node.$name$,
        vtag: node.$tag$,
        vtext: node.$text$
    });
var convertToPrivate = (node)=>{
    if (typeof node.vtag === "function") {
        const vnodeData = Object.assign({}, node.vattrs);
        if (node.vkey) {
            vnodeData.key = node.vkey;
        }
        if (node.vname) {
            vnodeData.name = node.vname;
        }
        return h(node.vtag, vnodeData, ...node.vchildren || []);
    }
    const vnode = newVNode(node.vtag, node.vtext);
    vnode.$attrs$ = node.vattrs;
    vnode.$children$ = node.vchildren;
    vnode.$key$ = node.vkey;
    vnode.$name$ = node.vname;
    return vnode;
};
var validateInputProperties = (inputElm)=>{
    const props = Object.keys(inputElm);
    const value = props.indexOf("value");
    if (value === -1) {
        return;
    }
    const typeIndex = props.indexOf("type");
    const minIndex = props.indexOf("min");
    const maxIndex = props.indexOf("max");
    const stepIndex = props.indexOf("step");
    if (value < typeIndex || value < minIndex || value < maxIndex || value < stepIndex) {
        consoleDevWarn(`The "value" prop of <input> should be set after "min", "max", "type" and "step"`);
    }
};
var initializeClientHydrate = (hostElm, tagName, hostId, hostRef)=>{
    const endHydrate = createTime("hydrateClient", tagName);
    const shadowRoot = hostElm.shadowRoot;
    const childRenderNodes = [];
    const slotNodes = [];
    const shadowRootNodes = BUILD.shadowDom && shadowRoot ? [] : null;
    const vnode = hostRef.$vnode$ = newVNode(tagName, null);
    if (!plt.$orgLocNodes$) {
        initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = /* @__PURE__ */ new Map());
    }
    hostElm[HYDRATE_ID] = hostId;
    hostElm.removeAttribute(HYDRATE_ID);
    clientHydrate(vnode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, hostElm, hostId);
    childRenderNodes.map((c)=>{
        const orgLocationId = c.$hostId$ + "." + c.$nodeId$;
        const orgLocationNode = plt.$orgLocNodes$.get(orgLocationId);
        const node = c.$elm$;
        if (orgLocationNode && supportsShadow && orgLocationNode["s-en"] === "") {
            orgLocationNode.parentNode.insertBefore(node, orgLocationNode.nextSibling);
        }
        if (!shadowRoot) {
            node["s-hn"] = tagName;
            if (orgLocationNode) {
                node["s-ol"] = orgLocationNode;
                node["s-ol"]["s-nr"] = node;
            }
        }
        plt.$orgLocNodes$.delete(orgLocationId);
    });
    if (BUILD.shadowDom && shadowRoot) {
        shadowRootNodes.map((shadowRootNode)=>{
            if (shadowRootNode) {
                shadowRoot.appendChild(shadowRootNode);
            }
        });
    }
    endHydrate();
};
var clientHydrate = (parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node, hostId)=>{
    let childNodeType;
    let childIdSplt;
    let childVNode;
    let i2;
    if (node.nodeType === 1) {
        childNodeType = node.getAttribute(HYDRATE_CHILD_ID);
        if (childNodeType) {
            childIdSplt = childNodeType.split(".");
            if (childIdSplt[0] === hostId || childIdSplt[0] === "0") {
                childVNode = {
                    $flags$: 0,
                    $hostId$: childIdSplt[0],
                    $nodeId$: childIdSplt[1],
                    $depth$: childIdSplt[2],
                    $index$: childIdSplt[3],
                    $tag$: node.tagName.toLowerCase(),
                    $elm$: node,
                    $attrs$: null,
                    $children$: null,
                    $key$: null,
                    $name$: null,
                    $text$: null
                };
                childRenderNodes.push(childVNode);
                node.removeAttribute(HYDRATE_CHILD_ID);
                if (!parentVNode.$children$) {
                    parentVNode.$children$ = [];
                }
                parentVNode.$children$[childVNode.$index$] = childVNode;
                parentVNode = childVNode;
                if (shadowRootNodes && childVNode.$depth$ === "0") {
                    shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                }
            }
        }
        for(i2 = node.childNodes.length - 1; i2 >= 0; i2--){
            clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.childNodes[i2], hostId);
        }
        if (node.shadowRoot) {
            for(i2 = node.shadowRoot.childNodes.length - 1; i2 >= 0; i2--){
                clientHydrate(parentVNode, childRenderNodes, slotNodes, shadowRootNodes, hostElm, node.shadowRoot.childNodes[i2], hostId);
            }
        }
    } else if (node.nodeType === 8) {
        childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[1] === hostId || childIdSplt[1] === "0") {
            childNodeType = childIdSplt[0];
            childVNode = {
                $flags$: 0,
                $hostId$: childIdSplt[1],
                $nodeId$: childIdSplt[2],
                $depth$: childIdSplt[3],
                $index$: childIdSplt[4],
                $elm$: node,
                $attrs$: null,
                $children$: null,
                $key$: null,
                $name$: null,
                $tag$: null,
                $text$: null
            };
            if (childNodeType === TEXT_NODE_ID) {
                childVNode.$elm$ = node.nextSibling;
                if (childVNode.$elm$ && childVNode.$elm$.nodeType === 3) {
                    childVNode.$text$ = childVNode.$elm$.textContent;
                    childRenderNodes.push(childVNode);
                    node.remove();
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                    if (shadowRootNodes && childVNode.$depth$ === "0") {
                        shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                    }
                }
            } else if (childVNode.$hostId$ === hostId) {
                if (childNodeType === SLOT_NODE_ID) {
                    childVNode.$tag$ = "slot";
                    if (childIdSplt[5]) {
                        node["s-sn"] = childVNode.$name$ = childIdSplt[5];
                    } else {
                        node["s-sn"] = "";
                    }
                    node["s-sr"] = true;
                    if (BUILD.shadowDom && shadowRootNodes) {
                        childVNode.$elm$ = doc.createElement(childVNode.$tag$);
                        if (childVNode.$name$) {
                            childVNode.$elm$.setAttribute("name", childVNode.$name$);
                        }
                        node.parentNode.insertBefore(childVNode.$elm$, node);
                        node.remove();
                        if (childVNode.$depth$ === "0") {
                            shadowRootNodes[childVNode.$index$] = childVNode.$elm$;
                        }
                    }
                    slotNodes.push(childVNode);
                    if (!parentVNode.$children$) {
                        parentVNode.$children$ = [];
                    }
                    parentVNode.$children$[childVNode.$index$] = childVNode;
                } else if (childNodeType === CONTENT_REF_ID) {
                    if (BUILD.shadowDom && shadowRootNodes) {
                        node.remove();
                    } else if (BUILD.slotRelocation) {
                        hostElm["s-cr"] = node;
                        node["s-cn"] = true;
                    }
                }
            }
        }
    } else if (parentVNode && parentVNode.$tag$ === "style") {
        const vnode = newVNode(null, node.textContent);
        vnode.$elm$ = node;
        vnode.$index$ = "0";
        parentVNode.$children$ = [
            vnode
        ];
    }
};
var initializeDocumentHydrate = (node, orgLocNodes)=>{
    if (node.nodeType === 1) {
        let i2 = 0;
        for(; i2 < node.childNodes.length; i2++){
            initializeDocumentHydrate(node.childNodes[i2], orgLocNodes);
        }
        if (node.shadowRoot) {
            for(i2 = 0; i2 < node.shadowRoot.childNodes.length; i2++){
                initializeDocumentHydrate(node.shadowRoot.childNodes[i2], orgLocNodes);
            }
        }
    } else if (node.nodeType === 8) {
        const childIdSplt = node.nodeValue.split(".");
        if (childIdSplt[0] === ORG_LOCATION_ID) {
            orgLocNodes.set(childIdSplt[1] + "." + childIdSplt[2], node);
            node.nodeValue = "";
            node["s-en"] = childIdSplt[3];
        }
    }
};
var computeMode = (elm)=>modeResolutionChain.map((h2)=>h2(elm)).find((m)=>!!m);
var parsePropertyValue = (propValue, propType)=>{
    if (propValue != null && !isComplexType(propValue)) {
        if (BUILD.propBoolean && propType & 4) {
            return propValue === "false" ? false : propValue === "" || !!propValue;
        }
        if (BUILD.propNumber && propType & 2) {
            return parseFloat(propValue);
        }
        if (BUILD.propString && propType & 1) {
            return String(propValue);
        }
        return propValue;
    }
    return propValue;
};
var getElement = (ref)=>BUILD.lazyLoad ? getHostRef(ref).$hostElement$ : ref;
var createEvent = (ref, name, flags2)=>{
    const elm = getElement(ref);
    return {
        emit: (detail)=>{
            if (BUILD.isDev && !elm.isConnected) {
                consoleDevWarn(`The "${name}" event was emitted, but the dispatcher node is no longer connected to the dom.`);
            }
            return emitEvent(elm, name, {
                bubbles: !!(flags2 & 4),
                composed: !!(flags2 & 2),
                cancelable: !!(flags2 & 1),
                detail
            });
        }
    };
};
var emitEvent = (elm, name, opts)=>{
    const ev = plt.ce(name, opts);
    elm.dispatchEvent(ev);
    return ev;
};
var rootAppliedStyles = /* @__PURE__ */ new WeakMap();
var registerStyle = (scopeId2, cssText, allowCS)=>{
    let style = styles.get(scopeId2);
    if (supportsConstructableStylesheets && allowCS) {
        style = style || new CSSStyleSheet();
        if (typeof style === "string") {
            style = cssText;
        } else {
            style.replaceSync(cssText);
        }
    } else {
        style = cssText;
    }
    styles.set(scopeId2, style);
};
var addStyle = (styleContainerNode, cmpMeta, mode, hostElm)=>{
    var _a;
    let scopeId2 = getScopeId(cmpMeta, mode);
    const style = styles.get(scopeId2);
    if (!BUILD.attachStyles) {
        return scopeId2;
    }
    styleContainerNode = styleContainerNode.nodeType === 11 ? styleContainerNode : doc;
    if (style) {
        if (typeof style === "string") {
            styleContainerNode = styleContainerNode.head || styleContainerNode;
            let appliedStyles = rootAppliedStyles.get(styleContainerNode);
            let styleElm;
            if (!appliedStyles) {
                rootAppliedStyles.set(styleContainerNode, appliedStyles = /* @__PURE__ */ new Set());
            }
            if (!appliedStyles.has(scopeId2)) {
                if (BUILD.hydrateClientSide && styleContainerNode.host && (styleElm = styleContainerNode.querySelector(`[${HYDRATED_STYLE_ID}="${scopeId2}"]`))) {
                    styleElm.innerHTML = style;
                } else {
                    if (BUILD.cssVarShim && plt.$cssShim$) {
                        styleElm = plt.$cssShim$.createHostStyle(hostElm, scopeId2, style, !!(cmpMeta.$flags$ & 10));
                        const newScopeId = styleElm["s-sc"];
                        if (newScopeId) {
                            scopeId2 = newScopeId;
                            appliedStyles = null;
                        }
                    } else {
                        styleElm = doc.createElement("style");
                        styleElm.innerHTML = style;
                    }
                    const nonce = (_a = plt.$nonce$) !== null && _a !== void 0 ? _a : queryNonceMetaTagContent(doc);
                    if (nonce != null) {
                        styleElm.setAttribute("nonce", nonce);
                    }
                    if (BUILD.hydrateServerSide || BUILD.hotModuleReplacement) {
                        styleElm.setAttribute(HYDRATED_STYLE_ID, scopeId2);
                    }
                    styleContainerNode.insertBefore(styleElm, styleContainerNode.querySelector("link"));
                }
                if (appliedStyles) {
                    appliedStyles.add(scopeId2);
                }
            }
        } else if (BUILD.constructableCSS && !styleContainerNode.adoptedStyleSheets.includes(style)) {
            styleContainerNode.adoptedStyleSheets = [
                ...styleContainerNode.adoptedStyleSheets,
                style
            ];
        }
    }
    return scopeId2;
};
var attachStyles = (hostRef)=>{
    const cmpMeta = hostRef.$cmpMeta$;
    const elm = hostRef.$hostElement$;
    const flags2 = cmpMeta.$flags$;
    const endAttachStyles = createTime("attachStyles", cmpMeta.$tagName$);
    const scopeId2 = addStyle(BUILD.shadowDom && supportsShadow && elm.shadowRoot ? elm.shadowRoot : elm.getRootNode(), cmpMeta, hostRef.$modeName$, elm);
    if ((BUILD.shadowDom || BUILD.scoped) && BUILD.cssAnnotations && flags2 & 10) {
        elm["s-sc"] = scopeId2;
        elm.classList.add(scopeId2 + "-h");
        if (BUILD.scoped && flags2 & 2) {
            elm.classList.add(scopeId2 + "-s");
        }
    }
    endAttachStyles();
};
var getScopeId = (cmp, mode)=>"sc-" + (BUILD.mode && mode && cmp.$flags$ & 32 ? cmp.$tagName$ + "-" + mode : cmp.$tagName$);
var setAccessor = (elm, memberName, oldValue, newValue, isSvg, flags2)=>{
    if (oldValue !== newValue) {
        let isProp = isMemberInElement(elm, memberName);
        let ln = memberName.toLowerCase();
        if (BUILD.vdomClass && memberName === "class") {
            const classList = elm.classList;
            const oldClasses = parseClassList(oldValue);
            const newClasses = parseClassList(newValue);
            classList.remove(...oldClasses.filter((c)=>c && !newClasses.includes(c)));
            classList.add(...newClasses.filter((c)=>c && !oldClasses.includes(c)));
        } else if (BUILD.vdomStyle && memberName === "style") {
            if (BUILD.updatable) {
                for(const prop in oldValue){
                    if (!newValue || newValue[prop] == null) {
                        if (!BUILD.hydrateServerSide && prop.includes("-")) {
                            elm.style.removeProperty(prop);
                        } else {
                            elm.style[prop] = "";
                        }
                    }
                }
            }
            for(const prop in newValue){
                if (!oldValue || newValue[prop] !== oldValue[prop]) {
                    if (!BUILD.hydrateServerSide && prop.includes("-")) {
                        elm.style.setProperty(prop, newValue[prop]);
                    } else {
                        elm.style[prop] = newValue[prop];
                    }
                }
            }
        } else if (BUILD.vdomKey && memberName === "key") ;
        else if (BUILD.vdomRef && memberName === "ref") {
            if (newValue) {
                newValue(elm);
            }
        } else if (BUILD.vdomListener && (BUILD.lazyLoad ? !isProp : !elm.__lookupSetter__(memberName)) && memberName[0] === "o" && memberName[1] === "n") {
            if (memberName[2] === "-") {
                memberName = memberName.slice(3);
            } else if (isMemberInElement(win, ln)) {
                memberName = ln.slice(2);
            } else {
                memberName = ln[2] + memberName.slice(3);
            }
            if (oldValue) {
                plt.rel(elm, memberName, oldValue, false);
            }
            if (newValue) {
                plt.ael(elm, memberName, newValue, false);
            }
        } else if (BUILD.vdomPropOrAttr) {
            const isComplex = isComplexType(newValue);
            if ((isProp || isComplex && newValue !== null) && !isSvg) {
                try {
                    if (!elm.tagName.includes("-")) {
                        const n = newValue == null ? "" : newValue;
                        if (memberName === "list") {
                            isProp = false;
                        } else if (oldValue == null || elm[memberName] != n) {
                            elm[memberName] = n;
                        }
                    } else {
                        elm[memberName] = newValue;
                    }
                } catch (e) {}
            }
            let xlink = false;
            if (BUILD.vdomXlink) {
                if (ln !== (ln = ln.replace(/^xlink\:?/, ""))) {
                    memberName = ln;
                    xlink = true;
                }
            }
            if (newValue == null || newValue === false) {
                if (newValue !== false || elm.getAttribute(memberName) === "") {
                    if (BUILD.vdomXlink && xlink) {
                        elm.removeAttributeNS(XLINK_NS, memberName);
                    } else {
                        elm.removeAttribute(memberName);
                    }
                }
            } else if ((!isProp || flags2 & 4 || isSvg) && !isComplex) {
                newValue = newValue === true ? "" : newValue;
                if (BUILD.vdomXlink && xlink) {
                    elm.setAttributeNS(XLINK_NS, memberName, newValue);
                } else {
                    elm.setAttribute(memberName, newValue);
                }
            }
        }
    }
};
var parseClassListRegex = /\s/;
var parseClassList = (value)=>!value ? [] : value.split(parseClassListRegex);
var updateElement = (oldVnode, newVnode, isSvgMode2, memberName)=>{
    const elm = newVnode.$elm$.nodeType === 11 && newVnode.$elm$.host ? newVnode.$elm$.host : newVnode.$elm$;
    const oldVnodeAttrs = oldVnode && oldVnode.$attrs$ || EMPTY_OBJ;
    const newVnodeAttrs = newVnode.$attrs$ || EMPTY_OBJ;
    if (BUILD.updatable) {
        for(memberName in oldVnodeAttrs){
            if (!(memberName in newVnodeAttrs)) {
                setAccessor(elm, memberName, oldVnodeAttrs[memberName], void 0, isSvgMode2, newVnode.$flags$);
            }
        }
    }
    for(memberName in newVnodeAttrs){
        setAccessor(elm, memberName, oldVnodeAttrs[memberName], newVnodeAttrs[memberName], isSvgMode2, newVnode.$flags$);
    }
};
var createElm = (oldParentVNode, newParentVNode, childIndex, parentElm)=>{
    const newVNode2 = newParentVNode.$children$[childIndex];
    let i2 = 0;
    let elm;
    let childNode;
    let oldVNode;
    if (BUILD.slotRelocation && !useNativeShadowDom) {
        checkSlotRelocate = true;
        if (newVNode2.$tag$ === "slot") {
            if (scopeId) {
                parentElm.classList.add(scopeId + "-s");
            }
            newVNode2.$flags$ |= newVNode2.$children$ ? // slot element has fallback content
            2 : // slot element does not have fallback content
            1;
        }
    }
    if (BUILD.isDev && newVNode2.$elm$) {
        consoleDevError(`The JSX ${newVNode2.$text$ !== null ? `"${newVNode2.$text$}" text` : `"${newVNode2.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`);
    }
    if (BUILD.vdomText && newVNode2.$text$ !== null) {
        elm = newVNode2.$elm$ = doc.createTextNode(newVNode2.$text$);
    } else if (BUILD.slotRelocation && newVNode2.$flags$ & 1) {
        elm = newVNode2.$elm$ = BUILD.isDebug || BUILD.hydrateServerSide ? slotReferenceDebugNode(newVNode2) : doc.createTextNode("");
    } else {
        if (BUILD.svg && !isSvgMode) {
            isSvgMode = newVNode2.$tag$ === "svg";
        }
        elm = newVNode2.$elm$ = BUILD.svg ? doc.createElementNS(isSvgMode ? SVG_NS : HTML_NS, BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$) : doc.createElement(BUILD.slotRelocation && newVNode2.$flags$ & 2 ? "slot-fb" : newVNode2.$tag$);
        if (BUILD.svg && isSvgMode && newVNode2.$tag$ === "foreignObject") {
            isSvgMode = false;
        }
        if (BUILD.vdomAttribute) {
            updateElement(null, newVNode2, isSvgMode);
        }
        if ((BUILD.shadowDom || BUILD.scoped) && isDef(scopeId) && elm["s-si"] !== scopeId) {
            elm.classList.add(elm["s-si"] = scopeId);
        }
        if (newVNode2.$children$) {
            for(i2 = 0; i2 < newVNode2.$children$.length; ++i2){
                childNode = createElm(oldParentVNode, newVNode2, i2, elm);
                if (childNode) {
                    elm.appendChild(childNode);
                }
            }
        }
        if (BUILD.svg) {
            if (newVNode2.$tag$ === "svg") {
                isSvgMode = false;
            } else if (elm.tagName === "foreignObject") {
                isSvgMode = true;
            }
        }
    }
    if (BUILD.slotRelocation) {
        elm["s-hn"] = hostTagName;
        if (newVNode2.$flags$ & (2 | 1)) {
            elm["s-sr"] = true;
            elm["s-cr"] = contentRef;
            elm["s-sn"] = newVNode2.$name$ || "";
            oldVNode = oldParentVNode && oldParentVNode.$children$ && oldParentVNode.$children$[childIndex];
            if (oldVNode && oldVNode.$tag$ === newVNode2.$tag$ && oldParentVNode.$elm$) {
                putBackInOriginalLocation(oldParentVNode.$elm$, false);
            }
        }
    }
    return elm;
};
var putBackInOriginalLocation = (parentElm, recursive)=>{
    plt.$flags$ |= 1;
    const oldSlotChildNodes = parentElm.childNodes;
    for(let i2 = oldSlotChildNodes.length - 1; i2 >= 0; i2--){
        const childNode = oldSlotChildNodes[i2];
        if (childNode["s-hn"] !== hostTagName && childNode["s-ol"]) {
            parentReferenceNode(childNode).insertBefore(childNode, referenceNode(childNode));
            childNode["s-ol"].remove();
            childNode["s-ol"] = void 0;
            checkSlotRelocate = true;
        }
        if (recursive) {
            putBackInOriginalLocation(childNode, recursive);
        }
    }
    plt.$flags$ &= ~1;
};
var addVnodes = (parentElm, before, parentVNode, vnodes, startIdx, endIdx)=>{
    let containerElm = BUILD.slotRelocation && parentElm["s-cr"] && parentElm["s-cr"].parentNode || parentElm;
    let childNode;
    if (BUILD.shadowDom && containerElm.shadowRoot && containerElm.tagName === hostTagName) {
        containerElm = containerElm.shadowRoot;
    }
    for(; startIdx <= endIdx; ++startIdx){
        if (vnodes[startIdx]) {
            childNode = createElm(null, parentVNode, startIdx, parentElm);
            if (childNode) {
                vnodes[startIdx].$elm$ = childNode;
                containerElm.insertBefore(childNode, BUILD.slotRelocation ? referenceNode(before) : before);
            }
        }
    }
};
var removeVnodes = (vnodes, startIdx, endIdx, vnode, elm)=>{
    for(; startIdx <= endIdx; ++startIdx){
        if (vnode = vnodes[startIdx]) {
            elm = vnode.$elm$;
            callNodeRefs(vnode);
            if (BUILD.slotRelocation) {
                checkSlotFallbackVisibility = true;
                if (elm["s-ol"]) {
                    elm["s-ol"].remove();
                } else {
                    putBackInOriginalLocation(elm, true);
                }
            }
            elm.remove();
        }
    }
};
var updateChildren = (parentElm, oldCh, newVNode2, newCh)=>{
    let oldStartIdx = 0;
    let newStartIdx = 0;
    let idxInOld = 0;
    let i2 = 0;
    let oldEndIdx = oldCh.length - 1;
    let oldStartVnode = oldCh[0];
    let oldEndVnode = oldCh[oldEndIdx];
    let newEndIdx = newCh.length - 1;
    let newStartVnode = newCh[0];
    let newEndVnode = newCh[newEndIdx];
    let node;
    let elmToMove;
    while(oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx){
        if (oldStartVnode == null) {
            oldStartVnode = oldCh[++oldStartIdx];
        } else if (oldEndVnode == null) {
            oldEndVnode = oldCh[--oldEndIdx];
        } else if (newStartVnode == null) {
            newStartVnode = newCh[++newStartIdx];
        } else if (newEndVnode == null) {
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newStartVnode)) {
            patch(oldStartVnode, newStartVnode);
            oldStartVnode = oldCh[++oldStartIdx];
            newStartVnode = newCh[++newStartIdx];
        } else if (isSameVnode(oldEndVnode, newEndVnode)) {
            patch(oldEndVnode, newEndVnode);
            oldEndVnode = oldCh[--oldEndIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldStartVnode, newEndVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldStartVnode.$elm$.parentNode, false);
            }
            patch(oldStartVnode, newEndVnode);
            parentElm.insertBefore(oldStartVnode.$elm$, oldEndVnode.$elm$.nextSibling);
            oldStartVnode = oldCh[++oldStartIdx];
            newEndVnode = newCh[--newEndIdx];
        } else if (isSameVnode(oldEndVnode, newStartVnode)) {
            if (BUILD.slotRelocation && (oldStartVnode.$tag$ === "slot" || newEndVnode.$tag$ === "slot")) {
                putBackInOriginalLocation(oldEndVnode.$elm$.parentNode, false);
            }
            patch(oldEndVnode, newStartVnode);
            parentElm.insertBefore(oldEndVnode.$elm$, oldStartVnode.$elm$);
            oldEndVnode = oldCh[--oldEndIdx];
            newStartVnode = newCh[++newStartIdx];
        } else {
            idxInOld = -1;
            if (BUILD.vdomKey) {
                for(i2 = oldStartIdx; i2 <= oldEndIdx; ++i2){
                    if (oldCh[i2] && oldCh[i2].$key$ !== null && oldCh[i2].$key$ === newStartVnode.$key$) {
                        idxInOld = i2;
                        break;
                    }
                }
            }
            if (BUILD.vdomKey && idxInOld >= 0) {
                elmToMove = oldCh[idxInOld];
                if (elmToMove.$tag$ !== newStartVnode.$tag$) {
                    node = createElm(oldCh && oldCh[newStartIdx], newVNode2, idxInOld, parentElm);
                } else {
                    patch(elmToMove, newStartVnode);
                    oldCh[idxInOld] = void 0;
                    node = elmToMove.$elm$;
                }
                newStartVnode = newCh[++newStartIdx];
            } else {
                node = createElm(oldCh && oldCh[newStartIdx], newVNode2, newStartIdx, parentElm);
                newStartVnode = newCh[++newStartIdx];
            }
            if (node) {
                if (BUILD.slotRelocation) {
                    parentReferenceNode(oldStartVnode.$elm$).insertBefore(node, referenceNode(oldStartVnode.$elm$));
                } else {
                    oldStartVnode.$elm$.parentNode.insertBefore(node, oldStartVnode.$elm$);
                }
            }
        }
    }
    if (oldStartIdx > oldEndIdx) {
        addVnodes(parentElm, newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].$elm$, newVNode2, newCh, newStartIdx, newEndIdx);
    } else if (BUILD.updatable && newStartIdx > newEndIdx) {
        removeVnodes(oldCh, oldStartIdx, oldEndIdx);
    }
};
var isSameVnode = (leftVNode, rightVNode)=>{
    if (leftVNode.$tag$ === rightVNode.$tag$) {
        if (BUILD.slotRelocation && leftVNode.$tag$ === "slot") {
            return leftVNode.$name$ === rightVNode.$name$;
        }
        if (BUILD.vdomKey) {
            return leftVNode.$key$ === rightVNode.$key$;
        }
        return true;
    }
    return false;
};
var referenceNode = (node)=>{
    return node && node["s-ol"] || node;
};
var parentReferenceNode = (node)=>(node["s-ol"] ? node["s-ol"] : node).parentNode;
var patch = (oldVNode, newVNode2)=>{
    const elm = newVNode2.$elm$ = oldVNode.$elm$;
    const oldChildren = oldVNode.$children$;
    const newChildren = newVNode2.$children$;
    const tag = newVNode2.$tag$;
    const text = newVNode2.$text$;
    let defaultHolder;
    if (!BUILD.vdomText || text === null) {
        if (BUILD.svg) {
            isSvgMode = tag === "svg" ? true : tag === "foreignObject" ? false : isSvgMode;
        }
        if (BUILD.vdomAttribute || BUILD.reflect) {
            if (BUILD.slot && tag === "slot") ;
            else {
                updateElement(oldVNode, newVNode2, isSvgMode);
            }
        }
        if (BUILD.updatable && oldChildren !== null && newChildren !== null) {
            updateChildren(elm, oldChildren, newVNode2, newChildren);
        } else if (newChildren !== null) {
            if (BUILD.updatable && BUILD.vdomText && oldVNode.$text$ !== null) {
                elm.textContent = "";
            }
            addVnodes(elm, null, newVNode2, newChildren, 0, newChildren.length - 1);
        } else if (BUILD.updatable && oldChildren !== null) {
            removeVnodes(oldChildren, 0, oldChildren.length - 1);
        }
        if (BUILD.svg && isSvgMode && tag === "svg") {
            isSvgMode = false;
        }
    } else if (BUILD.vdomText && BUILD.slotRelocation && (defaultHolder = elm["s-cr"])) {
        defaultHolder.parentNode.textContent = text;
    } else if (BUILD.vdomText && oldVNode.$text$ !== text) {
        elm.data = text;
    }
};
var updateFallbackSlotVisibility = (elm)=>{
    const childNodes = elm.childNodes;
    let childNode;
    let i2;
    let ilen;
    let j;
    let slotNameAttr;
    let nodeType;
    for(i2 = 0, ilen = childNodes.length; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode.nodeType === 1) {
            if (childNode["s-sr"]) {
                slotNameAttr = childNode["s-sn"];
                childNode.hidden = false;
                for(j = 0; j < ilen; j++){
                    nodeType = childNodes[j].nodeType;
                    if (childNodes[j]["s-hn"] !== childNode["s-hn"] || slotNameAttr !== "") {
                        if (nodeType === 1 && slotNameAttr === childNodes[j].getAttribute("slot")) {
                            childNode.hidden = true;
                            break;
                        }
                    } else {
                        if (nodeType === 1 || nodeType === 3 && childNodes[j].textContent.trim() !== "") {
                            childNode.hidden = true;
                            break;
                        }
                    }
                }
            }
            updateFallbackSlotVisibility(childNode);
        }
    }
};
var relocateNodes = [];
var relocateSlotContent = (elm)=>{
    let childNode;
    let node;
    let hostContentNodes;
    let slotNameAttr;
    let relocateNodeData;
    let j;
    let i2 = 0;
    const childNodes = elm.childNodes;
    const ilen = childNodes.length;
    for(; i2 < ilen; i2++){
        childNode = childNodes[i2];
        if (childNode["s-sr"] && (node = childNode["s-cr"]) && node.parentNode) {
            hostContentNodes = node.parentNode.childNodes;
            slotNameAttr = childNode["s-sn"];
            for(j = hostContentNodes.length - 1; j >= 0; j--){
                node = hostContentNodes[j];
                if (!node["s-cn"] && !node["s-nr"] && node["s-hn"] !== childNode["s-hn"]) {
                    if (isNodeLocatedInSlot(node, slotNameAttr)) {
                        relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                        checkSlotFallbackVisibility = true;
                        node["s-sn"] = node["s-sn"] || slotNameAttr;
                        if (relocateNodeData) {
                            relocateNodeData.$slotRefNode$ = childNode;
                        } else {
                            relocateNodes.push({
                                $slotRefNode$: childNode,
                                $nodeToRelocate$: node
                            });
                        }
                        if (node["s-sr"]) {
                            relocateNodes.map((relocateNode)=>{
                                if (isNodeLocatedInSlot(relocateNode.$nodeToRelocate$, node["s-sn"])) {
                                    relocateNodeData = relocateNodes.find((r)=>r.$nodeToRelocate$ === node);
                                    if (relocateNodeData && !relocateNode.$slotRefNode$) {
                                        relocateNode.$slotRefNode$ = relocateNodeData.$slotRefNode$;
                                    }
                                }
                            });
                        }
                    } else if (!relocateNodes.some((r)=>r.$nodeToRelocate$ === node)) {
                        relocateNodes.push({
                            $nodeToRelocate$: node
                        });
                    }
                }
            }
        }
        if (childNode.nodeType === 1) {
            relocateSlotContent(childNode);
        }
    }
};
var isNodeLocatedInSlot = (nodeToRelocate, slotNameAttr)=>{
    if (nodeToRelocate.nodeType === 1) {
        if (nodeToRelocate.getAttribute("slot") === null && slotNameAttr === "") {
            return true;
        }
        if (nodeToRelocate.getAttribute("slot") === slotNameAttr) {
            return true;
        }
        return false;
    }
    if (nodeToRelocate["s-sn"] === slotNameAttr) {
        return true;
    }
    return slotNameAttr === "";
};
var callNodeRefs = (vNode)=>{
    if (BUILD.vdomRef) {
        vNode.$attrs$ && vNode.$attrs$.ref && vNode.$attrs$.ref(null);
        vNode.$children$ && vNode.$children$.map(callNodeRefs);
    }
};
var renderVdom = (hostRef, renderFnResults)=>{
    const hostElm = hostRef.$hostElement$;
    const cmpMeta = hostRef.$cmpMeta$;
    const oldVNode = hostRef.$vnode$ || newVNode(null, null);
    const rootVnode = isHost(renderFnResults) ? renderFnResults : h(null, null, renderFnResults);
    hostTagName = hostElm.tagName;
    if (BUILD.isDev && Array.isArray(renderFnResults) && renderFnResults.some(isHost)) {
        throw new Error(`The <Host> must be the single root component.
Looks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.

The render() function should look like this instead:

render() {
  // Do not return an array
  return (
    <Host>{content}</Host>
  );
}
  `);
    }
    if (BUILD.reflect && cmpMeta.$attrsToReflect$) {
        rootVnode.$attrs$ = rootVnode.$attrs$ || {};
        cmpMeta.$attrsToReflect$.map(([propName, attribute])=>rootVnode.$attrs$[attribute] = hostElm[propName]);
    }
    rootVnode.$tag$ = null;
    rootVnode.$flags$ |= 4;
    hostRef.$vnode$ = rootVnode;
    rootVnode.$elm$ = oldVNode.$elm$ = BUILD.shadowDom ? hostElm.shadowRoot || hostElm : hostElm;
    if (BUILD.scoped || BUILD.shadowDom) {
        scopeId = hostElm["s-sc"];
    }
    if (BUILD.slotRelocation) {
        contentRef = hostElm["s-cr"];
        useNativeShadowDom = supportsShadow && (cmpMeta.$flags$ & 1) !== 0;
        checkSlotFallbackVisibility = false;
    }
    patch(oldVNode, rootVnode);
    if (BUILD.slotRelocation) {
        plt.$flags$ |= 1;
        if (checkSlotRelocate) {
            relocateSlotContent(rootVnode.$elm$);
            let relocateData;
            let nodeToRelocate;
            let orgLocationNode;
            let parentNodeRef;
            let insertBeforeNode;
            let refNode;
            let i2 = 0;
            for(; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (!nodeToRelocate["s-ol"]) {
                    orgLocationNode = BUILD.isDebug || BUILD.hydrateServerSide ? originalLocationDebugNode(nodeToRelocate) : doc.createTextNode("");
                    orgLocationNode["s-nr"] = nodeToRelocate;
                    nodeToRelocate.parentNode.insertBefore(nodeToRelocate["s-ol"] = orgLocationNode, nodeToRelocate);
                }
            }
            for(i2 = 0; i2 < relocateNodes.length; i2++){
                relocateData = relocateNodes[i2];
                nodeToRelocate = relocateData.$nodeToRelocate$;
                if (relocateData.$slotRefNode$) {
                    parentNodeRef = relocateData.$slotRefNode$.parentNode;
                    insertBeforeNode = relocateData.$slotRefNode$.nextSibling;
                    orgLocationNode = nodeToRelocate["s-ol"];
                    while(orgLocationNode = orgLocationNode.previousSibling){
                        refNode = orgLocationNode["s-nr"];
                        if (refNode && refNode["s-sn"] === nodeToRelocate["s-sn"] && parentNodeRef === refNode.parentNode) {
                            refNode = refNode.nextSibling;
                            if (!refNode || !refNode["s-nr"]) {
                                insertBeforeNode = refNode;
                                break;
                            }
                        }
                    }
                    if (!insertBeforeNode && parentNodeRef !== nodeToRelocate.parentNode || nodeToRelocate.nextSibling !== insertBeforeNode) {
                        if (nodeToRelocate !== insertBeforeNode) {
                            if (!nodeToRelocate["s-hn"] && nodeToRelocate["s-ol"]) {
                                nodeToRelocate["s-hn"] = nodeToRelocate["s-ol"].parentNode.nodeName;
                            }
                            parentNodeRef.insertBefore(nodeToRelocate, insertBeforeNode);
                        }
                    }
                } else {
                    if (nodeToRelocate.nodeType === 1) {
                        nodeToRelocate.hidden = true;
                    }
                }
            }
        }
        if (checkSlotFallbackVisibility) {
            updateFallbackSlotVisibility(rootVnode.$elm$);
        }
        plt.$flags$ &= ~1;
        relocateNodes.length = 0;
    }
};
var slotReferenceDebugNode = (slotVNode)=>doc.createComment(`<slot${slotVNode.$name$ ? ' name="' + slotVNode.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`);
var originalLocationDebugNode = (nodeToRelocate)=>doc.createComment(`org-location for ` + (nodeToRelocate.localName ? `<${nodeToRelocate.localName}> (host=${nodeToRelocate["s-hn"]})` : `[${nodeToRelocate.textContent}]`));
var attachToAncestor = (hostRef, ancestorComponent)=>{
    if (BUILD.asyncLoading && ancestorComponent && !hostRef.$onRenderResolve$ && ancestorComponent["s-p"]) {
        ancestorComponent["s-p"].push(new Promise((r)=>hostRef.$onRenderResolve$ = r));
    }
};
var scheduleUpdate = (hostRef, isInitialLoad)=>{
    if (BUILD.taskQueue && BUILD.updatable) {
        hostRef.$flags$ |= 16;
    }
    if (BUILD.asyncLoading && hostRef.$flags$ & 4) {
        hostRef.$flags$ |= 512;
        return;
    }
    attachToAncestor(hostRef, hostRef.$ancestorComponent$);
    const dispatch = ()=>dispatchHooks(hostRef, isInitialLoad);
    return BUILD.taskQueue ? writeTask(dispatch) : dispatch();
};
var dispatchHooks = (hostRef, isInitialLoad)=>{
    const elm = hostRef.$hostElement$;
    const endSchedule = createTime("scheduleUpdate", hostRef.$cmpMeta$.$tagName$);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    let promise;
    if (isInitialLoad) {
        if (BUILD.lazyLoad && BUILD.hostListener) {
            hostRef.$flags$ |= 256;
            if (hostRef.$queuedListeners$) {
                hostRef.$queuedListeners$.map(([methodName, event2])=>safeCall(instance, methodName, event2));
                hostRef.$queuedListeners$ = null;
            }
        }
        emitLifecycleEvent(elm, "componentWillLoad");
        if (BUILD.cmpWillLoad) {
            promise = safeCall(instance, "componentWillLoad");
        }
    } else {
        emitLifecycleEvent(elm, "componentWillUpdate");
        if (BUILD.cmpWillUpdate) {
            promise = safeCall(instance, "componentWillUpdate");
        }
    }
    emitLifecycleEvent(elm, "componentWillRender");
    if (BUILD.cmpWillRender) {
        promise = then(promise, ()=>safeCall(instance, "componentWillRender"));
    }
    endSchedule();
    return then(promise, ()=>updateComponent(hostRef, instance, isInitialLoad));
};
var updateComponent = function() {
    var _ref = _async_to_generator(function*(hostRef, instance, isInitialLoad) {
        const elm = hostRef.$hostElement$;
        const endUpdate = createTime("update", hostRef.$cmpMeta$.$tagName$);
        const rc = elm["s-rc"];
        if (BUILD.style && isInitialLoad) {
            attachStyles(hostRef);
        }
        const endRender = createTime("render", hostRef.$cmpMeta$.$tagName$);
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        if (BUILD.hydrateServerSide) {
            yield callRender(hostRef, instance, elm);
        } else {
            callRender(hostRef, instance, elm);
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.updateHost(elm);
        }
        if (BUILD.isDev) {
            hostRef.$renderCount$++;
            hostRef.$flags$ &= ~1024;
        }
        if (BUILD.hydrateServerSide) {
            try {
                serverSideConnected(elm);
                if (isInitialLoad) {
                    if (hostRef.$cmpMeta$.$flags$ & 1) {
                        elm["s-en"] = "";
                    } else if (hostRef.$cmpMeta$.$flags$ & 2) {
                        elm["s-en"] = "c";
                    }
                }
            } catch (e) {
                consoleError(e, elm);
            }
        }
        if (BUILD.asyncLoading && rc) {
            rc.map((cb)=>cb());
            elm["s-rc"] = void 0;
        }
        endRender();
        endUpdate();
        if (BUILD.asyncLoading) {
            const childrenPromises = elm["s-p"];
            const postUpdate = ()=>postUpdateComponent(hostRef);
            if (childrenPromises.length === 0) {
                postUpdate();
            } else {
                Promise.all(childrenPromises).then(postUpdate);
                hostRef.$flags$ |= 4;
                childrenPromises.length = 0;
            }
        } else {
            postUpdateComponent(hostRef);
        }
    });
    return function updateComponent(hostRef, instance, isInitialLoad) {
        return _ref.apply(this, arguments);
    };
}();
var callRender = (hostRef, instance, elm)=>{
    const allRenderFn = BUILD.allRenderFn ? true : false;
    const lazyLoad = BUILD.lazyLoad ? true : false;
    const taskQueue = BUILD.taskQueue ? true : false;
    const updatable = BUILD.updatable ? true : false;
    try {
        renderingRef = instance;
        instance = allRenderFn ? instance.render() : instance.render && instance.render();
        if (updatable && taskQueue) {
            hostRef.$flags$ &= ~16;
        }
        if (updatable || lazyLoad) {
            hostRef.$flags$ |= 2;
        }
        if (BUILD.hasRenderFn || BUILD.reflect) {
            if (BUILD.vdomRender || BUILD.reflect) {
                if (BUILD.hydrateServerSide) {
                    return Promise.resolve(instance).then((value)=>renderVdom(hostRef, value));
                } else {
                    renderVdom(hostRef, instance);
                }
            } else {
                elm.textContent = instance;
            }
        }
    } catch (e) {
        consoleError(e, hostRef.$hostElement$);
    }
    renderingRef = null;
    return null;
};
var postUpdateComponent = (hostRef)=>{
    const tagName = hostRef.$cmpMeta$.$tagName$;
    const elm = hostRef.$hostElement$;
    const endPostUpdate = createTime("postUpdate", tagName);
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    const ancestorComponent = hostRef.$ancestorComponent$;
    if (BUILD.cmpDidRender) {
        if (BUILD.isDev) {
            hostRef.$flags$ |= 1024;
        }
        safeCall(instance, "componentDidRender");
        if (BUILD.isDev) {
            hostRef.$flags$ &= ~1024;
        }
    }
    emitLifecycleEvent(elm, "componentDidRender");
    if (!(hostRef.$flags$ & 64)) {
        hostRef.$flags$ |= 64;
        if (BUILD.asyncLoading && BUILD.cssAnnotations) {
            addHydratedFlag(elm);
        }
        if (BUILD.cmpDidLoad) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 2048;
            }
            safeCall(instance, "componentDidLoad");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~2048;
            }
        }
        emitLifecycleEvent(elm, "componentDidLoad");
        endPostUpdate();
        if (BUILD.asyncLoading) {
            hostRef.$onReadyResolve$(elm);
            if (!ancestorComponent) {
                appDidLoad(tagName);
            }
        }
    } else {
        if (BUILD.cmpDidUpdate) {
            if (BUILD.isDev) {
                hostRef.$flags$ |= 1024;
            }
            safeCall(instance, "componentDidUpdate");
            if (BUILD.isDev) {
                hostRef.$flags$ &= ~1024;
            }
        }
        emitLifecycleEvent(elm, "componentDidUpdate");
        endPostUpdate();
    }
    if (BUILD.hotModuleReplacement) {
        elm["s-hmr-load"] && elm["s-hmr-load"]();
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstanceResolve$(elm);
    }
    if (BUILD.asyncLoading) {
        if (hostRef.$onRenderResolve$) {
            hostRef.$onRenderResolve$();
            hostRef.$onRenderResolve$ = void 0;
        }
        if (hostRef.$flags$ & 512) {
            nextTick2(()=>scheduleUpdate(hostRef, false));
        }
        hostRef.$flags$ &= ~(4 | 512);
    }
};
var appDidLoad = (who)=>{
    if (BUILD.cssAnnotations) {
        addHydratedFlag(doc.documentElement);
    }
    if (BUILD.asyncQueue) {
        plt.$flags$ |= 2;
    }
    nextTick2(()=>emitEvent(win, "appload", {
            detail: {
                namespace: NAMESPACE
            }
        }));
    if (BUILD.profile && performance.measure) {
        performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${who})`, "st:app:start");
    }
};
var safeCall = (instance, method, arg)=>{
    if (instance && instance[method]) {
        try {
            return instance[method](arg);
        } catch (e) {
            consoleError(e);
        }
    }
    return void 0;
};
var then = (promise, thenFn)=>{
    return promise && promise.then ? promise.then(thenFn) : thenFn();
};
var emitLifecycleEvent = (elm, lifecycleName)=>{
    if (BUILD.lifecycleDOMEvents) {
        emitEvent(elm, "stencil_" + lifecycleName, {
            bubbles: true,
            composed: true,
            detail: {
                namespace: NAMESPACE
            }
        });
    }
};
var addHydratedFlag = (elm)=>BUILD.hydratedClass ? elm.classList.add("hydrated") : BUILD.hydratedAttribute ? elm.setAttribute("hydrated", "") : void 0;
var serverSideConnected = (elm)=>{
    const children = elm.children;
    if (children != null) {
        for(let i2 = 0, ii = children.length; i2 < ii; i2++){
            const childElm = children[i2];
            if (typeof childElm.connectedCallback === "function") {
                childElm.connectedCallback();
            }
            serverSideConnected(childElm);
        }
    }
};
var getValue = (ref, propName)=>getHostRef(ref).$instanceValues$.get(propName);
var setValue = (ref, propName, newVal, cmpMeta)=>{
    const hostRef = getHostRef(ref);
    const elm = BUILD.lazyLoad ? hostRef.$hostElement$ : ref;
    const oldVal = hostRef.$instanceValues$.get(propName);
    const flags2 = hostRef.$flags$;
    const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
    newVal = parsePropertyValue(newVal, cmpMeta.$members$[propName][0]);
    const areBothNaN = Number.isNaN(oldVal) && Number.isNaN(newVal);
    const didValueChange = newVal !== oldVal && !areBothNaN;
    if ((!BUILD.lazyLoad || !(flags2 & 8) || oldVal === void 0) && didValueChange) {
        hostRef.$instanceValues$.set(propName, newVal);
        if (BUILD.isDev) {
            if (hostRef.$flags$ & 1024) {
                consoleDevWarn(`The state/prop "${propName}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            } else if (hostRef.$flags$ & 2048) {
                consoleDevWarn(`The state/prop "${propName}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`, "\nElement", elm, "\nNew value", newVal, "\nOld value", oldVal);
            }
        }
        if (!BUILD.lazyLoad || instance) {
            if (BUILD.watchCallback && cmpMeta.$watchers$ && flags2 & 128) {
                const watchMethods = cmpMeta.$watchers$[propName];
                if (watchMethods) {
                    watchMethods.map((watchMethodName)=>{
                        try {
                            instance[watchMethodName](newVal, oldVal, propName);
                        } catch (e) {
                            consoleError(e, elm);
                        }
                    });
                }
            }
            if (BUILD.updatable && (flags2 & (2 | 16)) === 2) {
                if (BUILD.cmpShouldUpdate && instance.componentShouldUpdate) {
                    if (instance.componentShouldUpdate(newVal, oldVal, propName) === false) {
                        return;
                    }
                }
                scheduleUpdate(hostRef, false);
            }
        }
    }
};
var proxyComponent = (Cstr, cmpMeta, flags2)=>{
    if (BUILD.member && cmpMeta.$members$) {
        if (BUILD.watchCallback && Cstr.watchers) {
            cmpMeta.$watchers$ = Cstr.watchers;
        }
        const members = Object.entries(cmpMeta.$members$);
        const prototype = Cstr.prototype;
        members.map(([memberName, [memberFlags]])=>{
            if ((BUILD.prop || BUILD.state) && (memberFlags & 31 || (!BUILD.lazyLoad || flags2 & 2) && memberFlags & 32)) {
                Object.defineProperty(prototype, memberName, {
                    get () {
                        return getValue(this, memberName);
                    },
                    set (newValue) {
                        if (BUILD.isDev) {
                            const ref = getHostRef(this);
                            if (// we are proxying the instance (not element)
                            (flags2 & 1) === 0 && // the element is not constructing
                            (ref.$flags$ & 8) === 0 && // the member is a prop
                            (memberFlags & 31) !== 0 && // the member is not mutable
                            (memberFlags & 1024) === 0) {
                                consoleDevWarn(`@Prop() "${memberName}" on <${cmpMeta.$tagName$}> is immutable but was modified from within the component.
More information: https://stenciljs.com/docs/properties#prop-mutability`);
                            }
                        }
                        setValue(this, memberName, newValue, cmpMeta);
                    },
                    configurable: true,
                    enumerable: true
                });
            } else if (BUILD.lazyLoad && BUILD.method && flags2 & 1 && memberFlags & 64) {
                Object.defineProperty(prototype, memberName, {
                    value (...args) {
                        const ref = getHostRef(this);
                        return ref.$onInstancePromise$.then(()=>ref.$lazyInstance$[memberName](...args));
                    }
                });
            }
        });
        if (BUILD.observeAttribute && (!BUILD.lazyLoad || flags2 & 1)) {
            const attrNameToPropName = /* @__PURE__ */ new Map();
            prototype.attributeChangedCallback = function(attrName, _oldValue, newValue) {
                plt.jmp(()=>{
                    const propName = attrNameToPropName.get(attrName);
                    if (this.hasOwnProperty(propName)) {
                        newValue = this[propName];
                        delete this[propName];
                    } else if (prototype.hasOwnProperty(propName) && typeof this[propName] === "number" && this[propName] == newValue) {
                        return;
                    }
                    this[propName] = newValue === null && typeof this[propName] === "boolean" ? false : newValue;
                });
            };
            Cstr.observedAttributes = members.filter(([_, m])=>m[0] & 15).map(([propName, m])=>{
                const attrName = m[1] || propName;
                attrNameToPropName.set(attrName, propName);
                if (BUILD.reflect && m[0] & 512) {
                    cmpMeta.$attrsToReflect$.push([
                        propName,
                        attrName
                    ]);
                }
                return attrName;
            });
        }
    }
    return Cstr;
};
var initializeComponent = function() {
    var _ref = _async_to_generator(function*(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        if ((BUILD.lazyLoad || BUILD.hydrateServerSide || BUILD.style) && (hostRef.$flags$ & 32) === 0) {
            if (BUILD.lazyLoad || BUILD.hydrateClientSide) {
                hostRef.$flags$ |= 32;
                Cstr = loadModule(cmpMeta, hostRef, hmrVersionId);
                if (Cstr.then) {
                    const endLoad = uniqueTime(`st:load:${cmpMeta.$tagName$}:${hostRef.$modeName$}`, `[Stencil] Load module for <${cmpMeta.$tagName$}>`);
                    Cstr = yield Cstr;
                    endLoad();
                }
                if ((BUILD.isDev || BUILD.isDebug) && !Cstr) {
                    throw new Error(`Constructor for "${cmpMeta.$tagName$}#${hostRef.$modeName$}" was not found`);
                }
                if (BUILD.member && !Cstr.isProxied) {
                    if (BUILD.watchCallback) {
                        cmpMeta.$watchers$ = Cstr.watchers;
                    }
                    proxyComponent(Cstr, cmpMeta, 2);
                    Cstr.isProxied = true;
                }
                const endNewInstance = createTime("createInstance", cmpMeta.$tagName$);
                if (BUILD.member) {
                    hostRef.$flags$ |= 8;
                }
                try {
                    new Cstr(hostRef);
                } catch (e) {
                    consoleError(e);
                }
                if (BUILD.member) {
                    hostRef.$flags$ &= ~8;
                }
                if (BUILD.watchCallback) {
                    hostRef.$flags$ |= 128;
                }
                endNewInstance();
                fireConnectedCallback(hostRef.$lazyInstance$);
            } else {
                Cstr = elm.constructor;
                hostRef.$flags$ |= 32;
                customElements.whenDefined(cmpMeta.$tagName$).then(()=>hostRef.$flags$ |= 128);
            }
            if (BUILD.style && Cstr.style) {
                let style = Cstr.style;
                if (BUILD.mode && typeof style !== "string") {
                    style = style[hostRef.$modeName$ = computeMode(elm)];
                    if (BUILD.hydrateServerSide && hostRef.$modeName$) {
                        elm.setAttribute("s-mode", hostRef.$modeName$);
                    }
                }
                const scopeId2 = getScopeId(cmpMeta, hostRef.$modeName$);
                if (!styles.has(scopeId2)) {
                    const endRegisterStyles = createTime("registerStyles", cmpMeta.$tagName$);
                    if (!BUILD.hydrateServerSide && BUILD.shadowDom && BUILD.shadowDomShim && cmpMeta.$flags$ & 8) {
                        style = yield __webpack_require__.e(/*! import() */ "vendors-node_modules_taro_h5_prebundle_shadow-css-DOYKNSL4_js").then(__webpack_require__.bind(__webpack_require__, /*! ./shadow-css-DOYKNSL4.js */ "./node_modules/.taro/h5/prebundle/shadow-css-DOYKNSL4.js")).then((m)=>m.scopeCss(style, scopeId2, false));
                    }
                    registerStyle(scopeId2, style, !!(cmpMeta.$flags$ & 1));
                    endRegisterStyles();
                }
            }
        }
        const ancestorComponent = hostRef.$ancestorComponent$;
        const schedule = ()=>scheduleUpdate(hostRef, true);
        if (BUILD.asyncLoading && ancestorComponent && ancestorComponent["s-rc"]) {
            ancestorComponent["s-rc"].push(schedule);
        } else {
            schedule();
        }
    });
    return function initializeComponent(elm, hostRef, cmpMeta, hmrVersionId, Cstr) {
        return _ref.apply(this, arguments);
    };
}();
var fireConnectedCallback = (instance)=>{
    if (BUILD.lazyLoad && BUILD.connectedCallback) {
        safeCall(instance, "connectedCallback");
    }
};
var connectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const cmpMeta = hostRef.$cmpMeta$;
        const endConnected = createTime("connectedCallback", cmpMeta.$tagName$);
        if (BUILD.hostListenerTargetParent) {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, true);
        }
        if (!(hostRef.$flags$ & 1)) {
            hostRef.$flags$ |= 1;
            let hostId;
            if (BUILD.hydrateClientSide) {
                hostId = elm.getAttribute(HYDRATE_ID);
                if (hostId) {
                    if (BUILD.shadowDom && supportsShadow && cmpMeta.$flags$ & 1) {
                        const scopeId2 = BUILD.mode ? addStyle(elm.shadowRoot, cmpMeta, elm.getAttribute("s-mode")) : addStyle(elm.shadowRoot, cmpMeta);
                        elm.classList.remove(scopeId2 + "-h", scopeId2 + "-s");
                    }
                    initializeClientHydrate(elm, cmpMeta.$tagName$, hostId, hostRef);
                }
            }
            if (BUILD.slotRelocation && !hostId) {
                if (BUILD.hydrateServerSide || (BUILD.slot || BUILD.shadowDom) && cmpMeta.$flags$ & (4 | 8)) {
                    setContentReference(elm);
                }
            }
            if (BUILD.asyncLoading) {
                let ancestorComponent = elm;
                while(ancestorComponent = ancestorComponent.parentNode || ancestorComponent.host){
                    if (BUILD.hydrateClientSide && ancestorComponent.nodeType === 1 && ancestorComponent.hasAttribute("s-id") && ancestorComponent["s-p"] || ancestorComponent["s-p"]) {
                        attachToAncestor(hostRef, hostRef.$ancestorComponent$ = ancestorComponent);
                        break;
                    }
                }
            }
            if (BUILD.prop && !BUILD.hydrateServerSide && cmpMeta.$members$) {
                Object.entries(cmpMeta.$members$).map(([memberName, [memberFlags]])=>{
                    if (memberFlags & 31 && elm.hasOwnProperty(memberName)) {
                        const value = elm[memberName];
                        delete elm[memberName];
                        elm[memberName] = value;
                    }
                });
            }
            if (BUILD.initializeNextTick) {
                nextTick2(()=>initializeComponent(elm, hostRef, cmpMeta));
            } else {
                initializeComponent(elm, hostRef, cmpMeta);
            }
        } else {
            addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
            fireConnectedCallback(hostRef.$lazyInstance$);
        }
        endConnected();
    }
};
var setContentReference = (elm)=>{
    const contentRefElm = elm["s-cr"] = doc.createComment(BUILD.isDebug ? `content-ref (host=${elm.localName})` : "");
    contentRefElm["s-cn"] = true;
    elm.insertBefore(contentRefElm, elm.firstChild);
};
var disconnectedCallback = (elm)=>{
    if ((plt.$flags$ & 1) === 0) {
        const hostRef = getHostRef(elm);
        const instance = BUILD.lazyLoad ? hostRef.$lazyInstance$ : elm;
        if (BUILD.hostListener) {
            if (hostRef.$rmListeners$) {
                hostRef.$rmListeners$.map((rmListener)=>rmListener());
                hostRef.$rmListeners$ = void 0;
            }
        }
        if (BUILD.cssVarShim && plt.$cssShim$) {
            plt.$cssShim$.removeHost(elm);
        }
        if (BUILD.lazyLoad && BUILD.disconnectedCallback) {
            safeCall(instance, "disconnectedCallback");
        }
        if (BUILD.cmpDidUnload) {
            safeCall(instance, "componentDidUnload");
        }
    }
};
var proxyCustomElement = (Cstr, compactMeta)=>{
    const cmpMeta = {
        $flags$: compactMeta[0],
        $tagName$: compactMeta[1]
    };
    if (BUILD.member) {
        cmpMeta.$members$ = compactMeta[2];
    }
    if (BUILD.hostListener) {
        cmpMeta.$listeners$ = compactMeta[3];
    }
    if (BUILD.watchCallback) {
        cmpMeta.$watchers$ = Cstr.$watchers$;
    }
    if (BUILD.reflect) {
        cmpMeta.$attrsToReflect$ = [];
    }
    if (BUILD.shadowDom && !supportsShadow && cmpMeta.$flags$ & 1) {
        cmpMeta.$flags$ |= 8;
    }
    const originalConnectedCallback = Cstr.prototype.connectedCallback;
    const originalDisconnectedCallback = Cstr.prototype.disconnectedCallback;
    Object.assign(Cstr.prototype, {
        __registerHost () {
            registerHost(this, cmpMeta);
        },
        connectedCallback () {
            connectedCallback(this);
            if (BUILD.connectedCallback && originalConnectedCallback) {
                originalConnectedCallback.call(this);
            }
        },
        disconnectedCallback () {
            disconnectedCallback(this);
            if (BUILD.disconnectedCallback && originalDisconnectedCallback) {
                originalDisconnectedCallback.call(this);
            }
        },
        __attachShadow () {
            if (supportsShadow) {
                if (BUILD.shadowDelegatesFocus) {
                    this.attachShadow({
                        mode: "open",
                        delegatesFocus: !!(cmpMeta.$flags$ & 16)
                    });
                } else {
                    this.attachShadow({
                        mode: "open"
                    });
                }
            } else {
                this.shadowRoot = this;
            }
        }
    });
    Cstr.is = cmpMeta.$tagName$;
    return proxyComponent(Cstr, cmpMeta, 1 | 2);
};
var addHostEventListeners = (elm, hostRef, listeners, attachParentListeners)=>{
    if (BUILD.hostListener && listeners) {
        if (BUILD.hostListenerTargetParent) {
            if (attachParentListeners) {
                listeners = listeners.filter(([flags2])=>flags2 & 32);
            } else {
                listeners = listeners.filter(([flags2])=>!(flags2 & 32));
            }
        }
        listeners.map(([flags2, name, method])=>{
            const target = BUILD.hostListenerTarget ? getHostListenerTarget(elm, flags2) : elm;
            const handler = hostListenerProxy(hostRef, method);
            const opts = hostListenerOpts(flags2);
            plt.ael(target, name, handler, opts);
            (hostRef.$rmListeners$ = hostRef.$rmListeners$ || []).push(()=>plt.rel(target, name, handler, opts));
        });
    }
};
var hostListenerProxy = (hostRef, methodName)=>(ev)=>{
        try {
            if (BUILD.lazyLoad) {
                if (hostRef.$flags$ & 256) {
                    hostRef.$lazyInstance$[methodName](ev);
                } else {
                    (hostRef.$queuedListeners$ = hostRef.$queuedListeners$ || []).push([
                        methodName,
                        ev
                    ]);
                }
            } else {
                hostRef.$hostElement$[methodName](ev);
            }
        } catch (e) {
            consoleError(e);
        }
    };
var getHostListenerTarget = (elm, flags2)=>{
    if (BUILD.hostListenerTargetDocument && flags2 & 4) return doc;
    if (BUILD.hostListenerTargetWindow && flags2 & 8) return win;
    if (BUILD.hostListenerTargetBody && flags2 & 16) return doc.body;
    if (BUILD.hostListenerTargetParent && flags2 & 32) return elm.parentElement;
    return elm;
};
var hostListenerOpts = (flags2)=>supportsListenerOptions ? {
        passive: (flags2 & 1) !== 0,
        capture: (flags2 & 2) !== 0
    } : (flags2 & 2) !== 0;
var hostRefs = /* @__PURE__ */ new WeakMap();
var getHostRef = (ref)=>hostRefs.get(ref);
var registerHost = (elm, cmpMeta)=>{
    const hostRef = {
        $flags$: 0,
        $hostElement$: elm,
        $cmpMeta$: cmpMeta,
        $instanceValues$: /* @__PURE__ */ new Map()
    };
    if (BUILD.isDev) {
        hostRef.$renderCount$ = 0;
    }
    if (BUILD.method && BUILD.lazyLoad) {
        hostRef.$onInstancePromise$ = new Promise((r)=>hostRef.$onInstanceResolve$ = r);
    }
    if (BUILD.asyncLoading) {
        hostRef.$onReadyPromise$ = new Promise((r)=>hostRef.$onReadyResolve$ = r);
        elm["s-p"] = [];
        elm["s-rc"] = [];
    }
    addHostEventListeners(elm, hostRef, cmpMeta.$listeners$, false);
    return hostRefs.set(elm, hostRef);
};
var isMemberInElement = (elm, memberName)=>memberName in elm;
var consoleError = (e, el)=>(customError || console.error)(e, el);
var STENCIL_DEV_MODE = BUILD.isTesting ? [
    "STENCIL:"
] : [
    "%cstencil",
    "color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"
];
var consoleDevError = (...m)=>console.error(...STENCIL_DEV_MODE, ...m);
var consoleDevWarn = (...m)=>console.warn(...STENCIL_DEV_MODE, ...m);
var cmpModules = /* @__PURE__ */ new Map();
var loadModule = (cmpMeta, hostRef, hmrVersionId)=>{
    const exportName = cmpMeta.$tagName$.replace(/-/g, "_");
    const bundleId = cmpMeta.$lazyBundleId$;
    if (BUILD.isDev && typeof bundleId !== "string") {
        consoleDevError(`Trying to lazily load component <${cmpMeta.$tagName$}> with style mode "${hostRef.$modeName$}", but it does not exist.`);
        return void 0;
    }
    const module2 = !BUILD.hotModuleReplacement ? cmpModules.get(bundleId) : false;
    if (module2) {
        return module2[exportName];
    }
    return /* @vite-ignore */ /* webpackInclude: /\.entry\.js$/ */ /* webpackExclude: /\.system\.entry\.js$/ */ /* webpackMode: "lazy" */ globImport_entry_js(`./${bundleId}.entry.js${BUILD.hotModuleReplacement && hmrVersionId ? "?s-hmr=" + hmrVersionId : ""}`).then((importedModule)=>{
        if (!BUILD.hotModuleReplacement) {
            cmpModules.set(bundleId, importedModule);
        }
        return importedModule[exportName];
    }, consoleError);
};
var styles = /* @__PURE__ */ new Map();
var modeResolutionChain = [];
var win = typeof window !== "undefined" ? window : {};
var CSS = BUILD.cssVarShim ? win.CSS : null;
var doc = win.document || {
    head: {}
};
var H = win.HTMLElement || class {
};
var plt = {
    $flags$: 0,
    $resourcesUrl$: "",
    jmp: (h2)=>h2(),
    raf: (h2)=>requestAnimationFrame(h2),
    ael: (el, eventName, listener, opts)=>el.addEventListener(eventName, listener, opts),
    rel: (el, eventName, listener, opts)=>el.removeEventListener(eventName, listener, opts),
    ce: (eventName, opts)=>new CustomEvent(eventName, opts)
};
var supportsShadow = BUILD.shadowDomShim && BUILD.shadowDom ? (()=>(doc.head.attachShadow + "").indexOf("[native") > -1)() : true;
var supportsListenerOptions = (()=>{
    let supportsListenerOptions2 = false;
    try {
        doc.addEventListener("e", null, Object.defineProperty({}, "passive", {
            get () {
                supportsListenerOptions2 = true;
            }
        }));
    } catch (e) {}
    return supportsListenerOptions2;
})();
var promiseResolve = (v)=>Promise.resolve(v);
var supportsConstructableStylesheets = BUILD.constructableCSS ? (()=>{
    try {
        new CSSStyleSheet();
        return typeof new CSSStyleSheet().replaceSync === "function";
    } catch (e) {}
    return false;
})() : false;
var queueDomReads = [];
var queueDomWrites = [];
var queueDomWritesLow = [];
var queueTask = (queue, write)=>(cb)=>{
        queue.push(cb);
        if (!queuePending) {
            queuePending = true;
            if (write && plt.$flags$ & 4) {
                nextTick2(flush);
            } else {
                plt.raf(flush);
            }
        }
    };
var consume = (queue)=>{
    for(let i2 = 0; i2 < queue.length; i2++){
        try {
            queue[i2](performance.now());
        } catch (e) {
            consoleError(e);
        }
    }
    queue.length = 0;
};
var consumeTimeout = (queue, timeout)=>{
    let i2 = 0;
    let ts = 0;
    while(i2 < queue.length && (ts = performance.now()) < timeout){
        try {
            queue[i2++](ts);
        } catch (e) {
            consoleError(e);
        }
    }
    if (i2 === queue.length) {
        queue.length = 0;
    } else if (i2 !== 0) {
        queue.splice(0, i2);
    }
};
var flush = ()=>{
    if (BUILD.asyncQueue) {
        queueCongestion++;
    }
    consume(queueDomReads);
    if (BUILD.asyncQueue) {
        const timeout = (plt.$flags$ & 6) === 2 ? performance.now() + 14 * Math.ceil(queueCongestion * (1 / 10)) : Infinity;
        consumeTimeout(queueDomWrites, timeout);
        consumeTimeout(queueDomWritesLow, timeout);
        if (queueDomWrites.length > 0) {
            queueDomWritesLow.push(...queueDomWrites);
            queueDomWrites.length = 0;
        }
        if (queuePending = queueDomReads.length + queueDomWrites.length + queueDomWritesLow.length > 0) {
            plt.raf(flush);
        } else {
            queueCongestion = 0;
        }
    } else {
        consume(queueDomWrites);
        if (queuePending = queueDomReads.length > 0) {
            plt.raf(flush);
        }
    }
};
var nextTick2 = (cb)=>promiseResolve().then(cb);
var readTask = queueTask(queueDomReads, false);
var writeTask = queueTask(queueDomWrites, true);
// node_modules/@tarojs/plugin-platform-h5/dist/runtime/apis/index.js

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
}
var listCacheClear_default = listCacheClear;
// node_modules/lodash-es/eq.js
function eq(value, other) {
    return value === other || value !== value && other !== other;
}
var eq_default = eq;
// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf(array2, key) {
    var length = array2.length;
    while(length--){
        if (eq_default(array2[length][0], key)) {
            return length;
        }
    }
    return -1;
}
var assocIndexOf_default = assocIndexOf;
// node_modules/lodash-es/_listCacheDelete.js
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
        return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
        data.pop();
    } else {
        splice.call(data, index, 1);
    }
    --this.size;
    return true;
}
var listCacheDelete_default = listCacheDelete;
// node_modules/lodash-es/_listCacheGet.js
function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    return index < 0 ? void 0 : data[index][1];
}
var listCacheGet_default = listCacheGet;
// node_modules/lodash-es/_listCacheHas.js
function listCacheHas(key) {
    return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas;
// node_modules/lodash-es/_listCacheSet.js
function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf_default(data, key);
    if (index < 0) {
        ++this.size;
        data.push([
            key,
            value
        ]);
    } else {
        data[index][1] = value;
    }
    return this;
}
var listCacheSet_default = listCacheSet;
// node_modules/lodash-es/_ListCache.js
function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
ListCache.prototype.clear = listCacheClear_default;
ListCache.prototype["delete"] = listCacheDelete_default;
ListCache.prototype.get = listCacheGet_default;
ListCache.prototype.has = listCacheHas_default;
ListCache.prototype.set = listCacheSet_default;
var ListCache_default = ListCache;
// node_modules/lodash-es/_stackClear.js
function stackClear() {
    this.__data__ = new ListCache_default();
    this.size = 0;
}
var stackClear_default = stackClear;
// node_modules/lodash-es/_stackDelete.js
function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
}
var stackDelete_default = stackDelete;
// node_modules/lodash-es/_stackGet.js
function stackGet(key) {
    return this.__data__.get(key);
}
var stackGet_default = stackGet;
// node_modules/lodash-es/_stackHas.js
function stackHas(key) {
    return this.__data__.has(key);
}
var stackHas_default = stackHas;
// node_modules/lodash-es/_freeGlobal.js
var freeGlobal = typeof __webpack_require__.g == "object" && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;
var freeGlobal_default = freeGlobal;
// node_modules/lodash-es/_root.js
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = freeGlobal_default || freeSelf || Function("return this")();
var root_default = root;
// node_modules/lodash-es/_Symbol.js
var Symbol2 = root_default.Symbol;
var Symbol_default = Symbol2;
// node_modules/lodash-es/_getRawTag.js
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var nativeObjectToString = objectProto.toString;
var symToStringTag = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
        value[symToStringTag] = void 0;
        var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString.call(value);
    if (unmasked) {
        if (isOwn) {
            value[symToStringTag] = tag;
        } else {
            delete value[symToStringTag];
        }
    }
    return result;
}
var getRawTag_default = getRawTag;
// node_modules/lodash-es/_objectToString.js
var objectProto2 = Object.prototype;
var nativeObjectToString2 = objectProto2.toString;
function objectToString(value) {
    return nativeObjectToString2.call(value);
}
var objectToString_default = objectToString;
// node_modules/lodash-es/_baseGetTag.js
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag2 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag(value) {
    if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag2 && symToStringTag2 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag;
// node_modules/lodash-es/isObject.js
function isObject2(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject2;
// node_modules/lodash-es/isFunction.js
var asyncTag = "[object AsyncFunction]";
var funcTag = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction2(value) {
    if (!isObject_default(value)) {
        return false;
    }
    var tag = baseGetTag_default(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_default = isFunction2;
// node_modules/lodash-es/_coreJsData.js
var coreJsData = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData;
// node_modules/lodash-es/_isMasked.js
var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
}
var isMasked_default = isMasked;
// node_modules/lodash-es/_toSource.js
var funcProto = Function.prototype;
var funcToString = funcProto.toString;
function toSource(func) {
    if (func != null) {
        try {
            return funcToString.call(func);
        } catch (e) {}
        try {
            return func + "";
        } catch (e) {}
    }
    return "";
}
var toSource_default = toSource;
// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto2 = Function.prototype;
var objectProto3 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty2 = objectProto3.hasOwnProperty;
var reIsNative = RegExp("^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(value) {
    if (!isObject_default(value) || isMasked_default(value)) {
        return false;
    }
    var pattern = isFunction_default(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative;
// node_modules/lodash-es/_getValue.js
function getValue2(object2, key) {
    return object2 == null ? void 0 : object2[key];
}
var getValue_default = getValue2;
// node_modules/lodash-es/_getNative.js
function getNative(object2, key) {
    var value = getValue_default(object2, key);
    return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative;
// node_modules/lodash-es/_Map.js
var Map2 = getNative_default(root_default, "Map");
var Map_default = Map2;
// node_modules/lodash-es/_nativeCreate.js
var nativeCreate = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate;
// node_modules/lodash-es/_hashClear.js
function hashClear() {
    this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
    this.size = 0;
}
var hashClear_default = hashClear;
// node_modules/lodash-es/_hashDelete.js
function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
}
var hashDelete_default = hashDelete;
// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED = "__lodash_hash_undefined__";
var objectProto4 = Object.prototype;
var hasOwnProperty3 = objectProto4.hasOwnProperty;
function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate_default) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty3.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet;
// node_modules/lodash-es/_hashHas.js
var objectProto5 = Object.prototype;
var hasOwnProperty4 = objectProto5.hasOwnProperty;
function hashHas(key) {
    var data = this.__data__;
    return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty4.call(data, key);
}
var hashHas_default = hashHas;
// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED2 : value;
    return this;
}
var hashSet_default = hashSet;
// node_modules/lodash-es/_Hash.js
function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
Hash.prototype.clear = hashClear_default;
Hash.prototype["delete"] = hashDelete_default;
Hash.prototype.get = hashGet_default;
Hash.prototype.has = hashHas_default;
Hash.prototype.set = hashSet_default;
var Hash_default = Hash;
// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
        "hash": new Hash_default(),
        "map": new (Map_default || ListCache_default)(),
        "string": new Hash_default()
    };
}
var mapCacheClear_default = mapCacheClear;
// node_modules/lodash-es/_isKeyable.js
function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable;
// node_modules/lodash-es/_getMapData.js
function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData;
// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete(key) {
    var result = getMapData_default(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
}
var mapCacheDelete_default = mapCacheDelete;
// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet(key) {
    return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet;
// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas(key) {
    return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas;
// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet(key, value) {
    var data = getMapData_default(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
}
var mapCacheSet_default = mapCacheSet;
// node_modules/lodash-es/_MapCache.js
function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while(++index < length){
        var entry = entries[index];
        this.set(entry[0], entry[1]);
    }
}
MapCache.prototype.clear = mapCacheClear_default;
MapCache.prototype["delete"] = mapCacheDelete_default;
MapCache.prototype.get = mapCacheGet_default;
MapCache.prototype.has = mapCacheHas_default;
MapCache.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache;
// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache_default) {
        var pairs = data.__data__;
        if (!Map_default || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([
                key,
                value
            ]);
            this.size = ++data.size;
            return this;
        }
        data = this.__data__ = new MapCache_default(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
}
var stackSet_default = stackSet;
// node_modules/lodash-es/_Stack.js
function Stack(entries) {
    var data = this.__data__ = new ListCache_default(entries);
    this.size = data.size;
}
Stack.prototype.clear = stackClear_default;
Stack.prototype["delete"] = stackDelete_default;
Stack.prototype.get = stackGet_default;
Stack.prototype.has = stackHas_default;
Stack.prototype.set = stackSet_default;
var Stack_default = Stack;
// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED3);
    return this;
}
var setCacheAdd_default = setCacheAdd;
// node_modules/lodash-es/_setCacheHas.js
function setCacheHas(value) {
    return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas;
// node_modules/lodash-es/_SetCache.js
function SetCache(values) {
    var index = -1, length = values == null ? 0 : values.length;
    this.__data__ = new MapCache_default();
    while(++index < length){
        this.add(values[index]);
    }
}
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd_default;
SetCache.prototype.has = setCacheHas_default;
var SetCache_default = SetCache;
// node_modules/lodash-es/_arraySome.js
function arraySome(array2, predicate) {
    var index = -1, length = array2 == null ? 0 : array2.length;
    while(++index < length){
        if (predicate(array2[index], index, array2)) {
            return true;
        }
    }
    return false;
}
var arraySome_default = arraySome;
// node_modules/lodash-es/_cacheHas.js
function cacheHas(cache, key) {
    return cache.has(key);
}
var cacheHas_default = cacheHas;
// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array2.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
    }
    var arrStacked = stack.get(array2);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
    }
    var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache_default() : void 0;
    stack.set(array2, other);
    stack.set(other, array2);
    while(++index < arrLength){
        var arrValue = array2[index], othValue = other[index];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
        }
        if (compared !== void 0) {
            if (compared) {
                continue;
            }
            result = false;
            break;
        }
        if (seen) {
            if (!arraySome_default(other, function(othValue2, othIndex) {
                if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                }
            })) {
                result = false;
                break;
            }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result = false;
            break;
        }
    }
    stack["delete"](array2);
    stack["delete"](other);
    return result;
}
var equalArrays_default = equalArrays;
// node_modules/lodash-es/_Uint8Array.js
var Uint8Array2 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array2;
// node_modules/lodash-es/_mapToArray.js
function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
        result[++index] = [
            key,
            value
        ];
    });
    return result;
}
var mapToArray_default = mapToArray;
// node_modules/lodash-es/_setToArray.js
function setToArray(set3) {
    var index = -1, result = Array(set3.size);
    set3.forEach(function(value) {
        result[++index] = value;
    });
    return result;
}
var setToArray_default = setToArray;
// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var mapTag = "[object Map]";
var numberTag = "[object Number]";
var regexpTag = "[object RegExp]";
var setTag = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag = "[object DataView]";
var symbolProto = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
    switch(tag){
        case dataViewTag:
            if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
                return false;
            }
            object2 = object2.buffer;
            other = other.buffer;
        case arrayBufferTag:
            if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object2), new Uint8Array_default(other))) {
                return false;
            }
            return true;
        case boolTag:
        case dateTag:
        case numberTag:
            return eq_default(+object2, +other);
        case errorTag:
            return object2.name == other.name && object2.message == other.message;
        case regexpTag:
        case stringTag:
            return object2 == other + "";
        case mapTag:
            var convert = mapToArray_default;
        case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
            convert || (convert = setToArray_default);
            if (object2.size != other.size && !isPartial) {
                return false;
            }
            var stacked = stack.get(object2);
            if (stacked) {
                return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG2;
            stack.set(object2, other);
            var result = equalArrays_default(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object2);
            return result;
        case symbolTag:
            if (symbolValueOf) {
                return symbolValueOf.call(object2) == symbolValueOf.call(other);
            }
    }
    return false;
}
var equalByTag_default = equalByTag;
// node_modules/lodash-es/_arrayPush.js
function arrayPush(array2, values) {
    var index = -1, length = values.length, offset = array2.length;
    while(++index < length){
        array2[offset + index] = values[index];
    }
    return array2;
}
var arrayPush_default = arrayPush;
// node_modules/lodash-es/isArray.js
var isArray = Array.isArray;
var isArray_default = isArray;
// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
    var result = keysFunc(object2);
    return isArray_default(object2) ? result : arrayPush_default(result, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys;
// node_modules/lodash-es/_arrayFilter.js
function arrayFilter(array2, predicate) {
    var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
    while(++index < length){
        var value = array2[index];
        if (predicate(value, index, array2)) {
            result[resIndex++] = value;
        }
    }
    return result;
}
var arrayFilter_default = arrayFilter;
// node_modules/lodash-es/stubArray.js
function stubArray() {
    return [];
}
var stubArray_default = stubArray;
// node_modules/lodash-es/_getSymbols.js
var objectProto6 = Object.prototype;
var propertyIsEnumerable = objectProto6.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols ? stubArray_default : function(object2) {
    if (object2 == null) {
        return [];
    }
    object2 = Object(object2);
    return arrayFilter_default(nativeGetSymbols(object2), function(symbol) {
        return propertyIsEnumerable.call(object2, symbol);
    });
};
var getSymbols_default = getSymbols;
// node_modules/lodash-es/_baseTimes.js
function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
var baseTimes_default = baseTimes;
// node_modules/lodash-es/isObjectLike.js
function isObjectLike(value) {
    return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike;
// node_modules/lodash-es/_baseIsArguments.js
var argsTag = "[object Arguments]";
function baseIsArguments(value) {
    return isObjectLike_default(value) && baseGetTag_default(value) == argsTag;
}
var baseIsArguments_default = baseIsArguments;
// node_modules/lodash-es/isArguments.js
var objectProto7 = Object.prototype;
var hasOwnProperty5 = objectProto7.hasOwnProperty;
var propertyIsEnumerable2 = objectProto7.propertyIsEnumerable;
var isArguments = baseIsArguments_default(/* @__PURE__ */ function() {
    return arguments;
}()) ? baseIsArguments_default : function(value) {
    return isObjectLike_default(value) && hasOwnProperty5.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
};
var isArguments_default = isArguments;
// node_modules/lodash-es/stubFalse.js
function stubFalse() {
    return false;
}
var stubFalse_default = stubFalse;
// node_modules/lodash-es/isBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && "object" == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;
// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
var isIndex_default = isIndex;
// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER2 = 9007199254740991;
function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
}
var isLength_default = isLength;
// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag2 = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag2 = "[object Function]";
var mapTag2 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag = "[object Object]";
var regexpTag2 = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag2 = "[object String]";
var weakMapTag = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag2] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag2] = typedArrayTags[boolTag2] = typedArrayTags[dataViewTag2] = typedArrayTags[dateTag2] = typedArrayTags[errorTag2] = typedArrayTags[funcTag2] = typedArrayTags[mapTag2] = typedArrayTags[numberTag2] = typedArrayTags[objectTag] = typedArrayTags[regexpTag2] = typedArrayTags[setTag2] = typedArrayTags[stringTag2] = typedArrayTags[weakMapTag] = false;
function baseIsTypedArray(value) {
    return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray;
// node_modules/lodash-es/_baseUnary.js
function baseUnary(func) {
    return function(value) {
        return func(value);
    };
}
var baseUnary_default = baseUnary;
// node_modules/lodash-es/_nodeUtil.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && "object" == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var freeProcess = moduleExports2 && freeGlobal_default.process;
var nodeUtil = function() {
    try {
        var types = freeModule2 && freeModule2.require && freeModule2.require("util").types;
        if (types) {
            return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {}
}();
var nodeUtil_default = nodeUtil;
// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray = nodeIsTypedArray ? baseUnary_default(nodeIsTypedArray) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray;
// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto8 = Object.prototype;
var hasOwnProperty6 = objectProto8.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
    var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
    for(var key in value){
        if ((inherited || hasOwnProperty6.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex_default(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
var arrayLikeKeys_default = arrayLikeKeys;
// node_modules/lodash-es/_isPrototype.js
var objectProto9 = Object.prototype;
function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto9;
    return value === proto;
}
var isPrototype_default = isPrototype;
// node_modules/lodash-es/_overArg.js
function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
var overArg_default = overArg;
// node_modules/lodash-es/_nativeKeys.js
var nativeKeys = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys;
// node_modules/lodash-es/_baseKeys.js
var objectProto10 = Object.prototype;
var hasOwnProperty7 = objectProto10.hasOwnProperty;
function baseKeys(object2) {
    if (!isPrototype_default(object2)) {
        return nativeKeys_default(object2);
    }
    var result = [];
    for(var key in Object(object2)){
        if (hasOwnProperty7.call(object2, key) && key != "constructor") {
            result.push(key);
        }
    }
    return result;
}
var baseKeys_default = baseKeys;
// node_modules/lodash-es/isArrayLike.js
function isArrayLike(value) {
    return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike;
// node_modules/lodash-es/keys.js
function keys(object2) {
    return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys;
// node_modules/lodash-es/_getAllKeys.js
function getAllKeys(object2) {
    return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys;
// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG3 = 1;
var objectProto11 = Object.prototype;
var hasOwnProperty8 = objectProto11.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG3, objProps = getAllKeys_default(object2), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
        return false;
    }
    var index = objLength;
    while(index--){
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty8.call(other, key))) {
            return false;
        }
    }
    var objStacked = stack.get(object2);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
    }
    var result = true;
    stack.set(object2, other);
    stack.set(other, object2);
    var skipCtor = isPartial;
    while(++index < objLength){
        key = objProps[index];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result = false;
            break;
        }
        skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && "constructor" in object2 && "constructor" in other && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
        }
    }
    stack["delete"](object2);
    stack["delete"](other);
    return result;
}
var equalObjects_default = equalObjects;
// node_modules/lodash-es/_DataView.js
var DataView2 = getNative_default(root_default, "DataView");
var DataView_default = DataView2;
// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;
// node_modules/lodash-es/_Set.js
var Set2 = getNative_default(root_default, "Set");
var Set_default = Set2;
// node_modules/lodash-es/_WeakMap.js
var WeakMap2 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap2;
// node_modules/lodash-es/_getTag.js
var mapTag3 = "[object Map]";
var objectTag2 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag3 = "[object Set]";
var weakMapTag2 = "[object WeakMap]";
var dataViewTag3 = "[object DataView]";
var dataViewCtorString = toSource_default(DataView_default);
var mapCtorString = toSource_default(Map_default);
var promiseCtorString = toSource_default(Promise_default);
var setCtorString = toSource_default(Set_default);
var weakMapCtorString = toSource_default(WeakMap_default);
var getTag = baseGetTag_default;
if (DataView_default && getTag(new DataView_default(new ArrayBuffer(1))) != dataViewTag3 || Map_default && getTag(new Map_default()) != mapTag3 || Promise_default && getTag(Promise_default.resolve()) != promiseTag || Set_default && getTag(new Set_default()) != setTag3 || WeakMap_default && getTag(new WeakMap_default()) != weakMapTag2) {
    getTag = function(value) {
        var result = baseGetTag_default(value), Ctor = result == objectTag2 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
        if (ctorString) {
            switch(ctorString){
                case dataViewCtorString:
                    return dataViewTag3;
                case mapCtorString:
                    return mapTag3;
                case promiseCtorString:
                    return promiseTag;
                case setCtorString:
                    return setTag3;
                case weakMapCtorString:
                    return weakMapTag2;
            }
        }
        return result;
    };
}
var getTag_default = getTag;
// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG4 = 1;
var argsTag3 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var objectTag3 = "[object Object]";
var objectProto12 = Object.prototype;
var hasOwnProperty9 = objectProto12.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray_default(object2), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag2 : getTag_default(object2), othTag = othIsArr ? arrayTag2 : getTag_default(other);
    objTag = objTag == argsTag3 ? objectTag3 : objTag;
    othTag = othTag == argsTag3 ? objectTag3 : othTag;
    var objIsObj = objTag == objectTag3, othIsObj = othTag == objectTag3, isSameTag = objTag == othTag;
    if (isSameTag && isBuffer_default(object2)) {
        if (!isBuffer_default(other)) {
            return false;
        }
        objIsArr = true;
        objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
        stack || (stack = new Stack_default());
        return objIsArr || isTypedArray_default(object2) ? equalArrays_default(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object2, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG4)) {
        var objIsWrapped = objIsObj && hasOwnProperty9.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty9.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack_default());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
    }
    if (!isSameTag) {
        return false;
    }
    stack || (stack = new Stack_default());
    return equalObjects_default(object2, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep;
// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
        return true;
    }
    if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
        return value !== value && other !== other;
    }
    return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual, stack);
}
var baseIsEqual_default = baseIsEqual;
// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG5 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object2 == null) {
        return !length;
    }
    object2 = Object(object2);
    while(index--){
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
            return false;
        }
    }
    while(++index < length){
        data = matchData[index];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
            if (objValue === void 0 && !(key in object2)) {
                return false;
            }
        } else {
            var stack = new Stack_default();
            if (customizer) {
                var result = customizer(objValue, srcValue, key, object2, source, stack);
            }
            if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG5 | COMPARE_UNORDERED_FLAG3, customizer, stack) : result)) {
                return false;
            }
        }
    }
    return true;
}
var baseIsMatch_default = baseIsMatch;
// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable(value) {
    return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable;
// node_modules/lodash-es/_getMatchData.js
function getMatchData(object2) {
    var result = keys_default(object2), length = result.length;
    while(length--){
        var key = result[length], value = object2[key];
        result[length] = [
            key,
            value,
            isStrictComparable_default(value)
        ];
    }
    return result;
}
var getMatchData_default = getMatchData;
// node_modules/lodash-es/isMatchWith.js
function isMatchWith(object2, source, customizer) {
    customizer = typeof customizer == "function" ? customizer : void 0;
    return baseIsMatch_default(object2, source, getMatchData_default(source), customizer);
}
var isMatchWith_default = isMatchWith;
// node_modules/lodash-es/_defineProperty.js
var defineProperty = function() {
    try {
        var func = getNative_default(Object, "defineProperty");
        func({}, "", {});
        return func;
    } catch (e) {}
}();
var defineProperty_default = defineProperty;
// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue(object2, key, value) {
    if (key == "__proto__" && defineProperty_default) {
        defineProperty_default(object2, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
        });
    } else {
        object2[key] = value;
    }
}
var baseAssignValue_default = baseAssignValue;
// node_modules/lodash-es/_assignValue.js
var objectProto13 = Object.prototype;
var hasOwnProperty10 = objectProto13.hasOwnProperty;
function assignValue(object2, key, value) {
    var objValue = object2[key];
    if (!(hasOwnProperty10.call(object2, key) && eq_default(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue_default(object2, key, value);
    }
}
var assignValue_default = assignValue;
// node_modules/lodash-es/isSymbol.js
var symbolTag2 = "[object Symbol]";
function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag2;
}
var isSymbol_default = isSymbol;
// node_modules/lodash-es/_isKey.js
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
    if (isArray_default(value)) {
        return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
        return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var isKey_default = isKey;
// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
    if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
            return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
    };
    memoized.cache = new (memoize.Cache || MapCache_default)();
    return memoized;
}
memoize.Cache = MapCache_default;
var memoize_default = memoize;
// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
    var result = memoize_default(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
        }
        return key;
    });
    var cache = result.cache;
    return result;
}
var memoizeCapped_default = memoizeCapped;
// node_modules/lodash-es/_stringToPath.js
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = memoizeCapped_default(function(string2) {
    var result = [];
    if (string2.charCodeAt(0) === 46) {
        result.push("");
    }
    string2.replace(rePropName, function(match2, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match2);
    });
    return result;
});
var stringToPath_default = stringToPath;
// node_modules/lodash-es/_arrayMap.js
function arrayMap(array2, iteratee) {
    var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
    while(++index < length){
        result[index] = iteratee(array2[index], index, array2);
    }
    return result;
}
var arrayMap_default = arrayMap;
// node_modules/lodash-es/_baseToString.js
var INFINITY = 1 / 0;
var symbolProto2 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString = symbolProto2 ? symbolProto2.toString : void 0;
function baseToString(value) {
    if (typeof value == "string") {
        return value;
    }
    if (isArray_default(value)) {
        return arrayMap_default(value, baseToString) + "";
    }
    if (isSymbol_default(value)) {
        return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
var baseToString_default = baseToString;
// node_modules/lodash-es/toString.js
function toString(value) {
    return value == null ? "" : baseToString_default(value);
}
var toString_default = toString;
// node_modules/lodash-es/_castPath.js
function castPath(value, object2) {
    if (isArray_default(value)) {
        return value;
    }
    return isKey_default(value, object2) ? [
        value
    ] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath;
// node_modules/lodash-es/_toKey.js
var INFINITY2 = 1 / 0;
function toKey(value) {
    if (typeof value == "string" || isSymbol_default(value)) {
        return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var toKey_default = toKey;
// node_modules/lodash-es/_baseSet.js
function baseSet(object2, path, value, customizer) {
    if (!isObject_default(object2)) {
        return object2;
    }
    path = castPath_default(path, object2);
    var index = -1, length = path.length, lastIndex = length - 1, nested = object2;
    while(nested != null && ++index < length){
        var key = toKey_default(path[index]), newValue = value;
        if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object2;
        }
        if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : void 0;
            if (newValue === void 0) {
                newValue = isObject_default(objValue) ? objValue : isIndex_default(path[index + 1]) ? [] : {};
            }
        }
        assignValue_default(nested, key, newValue);
        nested = nested[key];
    }
    return object2;
}
var baseSet_default = baseSet;
// node_modules/lodash-es/set.js
function set(object2, path, value) {
    return object2 == null ? object2 : baseSet_default(object2, path, value);
}
var set_default = set;
// node_modules/@tarojs/api/dist/index.esm.js
var ENV_TYPE = {
    ASCF: "ASCF",
    WEAPP: "WEAPP",
    SWAN: "SWAN",
    ALIPAY: "ALIPAY",
    TT: "TT",
    QQ: "QQ",
    JD: "JD",
    WEB: "WEB",
    RN: "RN",
    HARMONY: "HARMONY",
    QUICKAPP: "QUICKAPP",
    HARMONYHYBRID: "HARMONYHYBRID"
};
function getEnv() {
    if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (false) // removed by dead control flow
{} else if (true) {
        return ENV_TYPE.WEB;
    } else // removed by dead control flow
{}
}
var Chain = class _Chain {
    proceed(requestParams = {}) {
        this.requestParams = requestParams;
        if (this.index >= this.interceptors.length) {
            throw new Error("chain \u53C2\u6570\u9519\u8BEF, \u8BF7\u52FF\u76F4\u63A5\u4FEE\u6539 request.chain");
        }
        const nextInterceptor = this._getNextInterceptor();
        const nextChain = this._getNextChain();
        const p = nextInterceptor(nextChain);
        const res = p.catch((err)=>Promise.reject(err));
        Object.keys(p).forEach((k)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(p[k]) && (res[k] = p[k]));
        return res;
    }
    _getNextInterceptor() {
        return this.interceptors[this.index];
    }
    _getNextChain() {
        return new _Chain(this.requestParams, this.interceptors, this.index + 1);
    }
    constructor(requestParams, interceptors3, index){
        this.index = index || 0;
        this.requestParams = requestParams || {};
        this.interceptors = interceptors3 || [];
    }
};
var Link = class {
    request(requestParams) {
        const chain = this.chain;
        const taroInterceptor2 = this.taroInterceptor;
        chain.interceptors = chain.interceptors.filter((interceptor)=>interceptor !== taroInterceptor2).concat(taroInterceptor2);
        return chain.proceed(Object.assign({}, requestParams));
    }
    addInterceptor(interceptor) {
        this.chain.interceptors.push(interceptor);
    }
    cleanInterceptors() {
        this.chain = new Chain();
    }
    constructor(interceptor){
        this.taroInterceptor = interceptor;
        this.chain = new Chain();
    }
};
function interceptorify(promisifyApi) {
    return new Link(function(chain) {
        return promisifyApi(chain.requestParams);
    });
}
function timeoutInterceptor(chain) {
    const requestParams = chain.requestParams;
    let p;
    const res = new Promise((resolve, reject)=>{
        const timeout = setTimeout(()=>{
            clearTimeout(timeout);
            reject(new Error("\u7F51\u7EDC\u94FE\u63A5\u8D85\u65F6,\u8BF7\u7A0D\u540E\u518D\u8BD5\uFF01"));
        }, requestParams && requestParams.timeout || 6e4);
        p = chain.proceed(requestParams);
        p.then((res2)=>{
            if (!timeout) return;
            clearTimeout(timeout);
            resolve(res2);
        }).catch((err)=>{
            timeout && clearTimeout(timeout);
            reject(err);
        });
    });
    if (!(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isUndefined)(p) && (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(p.abort)) res.abort = p.abort;
    return res;
}
function logInterceptor(chain) {
    const requestParams = chain.requestParams;
    const { method, data, url } = requestParams;
    console.log(`http ${method || "GET"} --> ${url} data: `, data);
    const p = chain.proceed(requestParams);
    const res = p.then((res2)=>{
        console.log(`http <-- ${url} result:`, res2);
        return res2;
    });
    if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(p.abort)) res.abort = p.abort;
    return res;
}
var interceptors = Object.freeze({
    __proto__: null,
    logInterceptor,
    timeoutInterceptor
});
function Behavior(options3) {
    return options3;
}
function getPreload(current) {
    return function(key, val) {
        current.preloadData = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isObject)(key) ? key : {
            [key]: val
        };
    };
}
var defaultDesignWidth = 750;
var defaultDesignRatio = {
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
};
var defaultBaseFontSize = 20;
var defaultUnitPrecision = 5;
var defaultTargetUnit = "rpx";
function getInitPxTransform(taro2) {
    return function(config) {
        const { designWidth = defaultDesignWidth, deviceRatio = defaultDesignRatio, baseFontSize = defaultBaseFontSize, targetUnit = defaultTargetUnit, unitPrecision = defaultUnitPrecision } = config;
        taro2.config = taro2.config || {};
        taro2.config.designWidth = designWidth;
        taro2.config.deviceRatio = deviceRatio;
        taro2.config.baseFontSize = baseFontSize;
        taro2.config.targetUnit = targetUnit;
        taro2.config.unitPrecision = unitPrecision;
    };
}
function getPxTransform(taro2) {
    return function(size) {
        const config = taro2.config || {};
        const baseFontSize = config.baseFontSize;
        const deviceRatio = config.deviceRatio || defaultDesignRatio;
        const designWidth = ((input = 0)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(config.designWidth) ? config.designWidth(input) : config.designWidth || defaultDesignWidth)(size);
        if (!(designWidth in deviceRatio)) {
            throw new Error(`deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ${designWidth} \u7684\u8BBE\u7F6E\uFF01`);
        }
        const targetUnit = config.targetUnit || defaultTargetUnit;
        const unitPrecision = config.unitPrecision || defaultUnitPrecision;
        const formatSize = ~~size;
        let rootValue = 1 / deviceRatio[designWidth];
        switch(targetUnit){
            case "rem":
                rootValue *= baseFontSize * 2;
                break;
            case "px":
                rootValue *= 2;
                break;
        }
        let val = formatSize / rootValue;
        if (unitPrecision >= 0 && unitPrecision <= 100) {
            val = Number(val.toFixed(unitPrecision));
        }
        return val + targetUnit;
    };
}
var Taro = {
    Behavior,
    getEnv,
    ENV_TYPE,
    Link,
    interceptors,
    Current: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current,
    getCurrentInstance: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getCurrentInstance,
    options: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.options,
    nextTick: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.nextTick,
    eventCenter: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter,
    Events: _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Events,
    getInitPxTransform,
    interceptorify
};
Taro.initPxTransform = getInitPxTransform(Taro);
Taro.preload = getPreload(_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current);
Taro.pxTransform = getPxTransform(Taro);
// node_modules/@tarojs/taro-h5/dist/utils/handler.js
var MethodHandler = class {
    success(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:ok`;
        }
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__success) && this.__success(res);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__complete) && this.__complete(res);
        const { resolve = Promise.resolve.bind(Promise) } = promise;
        return resolve(res);
    }
    fail(res = {}, promise = {}) {
        if (!res.errMsg) {
            res.errMsg = `${this.methodName}:fail`;
        } else {
            res.errMsg = `${this.methodName}:fail ${res.errMsg}`;
        }
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__fail) && this.__fail(res);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__complete) && this.__complete(res);
        const { resolve = Promise.resolve.bind(Promise), reject = Promise.reject.bind(Promise) } = promise;
        return this.isHandlerError ? resolve(res) : reject(res);
    }
    constructor({ name, success, fail, complete }){
        this.isHandlerError = false;
        this.methodName = name;
        this.__success = success;
        this.__fail = fail;
        this.__complete = complete;
        this.isHandlerError = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__complete) || (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(this.__fail);
    }
};
var CallbackManager = class {
    constructor(){
        this.callbacks = [];
        this.add = (opt)=>{
            if (opt) this.callbacks.push(opt);
        };
        this.remove = (opt)=>{
            if (opt) {
                let pos = -1;
                this.callbacks.forEach((callback, k)=>{
                    if (callback === opt) {
                        pos = k;
                    }
                });
                if (pos > -1) {
                    this.callbacks.splice(pos, 1);
                }
            } else {
                this.callbacks = [];
            }
        };
        this.count = ()=>{
            return this.callbacks.length;
        };
        this.trigger = (...args)=>{
            this.callbacks.forEach((opt)=>{
                if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opt)) {
                    opt(...args);
                } else {
                    const { callback, ctx } = opt;
                    (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(callback) && callback.call(ctx, ...args);
                }
            });
        };
        this.clear = ()=>{
            this.callbacks = [];
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/utils/animation.js
var easeInOut = (t)=>t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
var getTimingFunc = (easeFunc, frameCnt)=>{
    return (x)=>{
        if (frameCnt <= 1) {
            return easeFunc(1);
        }
        const t = x / (frameCnt - 1);
        return easeFunc(t);
    };
};
// node_modules/@tarojs/taro-h5/dist/utils/helper.js
function createDownload(url = "", download = "") {
    const link2 = document.createElement("a");
    link2.style.display = "none";
    link2.href = url;
    link2.download = download;
    link2.click();
}
// node_modules/@tarojs/taro-h5/dist/utils/valid.js
var VALID_COLOR_REG = /^#[0-9a-fA-F]{6}$/;
var isValidColor = (color)=>{
    return VALID_COLOR_REG.test(color);
};
// node_modules/@tarojs/taro-h5/dist/utils/index.js
function shouldBeObject(target) {
    if (target && typeof target === "object") return {
        flag: true
    };
    return {
        flag: false,
        msg: getParameterError({
            correct: "Object",
            wrong: target
        })
    };
}
function findDOM(inst) {
    if (inst && _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.hooks.isExist("getDOMNode")) {
        return _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.hooks.call("getDOMNode", inst);
    }
    const page = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page;
    const path = page === null || page === void 0 ? void 0 : page.path;
    const msg = "\u6CA1\u6709\u627E\u5230\u5DF2\u7ECF\u52A0\u8F7D\u4E86\u7684\u9875\u9762\uFF0C\u8BF7\u5728\u9875\u9762\u52A0\u8F7D\u5B8C\u6210\u540E\u4F7F\u7528\u6B64 API\u3002";
    if (path == null) {
        throw new Error(msg);
    }
    const el = document.getElementById(path);
    if (el == null) {
        throw new Error("\u5728\u5DF2\u52A0\u8F7D\u9875\u9762\u4E2D\u6CA1\u6709\u627E\u5230\u5BF9\u5E94\u7684\u5BB9\u5668\u5143\u7D20\u3002");
    }
    return el;
}
function getParameterError({ name = "", para, correct, wrong, level = "error" }) {
    const parameter = para ? `parameter.${para}` : "parameter";
    const errorType = upperCaseFirstLetter(wrong === null ? "Null" : typeof wrong);
    return `${name ? `${name}:fail ` : ""}parameter ${level}: ${parameter} should be ${correct} instead of ${errorType}`;
}
function upperCaseFirstLetter(string2) {
    if (typeof string2 !== "string") return string2;
    string2 = string2.replace(/^./, (match2)=>match2.toUpperCase());
    return string2;
}
function inlineStyle(style) {
    let res = "";
    for(const attr in style)res += `${attr}: ${style[attr]};`;
    if (res.indexOf("display: flex;") >= 0) res += "display: -webkit-box;display: -webkit-flex;";
    res = res.replace(/transform:(.+?);/g, (s, $1)=>`${s}-webkit-transform:${$1};`);
    res = res.replace(/flex-direction:(.+?);/g, (s, $1)=>`${s}-webkit-flex-direction:${$1};`);
    return res;
}
function setTransform(el, val) {
    el.style.webkitTransform = val;
    el.style.transform = val;
}
function serializeParams(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map((key)=>`${encodeURIComponent(key)}=${typeof params[key] === "object" ? encodeURIComponent(JSON.stringify(params[key])) : encodeURIComponent(params[key])}`).join("&");
}
function temporarilyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u6682\u65F6\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "temporarily"
        });
        if (false) // removed by dead control flow
{} else {
            return handle.fail({
                errMsg
            });
        }
    };
}
function weixinCorpSupport(name) {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "h5 \u7AEF\u5F53\u524D\u4EC5\u5728\u5FAE\u4FE1\u516C\u4F17\u53F7 JS-SDK \u73AF\u5883\u4E0B\u652F\u6301\u6B64 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "weixin_corp"
        });
        if (false) // removed by dead control flow
{} else {
            return handle.fail({
                errMsg
            });
        }
    };
}
function permanentlyNotSupport(name = "") {
    return (option = {}, ...args)=>{
        const { success, fail, complete } = option;
        const handle = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        const errMsg = "\u4E0D\u652F\u6301 API";
        Taro.eventCenter.trigger("__taroNotSupport", {
            name,
            args: [
                option,
                ...args
            ],
            type: "method",
            category: "permanently"
        });
        if (false) // removed by dead control flow
{} else {
            return handle.fail({
                errMsg
            });
        }
    };
}
function processOpenApi({ name, defaultOptions, standardMethod, formatOptions = (options3)=>options3, formatResult = (res)=>res }) {
    const notSupported = weixinCorpSupport(name);
    return (options3 = {}, ...args)=>{
        var _a;
        const targetApi = (_a = window === null || window === void 0 ? void 0 : window.wx) === null || _a === void 0 ? void 0 : _a[name];
        const opts = formatOptions(Object.assign({}, defaultOptions, options3));
        if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(targetApi)) {
            return new Promise((resolve, reject)=>{
                [
                    "fail",
                    "success",
                    "complete"
                ].forEach((k)=>{
                    opts[k] = (preRef)=>{
                        const res = formatResult(preRef);
                        options3[k] && options3[k](res);
                        if (k === "success") {
                            resolve(res);
                        } else if (k === "fail") {
                            reject(res);
                        }
                    };
                    return targetApi(opts);
                });
            });
        } else if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(standardMethod)) {
            return standardMethod(opts);
        } else {
            return notSupported(options3, ...args);
        }
    };
}
function getCurrentPath() {
    var _a, _b, _c, _d, _e, _f;
    const appConfig = window.__taroAppConfig || {};
    const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getCurrentPage)((_a = appConfig.router) === null || _a === void 0 ? void 0 : _a.mode, (_b = appConfig.router) === null || _b === void 0 ? void 0 : _b.basename);
    const homePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getHomePage)((_d = (_c = appConfig.routes) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.path, (_e = appConfig.router) === null || _e === void 0 ? void 0 : _e.basename, (_f = appConfig.router) === null || _f === void 0 ? void 0 : _f.customRoutes, appConfig.entryPagePath);
    return `${routePath === "/" ? homePath : routePath}?stamp=1`;
}
// node_modules/@tarojs/taro-h5/dist/api/ad/index.js
var createRewardedVideoAd = temporarilyNotSupport("createRewardedVideoAd");
var createInterstitialAd = temporarilyNotSupport("createInterstitialAd");
// node_modules/@tarojs/taro-h5/dist/api/ai/facial.js
var stopFaceDetect = temporarilyNotSupport("stopFaceDetect");
var initFaceDetect = temporarilyNotSupport("initFaceDetect");
var faceDetect = temporarilyNotSupport("faceDetect");
// node_modules/@tarojs/taro-h5/dist/api/ai/inference.js
var getInferenceEnvInfo = temporarilyNotSupport("getInferenceEnvInfo");
var createInferenceSession = temporarilyNotSupport("createInferenceSession");
// node_modules/@tarojs/taro-h5/dist/api/ai/visual.js
var isVKSupport = temporarilyNotSupport("isVKSupport");
var createVKSession = temporarilyNotSupport("createVKSession");
// node_modules/@tarojs/taro-h5/dist/api/alipay/index.js
var getOpenUserInfo = temporarilyNotSupport("getOpenUserInfo");
var tradePay = temporarilyNotSupport("tradePay");
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var import_base64_js = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_base64_js());
// node_modules/@tarojs/taro-h5/dist/api/base/crypto.js
var getUserCryptoManager = temporarilyNotSupport("getUserCryptoManager");
// node_modules/@tarojs/taro-h5/dist/api/base/debug.js
var setEnableDebug = temporarilyNotSupport("setEnableDebug");
var getRealtimeLogManager = temporarilyNotSupport("getRealtimeLogManager");
var getLogManager = temporarilyNotSupport("getLogManager");
// node_modules/@tarojs/taro-h5/dist/api/base/performance.js
var reportPerformance = temporarilyNotSupport("reportPerformance");
var getPerformance = temporarilyNotSupport("getPerformance");
var preloadWebview = temporarilyNotSupport("preloadWebview");
var preloadSkylineView = temporarilyNotSupport("preloadSkylineView");
var preloadAssets = temporarilyNotSupport("preloadAssets");
// node_modules/@tarojs/taro-h5/dist/api/base/system.js
var import_platform = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_platform());
var openSystemBluetoothSetting = temporarilyNotSupport("openSystemBluetoothSetting");
var openAppAuthorizeSetting = temporarilyNotSupport("openAppAuthorizeSetting");
var getWindowInfo = ()=>{
    const info = {
        /**  */ pixelRatio: window.devicePixelRatio,
        /** px */ screenWidth: window.screen.width,
        /** px */ screenHeight: window.screen.height,
        /** px */ windowWidth: document.documentElement.clientWidth,
        /** px */ windowHeight: document.documentElement.clientHeight,
        /** px */ statusBarHeight: NaN,
        /**  */ safeArea: {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        }
    };
    return info;
};
var getSystemSetting = ()=>{
    const isLandscape = window.screen.width >= window.screen.height;
    const info = {
        /**  */ bluetoothEnabled: false,
        /**  */ locationEnabled: false,
        /** Wi-Fi  */ wifiEnabled: false,
        /**  */ deviceOrientation: isLandscape ? "landscape" : "portrait"
    };
    return info;
};
var getDeviceInfo = ()=>{
    var _a, _b;
    const info = {
        /**  Android  */ abi: "",
        /**  Android  */ deviceAbi: "",
        /** Android-2  0-1>=150 */ benchmarkLevel: -1,
        /**  */ brand: import_platform.default.manufacturer || "unknown",
        /**  */ model: import_platform.default.product || "unknown",
        /**  */ system: ((_a = import_platform.default.os) === null || _a === void 0 ? void 0 : _a.toString()) || "unknown",
        /**  */ platform: ((_b = import_platform.default.os) === null || _b === void 0 ? void 0 : _b.family) || "unknown",
        /**  Android  */ CPUType: ""
    };
    return info;
};
var getAppBaseInfo = ()=>{
    var _a;
    let isDarkMode = false;
    if ((_a = window.matchMedia) === null || _a === void 0 ? void 0 : _a.call(window, "(prefers-color-scheme: dark)").matches) {
        isDarkMode = true;
    }
    const info = {
        /**  */ SDKVersion: "",
        /**  [Taro.setEnableDebug](/docs/apis/base/debug/setEnableDebug)  */ enableDebug: true,
        /**  */ // host: { appId: '' },
        /**  */ language: navigator.language,
        /**  */ version: "",
        /** lightdark"darkmode":true undefined  */ theme: isDarkMode ? "dark" : "light"
    };
    return info;
};
var getAppAuthorizeSetting = ()=>{
    const info = {
        /**  iOS  */ albumAuthorized: "not determined",
        /**  iOS  */ bluetoothAuthorized: "not determined",
        /**  */ cameraAuthorized: "not determined",
        /**  */ locationAuthorized: "not determined",
        /** true false  iOS  */ locationReducedAccuracy: false,
        /**  */ microphoneAuthorized: "not determined",
        /**  */ notificationAuthorized: "not determined",
        /**  iOS  */ notificationAlertAuthorized: "not determined",
        /**  iOS  */ notificationBadgeAuthorized: "not determined",
        /**  iOS  */ notificationSoundAuthorized: "not determined",
        /**  */ phoneCalendarAuthorized: "not determined"
    };
    return info;
};
var getSystemInfoSync = ()=>{
    const windowInfo = getWindowInfo();
    const systemSetting = getSystemSetting();
    const deviceInfo = getDeviceInfo();
    const appBaseInfo = getAppBaseInfo();
    const appAuthorizeSetting = getAppAuthorizeSetting();
    delete deviceInfo.abi;
    const info = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, windowInfo), systemSetting), deviceInfo), appBaseInfo), {
        /** px--- */ fontSizeSetting: NaN,
        /**  iOS  */ albumAuthorized: appAuthorizeSetting.albumAuthorized === "authorized",
        /**  */ cameraAuthorized: appAuthorizeSetting.cameraAuthorized === "authorized",
        /**  */ locationAuthorized: appAuthorizeSetting.locationAuthorized === "authorized",
        /**  */ microphoneAuthorized: appAuthorizeSetting.microphoneAuthorized === "authorized",
        /**  */ notificationAuthorized: appAuthorizeSetting.notificationAuthorized === "authorized",
        /**  iOS  */ notificationAlertAuthorized: appAuthorizeSetting.notificationAlertAuthorized === "authorized",
        /**  iOS  */ notificationBadgeAuthorized: appAuthorizeSetting.notificationBadgeAuthorized === "authorized",
        /**  iOS  */ notificationSoundAuthorized: appAuthorizeSetting.notificationSoundAuthorized === "authorized",
        /**  */ phoneCalendarAuthorized: appAuthorizeSetting.phoneCalendarAuthorized === "authorized",
        /** `true` `false`  iOS  */ locationReducedAccuracy: appAuthorizeSetting.locationReducedAccuracy,
        /**  */ environment: ""
    });
    return info;
};
var getSystemInfoAsync = (...args_1)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_1
    ], void 0, function*(options3 = {}) {
        const { success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: "getSystemInfoAsync",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle.success(info);
        } catch (error) {
            return handle.fail({
                errMsg: error
            });
        }
    });
var getSystemInfo = (...args_2)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_2
    ], void 0, function*(options3 = {}) {
        const { success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: "getSystemInfo",
            success,
            fail,
            complete
        });
        try {
            const info = yield getSystemInfoSync();
            return handle.success(info);
        } catch (error) {
            return handle.fail({
                errMsg: error
            });
        }
    });
var getSkylineInfoSync = temporarilyNotSupport("getSkylineInfoSync");
var getSkylineInfo = temporarilyNotSupport("getSkylineInfo");
var getRendererUserAgent = temporarilyNotSupport("getRendererUserAgent");
// node_modules/@tarojs/taro-h5/dist/api/base/update.js
var updateWeChatApp = temporarilyNotSupport("updateWeChatApp");
var getUpdateManager = temporarilyNotSupport("getUpdateManager");
// node_modules/lodash-es/isNil.js
function isNil(value) {
    return value == null;
}
var isNil_default = isNil;
// node_modules/@tarojs/taro-h5/node_modules/query-string/base.js
var base_exports = {};
(0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__export)(base_exports, {
    exclude: ()=>exclude,
    extract: ()=>extract,
    parse: ()=>parse,
    parseUrl: ()=>parseUrl,
    pick: ()=>pick,
    stringify: ()=>stringify2,
    stringifyUrl: ()=>stringifyUrl
});
// node_modules/@tarojs/taro-h5/node_modules/decode-uri-component/index.js
var token = "%[a-f0-9]{2}";
var singleMatcher = new RegExp("(" + token + ")|([^%]+?)", "gi");
var multiMatcher = new RegExp("(" + token + ")+", "gi");
function decodeComponents(components, split2) {
    try {
        return [
            decodeURIComponent(components.join(""))
        ];
    } catch (e) {}
    if (components.length === 1) {
        return components;
    }
    split2 = split2 || 1;
    const left = components.slice(0, split2);
    const right = components.slice(split2);
    return Array.prototype.concat.call([], decodeComponents(left), decodeComponents(right));
}
function decode(input) {
    try {
        return decodeURIComponent(input);
    } catch (e) {
        let tokens = input.match(singleMatcher) || [];
        for(let i2 = 1; i2 < tokens.length; i2++){
            input = decodeComponents(tokens, i2).join("");
            tokens = input.match(singleMatcher) || [];
        }
        return input;
    }
}
function customDecodeURIComponent(input) {
    const replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
    };
    let match2 = multiMatcher.exec(input);
    while(match2){
        try {
            replaceMap[match2[0]] = decodeURIComponent(match2[0]);
        } catch (e) {
            const result = decode(match2[0]);
            if (result !== match2[0]) {
                replaceMap[match2[0]] = result;
            }
        }
        match2 = multiMatcher.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    const entries = Object.keys(replaceMap);
    for (const key of entries){
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
}
function decodeUriComponent(encodedURI) {
    if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
        return decodeURIComponent(encodedURI);
    } catch (e) {
        return customDecodeURIComponent(encodedURI);
    }
}
// node_modules/filter-obj/index.js
function includeKeys(object2, predicate) {
    const result = {};
    if (Array.isArray(predicate)) {
        for (const key of predicate){
            const descriptor = Object.getOwnPropertyDescriptor(object2, key);
            if (descriptor === null || descriptor === void 0 ? void 0 : descriptor.enumerable) {
                Object.defineProperty(result, key, descriptor);
            }
        }
    } else {
        for (const key of Reflect.ownKeys(object2)){
            const descriptor = Object.getOwnPropertyDescriptor(object2, key);
            if (descriptor.enumerable) {
                const value = object2[key];
                if (predicate(key, value, object2)) {
                    Object.defineProperty(result, key, descriptor);
                }
            }
        }
    }
    return result;
}
// node_modules/split-on-first/index.js
function splitOnFirst(string2, separator) {
    if (!(typeof string2 === "string" && typeof separator === "string")) {
        throw new TypeError("Expected the arguments to be of type `string`");
    }
    if (string2 === "" || separator === "") {
        return [];
    }
    const separatorIndex = string2.indexOf(separator);
    if (separatorIndex === -1) {
        return [];
    }
    return [
        string2.slice(0, separatorIndex),
        string2.slice(separatorIndex + separator.length)
    ];
}
// node_modules/@tarojs/taro-h5/node_modules/query-string/base.js
var isNullOrUndefined = (value)=>value === null || value === void 0;
var strictUriEncode = (string2)=>encodeURIComponent(string2).replaceAll(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);
var encodeFragmentIdentifier = Symbol("encodeFragmentIdentifier");
function encoderForArrayFormat(options3) {
    switch(options3.arrayFormat){
        case "index":
            {
                return (key)=>(result, value)=>{
                        const index = result.length;
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[",
                                    index,
                                    "]"
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode(key, options3),
                                "[",
                                encode(index, options3),
                                "]=",
                                encode(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "bracket":
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    "[]"
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode(key, options3),
                                "[]=",
                                encode(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "colon-list-separator":
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode(key, options3),
                                    ":list="
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode(key, options3),
                                ":list=",
                                encode(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "comma":
        case "separator":
        case "bracket-separator":
            {
                const keyValueSeparator = options3.arrayFormat === "bracket-separator" ? "[]=" : "=";
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        value = value === null ? "" : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode(key, options3),
                                    keyValueSeparator,
                                    encode(value, options3)
                                ].join("")
                            ];
                        }
                        return [
                            [
                                result,
                                encode(value, options3)
                            ].join(options3.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                encode(key, options3)
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode(key, options3),
                                "=",
                                encode(value, options3)
                            ].join("")
                        ];
                    };
            }
    }
}
function parserForArrayFormat(options3) {
    let result;
    switch(options3.arrayFormat){
        case "index":
            {
                return (key, value, accumulator)=>{
                    result = /\[(\d*)]$/.exec(key);
                    key = key.replace(/\[\d*]$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = {};
                    }
                    accumulator[key][result[1]] = value;
                };
            }
        case "bracket":
            {
                return (key, value, accumulator)=>{
                    result = /(\[])$/.exec(key);
                    key = key.replace(/\[]$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = [
                            value
                        ];
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        value
                    ];
                };
            }
        case "colon-list-separator":
            {
                return (key, value, accumulator)=>{
                    result = /(:list)$/.exec(key);
                    key = key.replace(/:list$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = [
                            value
                        ];
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        value
                    ];
                };
            }
        case "comma":
        case "separator":
            {
                return (key, value, accumulator)=>{
                    const isArray2 = typeof value === "string" && value.includes(options3.arrayFormatSeparator);
                    const newValue = isArray2 ? value.split(options3.arrayFormatSeparator).map((item)=>decode2(item, options3)) : value === null ? value : decode2(value, options3);
                    accumulator[key] = newValue;
                };
            }
        case "bracket-separator":
            {
                return (key, value, accumulator)=>{
                    const isArray2 = /(\[])$/.test(key);
                    key = key.replace(/\[]$/, "");
                    if (!isArray2) {
                        accumulator[key] = value ? decode2(value, options3) : value;
                        return;
                    }
                    const arrayValue = value === null ? [] : decode2(value, options3).split(options3.arrayFormatSeparator);
                    if (accumulator[key] === void 0) {
                        accumulator[key] = arrayValue;
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        ...arrayValue
                    ];
                };
            }
        default:
            {
                return (key, value, accumulator)=>{
                    if (accumulator[key] === void 0) {
                        accumulator[key] = value;
                        return;
                    }
                    accumulator[key] = [
                        ...[
                            accumulator[key]
                        ].flat(),
                        value
                    ];
                };
            }
    }
}
function validateArrayFormatSeparator(value) {
    if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
    }
}
function encode(value, options3) {
    if (options3.encode) {
        return options3.strict ? strictUriEncode(value) : encodeURIComponent(value);
    }
    return value;
}
function decode2(value, options3) {
    if (options3.decode) {
        return decodeUriComponent(value);
    }
    return value;
}
function keysSorter(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === "object") {
        return keysSorter(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash(url) {
    let hash = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function parseValue(value, options3, type) {
    if (type === "string" && typeof value === "string") {
        return value;
    }
    if (typeof type === "function" && typeof value === "string") {
        return type(value);
    }
    if (type === "boolean" && value === null) {
        return true;
    }
    if (type === "boolean" && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
    }
    if (type === "boolean" && value !== null && (value.toLowerCase() === "1" || value.toLowerCase() === "0")) {
        return value.toLowerCase() === "1";
    }
    if (type === "string[]" && options3.arrayFormat !== "none" && typeof value === "string") {
        return [
            value
        ];
    }
    if (type === "number[]" && options3.arrayFormat !== "none" && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return [
            Number(value)
        ];
    }
    if (type === "number" && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return Number(value);
    }
    if (options3.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
    }
    if (options3.parseNumbers && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return Number(value);
    }
    return value;
}
function extract(input) {
    input = removeHash(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
        return "";
    }
    return input.slice(queryStart + 1);
}
function parse(query, options3) {
    options3 = _object_spread({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false,
        types: /* @__PURE__ */ Object.create(null)
    }, options3);
    validateArrayFormatSeparator(options3.arrayFormatSeparator);
    const formatter = parserForArrayFormat(options3);
    const returnValue = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
        return returnValue;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
        return returnValue;
    }
    for (const parameter of query.split("&")){
        if (parameter === "") {
            continue;
        }
        const parameter_ = options3.decode ? parameter.replaceAll("+", " ") : parameter;
        let [key, value] = splitOnFirst(parameter_, "=");
        if (key === void 0) {
            key = parameter_;
        }
        value = value === void 0 ? null : [
            "comma",
            "separator",
            "bracket-separator"
        ].includes(options3.arrayFormat) ? value : decode2(value, options3);
        formatter(decode2(key, options3), value, returnValue);
    }
    for (const [key, value] of Object.entries(returnValue)){
        if (typeof value === "object" && value !== null && options3.types[key] !== "string") {
            for (const [key2, value2] of Object.entries(value)){
                const typeOption = options3.types[key];
                const type = typeof typeOption === "function" ? typeOption : typeOption ? typeOption.replace("[]", "") : void 0;
                value[key2] = parseValue(value2, options3, type);
            }
        } else if (typeof value === "object" && value !== null && options3.types[key] === "string") {
            returnValue[key] = Object.values(value).join(options3.arrayFormatSeparator);
        } else {
            returnValue[key] = parseValue(value, options3, options3.types[key]);
        }
    }
    if (options3.sort === false) {
        return returnValue;
    }
    return (options3.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options3.sort)).reduce((result, key)=>{
        const value = returnValue[key];
        result[key] = Boolean(value) && typeof value === "object" && !Array.isArray(value) ? keysSorter(value) : value;
        return result;
    }, /* @__PURE__ */ Object.create(null));
}
function stringify2(object2, options3) {
    if (!object2) {
        return "";
    }
    options3 = _object_spread({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
    }, options3);
    validateArrayFormatSeparator(options3.arrayFormatSeparator);
    const shouldFilter = (key)=>options3.skipNull && isNullOrUndefined(object2[key]) || options3.skipEmptyString && object2[key] === "";
    const formatter = encoderForArrayFormat(options3);
    const objectCopy = {};
    for (const [key, value] of Object.entries(object2)){
        if (!shouldFilter(key)) {
            objectCopy[key] = value;
        }
    }
    const keys2 = Object.keys(objectCopy);
    if (options3.sort !== false) {
        keys2.sort(options3.sort);
    }
    return keys2.map((key)=>{
        let value = object2[key];
        if (options3.replacer) {
            value = options3.replacer(key, value);
            if (value === void 0) {
                return "";
            }
        }
        if (value === void 0) {
            return "";
        }
        if (value === null) {
            return encode(key, options3);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options3.arrayFormat === "bracket-separator") {
                return encode(key, options3) + "[]";
            }
            let processedArray = value;
            if (options3.replacer) {
                processedArray = value.map((item, index)=>options3.replacer(`${key}[${index}]`, item)).filter((item)=>item !== void 0);
            }
            return processedArray.reduce(formatter(key), []).join("&");
        }
        return encode(key, options3) + "=" + encode(value, options3);
    }).filter((x)=>x.length > 0).join("&");
}
function parseUrl(url, options3) {
    var _url__split;
    options3 = _object_spread({
        decode: true
    }, options3);
    let [url_, hash] = splitOnFirst(url, "#");
    if (url_ === void 0) {
        url_ = url;
    }
    var _url__split_;
    return _object_spread({
        url: (_url__split_ = url_ === null || url_ === void 0 ? void 0 : (_url__split = url_.split("?")) === null || _url__split === void 0 ? void 0 : _url__split[0]) !== null && _url__split_ !== void 0 ? _url__split_ : "",
        query: parse(extract(url), options3)
    }, options3 && options3.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode2(hash, options3)
    } : {});
}
function stringifyUrl(object2, options3) {
    options3 = _object_spread({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier]: true
    }, options3);
    const url = removeHash(object2.url).split("?")[0] || "";
    const queryFromUrl = extract(object2.url);
    const query = _object_spread({}, parse(queryFromUrl, _object_spread({
        sort: false
    }, options3)), object2.query);
    let queryString = stringify2(query, options3);
    queryString && (queryString = `?${queryString}`);
    let hash = getHash(object2.url);
    if (typeof object2.fragmentIdentifier === "string") {
        const urlObjectForFragmentEncode = new URL(url);
        urlObjectForFragmentEncode.hash = object2.fragmentIdentifier;
        hash = options3[encodeFragmentIdentifier] ? urlObjectForFragmentEncode.hash : `#${object2.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
}
function pick(input, filter2, options3) {
    options3 = _object_spread({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier]: false
    }, options3);
    const { url, query, fragmentIdentifier } = parseUrl(input, options3);
    return stringifyUrl({
        url,
        query: includeKeys(query, filter2),
        fragmentIdentifier
    }, options3);
}
function exclude(input, filter2, options3) {
    const exclusionFilter = Array.isArray(filter2) ? (key)=>!filter2.includes(key) : (key, value)=>!filter2(key, value);
    return pick(input, exclusionFilter, options3);
}
// node_modules/@tarojs/taro-h5/node_modules/query-string/index.js
var query_string_default = base_exports;
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/app-event.js
var unhandledRejectionCallbackManager = new CallbackManager();
var themeChangeCallbackManager = new CallbackManager();
var pageNotFoundCallbackManager = new CallbackManager();
var errorCallbackManager = new CallbackManager();
var appShowCallbackManager = new CallbackManager();
var appHideCallbackManager = new CallbackManager();
var unhandledRejectionListener = (res)=>{
    unhandledRejectionCallbackManager.trigger(res);
};
var themeMatchMedia = null;
var themeChangeListener = (res)=>{
    themeChangeCallbackManager.trigger({
        theme: res.matches ? "light" : "dark"
    });
};
var pageNotFoundListener = (res)=>{
    pageNotFoundCallbackManager.trigger(res);
};
var errorListener = (res)=>{
    errorCallbackManager.trigger(res.stack || res.message || res);
};
var getApp = ()=>{
    var _a;
    const path = (_a = Taro.Current.page) === null || _a === void 0 ? void 0 : _a.path;
    return {
        /**  */ path: (path === null || path === void 0 ? void 0 : path.substring(0, path.indexOf("?"))) || "",
        /**  query  */ query: query_string_default.parse(location.search),
        /**  */ referrerInfo: {},
        /** [](https://developers.weixin.qq.com/miniprogram/dev/framework/app-service/scene.html) */ scene: 0,
        /** shareTicket[](https://developers.weixin.qq.com/miniprogram/dev/framework/open-ability/share.html) */ shareTicket: ""
    };
};
var appShowListener = ()=>{
    if (document.visibilityState !== "hidden") {
        appShowCallbackManager.trigger(getApp());
    }
};
var appHideListener = ()=>{
    if (document.visibilityState === "hidden") {
        appHideCallbackManager.trigger(getApp());
    }
};
var onUnhandledRejection = (callback)=>{
    unhandledRejectionCallbackManager.add(callback);
    if (unhandledRejectionCallbackManager.count() === 1) {
        window.addEventListener("unhandledrejection", unhandledRejectionListener);
    }
};
var onThemeChange = (callback)=>{
    themeChangeCallbackManager.add(callback);
    if (themeChangeCallbackManager.count() === 1) {
        if (isNil_default(themeMatchMedia)) {
            themeMatchMedia = window.matchMedia("(prefers-color-scheme: light)");
        }
        themeMatchMedia.addEventListener("change", themeChangeListener);
    }
};
var onPageNotFound = (callback)=>{
    pageNotFoundCallbackManager.add(callback);
    if (pageNotFoundCallbackManager.count() === 1) {
        Taro.eventCenter.on("__taroRouterNotFound", pageNotFoundListener);
    }
};
var onLazyLoadError = temporarilyNotSupport("onLazyLoadError");
var onError = (callback)=>{
    errorCallbackManager.add(callback);
    if (errorCallbackManager.count() === 1) {
        window.addEventListener("error", errorListener);
    }
};
var onAudioInterruptionEnd = temporarilyNotSupport("onAudioInterruptionEnd");
var onAudioInterruptionBegin = temporarilyNotSupport("onAudioInterruptionBegin");
var onAppShow = (callback)=>{
    appShowCallbackManager.add(callback);
    if (appShowCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appShowListener);
    }
};
var onAppHide = (callback)=>{
    appHideCallbackManager.add(callback);
    if (appHideCallbackManager.count() === 1) {
        window.addEventListener("visibilitychange", appHideListener);
    }
};
var offUnhandledRejection = (callback)=>{
    unhandledRejectionCallbackManager.remove(callback);
    if (unhandledRejectionCallbackManager.count() === 0) {
        window.removeEventListener("unhandledrejection", unhandledRejectionListener);
    }
};
var offThemeChange = (callback)=>{
    themeChangeCallbackManager.remove(callback);
    if (themeChangeCallbackManager.count() === 0) {
        if (isNil_default(themeMatchMedia)) {
            themeMatchMedia = window.matchMedia("(prefers-color-scheme: light)");
        }
        themeMatchMedia.removeEventListener("change", themeChangeListener);
        themeMatchMedia = null;
    }
};
var offPageNotFound = (callback)=>{
    pageNotFoundCallbackManager.remove(callback);
    if (pageNotFoundCallbackManager.count() === 0) {
        Taro.eventCenter.off("__taroRouterNotFound", pageNotFoundListener);
    }
};
var offLazyLoadError = temporarilyNotSupport("offLazyLoadError");
var offError = (callback)=>{
    errorCallbackManager.remove(callback);
    if (errorCallbackManager.count() === 0) {
        window.removeEventListener("error", errorListener);
    }
};
var offAudioInterruptionEnd = temporarilyNotSupport("offAudioInterruptionEnd");
var offAudioInterruptionBegin = temporarilyNotSupport("offAudioInterruptionBegin");
var offAppShow = (callback)=>{
    appShowCallbackManager.remove(callback);
    if (appShowCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appShowListener);
    }
};
var offAppHide = (callback)=>{
    appHideCallbackManager.remove(callback);
    if (appHideCallbackManager.count() === 0) {
        window.removeEventListener("visibilitychange", appHideListener);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/base/weapp/life-cycle.js
var launchOptions = {
    path: "",
    query: {},
    scene: 0,
    shareTicket: "",
    referrerInfo: {}
};
function initLaunchOptions(options3 = {}) {
    Object.assign(launchOptions, options3);
}
Taro.eventCenter.once("__taroRouterLaunch", initLaunchOptions);
var getLaunchOptionsSync = ()=>launchOptions;
var getEnterOptionsSync = ()=>launchOptions;
// node_modules/@tarojs/taro-h5/dist/api/base/index.js
var env = {
    FRAMEWORK: "react",
    TARO_ENV: "h5",
    TARO_PLATFORM: "web",
    TARO_VERSION: "4.1.11"
};
function arrayBufferToBase64(arrayBuffer) {
    return (0, import_base64_js.fromByteArray)(arrayBuffer);
}
function base64ToArrayBuffer(base64) {
    return (0, import_base64_js.toByteArray)(base64).buffer;
}
// node_modules/@tarojs/taro-h5/dist/api/canvas/CanvasContext.js
var TextBaseLineMap = {
    top: "top",
    bottom: "bottom",
    middle: "middle",
    normal: "alphabetic",
    hanging: "hanging",
    alphabetic: "alphabetic",
    ideographic: "ideographic"
};
var CanvasContext = class {
    set ctx(e) {
        this.__raw__ = e;
    }
    get ctx() {
        return this.__raw__ || {};
    }
    emptyActions() {
        this.actions.length = 0;
    }
    enqueueActions(func, ...args) {
        this.actions.push({
            func,
            args
        });
    }
    set fillStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = e;
        });
    }
    get fillStyle() {
        return this.ctx.fillStyle;
    }
    set font(e) {
        this.ctx.font = e;
    }
    get font() {
        return this.ctx.font;
    }
    set globalAlpha(e) {
        this.enqueueActions(()=>{
            this.ctx.globalAlpha = e;
        });
    }
    get globalAlpha() {
        return this.ctx.globalAlpha;
    }
    set globalCompositeOperation(e) {
        this.enqueueActions(()=>{
            this.ctx.globalCompositeOperation = e;
        });
    }
    get globalCompositeOperation() {
        return this.ctx.globalCompositeOperation;
    }
    set lineCap(e) {
        this.enqueueActions(()=>{
            this.ctx.lineCap = e;
        });
    }
    get lineCap() {
        return this.ctx.lineCap;
    }
    set lineDashOffset(e) {
        this.enqueueActions(()=>{
            this.ctx.lineDashOffset = e;
        });
    }
    get lineDashOffset() {
        return this.ctx.lineDashOffset;
    }
    set lineJoin(e) {
        this.enqueueActions(()=>{
            this.ctx.lineJoin = e;
        });
    }
    get lineJoin() {
        return this.ctx.lineJoin;
    }
    set lineWidth(e) {
        this.enqueueActions(()=>{
            this.ctx.lineWidth = e;
        });
    }
    get lineWidth() {
        return this.ctx.lineWidth;
    }
    set miterLimit(e) {
        this.enqueueActions(()=>{
            this.ctx.miterLimit = e;
        });
    }
    get miterLimit() {
        return this.ctx.miterLimit;
    }
    set shadowBlur(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowBlur = e;
        });
    }
    get shadowBlur() {
        return this.ctx.shadowBlur;
    }
    set shadowColor(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowColor = e;
        });
    }
    get shadowColor() {
        return this.ctx.shadowColor;
    }
    set shadowOffsetX(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = e;
        });
    }
    get shadowOffsetX() {
        return this.ctx.shadowOffsetX;
    }
    set shadowOffsetY(e) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetY = e;
        });
    }
    get shadowOffsetY() {
        return this.ctx.shadowOffsetY;
    }
    set strokeStyle(e) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = e;
        });
    }
    get strokeStyle() {
        return this.ctx.strokeStyle;
    }
    /**   */ set textAlign(e) {
        this.ctx.textAlign = e;
    }
    get textAlign() {
        return this.ctx.textAlign;
    }
    set textBaseline(e) {
        this.ctx.textBaseline = e;
    }
    get textBaseline() {
        return this.ctx.textBaseline;
    }
    set direction(e) {
        this.ctx.direction = e;
    }
    get direction() {
        return this.ctx.direction;
    }
    set imageSmoothingEnabled(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingEnabled = e;
        });
    }
    get imageSmoothingEnabled() {
        return this.ctx.imageSmoothingEnabled;
    }
    set imageSmoothingQuality(e) {
        this.enqueueActions(()=>{
            this.ctx.imageSmoothingQuality = e;
        });
    }
    get imageSmoothingQuality() {
        return this.ctx.imageSmoothingQuality;
    }
    set filter(e) {
        this.enqueueActions(()=>{
            this.ctx.filter = e;
        });
    }
    get filter() {
        return this.ctx.filter;
    }
    /**   */ arc(...args) {
        return this.enqueueActions(this.ctx.arc, ...args);
    }
    arcTo(...args) {
        return this.enqueueActions(this.ctx.arcTo, ...args);
    }
    beginPath(...args) {
        return this.enqueueActions(this.ctx.beginPath, ...args);
    }
    bezierCurveTo(...args) {
        return this.enqueueActions(this.ctx.bezierCurveTo, ...args);
    }
    clearRect(...args) {
        return this.enqueueActions(this.ctx.clearRect, ...args);
    }
    clip(...args) {
        return this.enqueueActions(this.ctx.clip, ...args);
    }
    closePath(...args) {
        return this.enqueueActions(this.ctx.closePath, ...args);
    }
    createPattern(imageResource, repetition) {
        if (typeof imageResource === "string") {
            const img = new Image();
            img.src = imageResource;
            return new Promise((resolve, reject)=>{
                img.onload = ()=>{
                    resolve(this.ctx.createPattern(img, repetition));
                };
                img.onerror = reject;
            });
        }
        return this.ctx.createPattern(imageResource, repetition);
    }
    /**
   *  canvas 
   * @todo  draw  width  height
   */ draw(reserve, callback) {
        return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
            try {
                if (!reserve) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
                for (const { func, args } of this.actions){
                    yield func.apply(this.ctx, args);
                }
                this.emptyActions();
                callback && callback();
            } catch (e) {
                throw {
                    errMsg: e.message
                };
            }
        });
    }
    drawImage(imageResource, ...extra) {
        this.enqueueActions(()=>{
            if (typeof imageResource === "string") {
                const img = new Image();
                img.src = imageResource;
                return new Promise((resolve, reject)=>{
                    img.onload = ()=>{
                        this.ctx.drawImage(img, ...extra);
                        resolve();
                    };
                    img.onerror = reject;
                });
            }
            this.ctx.drawImage(imageResource, ...extra);
        });
    }
    fill(...args) {
        return this.enqueueActions(this.ctx.fill, ...args);
    }
    fillRect(...args) {
        return this.enqueueActions(this.ctx.fillRect, ...args);
    }
    fillText(...args) {
        return this.enqueueActions(this.ctx.fillText, ...args);
    }
    lineTo(...args) {
        return this.enqueueActions(this.ctx.lineTo, ...args);
    }
    moveTo(...args) {
        return this.enqueueActions(this.ctx.moveTo, ...args);
    }
    quadraticCurveTo(...args) {
        return this.enqueueActions(this.ctx.quadraticCurveTo, ...args);
    }
    rect(...args) {
        return this.enqueueActions(this.ctx.rect, ...args);
    }
    // @ts-ignore
    reset() {
        return this.ctx.reset();
    }
    restore() {
        return this.ctx.restore();
    }
    rotate(...args) {
        return this.enqueueActions(this.ctx.rotate, ...args);
    }
    save() {
        return this.ctx.save();
    }
    scale(...args) {
        return this.enqueueActions(this.ctx.scale, ...args);
    }
    setFillStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.fillStyle = color;
        });
    }
    setFontSize(fontSize) {
        const arr = this.font.split(/\s/);
        const idx = arr.findIndex((e)=>/^\d+px$/.test(e));
        if (idx !== -1) {
            arr[idx] = `${fontSize}px`;
            this.font = arr.join(" ");
        }
    }
    setGlobalAlpha(alpha) {
        this.globalAlpha = alpha;
    }
    setLineCap(lineCap) {
        this.lineCap = lineCap;
    }
    setLineDash(pattern, offset) {
        this.enqueueActions(()=>{
            this.ctx.setLineDash(pattern);
            this.ctx.lineDashOffset = offset;
        });
    }
    setLineJoin(lineJoin) {
        this.lineJoin = lineJoin;
    }
    setLineWidth(lineWidth) {
        this.lineWidth = lineWidth;
    }
    setMiterLimit(miterLimit) {
        this.miterLimit = miterLimit;
    }
    setShadow(offsetX, offsetY, blur, color) {
        this.enqueueActions(()=>{
            this.ctx.shadowOffsetX = offsetX;
            this.ctx.shadowOffsetY = offsetY;
            this.ctx.shadowColor = color;
            this.ctx.shadowBlur = blur;
        });
    }
    setStrokeStyle(color) {
        this.enqueueActions(()=>{
            this.ctx.strokeStyle = color;
        });
    }
    setTextAlign(align) {
        this.textAlign = align;
    }
    setTextBaseline(textBaseline) {
        this.textBaseline = TextBaseLineMap[textBaseline] || "alphabetic";
    }
    setTransform(...args) {
        return this.enqueueActions(this.ctx.setTransform, ...args);
    }
    stroke(...args) {
        return this.enqueueActions(this.ctx.stroke, ...args);
    }
    strokeRect(...args) {
        return this.enqueueActions(this.ctx.strokeRect, ...args);
    }
    strokeText(...args) {
        return this.enqueueActions(this.ctx.strokeText, ...args);
    }
    transform(...args) {
        return this.enqueueActions(this.ctx.transform, ...args);
    }
    translate(...args) {
        return this.enqueueActions(this.ctx.translate, ...args);
    }
    measureText(text) {
        return this.ctx.measureText(text);
    }
    createCircularGradient(x, y, r) {
        const radialGradient = this.ctx.createRadialGradient(x, y, 0, x, y, r);
        return radialGradient;
    }
    createLinearGradient(x0, y0, x1, y1) {
        return this.ctx.createLinearGradient(x0, y0, x1, y1);
    }
    constructor(canvas, ctx){
        this.actions = [];
        this.canvas = canvas;
        this.ctx = ctx;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/createCanvasContext.js
var createCanvasContext = (canvasId, inst)=>{
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
    const context = new CanvasContext(canvas, ctx);
    if (!ctx) return context;
    context.canvas = canvas;
    context.ctx = ctx;
    return context;
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasToTempFilePath.js
var canvasToTempFilePath = ({ canvasId, fileType, quality, success, fail, complete }, inst)=>{
    const handle = new MethodHandler({
        name: "canvasToTempFilePath",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const dataURL = canvas === null || canvas === void 0 ? void 0 : canvas.toDataURL(`image/${(fileType === "jpg" ? "jpeg" : fileType) || "png"}`, quality);
        return handle.success({
            tempFilePath: dataURL
        });
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasPutImageData.js
var canvasPutImageData = ({ canvasId, data, x, y, success, fail, complete }, inst)=>{
    const handle = new MethodHandler({
        name: "canvasPutImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas.getContext("2d");
        ctx === null || ctx === void 0 ? void 0 : ctx.putImageData(data, x, y);
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/canvasGetImageData.js
var canvasGetImageData = ({ canvasId, success, fail, complete, x, y, width, height }, inst)=>{
    const handle = new MethodHandler({
        name: "canvasGetImageData",
        success,
        fail,
        complete
    });
    const el = findDOM(inst);
    const canvas = el === null || el === void 0 ? void 0 : el.querySelector(`canvas[canvas-id="${canvasId}"]`);
    try {
        const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext("2d");
        const data = ctx === null || ctx === void 0 ? void 0 : ctx.getImageData(x, y, width, height);
        return handle.success({
            width,
            height,
            data
        });
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/canvas/index.js
var createOffscreenCanvas = temporarilyNotSupport("createOffscreenCanvas");
// node_modules/@tarojs/taro-h5/dist/api/cloud/index.js
var cloud = class {
    constructor(){
        this.init = temporarilyNotSupport("cloud.init");
        this.CloudID = temporarilyNotSupport("cloud.CloudID");
        this.callFunction = temporarilyNotSupport("cloud.callFunction");
        this.uploadFile = temporarilyNotSupport("cloud.uploadFile");
        this.downloadFile = temporarilyNotSupport("cloud.downloadFile");
        this.getTempFileURL = temporarilyNotSupport("cloud.getTempFileURL");
        this.deleteFile = temporarilyNotSupport("cloud.deleteFile");
        this.database = temporarilyNotSupport("cloud.database");
        this.callContainer = temporarilyNotSupport("cloud.callContainer");
    }
};
// node_modules/@tarojs/taro-h5/dist/api/data-analysis/index.js
var reportMonitor = temporarilyNotSupport("reportMonitor");
var reportAnalytics = temporarilyNotSupport("reportAnalytics");
var reportEvent = temporarilyNotSupport("reportEvent");
var getExptInfoSync = temporarilyNotSupport("getExptInfoSync");
// node_modules/lodash-es/now.js
var now = function() {
    return root_default.Date.now();
};
var now_default = now;
// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
    var index = string2.length;
    while(index-- && reWhitespace.test(string2.charAt(index))){}
    return index;
}
var trimmedEndIndex_default = trimmedEndIndex;
// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
    return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;
// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
    if (typeof value == "number") {
        return value;
    }
    if (isSymbol_default(value)) {
        return NAN;
    }
    if (isObject_default(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject_default(other) ? other + "" : other;
    }
    if (typeof value != "string") {
        return value === 0 ? value : +value;
    }
    value = baseTrim_default(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;
// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT2 = "Expected a function";
var nativeMax = Math.max;
var nativeMin = Math.min;
function debounce(func, wait, options3) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT2);
    }
    wait = toNumber_default(wait) || 0;
    if (isObject_default(options3)) {
        leading = !!options3.leading;
        maxing = "maxWait" in options3;
        maxWait = maxing ? nativeMax(toNumber_default(options3.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options3 ? !!options3.trailing : trailing;
    }
    function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
    }
    function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
    }
    function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
        var time = now_default();
        if (shouldInvoke(time)) {
            return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
            return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
    }
    function cancel() {
        if (timerId !== void 0) {
            clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush2() {
        return timerId === void 0 ? result : trailingEdge(now_default());
    }
    function debounced() {
        var time = now_default(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
            if (timerId === void 0) {
                return leadingEdge(lastCallTime);
            }
            if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout(timerExpired, wait);
                return invokeFunc(lastCallTime);
            }
        }
        if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
        }
        return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush2;
    return debounced;
}
var debounce_default = debounce;
// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT3 = "Expected a function";
function throttle(func, wait, options3) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT3);
    }
    if (isObject_default(options3)) {
        leading = "leading" in options3 ? !!options3.leading : leading;
        trailing = "trailing" in options3 ? !!options3.trailing : trailing;
    }
    return debounce_default(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
    });
}
var throttle_default = throttle;
// node_modules/@tarojs/taro-h5/dist/api/device/accelerometer.js
var callbackManager = new CallbackManager();
var devicemotionListener;
var stopAccelerometer = ({ success, fail, complete } = {})=>{
    const res = {};
    const handle = new MethodHandler({
        name: "stopAccelerometer",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("devicemotion", devicemotionListener, true);
        return handle.success(res);
    } catch (e) {
        res.errMsg = e.message;
        return handle.fail(res);
    }
};
var INTERVAL_MAP = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var startAccelerometer = ({ interval = "normal", success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "startAccelerometer",
        success,
        fail,
        complete
    });
    try {
        if (window.DeviceMotionEvent) {
            const intervalObj = INTERVAL_MAP[interval];
            if (devicemotionListener) {
                stopAccelerometer();
            }
            devicemotionListener = throttle_default((evt)=>{
                var _a, _b, _c;
                callbackManager.trigger({
                    x: ((_a = evt.acceleration) === null || _a === void 0 ? void 0 : _a.x) || 0,
                    y: ((_b = evt.acceleration) === null || _b === void 0 ? void 0 : _b.y) || 0,
                    z: ((_c = evt.acceleration) === null || _c === void 0 ? void 0 : _c.z) || 0
                });
            }, intervalObj.interval);
            window.addEventListener("devicemotion", devicemotionListener, true);
        } else {
            throw new Error("accelerometer is not supported");
        }
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
var onAccelerometerChange = (callback)=>{
    callbackManager.add(callback);
};
var offAccelerometerChange = (callback)=>{
    callbackManager.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/accessibility.js
var checkIsOpenAccessibility = temporarilyNotSupport("checkIsOpenAccessibility");
// node_modules/@tarojs/taro-h5/dist/api/device/battery.js
var getBatteryInfoSync = permanentlyNotSupport("getBatteryInfoSync");
var getBatteryInfo = (...args_1)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_1
    ], void 0, function*({ success, fail, complete } = {}) {
        var _a;
        const handle = new MethodHandler({
            name: "getBatteryInfo",
            success,
            fail,
            complete
        });
        try {
            const battery = yield (_a = navigator.getBattery) === null || _a === void 0 ? void 0 : _a.call(navigator);
            return handle.success({
                isCharging: battery.charging,
                level: Number(battery.level || 0) * 100
            });
        } catch (error) {
            return handle.fail({
                errMsg: (error === null || error === void 0 ? void 0 : error.message) || error
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth.js
var stopBluetoothDevicesDiscovery = temporarilyNotSupport("stopBluetoothDevicesDiscovery");
var startBluetoothDevicesDiscovery = temporarilyNotSupport("startBluetoothDevicesDiscovery");
var openBluetoothAdapter = temporarilyNotSupport("openBluetoothAdapter");
var onBluetoothDeviceFound = temporarilyNotSupport("onBluetoothDeviceFound");
var onBluetoothAdapterStateChange = temporarilyNotSupport("onBluetoothAdapterStateChange");
var offBluetoothDeviceFound = temporarilyNotSupport("offBluetoothDeviceFound");
var offBluetoothAdapterStateChange = temporarilyNotSupport("offBluetoothAdapterStateChange");
var makeBluetoothPair = temporarilyNotSupport("makeBluetoothPair");
var isBluetoothDevicePaired = temporarilyNotSupport("isBluetoothDevicePaired");
var getConnectedBluetoothDevices = temporarilyNotSupport("getConnectedBluetoothDevices");
var getBluetoothDevices = temporarilyNotSupport("getBluetoothDevices");
var getBluetoothAdapterState = temporarilyNotSupport("getBluetoothAdapterState");
var closeBluetoothAdapter = temporarilyNotSupport("closeBluetoothAdapter");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-ble.js
var writeBLECharacteristicValue = temporarilyNotSupport("writeBLECharacteristicValue");
var setBLEMTU = temporarilyNotSupport("setBLEMTU");
var readBLECharacteristicValue = temporarilyNotSupport("readBLECharacteristicValue");
var onBLEMTUChange = temporarilyNotSupport("onBLEMTUChange");
var onBLEConnectionStateChange = temporarilyNotSupport("onBLEConnectionStateChange");
var onBLECharacteristicValueChange = temporarilyNotSupport("onBLECharacteristicValueChange");
var offBLEMTUChange = temporarilyNotSupport("offBLEMTUChange");
var offBLEConnectionStateChange = temporarilyNotSupport("offBLEConnectionStateChange");
var offBLECharacteristicValueChange = temporarilyNotSupport("offBLECharacteristicValueChange");
var notifyBLECharacteristicValueChange = temporarilyNotSupport("notifyBLECharacteristicValueChange");
var getBLEMTU = temporarilyNotSupport("getBLEMTU");
var getBLEDeviceServices = temporarilyNotSupport("getBLEDeviceServices");
var getBLEDeviceRSSI = temporarilyNotSupport("getBLEDeviceRSSI");
var getBLEDeviceCharacteristics = temporarilyNotSupport("getBLEDeviceCharacteristics");
var createBLEConnection = temporarilyNotSupport("createBLEConnection");
var closeBLEConnection = temporarilyNotSupport("closeBLEConnection");
// node_modules/@tarojs/taro-h5/dist/api/device/bluetooth-peripheral.js
var onBLEPeripheralConnectionStateChanged = temporarilyNotSupport("onBLEPeripheralConnectionStateChanged");
var offBLEPeripheralConnectionStateChanged = temporarilyNotSupport("offBLEPeripheralConnectionStateChanged");
var createBLEPeripheralServer = temporarilyNotSupport("createBLEPeripheralServer");
// node_modules/@tarojs/taro-h5/dist/api/device/calendar.js
var ics = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_dist2());
var addPhoneRepeatCalendar = (options3)=>{
    const methodName = "addPhoneRepeatCalendar";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, startTime = /* @__PURE__ */ new Date().getTime(), allDay = false, description = "", location: location2 = "", endTime, alarm = true, alarmOffset = 0, repeatInterval = "month", repeatEndTime, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof title !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    const start = new Date(startTime);
    const end = new Date(endTime || startTime);
    if (!endTime && allDay) {
        end.setDate(end.getDate() + 1);
    }
    const interval = 1e3 * 60 * 60 * 24;
    let days = 1;
    let repeat = 1;
    if (repeatEndTime) {
        const repeatEnd = new Date(repeatEndTime);
        if (repeatEnd < start) {
            return handle.fail({
                errMsg: "repeatEndTime must be greater than startTime"
            });
        }
        switch(repeatInterval){
            case "week":
                days = 7;
                break;
            case "month":
                days = 30;
                break;
            case "year":
                days = 365;
                break;
            default:
        }
        repeat = Math.ceil((repeatEnd.getTime() - start.getTime()) / (interval * days));
    }
    const { error, value } = ics.createEvent({
        title,
        start: parseTime2Array(start, allDay),
        description,
        location: location2,
        end: parseTime2Array(end, allDay),
        alarms: alarm ? [
            {
                action: "display",
                description,
                trigger: {
                    before: true,
                    seconds: alarmOffset
                },
                duration: {
                    days
                },
                repeat
            }
        ] : []
    });
    if (error || !value) {
        return handle.fail({
            errMsg: error === null || error === void 0 ? void 0 : error.message
        });
    }
    const url = URL.createObjectURL(new Blob([
        value
    ]));
    createDownload(url, `${title}.ics`);
    return handle.success();
};
var addPhoneCalendar = (options3)=>{
    const methodName = "addPhoneCalendar";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, startTime = /* @__PURE__ */ new Date().getTime(), allDay = false, description = "", location: location2 = "", endTime, alarm = true, alarmOffset = 0, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof title !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    const start = new Date(startTime);
    const end = new Date(endTime || startTime);
    if (!endTime && allDay) {
        end.setDate(end.getDate() + 1);
    }
    const { error, value } = ics.createEvent({
        title,
        start: parseTime2Array(start, allDay),
        description,
        location: location2,
        end: parseTime2Array(end, allDay),
        alarms: alarm ? [
            {
                action: "display",
                description,
                trigger: {
                    before: true,
                    seconds: alarmOffset
                }
            }
        ] : []
    });
    if (error || !value) {
        return handle.fail({
            errMsg: error === null || error === void 0 ? void 0 : error.message
        });
    }
    const url = URL.createObjectURL(new Blob([
        value
    ]));
    createDownload(url, `${title}.ics`);
    return handle.success();
};
function parseTime2Array(time, allDay = false) {
    const t = new Date(time);
    const timeArr = [
        t.getFullYear(),
        t.getMonth() + 1,
        t.getDate()
    ];
    if (!allDay) {
        timeArr.push(t.getHours(), t.getMinutes());
    }
    return timeArr;
}
// node_modules/@tarojs/taro-h5/dist/api/storage/background-fetch.js
var setBackgroundFetchToken = temporarilyNotSupport("setBackgroundFetchToken");
var onBackgroundFetchData = temporarilyNotSupport("onBackgroundFetchData");
var getBackgroundFetchToken = temporarilyNotSupport("getBackgroundFetchToken");
var getBackgroundFetchData = temporarilyNotSupport("getBackgroundFetchData");
// node_modules/@tarojs/taro-h5/dist/api/storage/cache-manager.js
var createCacheManager = temporarilyNotSupport("createCacheManager");
// node_modules/@tarojs/taro-h5/dist/api/storage/index.js
function getItem(key) {
    let item;
    try {
        item = JSON.parse(localStorage.getItem(key) || "");
    } catch (e) {}
    if (item && typeof item === "object" && item.hasOwnProperty("data")) {
        return {
            result: true,
            data: item.data
        };
    } else {
        return {
            result: false
        };
    }
}
var setStorageSync = (key, data = "")=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "setStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const type = typeof data;
    let obj = {};
    if (type === "symbol") {
        obj = {
            data: ""
        };
    } else {
        obj = {
            data
        };
    }
    localStorage.setItem(key, JSON.stringify(obj));
};
var setStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, data, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    setStorageSync(key, data);
    return handle.success();
};
var revokeBufferURL = temporarilyNotSupport("revokeBufferURL");
var removeStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "removeStorage",
            correct: "String",
            wrong: key
        }));
        return;
    }
    localStorage.removeItem(key);
};
var removeStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `removeStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "removeStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    removeStorageSync(key);
    return handle.success();
};
var getStorageSync = (key)=>{
    if (typeof key !== "string") {
        console.error(getParameterError({
            name: "getStorageSync",
            correct: "String",
            wrong: key
        }));
        return;
    }
    const res = getItem(key);
    if (res.result) return res.data;
    return "";
};
var getStorageInfoSync = ()=>{
    const res = {
        keys: Object.keys(localStorage),
        limitSize: NaN,
        currentSize: NaN
    };
    return res;
};
var getStorageInfo = ({ success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "getStorageInfo",
        success,
        fail,
        complete
    });
    return handle.success(getStorageInfoSync());
};
var getStorage = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getStorage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { key, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "getStorage",
        success,
        fail,
        complete
    });
    if (typeof key !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "key",
                correct: "String",
                wrong: key
            })
        });
    }
    const { result, data } = getItem(key);
    if (result) {
        return handle.success({
            data
        });
    } else {
        return handle.fail({
            errMsg: "data not found"
        });
    }
};
var createBufferURL = temporarilyNotSupport("createBufferURL");
var clearStorageSync = ()=>{
    localStorage.clear();
};
var clearStorage = ({ success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "clearStorage",
        success,
        fail,
        complete
    });
    clearStorageSync();
    return handle.success();
};
var batchSetStorageSync = temporarilyNotSupport("batchSetStorageSync");
var batchSetStorage = temporarilyNotSupport("batchSetStorage");
var batchGetStorageSync = temporarilyNotSupport("batchGetStorageSync");
var batchGetStorage = temporarilyNotSupport("batchGetStorage");
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/actionSheet.js
var noop = function() {};
var ActionSheet = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            const { maskStyle, actionSheetStyle, menuStyle, cellStyle, titleStyle, cancelStyle } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            this.el = document.createElement("div");
            this.el.className = "taro__actionSheet";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            this.mask = document.createElement("div");
            this.mask.setAttribute("style", inlineStyle(maskStyle));
            this.actionSheet = document.createElement("div");
            this.actionSheet.setAttribute("style", inlineStyle(actionSheetStyle));
            this.menu = document.createElement("div");
            this.menu.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, menuStyle), {
                color: config.itemColor
            })));
            this.cells = config.itemList.map((item, index)=>{
                const cell = document.createElement("div");
                cell.className = "taro-actionsheet__cell";
                cell.setAttribute("style", inlineStyle(cellStyle));
                cell.textContent = item;
                cell.dataset.tapIndex = `${index}`;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index2 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index2);
                };
                return cell;
            });
            this.title = document.createElement("div");
            this.title.setAttribute("style", inlineStyle(titleStyle));
            this.title.className = "taro-actionsheet__cell";
            this.title.textContent = config.alertText;
            this.title.style.display = config.alertText ? "block" : "none";
            this.cancel = document.createElement("div");
            this.cancel.setAttribute("style", inlineStyle(cancelStyle));
            this.cancel.textContent = "\u53D6\u6D88";
            this.menu.appendChild(this.title);
            this.cells.forEach((item)=>this.menu.appendChild(item));
            this.actionSheet.appendChild(this.menu);
            this.actionSheet.appendChild(this.cancel);
            this.el.appendChild(this.mask);
            this.el.appendChild(this.actionSheet);
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.lastConfig = config;
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            if (config.itemColor) this.menu.style.color = config.itemColor;
            const { cellStyle } = this.style;
            config.itemList.forEach((item, index)=>{
                let cell;
                if (this.cells[index]) {
                    cell = this.cells[index];
                } else {
                    cell = document.createElement("div");
                    cell.className = "taro-actionsheet__cell";
                    cell.setAttribute("style", inlineStyle(cellStyle));
                    cell.dataset.tapIndex = `${index}`;
                    this.cells.push(cell);
                    this.menu.appendChild(cell);
                }
                cell.textContent = item;
                cell.onclick = (e)=>{
                    this.hide();
                    const target = e.currentTarget;
                    const index2 = Number(target === null || target === void 0 ? void 0 : target.dataset.tapIndex) || 0;
                    resolve(index2);
                };
            });
            const cellsLen = this.cells.length;
            const itemListLen = config.itemList.length;
            if (cellsLen > itemListLen) {
                for(let i2 = itemListLen; i2 < cellsLen; i2++){
                    this.menu.removeChild(this.cells[i2]);
                }
                this.cells.splice(itemListLen);
            }
            this.title.textContent = config.alertText;
            this.title.style.display = config.alertText ? "block" : "none";
            const cb = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.mask.onclick = cb;
            this.cancel.onclick = cb;
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
                setTransform(this.actionSheet, "translate(0, 0)");
            }, 0);
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            setTransform(this.actionSheet, "translate(0, 100%)");
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            alertText: "",
            itemList: [],
            itemColor: "#000000",
            success: noop,
            fail: noop,
            complete: noop
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            actionSheetStyle: {
                "z-index": "4999",
                position: "fixed",
                left: "0",
                bottom: "0",
                "-webkit-transform": "translate(0, 100%)",
                transform: "translate(0, 100%)",
                width: "100%",
                "line-height": "1.6",
                background: "#EFEFF4",
                "-webkit-transition": "-webkit-transform .3s",
                transition: "transform .3s",
                "border-radius": "15px 15px 0 0"
            },
            menuStyle: {
                "background-color": "#FCFCFD",
                "border-radius": "15px 15px 0 0"
            },
            cellStyle: {
                position: "relative",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px"
            },
            titleStyle: {
                position: "relative",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "16px",
                color: "rgba(0,0,0,0.8)",
                display: "none"
            },
            cancelStyle: {
                "margin-top": "6px",
                padding: "10px 0",
                "text-align": "center",
                "font-size": "18px",
                color: "#000000",
                "background-color": "#FCFCFD"
            }
        };
        this.lastConfig = {};
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/modal.js
var Modal = class {
    create(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const { maskStyle, modalStyle, titleStyle, textStyle, footStyle, btnStyle } = this.style;
            const config = Object.assign(Object.assign({}, this.options), options3);
            this.el = document.createElement("div");
            this.el.className = "taro__modal";
            this.el.style.opacity = "0";
            this.el.style.transition = "opacity 0.2s linear";
            const eventHandler = (e)=>{
                e.stopPropagation();
                e.preventDefault();
            };
            const mask = document.createElement("div");
            mask.className = "taro-modal__mask";
            mask.setAttribute("style", inlineStyle(maskStyle));
            mask.ontouchmove = eventHandler;
            const modal2 = document.createElement("div");
            modal2.className = "taro-modal__content";
            modal2.setAttribute("style", inlineStyle(modalStyle));
            modal2.ontouchmove = eventHandler;
            const titleCSS = config.title ? titleStyle : Object.assign(Object.assign({}, titleStyle), {
                display: "none"
            });
            this.title = document.createElement("div");
            this.title.className = "taro-modal__title";
            this.title.setAttribute("style", inlineStyle(titleCSS));
            this.title.textContent = config.title;
            const textCSS = config.title ? textStyle : Object.assign(Object.assign({}, textStyle), {
                padding: "40px 20px 26px",
                color: "#353535"
            });
            this.text = document.createElement("div");
            this.text.className = "taro-modal__text";
            this.text.setAttribute("style", inlineStyle(textCSS));
            this.text.textContent = config.content;
            const foot = document.createElement("div");
            foot.className = "taro-modal__foot";
            foot.setAttribute("style", inlineStyle(footStyle));
            const cancelCSS = Object.assign(Object.assign({}, btnStyle), {
                color: config.cancelColor,
                display: config.showCancel ? "block" : "none"
            });
            this.cancel = document.createElement("div");
            this.cancel.className = "taro-model__btn taro-model__cancel";
            this.cancel.setAttribute("style", inlineStyle(cancelCSS));
            this.cancel.textContent = config.cancelText;
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm = document.createElement("div");
            this.confirm.className = "taro-model__btn taro-model__confirm";
            this.confirm.setAttribute("style", inlineStyle(btnStyle));
            this.confirm.style.color = config.confirmColor;
            this.confirm.textContent = config.confirmText;
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            foot.appendChild(this.cancel);
            foot.appendChild(this.confirm);
            modal2.appendChild(this.title);
            modal2.appendChild(this.text);
            modal2.appendChild(foot);
            this.el.appendChild(mask);
            this.el.appendChild(modal2);
            document.body.appendChild(this.el);
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    show(options3 = {}) {
        return new Promise((resolve)=>{
            var _a, _b;
            const config = Object.assign(Object.assign({}, this.options), options3);
            if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
            if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
            const { textStyle } = this.style;
            if (config.title) {
                this.title.textContent = config.title;
                this.title.style.display = "block";
                this.text.setAttribute("style", inlineStyle(textStyle));
            } else {
                this.title.textContent = "";
                this.title.style.display = "none";
                const textCSS = Object.assign(Object.assign({}, textStyle), {
                    padding: "40px 20px 26px",
                    color: "#353535"
                });
                this.text.setAttribute("style", inlineStyle(textCSS));
            }
            this.text.textContent = config.content || "";
            this.cancel.style.display = config.showCancel ? "block" : "none";
            this.cancel.textContent = config.cancelText || "";
            this.cancel.style.color = config.cancelColor || "";
            this.confirm.textContent = config.confirmText || "";
            this.confirm.style.color = config.confirmColor || "";
            this.cancel.onclick = ()=>{
                this.hide();
                resolve("cancel");
            };
            this.confirm.onclick = ()=>{
                this.hide();
                resolve("confirm");
            };
            this.el.style.display = "block";
            setTimeout(()=>{
                this.el.style.opacity = "1";
            }, 0);
            this.currentPath = (_b = (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        });
    }
    hide() {
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 200);
        }, 0);
    }
    constructor(){
        this.options = {
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0",
                background: "rgba(0,0,0,0.6)"
            },
            modalStyle: {
                "z-index": "4999",
                position: "fixed",
                top: "50%",
                left: "50%",
                transform: "translate(-50%, -50%)",
                width: "80%",
                "max-width": "300px",
                "border-radius": "3px",
                "text-align": "center",
                "line-height": "1.6",
                overflow: "hidden",
                background: "#FFFFFF"
            },
            titleStyle: {
                padding: "20px 24px 9px",
                "font-size": "18px"
            },
            textStyle: {
                padding: "0 24px 12px",
                "min-height": "40px",
                "font-size": "15px",
                "line-height": "1.3",
                color: "#808080",
                "word-wrap": "break-word",
                "word-break": "break-all"
            },
            footStyle: {
                position: "relative",
                "line-height": "48px",
                "font-size": "18px",
                display: "flex"
            },
            btnStyle: {
                position: "relative",
                "-webkit-box-flex": "1",
                "-webkit-flex": "1",
                flex: "1"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/toast.js
var Toast = class {
    create(options3 = {}, _type = "toast") {
        var _a, _b;
        const { maskStyle, toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle, textStyle } = this.style;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        this.el = document.createElement("div");
        this.el.className = "taro__toast";
        this.el.style.opacity = "0";
        this.el.style.transition = "opacity 0.1s linear";
        this.el.ontouchmove = (e)=>{
            e.stopPropagation();
            e.preventDefault();
        };
        this.mask = document.createElement("div");
        this.mask.setAttribute("style", inlineStyle(maskStyle));
        this.mask.style.display = config.mask ? "block" : "none";
        this.icon = document.createElement("p");
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                display: "none"
            } : {})));
        }
        this.toast = document.createElement("div");
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.title = document.createElement("p");
        this.title.setAttribute("style", inlineStyle(textStyle));
        this.title.textContent = config.title;
        this.toast.appendChild(this.icon);
        this.toast.appendChild(this.title);
        this.el.appendChild(this.mask);
        this.el.appendChild(this.toast);
        document.body.appendChild(this.el);
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    show(options3 = {}, _type = "toast") {
        var _a, _b;
        const config = Object.assign(Object.assign(Object.assign({}, this.options), options3), {
            _type
        });
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.title.textContent = config.title || "";
        this.mask.style.display = config.mask ? "block" : "none";
        const { toastStyle, successStyle, errrorStyle, loadingStyle, imageStyle } = this.style;
        if (config.image) {
            this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, imageStyle), {
                "background-image": `url(${config.image})`
            })));
        } else {
            if (!config.image && config.icon) {
                const iconStyle = config.icon === "loading" ? loadingStyle : config.icon === "error" ? errrorStyle : successStyle;
                this.icon.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, iconStyle), config.icon === "none" ? {
                    display: "none"
                } : {})));
            }
        }
        this.toast.setAttribute("style", inlineStyle(Object.assign(Object.assign({}, toastStyle), config.icon === "none" ? {
            "min-height": "0",
            padding: "10px 15px"
        } : {})));
        this.el.style.display = "block";
        setTimeout(()=>{
            this.el.style.opacity = "1";
        }, 0);
        this.type = config._type;
        config.duration >= 0 && this.hide(config.duration, this.type);
        this.currentPath = (_b = (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path) !== null && _b !== void 0 ? _b : getCurrentPath();
        return "";
    }
    hide(duration = 0, type = "") {
        if (type && type !== this.type) return;
        if (this.hideOpacityTimer) clearTimeout(this.hideOpacityTimer);
        if (this.hideDisplayTimer) clearTimeout(this.hideDisplayTimer);
        this.currentPath = null;
        this.hideOpacityTimer = setTimeout(()=>{
            this.el.style.opacity = "0";
            this.hideDisplayTimer = setTimeout(()=>{
                this.el.style.display = "none";
            }, 100);
        }, duration);
    }
    constructor(){
        this.options = {
            title: "",
            icon: "none",
            image: "",
            duration: 1500,
            mask: false
        };
        this.style = {
            maskStyle: {
                position: "fixed",
                "z-index": "1000",
                top: "0",
                right: "0",
                left: "0",
                bottom: "0"
            },
            toastStyle: {
                "z-index": "5000",
                "box-sizing": "border-box",
                display: "flex",
                "flex-direction": "column",
                "justify-content": "center",
                "-webkit-justify-content": "center",
                position: "fixed",
                top: "50%",
                left: "50%",
                "min-width": "120px",
                "max-width": "200px",
                "min-height": "120px",
                padding: "15px",
                transform: "translate(-50%, -50%)",
                "border-radius": "5px",
                "text-align": "center",
                "line-height": "1.6",
                color: "#FFFFFF",
                background: "rgba(17, 17, 17, 0.7)"
            },
            successStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTQ4OTYzMjA0IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjQzNDgiIHdpZHRoPSIyMDAiIGhlaWdodD0iMjAwIj48cGF0aCBkPSJNMjE5Ljk1MiA1MTIuNTc2bDIxMC40MzIgMjEwLjQzMi00NS4yNDggNDUuMjU2LTIxMC40MzItMjEwLjQzMnoiIHAtaWQ9IjQzNDkiIGZpbGw9IiNmZmZmZmYiPjwvcGF0aD48cGF0aCBkPSJNNzk5LjY3MiAyNjIuMjY0bDQ1LjI1NiA0NS4yNTYtNDYwLjQ2NCA0NjAuNDY0LTQ1LjI1Ni00NS4yNTZ6IiBwLWlkPSI0MzUwIiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            errrorStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB0PSIxNjM5NTUxMDU1MTgzIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjE0MDc2IiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNTggNjQgNjQgMjY0LjU4IDY0IDUxMnMyMDAuNTggNDQ4IDQ0OCA0NDggNDQ4LTIwMC41OCA0NDgtNDQ4Uzc1OS40MiA2NCA1MTIgNjR6IG0wIDc1MmEzNiAzNiAwIDEgMSAzNi0zNiAzNiAzNiAwIDAgMS0zNiAzNnogbTUxLjgzLTU1MS45NUw1NDggNjM2YTM2IDM2IDAgMCAxLTcyIDBsLTE1LjgzLTM3MS45NWMtMC4xLTEuMzMtMC4xNy0yLjY4LTAuMTctNC4wNWE1MiA1MiAwIDAgMSAxMDQgMGMwIDEuMzctMC4wNyAyLjcyLTAuMTcgNC4wNXoiIHAtaWQ9IjE0MDc3IiBmaWxsPSIjZmZmZmZmIj48L3BhdGg+PC9zdmc+) no-repeat",
                "background-size": "100%"
            },
            loadingStyle: {
                margin: "6px auto",
                width: "38px",
                height: "38px",
                "-webkit-animation": "taroLoading 1s steps(12, end) infinite",
                animation: "taroLoading 1s steps(12, end) infinite",
                background: "transparent url(data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiB2aWV3Qm94PSIwIDAgMTAwIDEwMCI+PHBhdGggZmlsbD0ibm9uZSIgZD0iTTAgMGgxMDB2MTAwSDB6Ii8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTlFOUU5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDAgLTMwKSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iIzk4OTY5NyIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgzMCAxMDUuOTggNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjOUI5OTlBIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDYwIDc1Ljk4IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0EzQTFBMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSg5MCA2NSA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNBQkE5QUEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoMTIwIDU4LjY2IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0IyQjJCMiIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgxNTAgNTQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjQkFCOEI5IiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKDE4MCA1MCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDMkMwQzEiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTE1MCA0NS45OCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNDQkNCQ0IiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTEyMCA0MS4zNCA2NSkiLz48cmVjdCB3aWR0aD0iNyIgaGVpZ2h0PSIyMCIgeD0iNDYuNSIgeT0iNDAiIGZpbGw9IiNEMkQyRDIiIHJ4PSI1IiByeT0iNSIgdHJhbnNmb3JtPSJyb3RhdGUoLTkwIDM1IDY1KSIvPjxyZWN0IHdpZHRoPSI3IiBoZWlnaHQ9IjIwIiB4PSI0Ni41IiB5PSI0MCIgZmlsbD0iI0RBREFEQSIgcng9IjUiIHJ5PSI1IiB0cmFuc2Zvcm09InJvdGF0ZSgtNjAgMjQuMDIgNjUpIi8+PHJlY3Qgd2lkdGg9IjciIGhlaWdodD0iMjAiIHg9IjQ2LjUiIHk9IjQwIiBmaWxsPSIjRTJFMkUyIiByeD0iNSIgcnk9IjUiIHRyYW5zZm9ybT0icm90YXRlKC0zMCAtNS45OCA2NSkiLz48L3N2Zz4=) no-repeat",
                "background-size": "100%"
            },
            imageStyle: {
                margin: "6px auto",
                width: "40px",
                height: "40px",
                background: "transparent no-repeat",
                "background-size": "100%"
            },
            textStyle: {
                margin: "0",
                "font-size": "16px"
            }
        };
    }
};
// node_modules/@tarojs/taro-h5/dist/api/ui/interaction/index.js
var status = "default";
function init(doc3) {
    if (status === "ready") return;
    const taroStyle = doc3.createElement("style");
    taroStyle.textContent = '@font-face{font-weight:normal;font-style:normal;font-family:"taro";src:url("data:application/x-font-ttf;charset=utf-8;base64, AAEAAAALAIAAAwAwR1NVQrD+s+0AAAE4AAAAQk9TLzJWs0t/AAABfAAAAFZjbWFwqVgGvgAAAeAAAAGGZ2x5Zph7qG0AAANwAAAAdGhlYWQRFoGhAAAA4AAAADZoaGVhCCsD7AAAALwAAAAkaG10eAg0AAAAAAHUAAAADGxvY2EADAA6AAADaAAAAAhtYXhwAQ4AJAAAARgAAAAgbmFtZYrphEEAAAPkAAACVXBvc3S3shtSAAAGPAAAADUAAQAAA+gAAABaA+gAAAAAA+gAAQAAAAAAAAAAAAAAAAAAAAMAAQAAAAEAAADih+FfDzz1AAsD6AAAAADXB57LAAAAANcHnssAAP/sA+gDOgAAAAgAAgAAAAAAAAABAAAAAwAYAAEAAAAAAAIAAAAKAAoAAAD/AAAAAAAAAAEAAAAKAB4ALAABREZMVAAIAAQAAAAAAAAAAQAAAAFsaWdhAAgAAAABAAAAAQAEAAQAAAABAAgAAQAGAAAAAQAAAAAAAQK8AZAABQAIAnoCvAAAAIwCegK8AAAB4AAxAQIAAAIABQMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUGZFZABAAHjqCAPoAAAAWgPoABQAAAABAAAAAAAAA+gAAABkAAAD6AAAAAAABQAAAAMAAAAsAAAABAAAAV4AAQAAAAAAWAADAAEAAAAsAAMACgAAAV4ABAAsAAAABgAEAAEAAgB46gj//wAAAHjqCP//AAAAAAABAAYABgAAAAEAAgAAAQYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAAAAAAAKAAAAAAAAAACAAAAeAAAAHgAAAABAADqCAAA6ggAAAACAAAAAAAAAAwAOgABAAD/7AAyABQAAgAANzMVFB4UKAAAAAABAAAAAAO7AzoAFwAAEy4BPwE+AR8BFjY3ATYWFycWFAcBBiInPQoGBwUHGgzLDCELAh0LHwsNCgr9uQoeCgGzCyEOCw0HCZMJAQoBvgkCCg0LHQv9sQsKAAAAAAAAEgDeAAEAAAAAAAAAHQAAAAEAAAAAAAEABAAdAAEAAAAAAAIABwAhAAEAAAAAAAMABAAoAAEAAAAAAAQABAAsAAEAAAAAAAUACwAwAAEAAAAAAAYABAA7AAEAAAAAAAoAKwA/AAEAAAAAAAsAEwBqAAMAAQQJAAAAOgB9AAMAAQQJAAEACAC3AAMAAQQJAAIADgC/AAMAAQQJAAMACADNAAMAAQQJAAQACADVAAMAAQQJAAUAFgDdAAMAAQQJAAYACADzAAMAAQQJAAoAVgD7AAMAAQQJAAsAJgFRCiAgQ3JlYXRlZCBieSBmb250LWNhcnJpZXIKICB3ZXVpUmVndWxhcndldWl3ZXVpVmVyc2lvbiAxLjB3ZXVpR2VuZXJhdGVkIGJ5IHN2ZzJ0dGYgZnJvbSBGb250ZWxsbyBwcm9qZWN0Lmh0dHA6Ly9mb250ZWxsby5jb20ACgAgACAAQwByAGUAYQB0AGUAZAAgAGIAeQAgAGYAbwBuAHQALQBjAGEAcgByAGkAZQByAAoAIAAgAHcAZQB1AGkAUgBlAGcAdQBsAGEAcgB3AGUAdQBpAHcAZQB1AGkAVgBlAHIAcwBpAG8AbgAgADEALgAwAHcAZQB1AGkARwBlAG4AZQByAGEAdABlAGQAIABiAHkAIABzAHYAZwAyAHQAdABmACAAZgByAG8AbQAgAEYAbwBuAHQAZQBsAGwAbwAgAHAAcgBvAGoAZQBjAHQALgBoAHQAdABwADoALwAvAGYAbwBuAHQAZQBsAGwAbwAuAGMAbwBtAAAAAAIAAAAAAAAACgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwECAQMBBAABeAd1bmlFQTA4AAAAAAA=") format("truetype");}@-webkit-keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}@keyframes taroLoading{0%{-webkit-transform:rotate3d(0, 0, 1, 0deg);}100%{-webkit-transform:rotate3d(0, 0, 1, 360deg);transform:rotate3d(0, 0, 1, 360deg);}}.taro-modal__foot:after {content: "";position: absolute;left: 0;top: 0;right: 0;height: 1px;border-top: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);} .taro-model__btn:active {background-color: #EEEEEE}.taro-model__btn:not(:first-child):after {content: "";position: absolute;left: 0;top: 0;width: 1px;bottom: 0;border-left: 1px solid #D5D5D6;color: #D5D5D6;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleX(0.5);transform: scaleX(0.5);}.taro-actionsheet__cell:not(:last-child):after {content: "";position: absolute;left: 0;bottom: 0;right: 0;height: 1px;border-top: 1px solid #e5e5e5;color: #e5e5e5;-webkit-transform-origin: 0 0;transform-origin: 0 0;-webkit-transform: scaleY(0.5);transform: scaleY(0.5);}';
    doc3.querySelector("head").appendChild(taroStyle);
    status = "ready";
}
var toast = new Toast();
var modal = new Modal();
var actionSheet = new ActionSheet();
var showToast = (options3 = {
    title: ""
})=>{
    init(document);
    options3 = Object.assign({
        title: "",
        icon: "success",
        image: "",
        duration: 1500,
        mask: false
    }, options3);
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "showToast",
        success,
        fail,
        complete
    });
    if (typeof options3.title !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    if (typeof options3.duration !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "duration",
                correct: "Number",
                wrong: options3.duration
            })
        });
    }
    if (options3.image && typeof options3.image !== "string") options3.image = "";
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "toast");
    } else {
        errMsg = toast.show(options3, "toast");
    }
    return handle.success({
        errMsg
    });
};
var hideToast = ({ noConflict = false, success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "hideToast",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle.success();
    toast.hide(0, noConflict ? "toast" : "");
    return handle.success();
};
var showLoading = (options3 = {
    title: ""
})=>{
    init(document);
    options3 = Object.assign({
        title: "",
        mask: false
    }, options3);
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "showLoading",
        success,
        fail,
        complete
    });
    const config = {
        icon: "loading",
        image: "",
        duration: -1
    };
    options3 = Object.assign({}, options3, config);
    if (typeof options3.title !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: options3.title
            })
        });
    }
    options3.mask = !!options3.mask;
    let errMsg = "";
    if (!toast.el) {
        errMsg = toast.create(options3, "loading");
    } else {
        errMsg = toast.show(options3, "loading");
    }
    return handle.success({
        errMsg
    });
};
var hideLoading = ({ noConflict = false, success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "hideLoading",
        success,
        fail,
        complete
    });
    if (!toast.el) return handle.success();
    toast.hide(0, noConflict ? "loading" : "");
    return handle.success();
};
var showModal = (...args_1)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_1
    ], void 0, function*(options3 = {}) {
        init(document);
        options3 = Object.assign({
            title: "",
            content: "",
            showCancel: true,
            cancelText: "\u53D6\u6D88",
            cancelColor: "#000000",
            confirmText: "\u786E\u5B9A",
            confirmColor: "#3CC51F"
        }, options3);
        const { success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: "showModal",
            success,
            fail,
            complete
        });
        if (typeof options3.title !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "title",
                    correct: "String",
                    wrong: options3.title
                })
            });
        }
        if (typeof options3.content !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "content",
                    correct: "String",
                    wrong: options3.content
                })
            });
        }
        if (typeof options3.cancelText !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "cancelText",
                    correct: "String",
                    wrong: options3.cancelText
                })
            });
        }
        if (options3.cancelText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle.fail({
                errMsg: "cancelText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.confirmText !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "confirmText",
                    correct: "String",
                    wrong: options3.confirmText
                })
            });
        }
        if (options3.confirmText.replace(/[\u0391-\uFFE5]/g, "aa").length > 8) {
            return handle.fail({
                errMsg: "confirmText length should not larger then 4 Chinese characters"
            });
        }
        if (typeof options3.cancelColor !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "cancelColor",
                    correct: "String",
                    wrong: options3.cancelColor
                })
            });
        }
        if (typeof options3.confirmColor !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "confirmColor",
                    correct: "String",
                    wrong: options3.confirmColor
                })
            });
        }
        options3.showCancel = !!options3.showCancel;
        let result = "";
        if (!modal.el) {
            result = yield modal.create(options3);
        } else {
            result = yield modal.show(options3);
        }
        const res = {
            cancel: false,
            confirm: false
        };
        res[result] = true;
        return handle.success(res);
    });
function hideModal() {
    if (!modal.el) return;
    modal.hide();
}
var showActionSheet = (...args_2)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_2
    ], void 0, function*(options3 = {
        itemList: []
    }, methodName = "showActionSheet") {
        init(document);
        options3 = Object.assign({
            itemColor: "#000000",
            itemList: []
        }, options3);
        const { success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: methodName,
            success,
            fail,
            complete
        });
        if (!Array.isArray(options3.itemList)) {
            return handle.fail({
                errMsg: getParameterError({
                    para: "itemList",
                    correct: "Array",
                    wrong: options3.itemList
                })
            });
        }
        if (options3.itemList.length < 1) {
            return handle.fail({
                errMsg: "parameter error: parameter.itemList should have at least 1 item"
            });
        }
        if (options3.itemList.length > 6) {
            return handle.fail({
                errMsg: "parameter error: parameter.itemList should not be large than 6"
            });
        }
        for(let i2 = 0; i2 < options3.itemList.length; i2++){
            if (typeof options3.itemList[i2] !== "string") {
                return handle.fail({
                    errMsg: getParameterError({
                        para: `itemList[${i2}]`,
                        correct: "String",
                        wrong: options3.itemList[i2]
                    })
                });
            }
        }
        if (typeof options3.itemColor !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "itemColor",
                    correct: "String",
                    wrong: options3.itemColor
                })
            });
        }
        let result = "";
        if (!actionSheet.el) {
            result = yield actionSheet.create(options3);
        } else {
            result = yield actionSheet.show(options3);
        }
        if (typeof result === "string") {
            return handle.fail({
                errMsg: result
            });
        } else {
            return handle.success({
                tapIndex: result
            });
        }
    });
Taro.eventCenter.on("__afterTaroRouterChange", ()=>{
    var _a, _b;
    if (toast.currentPath && toast.currentPath !== ((_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path)) {
        hideToast();
        hideLoading();
    }
    if (modal.currentPath && modal.currentPath !== ((_b = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _b === void 0 ? void 0 : _b.path)) {
        hideModal();
    }
});
var enableAlertBeforeUnload = temporarilyNotSupport("enableAlertBeforeUnload");
var disableAlertBeforeUnload = temporarilyNotSupport("disableAlertBeforeUnload");
// node_modules/@tarojs/taro-h5/dist/api/device/clipboard.js
var CLIPBOARD_STORAGE_NAME = "taro_clipboard";
document.addEventListener("copy", ()=>{
    var _a;
    setStorage({
        key: CLIPBOARD_STORAGE_NAME,
        data: (_a = window.getSelection()) === null || _a === void 0 ? void 0 : _a.toString()
    }).catch((e)=>{
        console.error(e);
    });
});
var setClipboardData = (_a)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        _a
    ], void 0, function*({ data, success, fail, complete }) {
        const handle = new MethodHandler({
            name: "setClipboardData",
            success,
            fail,
            complete
        });
        try {
            setStorageSync(CLIPBOARD_STORAGE_NAME, data);
            if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(document.execCommand)) {
                const textarea = document.createElement("textarea");
                textarea.readOnly = true;
                textarea.value = data;
                textarea.style.position = "absolute";
                textarea.style.width = "100px";
                textarea.style.left = "-10000px";
                document.body.appendChild(textarea);
                textarea.select();
                textarea.setSelectionRange(0, textarea.value.length);
                document.execCommand("copy");
                document.body.removeChild(textarea);
            } else {
                throw new Error("Unsupported Function: 'document.execCommand'.");
            }
            showToast({
                title: "\u5185\u5BB9\u5DF2\u590D\u5236",
                icon: "none",
                duration: 1500
            });
            return handle.success();
        } catch (e) {
            return handle.fail({
                errMsg: e.message
            });
        }
    });
var getClipboardData = (...args_1)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, [
        ...args_1
    ], void 0, function*({ success, fail, complete } = {}) {
        const handle = new MethodHandler({
            name: "getClipboardData",
            success,
            fail,
            complete
        });
        try {
            const data = getStorageSync(CLIPBOARD_STORAGE_NAME);
            return handle.success({
                data
            });
        } catch (e) {
            return handle.fail({
                errMsg: e.message
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/device/compass.js
var callbackManager2 = new CallbackManager();
var compassListener;
var deviceorientationEventName = [
    "absolutedeviceorientation",
    "deviceorientationabsolute",
    "deviceorientation"
].find((item)=>{
    if ("on" + item in window) {
        return item;
    }
}) || "";
var stopCompass = ({ success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "stopCompass",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener(deviceorientationEventName, compassListener, true);
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
var CompassChangeTrigger = false;
var startCompass = ({ success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "startCompass",
        success,
        fail,
        complete
    });
    try {
        if (deviceorientationEventName !== "") {
            if (compassListener) {
                stopCompass();
            }
            compassListener = throttle_default((evt)=>{
                const isAndroid = getDeviceInfo().system === "AndroidOS";
                if (isAndroid && !evt.absolute && !CompassChangeTrigger) {
                    CompassChangeTrigger = true;
                    console.warn("Warning: In 'onCompassChange', your browser is not supported to get the orientation relative to the earth, the orientation data will be related to the initial orientation of the device .");
                }
                const alpha = evt.alpha || 0;
                const accuracy = isAndroid ? evt.absolute ? "high" : "medium" : alpha;
                callbackManager2.trigger({
                    direction: 360 - alpha,
                    accuracy
                });
            }, 5e3);
            window.addEventListener(deviceorientationEventName, compassListener, true);
        } else {
            throw new Error("compass is not supported");
        }
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
var onCompassChange = (callback)=>{
    callbackManager2.add(callback);
};
var offCompassChange = (callback)=>{
    callbackManager2.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/contact.js
var chooseContact = temporarilyNotSupport("chooseContact");
var addPhoneContact = temporarilyNotSupport("addPhoneContact");
// node_modules/@tarojs/taro-h5/dist/api/device/crypto.js
var getRandomValues = temporarilyNotSupport("getRandomValues");
// node_modules/@tarojs/taro-h5/dist/api/device/gyroscope.js
var stopGyroscope = temporarilyNotSupport("stopGyroscope");
var startGyroscope = temporarilyNotSupport("startGyroscope");
var onGyroscopeChange = temporarilyNotSupport("onGyroscopeChange");
var offGyroscopeChange = temporarilyNotSupport("offGyroscopeChange");
// node_modules/@tarojs/taro-h5/dist/api/device/iBeacon.js
var stopBeaconDiscovery = temporarilyNotSupport("stopBeaconDiscovery");
var startBeaconDiscovery = temporarilyNotSupport("startBeaconDiscovery");
var onBeaconUpdate = temporarilyNotSupport("onBeaconUpdate");
var onBeaconServiceChange = temporarilyNotSupport("onBeaconServiceChange");
var offBeaconUpdate = temporarilyNotSupport("offBeaconUpdate");
var offBeaconServiceChange = temporarilyNotSupport("offBeaconServiceChange");
var getBeacons = temporarilyNotSupport("getBeacons");
// node_modules/@tarojs/taro-h5/dist/api/device/keyboard.js
var onKeyboardHeightChange = temporarilyNotSupport("onKeyboardHeightChange");
var offKeyboardHeightChange = temporarilyNotSupport("offKeyboardHeightChange");
var hideKeyboard = temporarilyNotSupport("hideKeyboard");
var getSelectedTextRange = temporarilyNotSupport("getSelectedTextRange");
// node_modules/@tarojs/taro-h5/dist/api/device/memory.js
var onMemoryWarning = temporarilyNotSupport("onMemoryWarning");
var offMemoryWarning = temporarilyNotSupport("offMemoryWarning");
// node_modules/@tarojs/taro-h5/dist/api/device/motion.js
var callbackManager3 = new CallbackManager();
var deviceMotionListener;
var INTERVAL_MAP2 = {
    game: {
        interval: 20,
        frequency: 50
    },
    ui: {
        interval: 60,
        frequency: 16.67
    },
    normal: {
        interval: 200,
        frequency: 5
    }
};
var stopDeviceMotionListening = ({ success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "stopDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        window.removeEventListener("deviceorientation", deviceMotionListener, true);
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
var startDeviceMotionListening = ({ interval = "normal", success, fail, complete } = {})=>{
    const handle = new MethodHandler({
        name: "startDeviceMotionListening",
        success,
        fail,
        complete
    });
    try {
        const intervalObj = INTERVAL_MAP2[interval];
        if (window.DeviceOrientationEvent) {
            if (deviceMotionListener) {
                stopDeviceMotionListening();
            }
            deviceMotionListener = throttle_default((evt)=>{
                callbackManager3.trigger({
                    alpha: evt.alpha,
                    beta: evt.beta,
                    gamma: evt.gamma
                });
            }, intervalObj.interval);
            window.addEventListener("deviceorientation", deviceMotionListener, true);
        } else {
            throw new Error("deviceMotion is not supported");
        }
        return handle.success();
    } catch (e) {
        return handle.fail({
            errMsg: e.message
        });
    }
};
var onDeviceMotionChange = (callback)=>{
    callbackManager3.add(callback);
};
var offDeviceMotionChange = (callback)=>{
    callbackManager3.remove(callback);
};
// node_modules/@tarojs/taro-h5/dist/api/device/network.js
function getConnection() {
    return navigator.connection || navigator.mozConnection || navigator.webkitConnection || navigator.msConnection;
}
var getNetworkType = (options3 = {})=>{
    const connection = getConnection();
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "getNetworkType",
        success,
        fail,
        complete
    });
    let networkType = "unknown";
    if (!connection) {
        return handle.success({
            networkType
        });
    }
    if (!isNaN(Number(connection.type))) {
        switch(connection.type){
            case connection.WIFI:
                networkType = "wifi";
                break;
            case connection.CELL_3G:
                networkType = "3g";
                break;
            case connection.CELL_2G:
                networkType = "2g";
                break;
            default:
                networkType = "unknown";
        }
    } else if (connection.type) {
        networkType = connection.type;
    } else if (connection.effectiveType) {
        networkType = connection.effectiveType;
    }
    return handle.success({
        networkType
    });
};
var networkStatusManager = new CallbackManager();
var networkStatusListener = ()=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, void 0, void 0, function*() {
        const { networkType } = yield getNetworkType();
        const isConnected = networkType !== "none";
        const obj = {
            isConnected,
            networkType
        };
        networkStatusManager.trigger(obj);
    });
var onNetworkWeakChange = temporarilyNotSupport("onNetworkWeakChange");
var onNetworkStatusChange = (callback)=>{
    networkStatusManager.add(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 1) {
        connection.addEventListener("change", networkStatusListener);
    }
};
var offNetworkWeakChange = temporarilyNotSupport("offNetworkWeakChange");
var offNetworkStatusChange = (callback)=>{
    networkStatusManager.remove(callback);
    const connection = getConnection();
    if (connection && networkStatusManager.count() === 0) {
        connection.removeEventListener("change", networkStatusListener);
    }
};
var getLocalIPAddress = temporarilyNotSupport("getLocalIPAddress");
// node_modules/@tarojs/taro-h5/dist/api/device/nfc.js
var stopHCE = temporarilyNotSupport("stopHCE");
var startHCE = temporarilyNotSupport("startHCE");
var sendHCEMessage = temporarilyNotSupport("sendHCEMessage");
var onHCEMessage = temporarilyNotSupport("onHCEMessage");
var offHCEMessage = temporarilyNotSupport("offHCEMessage");
var getNFCAdapter = temporarilyNotSupport("getNFCAdapter");
var getHCEState = temporarilyNotSupport("getHCEState");
// node_modules/@tarojs/taro-h5/dist/api/device/phone.js
var makePhoneCall = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `makePhoneCall:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { phoneNumber, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "makePhoneCall",
        success,
        fail,
        complete
    });
    if (typeof phoneNumber !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "phoneNumber",
                correct: "String",
                wrong: phoneNumber
            })
        });
    }
    window.location.href = `tel:${phoneNumber}`;
    return handle.success();
};
// node_modules/@tarojs/taro-h5/dist/api/device/scan.js
var scanCode = processOpenApi({
    name: "scanQRCode",
    defaultOptions: {
        needResult: 1
    },
    formatResult: (res)=>({
            errMsg: res.errMsg === "scanQRCode:ok" ? "scanCode:ok" : res.errMsg,
            result: res.resultStr
        })
});
// node_modules/@tarojs/taro-h5/dist/api/device/screen.js
var setVisualEffectOnCapture = temporarilyNotSupport("setVisualEffectOnCapture");
var setScreenBrightness = temporarilyNotSupport("setScreenBrightness");
var setKeepScreenOn = temporarilyNotSupport("setKeepScreenOn");
var onUserCaptureScreen = temporarilyNotSupport("onUserCaptureScreen");
var offUserCaptureScreen = temporarilyNotSupport("offUserCaptureScreen");
var getScreenBrightness = temporarilyNotSupport("getScreenBrightness");
var onScreenRecordingStateChanged = temporarilyNotSupport("onScreenRecordingStateChanged");
var offScreenRecordingStateChanged = temporarilyNotSupport("offScreenRecordingStateChanged");
var getScreenRecordingState = temporarilyNotSupport("getScreenRecordingState");
// node_modules/@tarojs/taro-h5/dist/api/device/sms.js
var sendSms = temporarilyNotSupport("sendSms");
// node_modules/@tarojs/taro-h5/dist/api/device/vibrate.js
var vibrator = function vibrator2(mm) {
    try {
        if (typeof window.navigator.vibrate === "function") {
            return window.navigator.vibrate(mm);
        }
        console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 vibrate\u3002");
        return false;
    } catch (e) {
        console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 vibrate\u3002");
        return false;
    }
};
var vibrateShort = (options3 = {})=>{
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "vibrateShort",
        success,
        fail,
        complete
    });
    if (vibrator(15)) {
        return handle.success();
    } else {
        return handle.fail({
            errMsg: "style is not support"
        });
    }
};
var vibrateLong = (options3 = {})=>{
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "vibrateLong",
        success,
        fail,
        complete
    });
    if (vibrator(400)) {
        return handle.success();
    } else {
        return handle.fail({
            errMsg: "style is not support"
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/device/wifi.js
var stopWifi = temporarilyNotSupport("stopWifi");
var startWifi = temporarilyNotSupport("startWifi");
var setWifiList = temporarilyNotSupport("setWifiList");
var onWifiConnectedWithPartialInfo = temporarilyNotSupport("onWifiConnectedWithPartialInfo");
var onWifiConnected = temporarilyNotSupport("onWifiConnected");
var onGetWifiList = temporarilyNotSupport("onGetWifiList");
var offWifiConnectedWithPartialInfo = temporarilyNotSupport("offWifiConnectedWithPartialInfo");
var offWifiConnected = temporarilyNotSupport("offWifiConnected");
var offGetWifiList = temporarilyNotSupport("offGetWifiList");
var getWifiList = temporarilyNotSupport("getWifiList");
var getConnectedWifi = temporarilyNotSupport("getConnectedWifi");
var connectWifi = temporarilyNotSupport("connectWifi");
// node_modules/@tarojs/taro-h5/dist/api/ext/index.js
var getExtConfigSync = temporarilyNotSupport("getExtConfigSync");
var getExtConfig = temporarilyNotSupport("getExtConfig");
// node_modules/@tarojs/taro-h5/dist/api/files/index.js
var saveFileToDisk = temporarilyNotSupport("saveFileToDisk");
var saveFile = temporarilyNotSupport("saveFile");
var removeSavedFile = temporarilyNotSupport("removeSavedFile");
var openDocument = temporarilyNotSupport("openDocument");
var getSavedFileList = temporarilyNotSupport("getSavedFileList");
var getSavedFileInfo = temporarilyNotSupport("getSavedFileInfo");
var getFileSystemManager = temporarilyNotSupport("getFileSystemManager");
var getFileInfo = temporarilyNotSupport("getFileInfo");
// node_modules/@tarojs/taro-h5/dist/api/framework/index.js
var getApp2 = function() {
    return Taro.getCurrentInstance().app;
};
var getCurrentInstance2 = Taro.getCurrentInstance;
// node_modules/@tarojs/taro-h5/dist/api/location/utils.js
var isGeolocationSupported = ()=>!!navigator.geolocation;
// node_modules/@tarojs/taro-h5/dist/api/location/getLocation.js
var getLocationByW3CApi = (options3)=>{
    var _a;
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getLocation:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "getLocation",
        success,
        fail,
        complete
    });
    const positionOptions = {
        enableHighAccuracy: options3.isHighAccuracy || options3.altitude != null,
        // 
        // maximumAge: defaultMaximumAge, // 
        timeout: options3.highAccuracyExpireTime
    };
    if (((_a = options3.type) === null || _a === void 0 ? void 0 : _a.toUpperCase()) !== "WGS84") {
        return handle.fail({
            errMsg: "This coordinate system type is not temporarily supported"
        });
    }
    if (!isGeolocationSupported()) {
        return handle.fail({
            errMsg: "The current browser does not support this feature"
        });
    }
    return new Promise((resolve, reject)=>{
        navigator.geolocation.getCurrentPosition((position)=>{
            const result = {
                /**  */ accuracy: position.coords.accuracy,
                /**  m */ altitude: position.coords.altitude,
                /**  m */ horizontalAccuracy: position.coords.accuracy,
                /**  -90~90 */ latitude: position.coords.latitude,
                /**  -180~180 */ longitude: position.coords.longitude,
                /**  m/s */ speed: position.coords.speed,
                /**  mAndroid  0 */ verticalAccuracy: position.coords.altitudeAccuracy || 0,
                /** , */ errMsg: ""
            };
            handle.success(result, {
                resolve,
                reject
            });
        }, (error)=>{
            handle.fail({
                errMsg: error.message
            }, {
                resolve,
                reject
            });
        }, positionOptions);
    });
};
var getLocation = processOpenApi({
    name: "getLocation",
    standardMethod: getLocationByW3CApi
});
// node_modules/@tarojs/taro-h5/dist/node_modules/.pnpm/style-inject@0.3.0/node_modules/style-inject/dist/style-inject.es.js
function styleInject(css, ref) {
    if (ref === void 0) ref = {};
    var insertAt = ref.insertAt;
    if (!css || typeof document === "undefined") {
        return;
    }
    var head2 = document.head || document.getElementsByTagName("head")[0];
    var style = document.createElement("style");
    style.type = "text/css";
    if (insertAt === "top") {
        if (head2.firstChild) {
            head2.insertBefore(style, head2.firstChild);
        } else {
            head2.appendChild(style);
        }
    } else {
        head2.appendChild(style);
    }
    if (style.styleSheet) {
        style.styleSheet.cssText = css;
    } else {
        style.appendChild(document.createTextNode(css));
    }
}
// node_modules/@tarojs/taro-h5/dist/api/location/style.scss.js
var css_248z = '.taro_choose_location{background-color:#fff;display:flex;flex-direction:column;height:100%;position:fixed;top:100%;transition:top .3s ease;width:100%;z-index:1}.taro_choose_location_bar{background-color:#ededed;color:#090909;display:flex;flex:0 95px;height:95px}.taro_choose_location_back{flex:0 45px;height:30px;margin-top:30px;position:relative;width:33px}.taro_choose_location_back:before{border:15px solid transparent;border-right-color:#090909;content:"";display:block;height:0;left:0;position:absolute;top:0;width:0}.taro_choose_location_back:after{border:15px solid transparent;border-right-color:#ededed;content:"";display:block;height:0;left:3px;position:absolute;top:0;width:0}.taro_choose_location_title{flex:1;line-height:95px;padding-left:30px}.taro_choose_location_submit{background-color:#08bf62;border:none;color:#fff;font-size:28px;height:60px;line-height:60px;margin:18px 30px 0 0;padding:0;width:110px}.taro_choose_location_frame{flex:1}';
styleInject(css_248z, {
    "insertAt": "top"
});
// node_modules/@tarojs/taro-h5/dist/api/location/chooseLocation.js
var container = null;
function createLocationChooser(handler, key = LOCATION_APIKEY, mapOpt = {}) {
    var _a, _b, _c;
    const { latitude, longitude } = mapOpt, opts = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__rest)(mapOpt, [
        "latitude",
        "longitude"
    ]);
    const query = Object.assign({
        key,
        type: 1,
        coord: ((_a = mapOpt.coord) !== null && _a !== void 0 ? _a : [
            latitude,
            longitude
        ].every((e)=>Number(e) >= 0)) ? `${latitude},${longitude}` : void 0,
        referer: "myapp"
    }, opts);
    if (!container) {
        const html = `
<div class='taro_choose_location'>
  <div class='taro_choose_location_bar'>
    <div class='taro_choose_location_back'></div>
    <p class='taro_choose_location_title'>\u4F4D\u7F6E</p>
    <button class='taro_choose_location_submit'>\u5B8C\u6210</button>
  </div>
  <iframe class='taro_choose_location_frame' frameborder='0' src="https://apis.map.qq.com/tools/locpicker?${query_string_default.stringify(query, {
            arrayFormat: "comma",
            skipNull: true
        })}" />
</div>
`;
        container = document.createElement("div");
        container.innerHTML = html;
    }
    const main = container.querySelector(".taro_choose_location");
    function show() {
        setTimeout(()=>{
            main.style.top = "0";
        });
    }
    function hide() {
        main.style.top = "100%";
    }
    function back() {
        hide();
        handler({
            errMsg: "cancel"
        });
    }
    function submit() {
        hide();
        handler();
    }
    function remove2() {
        container === null || container === void 0 ? void 0 : container.remove();
        container = null;
        window.removeEventListener("popstate", back);
    }
    (_b = container.querySelector(".taro_choose_location_back")) === null || _b === void 0 ? void 0 : _b.addEventListener("click", back);
    (_c = container.querySelector(".taro_choose_location_submit")) === null || _c === void 0 ? void 0 : _c.addEventListener("click", submit);
    window.addEventListener("popstate", back);
    return {
        show,
        remove: remove2,
        container
    };
}
var chooseLocation = ({ success, fail, complete, mapOpts } = {})=>{
    const handle = new MethodHandler({
        name: "chooseLocation",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const chooseLocation2 = {};
        if (typeof LOCATION_APIKEY === "undefined") {
            console.warn("chooseLocation api \u4F9D\u8D56\u817E\u8BAF\u5730\u56FE\u5B9A\u4F4Dapi\uFF0C\u9700\u8981\u5728 defineConstants \u4E2D\u914D\u7F6E LOCATION_APIKEY");
            return handle.fail({
                errMsg: "LOCATION_APIKEY needed"
            }, {
                resolve,
                reject
            });
        }
        const key = LOCATION_APIKEY;
        const onMessage = (event2)=>{
            const loc = event2.data;
            if (!loc || loc.module !== "locationPicker") return;
            chooseLocation2.name = loc.poiname;
            chooseLocation2.address = loc.poiaddress;
            chooseLocation2.latitude = loc.latlng.lat;
            chooseLocation2.longitude = loc.latlng.lng;
        };
        const chooser = createLocationChooser((res)=>{
            window.removeEventListener("message", onMessage, false);
            setTimeout(()=>{
                chooser.remove();
            }, 300);
            if (res) {
                return handle.fail(res, {
                    resolve,
                    reject
                });
            } else {
                if (chooseLocation2.latitude && chooseLocation2.longitude) {
                    return handle.success(chooseLocation2, {
                        resolve,
                        reject
                    });
                } else {
                    return handle.fail({}, {
                        resolve,
                        reject
                    });
                }
            }
        }, key, mapOpts);
        document.body.appendChild(chooser.container);
        window.addEventListener("message", onMessage, false);
        chooser.show();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/location/locationChange.js
var _successCbManager = new CallbackManager();
var _errorCbManager = new CallbackManager();
var _watchID = -1;
function onLocationChange(callback) {
    _successCbManager.add(callback);
}
function offLocationChange(callback) {
    if (callback && typeof callback === "function") {
        _successCbManager.remove(callback);
    } else if (callback === void 0) {
        _successCbManager.clear();
    } else {
        console.warn("offLocationChange failed");
    }
}
function onLocationChangeError(callback) {
    _errorCbManager.add(callback);
}
function offLocationChangeError(callback) {
    if (callback && typeof callback === "function") {
        _errorCbManager.remove(callback);
    } else if (callback === void 0) {
        _errorCbManager.clear();
    } else {
        console.warn("offLocationChangeError failed");
    }
}
function startLocationUpdateByW3CApi(opts) {
    const isObject6 = shouldBeObject(opts);
    if (!isObject6.flag) {
        const res = {
            errMsg: `startLocationUpdate:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success, fail, complete } = opts;
    const handle = new MethodHandler({
        name: "startLocationUpdate",
        success,
        fail,
        complete
    });
    if (!isGeolocationSupported()) {
        return handle.fail({
            errMsg: "The current browser does not support this feature"
        });
    }
    try {
        if (_watchID > -1) {
            console.error("startLocationUpdate:fail");
            return handle.fail();
        } else {
            _watchID = navigator.geolocation.watchPosition(({ coords })=>{
                const { latitude, longitude, altitude, accuracy, speed } = coords;
                _successCbManager.trigger({
                    accuracy,
                    altitude,
                    horizontalAccuracy: 0,
                    verticalAccuracy: 0,
                    latitude,
                    longitude,
                    speed
                });
            }, (err)=>{
                _errorCbManager.trigger({
                    errMsg: "Watch Position error",
                    err
                });
            }, {
                timeout: 10,
                maximumAge: 0,
                enableHighAccuracy: true
            });
            return handle.success();
        }
    } catch (error) {
        return handle.fail();
    }
}
function stopLocationUpdateByW3CApi(opts) {
    const isObject6 = shouldBeObject(opts);
    if (!isObject6.flag) {
        const res = {
            errMsg: `stopLocationUpdate:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { success, fail, complete } = opts;
    const handle = new MethodHandler({
        name: "stopLocationUpdate",
        success,
        fail,
        complete
    });
    if (!isGeolocationSupported()) {
        return handle.fail({
            errMsg: "The current browser does not support this feature"
        });
    }
    try {
        navigator.geolocation.clearWatch(_watchID);
        _watchID = -1;
        return handle.success();
    } catch (error) {
        return handle.fail();
    }
}
var stopLocationUpdate = processOpenApi({
    name: "stopLocationUpdate",
    standardMethod: stopLocationUpdateByW3CApi
});
var startLocationUpdate = processOpenApi({
    name: "startLocationUpdate",
    standardMethod: startLocationUpdateByW3CApi
});
// node_modules/@tarojs/taro-h5/dist/api/location/index.js
var startLocationUpdateBackground = temporarilyNotSupport("startLocationUpdateBackground");
var openLocation = processOpenApi({
    name: "openLocation",
    defaultOptions: {
        scale: 18
    }
});
var choosePoi = temporarilyNotSupport("choosePoi");
var getFuzzyLocation = temporarilyNotSupport("getFuzzyLocation");
// node_modules/@tarojs/taro-h5/dist/api/media/audio/InnerAudioContext.js
var InnerAudioContext = class {
    set autoplay(e) {
        this.setProperty("autoplay", e);
    }
    get autoplay() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.autoplay) || false;
    }
    get buffered() {
        const { currentTime = 0, buffered: timeRange } = this.Instance || {};
        if (timeRange) {
            for(let i2 = 0; i2 < timeRange.length; i2++){
                if (timeRange.start(i2) <= currentTime && timeRange.end(i2) >= currentTime) {
                    return timeRange.end(i2);
                }
            }
        }
        return 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    set currentTime(e) {
        this.seek(e);
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    set loop(e) {
        this.setProperty("loop", e);
    }
    get loop() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.loop) || false;
    }
    get paused() {
        var _a, _b;
        return (_b = (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) !== null && _b !== void 0 ? _b : true;
    }
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set volume(e) {
        this.setProperty("volume", e);
    }
    get volume() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.volume) || 0;
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    set obeyMuteSwitch(_e) {
        permanentlyNotSupport("InnerAudioContext.obeyMuteSwitch")();
    }
    get obeyMuteSwitch() {
        return true;
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.__isFirstPlay = true;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.destroy = ()=>{
            this.stop();
            if (this.Instance) {
                this.Instance = void 0;
            }
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.onerror = this.errorStack.trigger;
        Taro.eventCenter.on("__taroRouterChange", ()=>{
            this.stop();
        });
        this.onPlay(()=>{
            if (this.__isFirstPlay) {
                this.__isFirstPlay = false;
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/audio/index.js
var stopVoice = temporarilyNotSupport("stopVoice");
var setInnerAudioOption = temporarilyNotSupport("setInnerAudioOption");
var playVoice = temporarilyNotSupport("playVoice");
var pauseVoice = temporarilyNotSupport("pauseVoice");
var getAvailableAudioSources = temporarilyNotSupport("getAvailableAudioSources");
var createWebAudioContext = temporarilyNotSupport("createWebAudioContext");
var createMediaAudioPlayer = temporarilyNotSupport("createMediaAudioPlayer");
var createInnerAudioContext = ()=>new InnerAudioContext();
var createAudioContext = temporarilyNotSupport("createAudioContext");
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/BackgroundAudioManager.js
var BackgroundAudioManager = class {
    set src(e) {
        this.setProperty("src", e);
    }
    get src() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.src) || "";
    }
    set startTime(e) {
        this.__startTime = e;
    }
    get startTime() {
        return this.__startTime || 0;
    }
    set title(e) {
        this.dataset("title", e);
    }
    get title() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.title) || "";
    }
    set epname(e) {
        this.dataset("epname", e);
    }
    get epname() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.epname) || "";
    }
    set singer(e) {
        this.dataset("singer", e);
    }
    get singer() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.singer) || "";
    }
    set coverImgUrl(e) {
        this.dataset("coverImgUrl", e);
    }
    get coverImgUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.coverImgUrl) || "";
    }
    set webUrl(e) {
        this.dataset("webUrl", e);
    }
    get webUrl() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.webUrl) || "";
    }
    set protocol(e) {
        this.dataset("protocol", e);
    }
    get protocol() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.dataset.protocol) || "";
    }
    set playbackRate(e) {
        this.setProperty("playbackRate", e);
    }
    get playbackRate() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.playbackRate) || 0;
    }
    get duration() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.duration) || 0;
    }
    get currentTime() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.currentTime) || 0;
    }
    get paused() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.paused) || false;
    }
    get buffered() {
        const { currentTime = 0, buffered: timeRange } = this.Instance || {};
        if (timeRange) {
            for(let i2 = 0; i2 < timeRange.length; i2++){
                if (timeRange.start(i2) <= currentTime && timeRange.end(i2) >= currentTime) {
                    return timeRange.end(i2);
                }
            }
        }
        return 0;
    }
    set referrerPolicy(e) {
        var _a;
        (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.setAttribute("referrerpolicy", e);
    }
    get referrerPolicy() {
        var _a;
        return ((_a = this.Instance) === null || _a === void 0 ? void 0 : _a.getAttribute("referrerpolicy")) || "origin";
    }
    setProperty(key, value) {
        if (this.Instance) {
            this.Instance[key] = value;
        }
    }
    dataset(key, value) {
        if (this.Instance) {
            this.Instance.dataset[key] = value;
        }
    }
    constructor(){
        this.__startTime = 0;
        this.play = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.play();
        };
        this.pause = ()=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.pause();
        };
        this.seek = (position)=>{
            if (this.Instance) {
                this.Instance.currentTime = position;
            }
        };
        this.stop = ()=>{
            this.pause();
            this.seek(0);
            this.stopStack.trigger();
        };
        this.onCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("canplay", callback);
        };
        this.onWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("waiting", callback);
        };
        this.onError = (callback)=>this.errorStack.add(callback);
        this.onPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("play", callback);
        };
        this.onPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("pause", callback);
        };
        this.onSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeking", callback);
        };
        this.onSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("seeked", callback);
        };
        this.onEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("ended", callback);
        };
        this.onStop = (callback = ()=>{})=>this.stopStack.add(callback);
        this.onTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.addEventListener("timeupdate", callback);
        };
        this.onPrev = permanentlyNotSupport("BackgroundAudioManager.onPrev");
        this.onNext = permanentlyNotSupport("BackgroundAudioManager.onNext");
        this.offCanplay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("canplay", callback);
        };
        this.offWaiting = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("waiting", callback);
        };
        this.offError = (callback = ()=>{})=>this.errorStack.remove(callback);
        this.offPlay = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("play", callback);
        };
        this.offPause = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("pause", callback);
        };
        this.offSeeking = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeking", callback);
        };
        this.offSeeked = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("seeked", callback);
        };
        this.offEnded = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("ended", callback);
        };
        this.offStop = (callback = ()=>{})=>this.stopStack.remove(callback);
        this.offTimeUpdate = (callback = ()=>{})=>{
            var _a;
            return (_a = this.Instance) === null || _a === void 0 ? void 0 : _a.removeEventListener("timeupdate", callback);
        };
        this.offPrev = permanentlyNotSupport("BackgroundAudioManager.offPrev");
        this.offNext = permanentlyNotSupport("BackgroundAudioManager.offNext");
        this.Instance = new Audio();
        this.errorStack = new CallbackManager();
        this.stopStack = new CallbackManager();
        this.Instance.onerror = this.errorStack.trigger;
        this.Instance.autoplay = true;
        this.onPlay(()=>{
            if (this.currentTime !== this.startTime) {
                this.seek(this.startTime);
            }
        });
    }
};
// node_modules/@tarojs/taro-h5/dist/api/media/background-audio/index.js
var stopBackgroundAudio = temporarilyNotSupport("stopBackgroundAudio");
var seekBackgroundAudio = temporarilyNotSupport("seekBackgroundAudio");
var playBackgroundAudio = temporarilyNotSupport("playBackgroundAudio");
var pauseBackgroundAudio = temporarilyNotSupport("pauseBackgroundAudio");
var onBackgroundAudioStop = temporarilyNotSupport("onBackgroundAudioStop");
var onBackgroundAudioPlay = temporarilyNotSupport("onBackgroundAudioPlay");
var onBackgroundAudioPause = temporarilyNotSupport("onBackgroundAudioPause");
var getBackgroundAudioPlayerState = temporarilyNotSupport("getBackgroundAudioPlayerState");
var _instance = null;
var getBackgroundAudioManager = ()=>{
    if (!_instance) _instance = new BackgroundAudioManager();
    return _instance;
};
// node_modules/@tarojs/taro-h5/dist/api/media/camera.js
var createCameraContext = temporarilyNotSupport("createCameraContext");
// node_modules/@tarojs/taro-h5/dist/api/media/image/saveImageToPhotosAlbum.js
var saveImageToPhotosAlbum = (options3)=>{
    const methodName = "saveImageToPhotosAlbum";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { filePath, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof filePath !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "filePath",
                correct: "String",
                wrong: filePath
            })
        });
    }
    createDownload(filePath);
    return handle.success();
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/getImageInfo.js
var getImageInfo = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `getImageInfo:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const getBase64Image = (image)=>{
        try {
            const canvas = document.createElement("canvas");
            canvas.width = image.width;
            canvas.height = image.height;
            const ctx = canvas.getContext("2d");
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(image, 0, 0, image.width, image.height);
            return canvas.toDataURL("image/png");
        } catch (e) {
            console.error("getImageInfo:get base64 fail", e);
        }
    };
    const { src, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "getImageInfo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        const image = new Image();
        image.crossOrigin = "";
        image.onload = ()=>{
            handle.success({
                width: image.naturalWidth,
                height: image.naturalHeight,
                path: getBase64Image(image) || src
            }, {
                resolve,
                reject
            });
        };
        image.onerror = (e)=>{
            handle.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        };
        image.src = src;
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/previewImage.js
var previewImage = (options3)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, void 0, void 0, function*() {
        defineCustomElement();
        defineCustomElement2();
        function loadImage(url, loadFail) {
            return new Promise((resolve)=>{
                const item = document.createElement("taro-swiper-item-core");
                item.style.cssText = "display:flex;align-items:start;justify-content:center;overflow-y:scroll;";
                const image = new Image();
                image.style.maxWidth = "100%";
                image.src = url;
                const div = document.createElement("div");
                div.classList.add("swiper-zoom-container");
                div.style.cssText = "display:flex;align-items:center;justify-content:center;max-width:100%;min-height:100%;";
                div.appendChild(image);
                item.appendChild(div);
                resolve(item);
                if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(loadFail)) {
                    image.addEventListener("error", (err)=>{
                        loadFail({
                            errMsg: err.message
                        });
                    });
                }
            });
        }
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res = {
                errMsg: `previewImage:fail ${isObject6.msg}`
            };
            console.error(res.errMsg);
            return Promise.reject(res);
        }
        const { urls = [], current = "", success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: "previewImage",
            success,
            fail,
            complete
        });
        const container2 = document.createElement("div");
        const removeHandler = ()=>{
            _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.off("__taroRouterChange", removeHandler);
            container2.remove();
        };
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.on("__taroRouterChange", removeHandler);
        container2.classList.add("preview-image");
        container2.style.cssText = "position:fixed;top:0;left:0;z-index:1050;width:100%;height:100%;overflow:hidden;outline:0;background-color:#111;";
        container2.addEventListener("click", removeHandler);
        const swiper = document.createElement("taro-swiper-core");
        swiper.full = true;
        swiper.zoom = true;
        let children = [];
        try {
            children = yield Promise.all(urls.map((e)=>loadImage(e, fail)));
        } catch (error) {
            return handle.fail({
                errMsg: error
            });
        }
        for(let i2 = 0; i2 < children.length; i2++){
            const child = children[i2];
            swiper.appendChild(child);
        }
        const currentIndex = typeof current === "number" ? current : urls.indexOf(current);
        swiper.current = currentIndex;
        container2.appendChild(swiper);
        document.body.appendChild(container2);
        return handle.success();
    });
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseMedia.js
var import_is_mobile = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_is_mobile());
// node_modules/@tarojs/taro-h5/dist/api/ui/animation/index.js
var StyleSheet = class {
    constructor(){
        this.$style = null;
        this.sheet = null;
        this.appendStyleSheet = ()=>{
            if (this.$style) {
                const head2 = document.getElementsByTagName("head")[0];
                this.$style.setAttribute("type", "text/css");
                this.$style.setAttribute("data-type", "Taro");
                head2.appendChild(this.$style);
                this.sheet = this.$style.sheet;
            }
            if (this.sheet && !("insertRule" in this.sheet)) {
                console.warn("\u5F53\u524D\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 stylesheet.insertRule \u63A5\u53E3");
            }
        };
        this.add = (cssText, index = 0)=>{
            var _a;
            if (this.sheet === null) {
                this.appendStyleSheet();
            }
            (_a = this.sheet) === null || _a === void 0 ? void 0 : _a.insertRule(cssText, index);
        };
        this.$style = document.createElement("style");
    }
};
var styleSheet = new StyleSheet();
var TRANSITION_END = "transitionend";
var TRANSFORM = "transform";
var $detect = document.createElement("div");
$detect.style.cssText = "-webkit-animation-name:webkit;-moz-animation-name:moz;-ms-animation-name:ms;animation-name:standard;";
if ($detect.style["animation-name"] === "standard") {
    TRANSITION_END = "transitionend";
    TRANSFORM = "transform";
} else if ($detect.style["-webkit-animation-name"] === "webkit") {
    TRANSITION_END = "webkitTransitionEnd";
    TRANSFORM = "-webkit-transform";
} else if ($detect.style["-moz-animation-name"] === "moz") {
    TRANSITION_END = "mozTransitionEnd";
    TRANSFORM = "-moz-transform";
} else if ($detect.style["-ms-animation-name"] === "ms") {
    TRANSITION_END = "msTransitionEnd";
    TRANSFORM = "-ms-transform";
}
var animId = 0;
var Animation = class {
    transformUnit(...args) {
        const ret = [];
        args.forEach((each)=>{
            ret.push(isNaN(each) ? each : `${each}${this.unit}`);
        });
        return ret;
    }
    // 
    setDefault(duration, delay, timingFunction, transformOrigin) {
        this.DEFAULT = {
            duration,
            delay,
            timingFunction,
            transformOrigin
        };
    }
    matrix(a, b, c, d, tx, ty) {
        this.transform.push({
            key: "matrix",
            transform: `matrix(${a}, ${b}, ${c}, ${d}, ${tx}, ${ty})`
        });
        return this;
    }
    matrix3d(a1, b1, c1, d1, a2, b2, c2, d2, a3, b3, c3, d3, a4, b4, c4, d4) {
        this.transform.push({
            key: "matrix3d",
            transform: `matrix3d(${a1}, ${b1}, ${c1}, ${d1}, ${a2}, ${b2}, ${c2}, ${d2}, ${a3}, ${b3}, ${c3}, ${d3}, ${a4}, ${b4}, ${c4}, ${d4})`
        });
        return this;
    }
    rotate(angle) {
        this.transform.push({
            key: "rotate",
            transform: `rotate(${angle}deg)`
        });
        return this;
    }
    rotate3d(x, y, z, angle) {
        if (typeof y !== "number") {
            this.transform.push({
                key: "rotate3d",
                transform: `rotate3d(${x})`
            });
        } else {
            this.transform.push({
                key: "rotate3d",
                transform: `rotate3d(${x}, ${y || 0}, ${z || 0}, ${angle || 0}deg)`
            });
        }
        return this;
    }
    rotateX(angle) {
        this.transform.push({
            key: "rotateX",
            transform: `rotateX(${angle}deg)`
        });
        return this;
    }
    rotateY(angle) {
        this.transform.push({
            key: "rotateY",
            transform: `rotateY(${angle}deg)`
        });
        return this;
    }
    rotateZ(angle) {
        this.transform.push({
            key: "rotateZ",
            transform: `rotateZ(${angle}deg)`
        });
        return this;
    }
    scale(x, y) {
        const scaleY = typeof y !== "undefined" && y !== null ? y : x;
        this.transform.push({
            key: "scale",
            transform: `scale(${x}, ${scaleY})`
        });
        return this;
    }
    scale3d(x, y, z) {
        this.transform.push({
            key: "scale3d",
            transform: `scale3d(${x}, ${y}, ${z})`
        });
        return this;
    }
    scaleX(scale) {
        this.transform.push({
            key: "scaleX",
            transform: `scaleX(${scale})`
        });
        return this;
    }
    scaleY(scale) {
        this.transform.push({
            key: "scaleY",
            transform: `scaleY(${scale})`
        });
        return this;
    }
    scaleZ(scale) {
        this.transform.push({
            key: "scaleZ",
            transform: `scaleZ(${scale})`
        });
        return this;
    }
    skew(x, y) {
        this.transform.push({
            key: "skew",
            transform: `skew(${x}deg, ${y}deg)`
        });
        return this;
    }
    skewX(angle) {
        this.transform.push({
            key: "skewX",
            transform: `skewX(${angle}deg)`
        });
        return this;
    }
    skewY(angle) {
        this.transform.push({
            key: "skewY",
            transform: `skewY(${angle}deg)`
        });
        return this;
    }
    translate(x, y) {
        [x, y] = this.transformUnit(x, y);
        this.transform.push({
            key: "translate",
            transform: `translate(${x}, ${y})`
        });
        return this;
    }
    translate3d(x, y, z) {
        [x, y, z] = this.transformUnit(x, y, z);
        this.transform.push({
            key: "translate3d",
            transform: `translate3d(${x}, ${y}, ${z})`
        });
        return this;
    }
    translateX(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push({
            key: "translateX",
            transform: `translateX(${translate2})`
        });
        return this;
    }
    translateY(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push({
            key: "translateY",
            transform: `translateY(${translate2})`
        });
        return this;
    }
    translateZ(translate2) {
        [translate2] = this.transformUnit(translate2);
        this.transform.push({
            key: "translateZ",
            transform: `translateZ(${translate2})`
        });
        return this;
    }
    opacity(value) {
        this.rules.push({
            key: "opacity",
            rule: `opacity: ${value}`
        });
        return this;
    }
    backgroundColor(value) {
        this.rules.push({
            key: "backgroundColor",
            rule: `background-color: ${value}`
        });
        return this;
    }
    width(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "width",
            rule: `width: ${value}`
        });
        return this;
    }
    height(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "height",
            rule: `height: ${value}`
        });
        return this;
    }
    top(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "top",
            rule: `top: ${value}`
        });
        return this;
    }
    right(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "right",
            rule: `right: ${value}`
        });
        return this;
    }
    bottom(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "bottom",
            rule: `bottom: ${value}`
        });
        return this;
    }
    left(value) {
        [value] = this.transformUnit(value);
        this.rules.push({
            key: "left",
            rule: `left: ${value}`
        });
        return this;
    }
    // 
    step(arg = {}) {
        const { DEFAULT } = this;
        const { duration = DEFAULT.duration, delay = DEFAULT.delay, timingFunction = DEFAULT.timingFunction, transformOrigin = DEFAULT.transformOrigin } = arg;
        this.transform.map((t0)=>{
            const index = this.historyAnimations.findIndex((t1)=>t1.key === t0.key);
            if (index === -1) {
                this.historyAnimations.push(t0);
            } else {
                this.historyAnimations[index] = t0;
            }
        });
        const transforms = this.historyAnimations.map((t)=>t.transform);
        const transformSequence = transforms.length > 0 ? `${TRANSFORM}:${transforms.join(" ")}!important` : "";
        this.rules.map((r0)=>{
            const index = this.historyRules.findIndex((r1)=>r1.key === r0.key);
            if (index === -1) {
                this.historyRules.push(r0);
            } else {
                this.historyRules[index] = r0;
            }
        });
        const rules = this.historyRules.map((t)=>t.rule);
        const ruleSequence = rules.length > 0 ? rules.map((rule)=>`${rule}!important`).join(";") : "";
        this.steps.push([
            ruleSequence,
            transformSequence,
            `${TRANSFORM}-origin: ${transformOrigin}`,
            `transition: all ${duration}ms ${timingFunction} ${delay}ms`
        ].filter((item)=>item !== "").join(";"));
        this.rules = [];
        this.transform = [];
        return this;
    }
    // 
    createAnimationData() {
        const animIndex = `taro-h5-poly-fill/${this.id}/create-animation__${this.animationMapCount++}`;
        this.animationMap[animIndex] = this.steps.length;
        this.steps.forEach((step, index)=>{
            const selector = index === 0 ? `[animation="${animIndex}"], [data-animation="${animIndex}"]` : `[animation="${animIndex}--${index}"], [data-animation="${animIndex}--${index}"]`;
            styleSheet.add(`${selector} { ${step} }`);
        });
        this.steps = [];
        return animIndex;
    }
    // 
    export() {
        return this.createAnimationData();
    }
    constructor({ duration = 400, delay = 0, timingFunction = "linear", transformOrigin = "50% 50% 0", unit = "px" } = {}){
        this.rules = [];
        this.transform = [];
        this.steps = [];
        this.animationMap = {};
        this.animationMapCount = 0;
        this.historyAnimations = [];
        this.historyRules = [];
        this.setDefault(duration, delay, timingFunction, transformOrigin);
        this.unit = unit;
        let animAttr = "animation";
        this.id = ++animId;
        document.body.addEventListener(TRANSITION_END, (e)=>{
            const target = e.target;
            if (target.getAttribute(animAttr) === null) {
                animAttr = "data-animation";
            }
            const animData = target.getAttribute(animAttr);
            if (animData === null) return;
            const [animName, animPath] = animData.split("__");
            if (animName === `taro-h5-poly-fill/${this.id}/create-animation`) {
                const [animIndex, __stepIndex = 0] = animPath.split("--");
                const stepIndex = Number(__stepIndex);
                const animStepsCount = this.animationMap[`${animName}__${animIndex}`];
                const animStepsMaxIndex = animStepsCount - 1;
                if (stepIndex < animStepsMaxIndex) {
                    target.setAttribute(animAttr, `${animName}__${animIndex}--${stepIndex + 1}`);
                    if (animAttr === "data-animation") {
                        target.setAttribute("animation", `${animName}__${animIndex}--${stepIndex + 1}`);
                    }
                }
            }
        });
    }
};
var createAnimation = (option)=>{
    return new Animation(option);
};
// node_modules/@tarojs/taro-h5/dist/api/ui/animation/worklet.js
var createNotSupportedObject = (obj, methods2)=>{
    methods2.forEach((method)=>{
        Object.defineProperty(obj, method, {
            get: ()=>temporarilyNotSupport(method)
        });
    });
    return obj;
};
var easingMethods = [
    "bounce",
    "ease",
    "elastic",
    "linear",
    "quad",
    "cubic",
    "poly",
    "bezier",
    "circle",
    "sin",
    "exp",
    "in",
    "out",
    "inOut"
];
var workletMethods = [
    "cancelAnimation",
    "derived",
    "shared",
    "decay",
    "spring",
    "timing",
    "delay",
    "repeat",
    "sequence",
    "runOnJS",
    "runOnUI"
];
var worklet = createNotSupportedObject({}, workletMethods);
worklet.Easing = createNotSupportedObject({}, easingMethods);
worklet.scrollViewContext = createNotSupportedObject({}, [
    "scrollTo"
]);
// node_modules/@tarojs/taro-h5/dist/api/ui/background.js
var setBackgroundTextStyle = temporarilyNotSupport("setBackgroundTextStyle");
var setBackgroundColor = temporarilyNotSupport("setBackgroundColor");
// node_modules/@tarojs/taro-h5/dist/api/ui/custom-component.js
var nextTick3 = Taro.nextTick;
// node_modules/@tarojs/taro-h5/dist/api/ui/fonts.js
var loadFontFace = (options3)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(void 0, void 0, void 0, function*() {
        options3 = Object.assign({
            global: false
        }, options3);
        const { success, fail, complete, family, source, desc = {} } = options3;
        const handle = new MethodHandler({
            name: "loadFontFace",
            success,
            fail,
            complete
        });
        const fonts = document.fonts;
        if (fonts) {
            const fontFace = new FontFace(family, source, desc);
            try {
                yield fontFace.load();
                fonts.add(fontFace);
                return handle.success({
                    status: "loaded"
                });
            } catch (error) {
                return handle.fail({
                    status: "error",
                    errMsg: error.message || error
                });
            }
        } else {
            const style = document.createElement("style");
            let innerText = `font-family:"${family}";src:${source};font-style:${desc.style || "normal"};font-weight:${desc.weight || "normal"};font-variant:${desc.variant || "normal"};`;
            if (desc.ascentOverride) {
                innerText += `ascent-override:${desc.ascentOverride};`;
            }
            if (desc.descentOverride) {
                innerText += `descent-override:${desc.descentOverride};`;
            }
            if (desc.featureSettings) {
                innerText += `font-feature-settings:${desc.featureSettings};`;
            }
            if (desc.lineGapOverride) {
                innerText += `line-gap-override:${desc.lineGapOverride};`;
            }
            if (desc.stretch) {
                innerText += `font-stretch:${desc.stretch};`;
            }
            if (desc.unicodeRange) {
                innerText += `unicode-range:${desc.unicodeRange};`;
            }
            if (desc.variationSettings) {
                innerText += `font-variation-settings:${desc.variationSettings};`;
            }
            style.innerText = `@font-face{${innerText}}`;
            document.head.appendChild(style);
            return handle.success({
                status: "loaded"
            });
        }
    });
// node_modules/@tarojs/taro-h5/dist/api/ui/menu.js
var getMenuButtonBoundingClientRect = temporarilyNotSupport("getMenuButtonBoundingClientRect");
// node_modules/@tarojs/taro-h5/dist/api/ui/navigation-bar/index.js
function showNavigationBarLoading(options3 = {}) {
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "showNavigationBarLoading",
        success,
        fail,
        complete
    });
    setNavigationBarLoading(true);
    return handle.success();
}
function setNavigationBarTitle(options3) {
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setNavigationBarTitle:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { title, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setNavigationBarTitle",
        success,
        fail,
        complete
    });
    if (!title || typeof title !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "title",
                correct: "String",
                wrong: title
            })
        });
    }
    setTitle(title);
    return handle.success();
}
var setNavigationBarColor = (options3)=>{
    const { backgroundColor, frontColor, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setNavigationBarColor",
        success,
        fail,
        complete
    });
    const meta = document.createElement("meta");
    meta.setAttribute("name", "theme-color");
    meta.setAttribute("content", backgroundColor);
    document.head.appendChild(meta);
    setNavigationBarStyle({
        frontColor,
        backgroundColor
    });
    return handle.success();
};
function hideNavigationBarLoading(options3 = {}) {
    const { success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "hideNavigationBarLoading",
        success,
        fail,
        complete
    });
    setNavigationBarLoading(false);
    return handle.success();
}
var hideHomeButton = temporarilyNotSupport("hideHomeButton");
// node_modules/@tarojs/taro-h5/dist/api/ui/pull-down-refresh.js
var startPullDownRefresh = function({ success, fail, complete } = {}) {
    const handle = new MethodHandler({
        name: "startPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStartPullDownRefresh", {
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var stopPullDownRefresh = function({ success, fail, complete } = {}) {
    const handle = new MethodHandler({
        name: "stopPullDownRefresh",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroStopPullDownRefresh", {
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/scroll/index.js
var timer;
var FRAME_DURATION = 17;
var pageScrollTo = ({ scrollTop, selector = "", offsetTop = 0, duration = 300, success, fail, complete })=>{
    let scrollFunc;
    const handle = new MethodHandler({
        name: "pageScrollTo",
        success,
        fail,
        complete
    });
    return new Promise((resolve, reject)=>{
        var _a, _b, _c;
        try {
            if (scrollTop === void 0 && !selector) {
                return handle.fail({
                    errMsg: 'scrollTop" \u6216 "selector" \u9700\u8981\u5176\u4E4B\u4E00'
                }, {
                    resolve,
                    reject
                });
            }
            const usingWindowScroll = (_a = window.__taroAppConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll;
            const id = (_c = (_b = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _b === void 0 ? void 0 : _b.path) === null || _c === void 0 ? void 0 : _c.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
            const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
            if (!scrollFunc) {
                if (usingWindowScroll) {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return window.pageYOffset;
                        } else {
                            window.scrollTo(0, pos);
                        }
                    };
                } else {
                    scrollFunc = (pos)=>{
                        if (pos === void 0) {
                            return el.scrollTop;
                        } else {
                            el.scrollTop = pos;
                        }
                    };
                }
            }
            if (scrollTop && selector) {
                console.warn('"scrollTop" \u6216 "selector" \u5EFA\u8BAE\u53EA\u8BBE\u4E00\u4E2A\u503C\uFF0C\u5168\u90E8\u8BBE\u7F6E\u4F1A\u5FFD\u7565selector');
            }
            const from = scrollFunc();
            let to;
            if (selector) {
                const el2 = document.querySelector(selector);
                to = ((el2 === null || el2 === void 0 ? void 0 : el2.offsetTop) || 0) + offsetTop;
            } else {
                to = typeof scrollTop === "number" ? scrollTop : 0;
            }
            const delta = to - from;
            const frameCnt = duration / FRAME_DURATION;
            const easeFunc = getTimingFunc(easeInOut, frameCnt);
            const scroll = (frame = 0)=>{
                const dest = from + delta * easeFunc(frame);
                scrollFunc(dest);
                if (frame < frameCnt) {
                    timer && clearTimeout(timer);
                    timer = setTimeout(()=>{
                        scroll(frame + 1);
                    }, FRAME_DURATION);
                } else {
                    return handle.success({}, {
                        resolve,
                        reject
                    });
                }
            };
            scroll();
        } catch (e) {
            return handle.fail({
                errMsg: e.message
            }, {
                resolve,
                reject
            });
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/sticky.js
var setTopBarText = temporarilyNotSupport("setTopBarText");
// node_modules/@tarojs/taro-h5/dist/api/ui/tab-bar.js
var tabConf;
function initTabBarApis(config = {}) {
    tabConf = config.tabBar;
}
var showTabBarRedDot = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `showTabBarRedDot:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "showTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBarRedDotHandler", {
            index,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var showTabBar = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `showTabBar:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "showTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroShowTabBar", {
            animation,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarStyle = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarStyle:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { color, selectedColor, backgroundColor, borderStyle, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setTabBarStyle",
        success,
        fail,
        complete
    });
    let errMsg;
    if (color && !isValidColor(color)) {
        errMsg = "color";
    } else if (selectedColor && !isValidColor(selectedColor)) {
        errMsg = "selectedColor";
    } else if (backgroundColor && !isValidColor(backgroundColor)) {
        errMsg = "backgroundColor";
    } else if (borderStyle && !/^(black|white)$/.test(borderStyle)) {
        errMsg = "borderStyle";
    }
    if (errMsg) {
        return handle.fail({
            errMsg: `invalid ${errMsg}`
        });
    }
    if (!tabConf) {
        return handle.fail();
    }
    const obj = {};
    if (color) obj.color = color;
    if (selectedColor) obj.selectedColor = selectedColor;
    if (backgroundColor) obj.backgroundColor = backgroundColor;
    if (borderStyle) obj.borderStyle = borderStyle;
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarStyle", {
            color,
            selectedColor,
            backgroundColor,
            borderStyle,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarItem = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarItem:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, text, iconPath, selectedIconPath, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setTabBarItem",
        success,
        fail,
        complete
    });
    if (typeof index !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarItem", {
            index,
            text,
            iconPath,
            selectedIconPath,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var setTabBarBadge = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `setTabBarBadge:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, text, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "setTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index
            })
        });
    }
    if (typeof text !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "text",
                correct: "String",
                wrong: text
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroSetTabBarBadge", {
            index,
            text: text.replace(/[\u0391-\uFFE5]/g, "aa").length > 4 ? "..." : text,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var removeTabBarBadge = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `removeTabBarBadge:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "removeTabBarBadge",
        success,
        fail,
        complete
    });
    if (typeof index !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroRemoveTabBarBadge", {
            index,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBarRedDot = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `hideTabBarRedDot:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { index, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "hideTabBarRedDot",
        success,
        fail,
        complete
    });
    if (typeof index !== "number") {
        return handle.fail({
            errMsg: getParameterError({
                para: "index",
                correct: "Number",
                wrong: index
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBarRedDotHandler", {
            index,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
var hideTabBar = (options3 = {})=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `hideTabBar:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { animation, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: "hideTabBar",
        success,
        fail,
        complete
    });
    if (options3.hasOwnProperty("animation") && typeof animation !== "boolean") {
        return handle.fail({
            errMsg: getParameterError({
                para: "animation",
                correct: "Boolean",
                wrong: animation
            })
        });
    }
    return new Promise((resolve, reject)=>{
        Taro.eventCenter.trigger("__taroHideTabBar", {
            animation,
            successHandler: (res = {})=>handle.success(res, {
                    resolve,
                    reject
                }),
            errorHandler: (res = {})=>handle.fail(res, {
                    resolve,
                    reject
                })
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/ui/window.js
var callbackManager4 = new CallbackManager();
var resizeListener = ()=>{
    callbackManager4.trigger({
        windowWidth: window.screen.width,
        windowHeight: window.screen.height
    });
};
var setWindowSize = temporarilyNotSupport("setWindowSize");
var onWindowResize = (callback)=>{
    callbackManager4.add(callback);
    if (callbackManager4.count() === 1) {
        window.addEventListener("resize", resizeListener);
    }
};
var offWindowResize = (callback)=>{
    callbackManager4.remove(callback);
    if (callbackManager4.count() === 0) {
        window.removeEventListener("resize", resizeListener);
    }
};
var checkIsPictureInPictureActive = temporarilyNotSupport("checkIsPictureInPictureActive");
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseMedia.js
var chooseMedia = function(options_1) {
    return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, arguments, void 0, function*(options3, methodName = "chooseMedia") {
        var _a;
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res2 = {
                errMsg: `${methodName}:fail ${isObject6.msg}`
            };
            console.error(res2.errMsg);
            return Promise.reject(res2);
        }
        const { count = 9, mediaId = "taroChooseMedia", mediaType = [
            "image",
            "video"
        ], sourceType = [
            "album",
            "camera"
        ], // sizeType = ['original', 'compressed'], // TODO  ffmpeg 
        // maxDuration = 10, // TODO  ffmpeg 
        camera = "back", success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: methodName,
            success,
            fail,
            complete
        });
        const withImage = mediaType.length < 1 || mediaType.indexOf("image") > -1;
        const withVideo = mediaType.length < 1 || mediaType.indexOf("video") > -1;
        const res = {
            tempFiles: [],
            type: withImage && withVideo ? "mix" : withImage ? "image" : "video"
        };
        if (count && typeof count !== "number") {
            res.errMsg = getParameterError({
                para: "count",
                correct: "Number",
                wrong: count
            });
            return handle.fail(res);
        }
        let el = document.getElementById(mediaId);
        if (!el) {
            el = document.createElement("input");
            el.setAttribute("type", "file");
            el.setAttribute("id", mediaId);
            el.setAttribute("style", "position: fixed; top: -4000px; left: -3000px; z-index: -300;");
        }
        if (count > 1) {
            el.setAttribute("multiple", "multiple");
        } else {
            el.removeAttribute("multiple");
        }
        if ((0, import_is_mobile.isMobile)()) {
            if (sourceType.length > 1 || sourceType.length < 1) {
                try {
                    const { tapIndex } = yield showActionSheet({
                        itemList: [
                            "\u62CD\u6444",
                            "\u4ECE\u76F8\u518C\u9009\u62E9"
                        ]
                    }, methodName);
                    sourceType.splice(0, sourceType.length, tapIndex === 0 ? "camera" : "album");
                } catch (e) {
                    return handle.fail({
                        errMsg: (_a = e.errMsg) === null || _a === void 0 ? void 0 : _a.replace("^.*:fail ", "")
                    });
                }
            }
        }
        if (sourceType.includes("camera")) {
            el.setAttribute("capture", camera === "front" ? "user" : "environment");
        } else {
            el.removeAttribute("capture");
        }
        if (res.type === "image") {
            el.setAttribute("accept", "image/*");
        } else if (res.type === "video") {
            el.setAttribute("accept", "video/*");
        } else {
            el.setAttribute("accept", "image/*, video/*");
        }
        return new Promise((resolve, reject)=>{
            if (!el) return;
            document.body.appendChild(el);
            el.onchange = function(e) {
                return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
                    const target = e.target;
                    if (target) {
                        const files = target.files || [];
                        const arr = [
                            ...files
                        ];
                        yield Promise.all(arr.map((item)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
                                var _a2;
                                try {
                                    (_a2 = res.tempFiles) === null || _a2 === void 0 ? void 0 : _a2.push((yield loadMedia(item)));
                                } catch (error) {
                                    console.error(error);
                                }
                            })));
                    }
                    handle.success(res, {
                        resolve,
                        reject
                    });
                    target.value = "";
                });
            };
            el.onabort = ()=>handle.fail({
                    errMsg: "abort"
                }, {
                    resolve,
                    reject
                });
            el.oncancel = ()=>handle.fail({
                    errMsg: "cancel"
                }, {
                    resolve,
                    reject
                });
            el.onerror = (e)=>handle.fail({
                    errMsg: e.toString()
                }, {
                    resolve,
                    reject
                });
            el.click();
        }).finally(()=>{
            if (!el) return;
            document.body.removeChild(el);
        });
        function loadMedia(file) {
            const dataUrl = URL.createObjectURL(file);
            const res2 = {
                tempFilePath: dataUrl,
                size: file.size,
                duration: 0,
                height: 0,
                width: 0,
                thumbTempFilePath: "",
                fileType: file.type,
                originalFileObj: file
            };
            if (/^video\//.test(res2.fileType)) {
                const isIOS = getDeviceInfo().system.toLowerCase().includes("ios");
                const video = document.createElement("video");
                const reader = new FileReader();
                video.crossOrigin = "Anonymous";
                video.preload = "metadata";
                video.src = res2.tempFilePath;
                return new Promise((resolve, reject)=>{
                    reader.onload = (event2)=>{
                        var _a2;
                        res2.tempFilePath = (_a2 = event2.target) === null || _a2 === void 0 ? void 0 : _a2.result;
                    };
                    reader.onerror = (e)=>reject(e);
                    reader.readAsDataURL(res2.originalFileObj);
                    video.onloadedmetadata = ()=>{
                        res2.duration = video.duration;
                        res2.height = video.videoHeight;
                        res2.width = video.videoWidth;
                    };
                    video.oncanplay = ()=>{
                        res2.thumbTempFilePath = getThumbTempFilePath(video, res2.height, res2.width, 0.8);
                        resolve(res2);
                    };
                    video.onerror = (e)=>reject(e);
                    isIOS && video.load();
                });
            } else {
                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = res2.tempFilePath;
                return new Promise((resolve, reject)=>{
                    if (img.complete) {
                        res2.height = img.height;
                        res2.width = img.width;
                        res2.thumbTempFilePath = getThumbTempFilePath(img, res2.height, res2.width, 0.8);
                        resolve(res2);
                    } else {
                        img.onload = ()=>{
                            res2.height = img.height;
                            res2.width = img.width;
                            res2.thumbTempFilePath = getThumbTempFilePath(img, res2.height, res2.width, 0.8);
                            resolve(res2);
                        };
                        img.onerror = (e)=>reject(e);
                    }
                });
            }
        }
        function getThumbTempFilePath(el2, height = 0, width = height, quality = 0.8) {
            const max = 256;
            const canvas = document.createElement("canvas");
            if (height > max || width > max) {
                const radio = height / width;
                if (radio > 1) {
                    height = max;
                    width = height / radio;
                } else {
                    width = max;
                    height = width * radio;
                }
            }
            canvas.height = height;
            canvas.width = width;
            const ctx = canvas.getContext("2d");
            ctx === null || ctx === void 0 ? void 0 : ctx.drawImage(el2, 0, 0, canvas.width, canvas.height);
            return canvas.toDataURL("image/jpeg", quality);
        }
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/chooseImage.js
var chooseImage = function(options3) {
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `chooseImage:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    let camera = "back";
    const { sourceType = [
        "album",
        "camera"
    ], success, complete, fail } = options3, args = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__rest)(options3, [
        "sourceType",
        "success",
        "complete",
        "fail"
    ]);
    if (sourceType.includes("camera") && sourceType.indexOf("user") > -1) {
        camera = "front";
    }
    function parseRes(res) {
        const { tempFiles = [], errMsg } = res;
        return {
            tempFilePaths: tempFiles.map((item)=>item.tempFilePath),
            tempFiles: tempFiles.map((item)=>({
                    path: item.tempFilePath,
                    size: item.size,
                    type: item.fileType,
                    originalFileObj: item.originalFileObj
                })),
            errMsg
        };
    }
    return chooseMedia(Object.assign(Object.assign({
        mediaId: "taroChooseImage"
    }, args), {
        sourceType,
        mediaType: [
            "image"
        ],
        camera,
        success: (res)=>{
            const param = parseRes(res);
            success === null || success === void 0 ? void 0 : success(param);
            complete === null || complete === void 0 ? void 0 : complete(param);
        },
        fail: (err)=>{
            fail === null || fail === void 0 ? void 0 : fail(err);
            complete === null || complete === void 0 ? void 0 : complete(err);
        }
    }), "chooseImage").then(parseRes);
};
// node_modules/@tarojs/taro-h5/dist/api/media/image/index.js
var previewMedia = temporarilyNotSupport("previewMedia");
var compressImage = temporarilyNotSupport("compressImage");
var chooseMessageFile = permanentlyNotSupport("chooseMessageFile");
var editImage = temporarilyNotSupport("editImage");
var cropImage = temporarilyNotSupport("cropImage");
// node_modules/@tarojs/taro-h5/dist/api/media/live.js
var createLivePusherContext = temporarilyNotSupport("createLivePusherContext");
var createLivePlayerContext = temporarilyNotSupport("createLivePlayerContext");
// node_modules/@tarojs/taro-h5/dist/api/media/map.js
var createMapContext = temporarilyNotSupport("createMapContext");
// node_modules/@tarojs/taro-h5/dist/api/media/media-recorder.js
var createMediaRecorder = temporarilyNotSupport("createMediaRecorder");
// node_modules/@tarojs/taro-h5/dist/api/media/recorder.js
var stopRecord = temporarilyNotSupport("stopRecord");
var startRecord = temporarilyNotSupport("startRecord");
var getRecorderManager = temporarilyNotSupport("getRecorderManager");
// node_modules/@tarojs/taro-h5/dist/api/media/video/saveVideoToPhotosAlbum.js
var saveVideoToPhotosAlbum = (options3)=>{
    const methodName = "saveVideoToPhotosAlbum";
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `${methodName}:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { filePath, success, fail, complete } = options3;
    const handle = new MethodHandler({
        name: methodName,
        success,
        fail,
        complete
    });
    if (typeof filePath !== "string") {
        return handle.fail({
            errMsg: getParameterError({
                para: "filePath",
                correct: "String",
                wrong: filePath
            })
        });
    }
    createDownload(filePath);
    return handle.success();
};
// node_modules/whatwg-fetch/fetch.js
var g = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || // eslint-disable-next-line no-undef
typeof __webpack_require__.g !== "undefined" && __webpack_require__.g || {};
var support = {
    searchParams: "URLSearchParams" in g,
    iterable: "Symbol" in g && "iterator" in Symbol,
    blob: "FileReader" in g && "Blob" in g && function() {
        try {
            new Blob();
            return true;
        } catch (e) {
            return false;
        }
    }(),
    formData: "FormData" in g,
    arrayBuffer: "ArrayBuffer" in g
};
function isDataView(obj) {
    return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
    viewClasses = [
        "[object Int8Array]",
        "[object Uint8Array]",
        "[object Uint8ClampedArray]",
        "[object Int16Array]",
        "[object Uint16Array]",
        "[object Int32Array]",
        "[object Uint32Array]",
        "[object Float32Array]",
        "[object Float64Array]"
    ];
    isArrayBufferView = ArrayBuffer.isView || function(obj) {
        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
    };
}
var viewClasses;
var isArrayBufferView;
function normalizeName(name) {
    if (typeof name !== "string") {
        name = String(name);
    }
    if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
        throw new TypeError('Invalid character in header field name: "' + name + '"');
    }
    return name.toLowerCase();
}
function normalizeValue(value) {
    if (typeof value !== "string") {
        value = String(value);
    }
    return value;
}
function iteratorFor(items) {
    var iterator = {
        next: function() {
            var value = items.shift();
            return {
                done: value === void 0,
                value
            };
        }
    };
    if (support.iterable) {
        iterator[Symbol.iterator] = function() {
            return iterator;
        };
    }
    return iterator;
}
function Headers(headers) {
    this.map = {};
    if (headers instanceof Headers) {
        headers.forEach(function(value, name) {
            this.append(name, value);
        }, this);
    } else if (Array.isArray(headers)) {
        headers.forEach(function(header) {
            if (header.length != 2) {
                throw new TypeError("Headers constructor: expected name/value pair to be length 2, found" + header.length);
            }
            this.append(header[0], header[1]);
        }, this);
    } else if (headers) {
        Object.getOwnPropertyNames(headers).forEach(function(name) {
            this.append(name, headers[name]);
        }, this);
    }
}
Headers.prototype.append = function(name, value) {
    name = normalizeName(name);
    value = normalizeValue(value);
    var oldValue = this.map[name];
    this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
    delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
    name = normalizeName(name);
    return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
    return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
    this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
    for(var name in this.map){
        if (this.map.hasOwnProperty(name)) {
            callback.call(thisArg, this.map[name], name, this);
        }
    }
};
Headers.prototype.keys = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push(name);
    });
    return iteratorFor(items);
};
Headers.prototype.values = function() {
    var items = [];
    this.forEach(function(value) {
        items.push(value);
    });
    return iteratorFor(items);
};
Headers.prototype.entries = function() {
    var items = [];
    this.forEach(function(value, name) {
        items.push([
            name,
            value
        ]);
    });
    return iteratorFor(items);
};
if (support.iterable) {
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
    if (body._noBody) return;
    if (body.bodyUsed) {
        return Promise.reject(new TypeError("Already read"));
    }
    body.bodyUsed = true;
}
function fileReaderReady(reader) {
    return new Promise(function(resolve, reject) {
        reader.onload = function() {
            resolve(reader.result);
        };
        reader.onerror = function() {
            reject(reader.error);
        };
    });
}
function readBlobAsArrayBuffer(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    reader.readAsArrayBuffer(blob);
    return promise;
}
function readBlobAsText(blob) {
    var reader = new FileReader();
    var promise = fileReaderReady(reader);
    var match2 = /charset=([A-Za-z0-9_-]+)/.exec(blob.type);
    var encoding = match2 ? match2[1] : "utf-8";
    reader.readAsText(blob, encoding);
    return promise;
}
function readArrayBufferAsText(buf) {
    var view = new Uint8Array(buf);
    var chars = new Array(view.length);
    for(var i2 = 0; i2 < view.length; i2++){
        chars[i2] = String.fromCharCode(view[i2]);
    }
    return chars.join("");
}
function bufferClone(buf) {
    if (buf.slice) {
        return buf.slice(0);
    } else {
        var view = new Uint8Array(buf.byteLength);
        view.set(new Uint8Array(buf));
        return view.buffer;
    }
}
function Body() {
    this.bodyUsed = false;
    this._initBody = function(body) {
        this.bodyUsed = this.bodyUsed;
        this._bodyInit = body;
        if (!body) {
            this._noBody = true;
            this._bodyText = "";
        } else if (typeof body === "string") {
            this._bodyText = body;
        } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
            this._bodyBlob = body;
        } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
            this._bodyFormData = body;
        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
            this._bodyText = body.toString();
        } else if (support.arrayBuffer && support.blob && isDataView(body)) {
            this._bodyArrayBuffer = bufferClone(body.buffer);
            this._bodyInit = new Blob([
                this._bodyArrayBuffer
            ]);
        } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
            this._bodyArrayBuffer = bufferClone(body);
        } else {
            this._bodyText = body = Object.prototype.toString.call(body);
        }
        if (!this.headers.get("content-type")) {
            if (typeof body === "string") {
                this.headers.set("content-type", "text/plain;charset=UTF-8");
            } else if (this._bodyBlob && this._bodyBlob.type) {
                this.headers.set("content-type", this._bodyBlob.type);
            } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
            }
        }
    };
    if (support.blob) {
        this.blob = function() {
            var rejected = consumed(this);
            if (rejected) {
                return rejected;
            }
            if (this._bodyBlob) {
                return Promise.resolve(this._bodyBlob);
            } else if (this._bodyArrayBuffer) {
                return Promise.resolve(new Blob([
                    this._bodyArrayBuffer
                ]));
            } else if (this._bodyFormData) {
                throw new Error("could not read FormData body as blob");
            } else {
                return Promise.resolve(new Blob([
                    this._bodyText
                ]));
            }
        };
    }
    this.arrayBuffer = function() {
        if (this._bodyArrayBuffer) {
            var isConsumed = consumed(this);
            if (isConsumed) {
                return isConsumed;
            } else if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
                return Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength));
            } else {
                return Promise.resolve(this._bodyArrayBuffer);
            }
        } else if (support.blob) {
            return this.blob().then(readBlobAsArrayBuffer);
        } else {
            throw new Error("could not read as ArrayBuffer");
        }
    };
    this.text = function() {
        var rejected = consumed(this);
        if (rejected) {
            return rejected;
        }
        if (this._bodyBlob) {
            return readBlobAsText(this._bodyBlob);
        } else if (this._bodyArrayBuffer) {
            return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
        } else if (this._bodyFormData) {
            throw new Error("could not read FormData body as text");
        } else {
            return Promise.resolve(this._bodyText);
        }
    };
    if (support.formData) {
        this.formData = function() {
            return this.text().then(decode3);
        };
    }
    this.json = function() {
        return this.text().then(JSON.parse);
    };
    return this;
}
var methods = [
    "CONNECT",
    "DELETE",
    "GET",
    "HEAD",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
    "TRACE"
];
function normalizeMethod(method) {
    var upcased = method.toUpperCase();
    return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options3) {
    if (!(this instanceof Request)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    options3 = options3 || {};
    var body = options3.body;
    if (input instanceof Request) {
        if (input.bodyUsed) {
            throw new TypeError("Already read");
        }
        this.url = input.url;
        this.credentials = input.credentials;
        if (!options3.headers) {
            this.headers = new Headers(input.headers);
        }
        this.method = input.method;
        this.mode = input.mode;
        this.signal = input.signal;
        if (!body && input._bodyInit != null) {
            body = input._bodyInit;
            input.bodyUsed = true;
        }
    } else {
        this.url = String(input);
    }
    this.credentials = options3.credentials || this.credentials || "same-origin";
    if (options3.headers || !this.headers) {
        this.headers = new Headers(options3.headers);
    }
    this.method = normalizeMethod(options3.method || this.method || "GET");
    this.mode = options3.mode || this.mode || null;
    this.signal = options3.signal || this.signal || function() {
        if ("AbortController" in g) {
            var ctrl = new AbortController();
            return ctrl.signal;
        }
    }();
    this.referrer = null;
    if ((this.method === "GET" || this.method === "HEAD") && body) {
        throw new TypeError("Body not allowed for GET or HEAD requests");
    }
    this._initBody(body);
    if (this.method === "GET" || this.method === "HEAD") {
        if (options3.cache === "no-store" || options3.cache === "no-cache") {
            var reParamSearch = /([?&])_=[^&]*/;
            if (reParamSearch.test(this.url)) {
                this.url = this.url.replace(reParamSearch, "$1_=" + /* @__PURE__ */ new Date().getTime());
            } else {
                var reQueryString = /\?/;
                this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + /* @__PURE__ */ new Date().getTime();
            }
        }
    }
}
Request.prototype.clone = function() {
    return new Request(this, {
        body: this._bodyInit
    });
};
function decode3(body) {
    var form = new FormData();
    body.trim().split("&").forEach(function(bytes) {
        if (bytes) {
            var split2 = bytes.split("=");
            var name = split2.shift().replace(/\+/g, " ");
            var value = split2.join("=").replace(/\+/g, " ");
            form.append(decodeURIComponent(name), decodeURIComponent(value));
        }
    });
    return form;
}
function parseHeaders(rawHeaders) {
    var headers = new Headers();
    var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
    preProcessedHeaders.split("\r").map(function(header) {
        return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
    }).forEach(function(line) {
        var parts = line.split(":");
        var key = parts.shift().trim();
        if (key) {
            var value = parts.join(":").trim();
            try {
                headers.append(key, value);
            } catch (error) {
                console.warn("Response " + error.message);
            }
        }
    });
    return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options3) {
    if (!(this instanceof Response)) {
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
    }
    if (!options3) {
        options3 = {};
    }
    this.type = "default";
    this.status = options3.status === void 0 ? 200 : options3.status;
    if (this.status < 200 || this.status > 599) {
        throw new RangeError("Failed to construct 'Response': The status provided (0) is outside the range [200, 599].");
    }
    this.ok = this.status >= 200 && this.status < 300;
    this.statusText = options3.statusText === void 0 ? "" : "" + options3.statusText;
    this.headers = new Headers(options3.headers);
    this.url = options3.url || "";
    this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
    return new Response(this._bodyInit, {
        status: this.status,
        statusText: this.statusText,
        headers: new Headers(this.headers),
        url: this.url
    });
};
Response.error = function() {
    var response = new Response(null, {
        status: 200,
        statusText: ""
    });
    response.ok = false;
    response.status = 0;
    response.type = "error";
    return response;
};
var redirectStatuses = [
    301,
    302,
    303,
    307,
    308
];
Response.redirect = function(url, status2) {
    if (redirectStatuses.indexOf(status2) === -1) {
        throw new RangeError("Invalid status code");
    }
    return new Response(null, {
        status: status2,
        headers: {
            location: url
        }
    });
};
var DOMException2 = g.DOMException;
try {
    new DOMException2();
} catch (err) {
    DOMException2 = function(message, name) {
        this.message = message;
        this.name = name;
        var error = Error(message);
        this.stack = error.stack;
    };
    DOMException2.prototype = Object.create(Error.prototype);
    DOMException2.prototype.constructor = DOMException2;
}
function fetch2(input, init2) {
    return new Promise(function(resolve, reject) {
        var request2 = new Request(input, init2);
        if (request2.signal && request2.signal.aborted) {
            return reject(new DOMException2("Aborted", "AbortError"));
        }
        var xhr = new XMLHttpRequest();
        function abortXhr() {
            xhr.abort();
        }
        xhr.onload = function() {
            var options3 = {
                statusText: xhr.statusText,
                headers: parseHeaders(xhr.getAllResponseHeaders() || "")
            };
            if (request2.url.indexOf("file://") === 0 && (xhr.status < 200 || xhr.status > 599)) {
                options3.status = 200;
            } else {
                options3.status = xhr.status;
            }
            options3.url = "responseURL" in xhr ? xhr.responseURL : options3.headers.get("X-Request-URL");
            var body = "response" in xhr ? xhr.response : xhr.responseText;
            setTimeout(function() {
                resolve(new Response(body, options3));
            }, 0);
        };
        xhr.onerror = function() {
            setTimeout(function() {
                reject(new TypeError("Network request failed"));
            }, 0);
        };
        xhr.ontimeout = function() {
            setTimeout(function() {
                reject(new TypeError("Network request timed out"));
            }, 0);
        };
        xhr.onabort = function() {
            setTimeout(function() {
                reject(new DOMException2("Aborted", "AbortError"));
            }, 0);
        };
        function fixUrl(url) {
            try {
                return url === "" && g.location.href ? g.location.href : url;
            } catch (e) {
                return url;
            }
        }
        xhr.open(request2.method, fixUrl(request2.url), true);
        if (request2.credentials === "include") {
            xhr.withCredentials = true;
        } else if (request2.credentials === "omit") {
            xhr.withCredentials = false;
        }
        if ("responseType" in xhr) {
            if (support.blob) {
                xhr.responseType = "blob";
            } else if (support.arrayBuffer) {
                xhr.responseType = "arraybuffer";
            }
        }
        if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers || g.Headers && init2.headers instanceof g.Headers)) {
            var names = [];
            Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
                names.push(normalizeName(name));
                xhr.setRequestHeader(name, normalizeValue(init2.headers[name]));
            });
            request2.headers.forEach(function(value, name) {
                if (names.indexOf(name) === -1) {
                    xhr.setRequestHeader(name, value);
                }
            });
        } else {
            request2.headers.forEach(function(value, name) {
                xhr.setRequestHeader(name, value);
            });
        }
        if (request2.signal) {
            request2.signal.addEventListener("abort", abortXhr);
            xhr.onreadystatechange = function() {
                if (xhr.readyState === 4) {
                    request2.signal.removeEventListener("abort", abortXhr);
                }
            };
        }
        xhr.send(typeof request2._bodyInit === "undefined" ? null : request2._bodyInit);
    });
}
fetch2.polyfill = true;
if (!g.fetch) {
    g.fetch = fetch2;
    g.Headers = Headers;
    g.Request = Request;
    g.Response = Response;
}
// node_modules/@tarojs/taro-h5/dist/api/media/video/getVideoInfo.js
var getVideoInfo = function(options3) {
    return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res2 = {
                errMsg: `getVideoInfo:fail ${isObject6.msg}`
            };
            console.error(res2.errMsg);
            return Promise.reject(res2);
        }
        const res = {
            orientation: "up",
            type: "",
            duration: 0,
            size: 0,
            height: 0,
            width: 0,
            fps: 30,
            bitrate: 0
        };
        const { src, success, fail, complete } = options3;
        const handle = new MethodHandler({
            name: "getVideoInfo",
            success,
            fail,
            complete
        });
        if (typeof src !== "string") {
            res.errMsg = getParameterError({
                para: "src",
                correct: "String",
                wrong: src
            });
            return handle.fail(res);
        }
        const video = document.createElement("video");
        video.crossOrigin = "Anonymous";
        video.preload = "metadata";
        video.src = src;
        return new Promise((resolve, reject)=>{
            video.onloadedmetadata = ()=>{
                res.duration = video.duration;
                res.height = video.videoHeight;
                res.width = video.videoWidth;
                fetch(src).then((e)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
                        const blob = yield e.blob();
                        res.type = blob.type;
                        res.size = blob.size;
                        res.bitrate = blob.size / video.duration;
                        handle.success(res, {
                            resolve,
                            reject
                        });
                    })).catch((e)=>{
                    handle.fail({
                        errMsg: e.toString()
                    }, {
                        resolve,
                        reject
                    });
                });
            };
        });
    });
};
// node_modules/@tarojs/taro-h5/dist/api/media/video/chooseVideo.js
var chooseVideo = (options3)=>{
    const isObject6 = shouldBeObject(options3);
    if (!isObject6.flag) {
        const res = {
            errMsg: `chooseVideo:fail ${isObject6.msg}`
        };
        console.error(res.errMsg);
        return Promise.reject(res);
    }
    const { sourceType = [
        "album",
        "camera"
    ], // TODO  ffmpeg 
    // compressed = true,
    maxDuration = 60, camera = "back", success, fail, complete } = options3;
    function parseRes(res) {
        const { tempFiles = [], errMsg } = res;
        const [video] = tempFiles;
        return Object.assign(Object.assign({}, video), {
            errMsg
        });
    }
    return chooseMedia({
        mediaId: "taroChooseVideo",
        sourceType,
        mediaType: [
            "video"
        ],
        maxDuration,
        camera,
        success: (res)=>{
            const param = parseRes(res);
            success === null || success === void 0 ? void 0 : success(param);
            complete === null || complete === void 0 ? void 0 : complete(param);
        },
        fail: (err)=>{
            fail === null || fail === void 0 ? void 0 : fail(err);
            complete === null || complete === void 0 ? void 0 : complete(err);
        }
    }, "chooseVideo").then(parseRes);
};
// node_modules/@tarojs/taro-h5/dist/api/media/video/index.js
var openVideoEditor = temporarilyNotSupport("openVideoEditor");
var createVideoContext = (id, inst)=>{
    const el = findDOM(inst);
    return el === null || el === void 0 ? void 0 : el.querySelector(`taro-video-core[id=${id}]`);
};
var compressVideo = temporarilyNotSupport("compressVideo");
// node_modules/@tarojs/taro-h5/dist/api/media/video-decoder.js
var createVideoDecoder = temporarilyNotSupport("createVideoDecoder");
// node_modules/@tarojs/taro-h5/dist/api/media/video-processing.js
var createMediaContainer = temporarilyNotSupport("createMediaContainer");
// node_modules/@tarojs/taro-h5/dist/api/media/voip.js
var updateVoIPChatMuteConfig = temporarilyNotSupport("updateVoIPChatMuteConfig");
var subscribeVoIPVideoMembers = temporarilyNotSupport("subscribeVoIPVideoMembers");
var setEnable1v1Chat = temporarilyNotSupport("setEnable1v1Chat");
var onVoIPVideoMembersChanged = temporarilyNotSupport("onVoIPVideoMembersChanged");
var onVoIPChatStateChanged = temporarilyNotSupport("onVoIPChatStateChanged");
var onVoIPChatSpeakersChanged = temporarilyNotSupport("onVoIPChatSpeakersChanged");
var onVoIPChatMembersChanged = temporarilyNotSupport("onVoIPChatMembersChanged");
var onVoIPChatInterrupted = temporarilyNotSupport("onVoIPChatInterrupted");
var offVoIPChatSpeakersChanged = temporarilyNotSupport("offVoIPChatSpeakersChanged");
var offVoIPVideoMembersChanged = temporarilyNotSupport("offVoIPVideoMembersChanged");
var offVoIPChatStateChanged = temporarilyNotSupport("offVoIPChatStateChanged");
var offVoIPChatMembersChanged = temporarilyNotSupport("offVoIPChatMembersChanged");
var offVoIPChatInterrupted = temporarilyNotSupport("offVoIPChatInterrupted");
var joinVoIPChat = temporarilyNotSupport("joinVoIPChat");
var join1v1Chat = temporarilyNotSupport("join1v1Chat");
var exitVoIPChat = temporarilyNotSupport("exitVoIPChat");
// node_modules/@tarojs/taro-h5/dist/api/navigate/index.js
var openEmbeddedMiniProgram = temporarilyNotSupport("openEmbeddedMiniProgram");
var navigateToMiniProgram = temporarilyNotSupport("navigateToMiniProgram");
var navigateBackMiniProgram = temporarilyNotSupport("navigateBackMiniProgram");
var exitMiniProgram = temporarilyNotSupport("exitMiniProgram");
var openBusinessView = temporarilyNotSupport("openBusinessView");
// node_modules/@tarojs/taro-h5/dist/api/network/utils.js
var NETWORK_TIMEOUT = 6e4;
var XHR_STATS = {
    UNSENT: 0,
    // Client has been created. open() not called yet.
    OPENED: 1,
    // open() has been called.
    HEADERS_RECEIVED: 2,
    // send() has been called, and headers and status are available.
    LOADING: 3,
    // Downloading; responseText holds partial data.
    DONE: 4
};
var setHeader = (xhr, header)=>{
    let headerKey;
    for(headerKey in header){
        xhr.setRequestHeader(headerKey, header[headerKey]);
    }
};
var convertObjectUrlToBlob = (url)=>{
    return new Promise((resolve, reject)=>{
        const xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.responseType = "blob";
        xhr.withCredentials = true;
        xhr.onload = function() {
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject({
                    status: this.status
                });
            }
        };
        xhr.send();
    });
};
// node_modules/@tarojs/taro-h5/dist/api/network/download.js
var createDownloadTask = ({ url, header, withCredentials = true, timeout, success, error })=>{
    let timeoutInter;
    const apiName = "downloadFile";
    const xhr = new XMLHttpRequest();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("GET", url, true);
    xhr.withCredentials = !!withCredentials;
    xhr.responseType = "blob";
    setHeader(xhr, header);
    xhr.onprogress = (e)=>{
        const { loaded, total } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesWritten: loaded,
            totalBytesExpectedToWrite: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const response = xhr.response;
        const status2 = xhr.status;
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            tempFilePath: window.URL.createObjectURL(response)
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        xhr.abort();
    };
    const send = ()=>{
        xhr.send();
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    send();
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var downloadFile = ({ url, header, withCredentials, timeout, success, fail, complete })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createDownloadTask({
            url,
            header,
            withCredentials,
            timeout,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived.bind(task);
    result.progress = task.onProgressUpdate.bind(task);
    const properties = {};
    Object.keys(task).forEach((key)=>{
        properties[key] = {
            get () {
                return typeof task[key] === "function" ? task[key].bind(task) : task[key];
            }
        };
    });
    return Object.defineProperties(result, properties);
};
// node_modules/@tarojs/taro-h5/dist/api/network/mdns.js
var stopLocalServiceDiscovery = temporarilyNotSupport("stopLocalServiceDiscovery");
var startLocalServiceDiscovery = temporarilyNotSupport("startLocalServiceDiscovery");
var onLocalServiceResolveFail = temporarilyNotSupport("onLocalServiceResolveFail");
var onLocalServiceLost = temporarilyNotSupport("onLocalServiceLost");
var onLocalServiceFound = temporarilyNotSupport("onLocalServiceFound");
var onLocalServiceDiscoveryStop = temporarilyNotSupport("onLocalServiceDiscoveryStop");
var offLocalServiceResolveFail = temporarilyNotSupport("offLocalServiceResolveFail");
var offLocalServiceLost = temporarilyNotSupport("offLocalServiceLost");
var offLocalServiceFound = temporarilyNotSupport("offLocalServiceFound");
var offLocalServiceDiscoveryStop = temporarilyNotSupport("offLocalServiceDiscoveryStop");
// node_modules/abortcontroller-polyfill/dist/abortcontroller-polyfill-only.js
(function(factory) {
     false ? 0 : factory();
})(function() {
    "use strict";
    function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for(var e = 0, n = Array(a); e < a; e++)n[e] = r[e];
        return n;
    }
    function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
    }
    function _callSuper(t, o, e) {
        return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
    }
    function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }
    function _defineProperties(e, r) {
        for(var t = 0; t < r.length; t++){
            var o = r[t];
            o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, _toPropertyKey(o.key), o);
        }
    }
    function _createClass(e, r, t) {
        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
            writable: false
        }), e;
    }
    function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
            if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
                t && (r = t);
                var n = 0, F = function() {};
                return {
                    s: F,
                    n: function() {
                        return n >= r.length ? {
                            done: true
                        } : {
                            done: false,
                            value: r[n++]
                        };
                    },
                    e: function(r2) {
                        throw r2;
                    },
                    f: F
                };
            }
            throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o, a = true, u = false;
        return {
            s: function() {
                t = t.call(r);
            },
            n: function() {
                var r2 = t.next();
                return a = r2.done, r2;
            },
            e: function(r2) {
                u = true, o = r2;
            },
            f: function() {
                try {
                    a || null == t.return || t.return();
                } finally{
                    if (u) throw o;
                }
            }
        };
    }
    function _get() {
        return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
            var p = _superPropBase(e, t);
            if (p) {
                var n = Object.getOwnPropertyDescriptor(p, t);
                return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
            }
        }, _get.apply(null, arguments);
    }
    function _getPrototypeOf(t) {
        return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t2) {
            return t2.__proto__ || Object.getPrototypeOf(t2);
        }, _getPrototypeOf(t);
    }
    function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
            constructor: {
                value: t,
                writable: true,
                configurable: true
            }
        }), Object.defineProperty(t, "prototype", {
            writable: false
        }), e && _setPrototypeOf(t, e);
    }
    function _isNativeReflectConstruct() {
        try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        } catch (t2) {}
        return (_isNativeReflectConstruct = function() {
            return !!t;
        })();
    }
    function _possibleConstructorReturn(t, e) {
        if (e && ("object" == typeof e || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return _assertThisInitialized(t);
    }
    function _setPrototypeOf(t, e) {
        return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t2, e2) {
            return t2.__proto__ = e2, t2;
        }, _setPrototypeOf(t, e);
    }
    function _superPropBase(t, o) {
        for(; !({}).hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)););
        return t;
    }
    function _superPropGet(t, o, e, r) {
        var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e);
        return 2 & r && "function" == typeof p ? function(t2) {
            return p.apply(e, t2);
        } : p;
    }
    function _toPrimitive(t, r) {
        if ("object" != typeof t || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
            var i2 = e.call(t, r || "default");
            if ("object" != typeof i2) return i2;
            throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
    }
    function _toPropertyKey(t) {
        var i2 = _toPrimitive(t, "string");
        return "symbol" == typeof i2 ? i2 : i2 + "";
    }
    function _unsupportedIterableToArray(r, a) {
        if (r) {
            if ("string" == typeof r) return _arrayLikeToArray(r, a);
            var t = ({}).toString.call(r).slice(8, -1);
            return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
    }
    (function(self2) {
        return {
            NativeAbortSignal: self2.AbortSignal,
            NativeAbortController: self2.AbortController
        };
    })(typeof self !== "undefined" ? self : __webpack_require__.g);
    function createAbortEvent(reason) {
        var event2;
        try {
            event2 = new Event("abort");
        } catch (e) {
            if (typeof document !== "undefined") {
                if (!document.createEvent) {
                    event2 = document.createEventObject();
                    event2.type = "abort";
                } else {
                    event2 = document.createEvent("Event");
                    event2.initEvent("abort", false, false);
                }
            } else {
                event2 = {
                    type: "abort",
                    bubbles: false,
                    cancelable: false
                };
            }
        }
        event2.reason = reason;
        return event2;
    }
    function normalizeAbortReason(reason) {
        if (reason === void 0) {
            if (typeof document === "undefined") {
                reason = new Error("This operation was aborted");
                reason.name = "AbortError";
            } else {
                try {
                    reason = new DOMException("signal is aborted without reason");
                    Object.defineProperty(reason, "name", {
                        value: "AbortError"
                    });
                } catch (err) {
                    reason = new Error("This operation was aborted");
                    reason.name = "AbortError";
                }
            }
        }
        return reason;
    }
    var Emitter = function() {
        function Emitter2() {
            _classCallCheck(this, Emitter2);
            Object.defineProperty(this, "listeners", {
                value: {},
                writable: true,
                configurable: true
            });
        }
        return _createClass(Emitter2, [
            {
                key: "addEventListener",
                value: function addEventListener(type, callback, options3) {
                    if (!(type in this.listeners)) {
                        this.listeners[type] = [];
                    }
                    this.listeners[type].push({
                        callback,
                        options: options3
                    });
                }
            },
            {
                key: "removeEventListener",
                value: function removeEventListener(type, callback) {
                    if (!(type in this.listeners)) {
                        return;
                    }
                    var stack = this.listeners[type];
                    for(var i2 = 0, l = stack.length; i2 < l; i2++){
                        if (stack[i2].callback === callback) {
                            stack.splice(i2, 1);
                            return;
                        }
                    }
                }
            },
            {
                key: "dispatchEvent",
                value: function dispatchEvent(event2) {
                    var _this = this;
                    if (!(event2.type in this.listeners)) {
                        return;
                    }
                    var stack = this.listeners[event2.type];
                    var stackToCall = stack.slice();
                    var _loop = function _loop2() {
                        var listener = stackToCall[i2];
                        try {
                            listener.callback.call(_this, event2);
                        } catch (e) {
                            Promise.resolve().then(function() {
                                throw e;
                            });
                        }
                        if (listener.options && listener.options.once) {
                            _this.removeEventListener(event2.type, listener.callback);
                        }
                    };
                    for(var i2 = 0, l = stackToCall.length; i2 < l; i2++){
                        _loop();
                    }
                    return !event2.defaultPrevented;
                }
            }
        ]);
    }();
    var AbortSignal = function(_Emitter) {
        function AbortSignal2() {
            var _this2;
            _classCallCheck(this, AbortSignal2);
            _this2 = _callSuper(this, AbortSignal2);
            if (!_this2.listeners) {
                Emitter.call(_this2);
            }
            Object.defineProperty(_this2, "aborted", {
                value: false,
                writable: true,
                configurable: true
            });
            Object.defineProperty(_this2, "onabort", {
                value: null,
                writable: true,
                configurable: true
            });
            Object.defineProperty(_this2, "reason", {
                value: void 0,
                writable: true,
                configurable: true
            });
            return _this2;
        }
        _inherits(AbortSignal2, _Emitter);
        return _createClass(AbortSignal2, [
            {
                key: "toString",
                value: function toString3() {
                    return "[object AbortSignal]";
                }
            },
            {
                key: "dispatchEvent",
                value: function dispatchEvent(event2) {
                    if (event2.type === "abort") {
                        this.aborted = true;
                        if (typeof this.onabort === "function") {
                            this.onabort.call(this, event2);
                        }
                    }
                    _superPropGet(AbortSignal2, "dispatchEvent", this, 3)([
                        event2
                    ]);
                }
            },
            {
                key: "throwIfAborted",
                value: function throwIfAborted() {
                    var aborted = this.aborted, _this$reason = this.reason, reason = _this$reason === void 0 ? "Aborted" : _this$reason;
                    if (!aborted) return;
                    throw reason;
                }
            }
        ], [
            {
                key: "timeout",
                value: function timeout(time) {
                    var controller = new AbortController2();
                    setTimeout(function() {
                        return controller.abort(new DOMException("This signal is timeout in ".concat(time, "ms"), "TimeoutError"));
                    }, time);
                    return controller.signal;
                }
            },
            {
                key: "any",
                value: function any(iterable) {
                    var controller = new AbortController2();
                    function abort() {
                        controller.abort(this.reason);
                        clean();
                    }
                    function clean() {
                        var _iterator = _createForOfIteratorHelper(iterable), _step;
                        try {
                            for(_iterator.s(); !(_step = _iterator.n()).done;){
                                var signal2 = _step.value;
                                signal2.removeEventListener("abort", abort);
                            }
                        } catch (err) {
                            _iterator.e(err);
                        } finally{
                            _iterator.f();
                        }
                    }
                    var _iterator2 = _createForOfIteratorHelper(iterable), _step2;
                    try {
                        for(_iterator2.s(); !(_step2 = _iterator2.n()).done;){
                            var signal = _step2.value;
                            if (signal.aborted) {
                                controller.abort(signal.reason);
                                break;
                            } else signal.addEventListener("abort", abort);
                        }
                    } catch (err) {
                        _iterator2.e(err);
                    } finally{
                        _iterator2.f();
                    }
                    return controller.signal;
                }
            }
        ]);
    }(Emitter);
    var AbortController2 = function() {
        function AbortController3() {
            _classCallCheck(this, AbortController3);
            Object.defineProperty(this, "signal", {
                value: new AbortSignal(),
                writable: true,
                configurable: true
            });
        }
        return _createClass(AbortController3, [
            {
                key: "abort",
                value: function abort(reason) {
                    var signalReason = normalizeAbortReason(reason);
                    var event2 = createAbortEvent(signalReason);
                    this.signal.reason = signalReason;
                    this.signal.dispatchEvent(event2);
                }
            },
            {
                key: "toString",
                value: function toString3() {
                    return "[object AbortController]";
                }
            }
        ]);
    }();
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
        AbortController2.prototype[Symbol.toStringTag] = "AbortController";
        AbortSignal.prototype[Symbol.toStringTag] = "AbortSignal";
    }
    function polyfillNeeded(self2) {
        if (self2.__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL) {
            console.log("__FORCE_INSTALL_ABORTCONTROLLER_POLYFILL=true is set, will force install polyfill");
            return true;
        }
        return typeof self2.Request === "function" && !self2.Request.prototype.hasOwnProperty("signal") || !self2.AbortController;
    }
    (function(self2) {
        if (!polyfillNeeded(self2)) {
            return;
        }
        self2.AbortController = AbortController2;
        self2.AbortSignal = AbortSignal;
    })(typeof self !== "undefined" ? self : __webpack_require__.g);
});
// node_modules/jsonp-retry/dist/jsonp.esm.js
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty11 = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
    if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
    }
    return Object(val);
}
function shouldUseNative() {
    try {
        if (!Object.assign) {
            return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
            return false;
        }
        var test2 = {};
        for(var i2 = 0; i2 < 10; i2++){
            test2["_" + String.fromCharCode(i2)] = i2;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
            return test2[n];
        });
        if (order2.join("") !== "0123456789") {
            return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
            test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
            return false;
        }
        return true;
    } catch (err) {
        return false;
    }
}
var objectAssign$1 = shouldUseNative() ? Object.assign : function(target, source) {
    var from;
    var to = toObject(target);
    var symbols;
    for(var s = 1; s < arguments.length; s++){
        from = Object(arguments[s]);
        for(var key in from){
            if (hasOwnProperty11.call(from, key)) {
                to[key] = from[key];
            }
        }
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for(var i2 = 0; i2 < symbols.length; i2++){
                if (propIsEnumerable.call(from, symbols[i2])) {
                    to[symbols[i2]] = from[symbols[i2]];
                }
            }
        }
    }
    return to;
};
var enc = encodeURIComponent;
function serializeParams2(params) {
    if (!params) {
        return "";
    }
    return Object.keys(params).map(function(item) {
        return item + "=" + enc(params[item]);
    }).join("&");
}
function isFunction3(fn) {
    return typeof fn === "function";
}
function getUrlQueryParamByName(url, name) {
    if (!url) {
        url = window.location.href;
    }
    name = name.replace(/[[]]/g, "\\$&");
    var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)");
    var results = regex.exec(url);
    if (!results) {
        return null;
    }
    if (!results[2]) {
        return "";
    }
    return decodeURIComponent(results[2].replace(/\+/g, " "));
}
function updateQueryStringParamByName(url, name, value) {
    var re = new RegExp("([?&])" + name + "=.*?(&|$)", "i");
    var separator = url.indexOf("?") !== -1 ? "&" : "?";
    if (url.match(re)) {
        return url.replace(re, "$1" + name + "=" + value + "$2");
    }
    return url + separator + name + "=" + value;
}
var win$1 = typeof window !== "undefined" ? window : __webpack_require__.g;
var localStorageName = "localStorage";
var storage = win$1[localStorageName];
var store = {
    disabled: false,
    set: function set2(key, val) {
        if (val === void 0) {
            return store.remove(key);
        }
        storage.setItem(key, store.serialize(val));
        return val;
    },
    get: function get(key, defaultVal) {
        var val = store.deserialize(storage.getItem(key));
        return val === void 0 ? defaultVal : val;
    },
    remove: function remove(key) {
        storage.removeItem(key);
    },
    clear: function clear() {
        storage.clear();
    },
    has: function has(key) {
        return store.get(key) !== void 0;
    },
    forEach: function forEach2(callback) {
        for(var i2 = 0; i2 < storage.length; i2++){
            var key = storage.key(i2);
            callback(key, store.get(key));
        }
    },
    getAll: function getAll() {
        var ret = {};
        store.forEach(function(key, val) {
            ret[key] = val;
        });
        return ret;
    },
    serialize: function serialize(value) {
        return JSON.stringify(value);
    },
    deserialize: function deserialize(value) {
        if (typeof value !== "string") {
            return;
        }
        try {
            return JSON.parse(value);
        } catch (err) {
            return value || void 0;
        }
    }
};
try {
    testKey = "__store__";
    store.set(testKey, testKey);
    if (store.get(testKey) !== testKey) {
        store.disabled = true;
    }
    store.remove(testKey);
} catch (err) {
    store.disabled = true;
}
var testKey;
store.enabled = !store.disabled;
var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
    return typeof obj;
} : function(obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};
var win2 = typeof window !== "undefined" ? window : __webpack_require__.g;
var canUsePromise = function() {
    return "Promise" in win2 && _typeof(isFunction3(Promise));
}();
var noop2 = function noop3() {};
var encodeC = encodeURIComponent;
var doc2 = win2.document;
var head = doc2 ? doc2.head || doc2.getElementsByTagName("head")[0] : null;
var TIMEOUT_CONST = 2e3;
var defaultConfig = {
    timeout: TIMEOUT_CONST,
    retryTimes: 2,
    backup: null,
    params: {},
    jsonp: "callback",
    name: null,
    cache: false,
    useStore: false,
    storeCheck: null,
    storeSign: null,
    storeCheckKey: null,
    dataCheck: null,
    charset: "UTF-8"
};
var timestamp = /* @__PURE__ */ new Date().getTime();
function jsonp$1(url, opts, cb) {
    if (isFunction3(url)) {
        cb = url;
        opts = {};
    } else if (url && (typeof url === "undefined" ? "undefined" : _typeof(url)) === "object") {
        cb = opts;
        opts = url || {};
        url = opts.url;
    }
    if (isFunction3(opts)) {
        cb = opts;
        opts = {};
    }
    if (!opts) {
        opts = {};
    }
    opts = objectAssign$1({}, defaultConfig, opts);
    url = url || opts.url;
    cb = cb || noop2;
    if (!url || typeof url !== "string") {
        cb(new Error("Param url is needed!"));
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve, reject) {
                return reject(new Error("Param url is needed!"));
            });
        }
        return;
    }
    var urlWithParams = generateJsonpUrlWithParams(url, opts.params);
    var datafromStore = getDataFromStore({
        useStore: opts.useStore,
        storeKey: urlWithParams,
        storeCheck: opts.storeCheck,
        storeCheckKey: opts.storeCheckKey,
        storeSign: opts.storeSign,
        dataCheck: opts.dataCheck
    });
    if (datafromStore) {
        cb(null, datafromStore);
        if (!jsonp$1.promiseClose && canUsePromise) {
            return new Promise(function(resolve) {
                return resolve(datafromStore);
            });
        }
        return;
    }
    opts.originalUrl = urlWithParams;
    if (!jsonp$1.promiseClose && canUsePromise) {
        return new Promise(function(resolve, reject) {
            fetchData(urlWithParams, opts, function(err, data) {
                if (err) {
                    cb(err);
                    return reject(err);
                }
                cb(null, data);
                resolve(data);
            });
        });
    }
    fetchData(urlWithParams, opts, cb);
}
function generateJsonpUrlWithParams(url, params) {
    params = typeof params === "string" ? params : serializeParams2(params);
    url += (~url.indexOf("?") ? "&" : "?") + ("" + params);
    url = url.replace("?&", "?");
    return url;
}
function fetchData(url, opts, cb) {
    var originalUrl = opts.originalUrl;
    var charset = opts.charset;
    var jsonpUrlQueryParam = getUrlQueryParamByName(url, opts.jsonp);
    var funcId = (jsonpUrlQueryParam === "?" ? false : jsonpUrlQueryParam) || opts.name || "__jsonp" + timestamp++;
    var gotoBackupInfo = arguments[3] || null;
    if (jsonpUrlQueryParam) {
        if (jsonpUrlQueryParam === "?") {
            url = updateQueryStringParamByName(url, opts.jsonp, encodeC(funcId));
        }
    } else {
        url += (url.split("").pop() === "&" ? "" : "&") + (opts.jsonp + "=" + encodeC(funcId));
    }
    if (!opts.cache) {
        url += (url.split("").pop() === "&" ? "" : "&") + ("_=" + /* @__PURE__ */ new Date().getTime());
    }
    clearTimeout(win2["timer_" + funcId]);
    var prevFunc = win2[funcId];
    win2[funcId] = function(data) {
        prevFunc && prevFunc(data);
        cleanup(funcId);
        if (gotoBackupInfo) {
            data.__$$backupCall = gotoBackupInfo;
        }
        if (opts.dataCheck) {
            if (opts.dataCheck(data) !== false) {
                setDataToStore({
                    useStore: opts.useStore,
                    storeKey: originalUrl,
                    data
                });
                return cb(null, data);
            }
            if (fallback(originalUrl, opts, cb) === false) {
                cb(new Error("Data check error, and no fallback"));
            }
        } else {
            setDataToStore({
                useStore: opts.useStore,
                storeKey: originalUrl,
                data
            });
            cb(null, data);
        }
    };
    var script = appendScriptTagToHead({
        url,
        charset
    });
    var timeout = opts.timeout != null ? opts.timeout : TIMEOUT_CONST;
    win2["timer_" + funcId] = setTimeout(function() {
        cleanup(funcId);
        if (typeof opts.retryTimes === "number" && opts.retryTimes > 0) {
            opts.retryTimes--;
            return fetchData(originalUrl, opts, cb);
        }
        if (fallback(originalUrl, opts, cb) === false) {
            return cb(new Error("Timeout and no data return"));
        }
    }, timeout);
    function cleanup(funcId2) {
        if (script.parentNode) {
            script.parentNode.removeChild(script);
        }
        win2[funcId2] = noop2;
        clearTimeout(win2["timer_" + funcId2]);
    }
}
function storeCheckFn(storeData, storeCheckKey, storeSign) {
    if (storeData && storeCheckKey && storeSign) {
        return storeData[storeCheckKey] && storeData[storeCheckKey] === storeSign;
    }
    return false;
}
function getDataFromStore(_ref) {
    var useStore = _ref.useStore, storeKey = _ref.storeKey, storeCheck = _ref.storeCheck, storeCheckKey = _ref.storeCheckKey, storeSign = _ref.storeSign, dataCheck = _ref.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        storeCheck = storeCheck || storeCheckFn;
        if (storeCheck(storeData, storeCheckKey, storeSign)) {
            if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
                return storeData;
            }
        }
    }
    return null;
}
function getDataFromStoreWithoutCheck(_ref2) {
    var useStore = _ref2.useStore, storeKey = _ref2.storeKey, dataCheck = _ref2.dataCheck;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        var storeData = store.get(storeKey);
        if (!dataCheck || storeData && dataCheck && dataCheck(storeData) !== false) {
            return storeData;
        }
    }
    return null;
}
function setDataToStore(_ref3) {
    var useStore = _ref3.useStore, storeKey = _ref3.storeKey, data = _ref3.data;
    useStore = useStore ? store.enabled : false;
    if (useStore) {
        store.set(storeKey, data);
    }
}
function fallback(url, opts, cb) {
    var backup = opts.backup;
    var backupWithParams = void 0;
    if (backup) {
        if (typeof backup === "string") {
            delete opts.backup;
            backupWithParams = generateJsonpUrlWithParams(backup, opts.params);
            return fetchData(backupWithParams, opts, cb, {
                backup
            });
        } else if (Array.isArray(backup)) {
            if (backup.length) {
                var backupUrl = backup.shift();
                backupWithParams = generateJsonpUrlWithParams(backupUrl, opts.params);
                return fetchData(backupWithParams, opts, cb, {
                    backup: backupUrl
                });
            }
        }
    }
    var dataFromStoreWithoutCheck = getDataFromStoreWithoutCheck({
        useStore: opts.useStore,
        storeKey: url,
        dataCheck: opts.dataCheck
    });
    if (dataFromStoreWithoutCheck) {
        cb(null, dataFromStoreWithoutCheck);
        return true;
    }
    return false;
}
function appendScriptTagToHead(_ref4) {
    var url = _ref4.url, charset = _ref4.charset;
    if (!doc2) {
        return;
    }
    var script = doc2.createElement("script");
    script.type = "text/javascript";
    if (charset) {
        script.charset = charset;
    }
    script.src = url;
    head.appendChild(script);
    return script;
}
var jsonp_esm_default = jsonp$1;
// node_modules/@tarojs/taro-h5/dist/api/network/request/index.js
var { Link: Link2 } = Taro;
function generateRequestUrlWithParams(url = "", params) {
    params = typeof params === "string" ? params : serializeParams(params);
    if (params) {
        url += (~url.indexOf("?") ? "&" : "?") + params;
    }
    url = url.replace("?&", "?");
    return url;
}
function _request(options3 = {}) {
    const { success, complete, fail } = options3;
    const params = {};
    const res = {};
    let { cache = "default", credentials, data, dataType, header = {}, jsonp, method = "GET", mode, responseType, signal, timeout, url = "" } = options3, opts = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__rest)(options3, [
        "cache",
        "credentials",
        "data",
        "dataType",
        "header",
        "jsonp",
        "method",
        "mode",
        "responseType",
        "signal",
        "timeout",
        "url"
    ]);
    if (typeof timeout !== "number") {
        timeout = NETWORK_TIMEOUT;
    }
    Object.assign(params, opts);
    if (jsonp) {
        const jsonpParams = Object.assign(Object.assign({}, params), {
            params: data,
            cache: opts.jsonpCache,
            timeout
        });
        if (typeof jsonp === "string") {
            jsonpParams.name = jsonp;
        }
        return jsonp_esm_default(url, jsonpParams).then((data2)=>{
            res.statusCode = 200;
            res.data = data2;
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(success) && success(res);
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
            return res;
        }).catch((err)=>{
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fail) && fail(err);
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
            return Promise.reject(err);
        });
    }
    params.method = method;
    const methodUpper = params.method.toUpperCase();
    params.cache = cache;
    if (methodUpper === "GET" || methodUpper === "HEAD") {
        url = generateRequestUrlWithParams(url, data);
    } else if ([
        "[object Array]",
        "[object Object]"
    ].indexOf(Object.prototype.toString.call(data)) >= 0) {
        const keyOfContentType = Object.keys(header).find((item)=>item.toLowerCase() === "content-type");
        if (!keyOfContentType) {
            header["Content-Type"] = "application/json";
        }
        const contentType = header[keyOfContentType || "Content-Type"];
        if (contentType.indexOf("application/json") >= 0) {
            params.body = JSON.stringify(data);
        } else if (contentType.indexOf("application/x-www-form-urlencoded") >= 0) {
            params.body = serializeParams(data);
        } else {
            params.body = data;
        }
    } else {
        params.body = data;
    }
    if (header) {
        params.headers = header;
    }
    if (mode) {
        params.mode = mode;
    }
    let timeoutTimer = null;
    let controller = null;
    if (signal) {
        params.signal = signal;
    } else {
        controller = new window.AbortController();
        params.signal = controller.signal;
        timeoutTimer = setTimeout(function() {
            if (controller) controller.abort();
        }, timeout);
    }
    params.credentials = credentials;
    const p = fetch(url, params).then((response)=>{
        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = null;
        }
        if (controller) {
            controller = null;
        }
        if (!response) {
            const errorResponse = {
                ok: false
            };
            throw errorResponse;
        }
        res.statusCode = response.status;
        res.header = {};
        for (const key of response.headers.keys()){
            res.header[key] = response.headers.get(key);
        }
        if (responseType === "arraybuffer") {
            return response.arrayBuffer();
        }
        if (res.statusCode !== 204) {
            if (dataType === "json" || typeof dataType === "undefined") {
                return response.json().catch(()=>{
                    return null;
                });
            }
        }
        if (responseType === "text" || dataType === "text") {
            return response.text();
        }
        return Promise.resolve(null);
    }).then((data2)=>{
        res.data = data2;
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(success) && success(res);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
        return res;
    }).catch((err)=>{
        if (timeoutTimer) {
            clearTimeout(timeoutTimer);
            timeoutTimer = null;
        }
        if (controller) {
            controller = null;
        }
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fail) && fail(err);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
        err.statusCode = res.statusCode;
        err.errMsg = err.message;
        return Promise.reject(err);
    });
    if (!p.abort && controller) {
        p.abort = (cb)=>{
            if (controller) {
                cb && cb();
                controller.abort();
                if (timeoutTimer) {
                    clearTimeout(timeoutTimer);
                    timeoutTimer = null;
                }
            }
        };
    }
    return p;
}
function taroInterceptor(chain) {
    return _request(chain.requestParams);
}
var link = new Link2(taroInterceptor);
var request = (...args)=>{
    const [url = "", options3 = {}] = args;
    if (typeof url === "string") {
        options3.url = url;
    } else {
        Object.assign(options3, url);
    }
    return link.request(options3);
};
var addInterceptor = link.addInterceptor.bind(link);
var cleanInterceptors = link.cleanInterceptors.bind(link);
// node_modules/@tarojs/taro-h5/dist/api/network/tcp.js
var createTCPSocket = temporarilyNotSupport("createTCPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/udp.js
var createUDPSocket = temporarilyNotSupport("createUDPSocket");
// node_modules/@tarojs/taro-h5/dist/api/network/upload.js
var createUploadTask = ({ url, filePath, formData = {}, name, header, timeout, fileName, withCredentials = true, success, error })=>{
    let timeoutInter;
    let formKey;
    const apiName = "uploadFile";
    const xhr = new XMLHttpRequest();
    const form = new FormData();
    const callbackManager5 = {
        headersReceived: new CallbackManager(),
        progressUpdate: new CallbackManager()
    };
    xhr.open("POST", url);
    xhr.withCredentials = !!withCredentials;
    setHeader(xhr, header);
    for(formKey in formData){
        form.append(formKey, formData[formKey]);
    }
    xhr.upload.onprogress = (e)=>{
        const { loaded, total } = e;
        callbackManager5.progressUpdate.trigger({
            progress: Math.round(loaded / total * 100),
            totalBytesSent: loaded,
            totalBytesExpectedToSend: total
        });
    };
    xhr.onreadystatechange = ()=>{
        if (xhr.readyState !== XHR_STATS.HEADERS_RECEIVED) return;
        callbackManager5.headersReceived.trigger({
            header: xhr.getAllResponseHeaders()
        });
    };
    xhr.onload = ()=>{
        const status2 = xhr.status;
        clearTimeout(timeoutInter);
        success({
            errMsg: `${apiName}:ok`,
            statusCode: status2,
            data: xhr.responseText || xhr.response
        });
    };
    xhr.onabort = ()=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail abort`
        });
    };
    xhr.onerror = (e)=>{
        clearTimeout(timeoutInter);
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    };
    const abort = ()=>{
        clearTimeout(timeoutInter);
        xhr.abort();
    };
    const send = ()=>{
        xhr.send(form);
        timeoutInter = setTimeout(()=>{
            xhr.onabort = null;
            xhr.onload = null;
            xhr.upload.onprogress = null;
            xhr.onreadystatechange = null;
            xhr.onerror = null;
            abort();
            error({
                errMsg: `${apiName}:fail timeout`
            });
        }, timeout || NETWORK_TIMEOUT);
    };
    convertObjectUrlToBlob(filePath).then((fileObj)=>{
        if (!fileName) {
            fileName = typeof fileObj !== "string" && fileObj.name;
        }
        form.append(name, fileObj, fileName || `file-${Date.now()}`);
        send();
    }).catch((e)=>{
        error({
            errMsg: `${apiName}:fail ${e.message}`
        });
    });
    const onHeadersReceived = callbackManager5.headersReceived.add;
    const offHeadersReceived = callbackManager5.headersReceived.remove;
    const onProgressUpdate = callbackManager5.progressUpdate.add;
    const offProgressUpdate = callbackManager5.progressUpdate.remove;
    return {
        abort,
        onHeadersReceived,
        offHeadersReceived,
        onProgressUpdate,
        offProgressUpdate
    };
};
var uploadFile = ({ url, filePath, name, header, formData, timeout, fileName, withCredentials, success, fail, complete })=>{
    let task;
    const result = new Promise((resolve, reject)=>{
        task = createUploadTask({
            url,
            header,
            name,
            filePath,
            formData,
            timeout,
            fileName,
            withCredentials,
            success: (res)=>{
                success && success(res);
                complete && complete(res);
                resolve(res);
            },
            error: (res)=>{
                fail && fail(res);
                complete && complete(res);
                reject(res);
            }
        });
    });
    result.headersReceive = task.onHeadersReceived.bind(task);
    result.progress = task.onProgressUpdate.bind(task);
    const properties = {};
    Object.keys(task).forEach((key)=>{
        properties[key] = {
            get () {
                return typeof task[key] === "function" ? task[key].bind(task) : task[key];
            }
        };
    });
    return Object.defineProperties(result, properties);
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/socketTask.js
var SocketTask = class {
    get readyState() {
        return this.ws.readyState;
    }
    send(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { data = "", success, fail, complete } = opts;
        if (this.readyState !== 1) {
            const res2 = {
                errMsg: "SocketTask.send:fail SocketTask.readState is not OPEN"
            };
            console.error(res2.errMsg);
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(fail) && fail(res2);
            (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res2);
            return Promise.reject(res2);
        }
        this.ws.send(data);
        const res = {
            errMsg: "sendSocketMessage:ok"
        };
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(success) && success(res);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
        return Promise.resolve(res);
    }
    close(opts = {}) {
        if (typeof opts !== "object" || !opts) opts = {};
        const { code = 1e3, reason = "server complete,close", success, complete } = opts;
        this.closeDetail = {
            code,
            reason
        };
        this._destroyWhenClose && this._destroyWhenClose();
        this.ws.close();
        const res = {
            errMsg: "closeSocket:ok"
        };
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(success) && success(res);
        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(complete) && complete(res);
        return Promise.resolve(res);
    }
    onOpen(func) {
        this.ws.onopen = func;
    }
    onMessage(func) {
        this.ws.onmessage = func;
    }
    onClose(func) {
        this.ws.onclose = ()=>{
            this._destroyWhenClose && this._destroyWhenClose();
            func(this.closeDetail || {
                code: 1006,
                reason: "abnormal closure"
            });
        };
    }
    onError(func) {
        this.ws.onerror = func;
    }
    constructor(url, protocols){
        if (protocols && protocols.length) {
            this.ws = new WebSocket(url, protocols);
        } else {
            this.ws = new WebSocket(url);
        }
        this.CONNECTING = 0;
        this.OPEN = 1;
        this.CLOSING = 2;
        this.CLOSED = 3;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/network/websocket/index.js
var socketTasks = [];
var socketsCounter = 1;
function sendSocketMessage() {
    console.warn("Deprecated.Please use socketTask.send instead.");
}
function onSocketOpen() {
    console.warn("Deprecated.Please use socketTask.onOpen instead.");
}
function onSocketMessage() {
    console.warn("Deprecated.Please use socketTask.onMessage instead.");
}
function onSocketError() {
    console.warn("Deprecated.Please use socketTask.onError instead.");
}
function onSocketClose() {
    console.warn("Deprecated.Please use socketTask.onClose instead.");
}
function connectSocket(options3) {
    const name = "connectSocket";
    return new Promise((resolve, reject)=>{
        const isObject6 = shouldBeObject(options3);
        if (!isObject6.flag) {
            const res = {
                errMsg: `${name}:fail ${isObject6.msg}`
            };
            console.error(res.errMsg);
            return reject(res);
        }
        const { url, protocols, success, fail, complete } = options3;
        const handle = new MethodHandler({
            name,
            success,
            fail,
            complete
        });
        if (typeof url !== "string") {
            return handle.fail({
                errMsg: getParameterError({
                    para: "url",
                    correct: "String",
                    wrong: url
                })
            }, {
                resolve,
                reject
            });
        }
        if (!url.startsWith("ws://") && !url.startsWith("wss://")) {
            return handle.fail({
                errMsg: `request:fail invalid url "${url}"`
            }, {
                resolve,
                reject
            });
        }
        const _protocols = Array.isArray(protocols) ? protocols : null;
        if (socketTasks.length >= 5) {
            return handle.fail({
                errMsg: "\u540C\u65F6\u6700\u591A\u53D1\u8D77 5 \u4E2A socket \u8BF7\u6C42\uFF0C\u66F4\u591A\u8BF7\u53C2\u8003\u6587\u6863\u3002"
            }, {
                resolve,
                reject
            });
        }
        const task = new SocketTask(url, _protocols);
        task._destroyWhenClose = function() {
            socketTasks = socketTasks.filter((socketTask)=>socketTask !== this);
        };
        socketTasks.push(task);
        handle.success({
            socketTaskId: socketsCounter++
        });
        return resolve(task);
    });
}
function closeSocket() {
    console.warn("Deprecated.Please use socketTask.close instead.");
}
// node_modules/@tarojs/taro-h5/dist/api/open-api/account.js
var getAccountInfoSync = temporarilyNotSupport("getAccountInfoSync");
// node_modules/@tarojs/taro-h5/dist/api/open-api/address.js
var chooseAddress = temporarilyNotSupport("chooseAddress");
// node_modules/@tarojs/taro-h5/dist/api/open-api/authorize.js
var authorizeForMiniProgram = temporarilyNotSupport("authorizeForMiniProgram");
var authorize = temporarilyNotSupport("authorize");
// node_modules/@tarojs/taro-h5/dist/api/open-api/card.js
var openCard = temporarilyNotSupport("openCard");
var addCard = temporarilyNotSupport("addCard");
// node_modules/@tarojs/taro-h5/dist/api/open-api/channels-live.js
var reserveChannelsLive = temporarilyNotSupport("reserveChannelsLive");
var openChannelsUserProfile = temporarilyNotSupport("openChannelsUserProfile");
var openChannelsLive = temporarilyNotSupport("openChannelsLive");
var openChannelsEvent = temporarilyNotSupport("openChannelsEvent");
var openChannelsActivity = temporarilyNotSupport("openChannelsActivity");
var getChannelsShareKey = temporarilyNotSupport("getChannelsShareKey");
var getChannelsLiveNoticeInfo = temporarilyNotSupport("getChannelsLiveNoticeInfo");
var getChannelsLiveInfo = temporarilyNotSupport("getChannelsLiveInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/customer-service.js
var openCustomerServiceChat = temporarilyNotSupport("openCustomerServiceChat");
// node_modules/@tarojs/taro-h5/dist/api/open-api/device-voip.js
var requestDeviceVoIP = temporarilyNotSupport("requestDeviceVoIP");
var getDeviceVoIPList = temporarilyNotSupport("getDeviceVoIPList");
// node_modules/@tarojs/taro-h5/dist/api/open-api/facial.js
var checkIsSupportFacialRecognition = temporarilyNotSupport("checkIsSupportFacialRecognition");
var startFacialRecognitionVerify = temporarilyNotSupport("startFacialRecognitionVerify");
var startFacialRecognitionVerifyAndUploadVideo = temporarilyNotSupport("startFacialRecognitionVerifyAndUploadVideo");
var faceVerifyForPay = temporarilyNotSupport("faceVerifyForPay");
// node_modules/@tarojs/taro-h5/dist/api/open-api/favorites.js
var addVideoToFavorites = temporarilyNotSupport("addVideoToFavorites");
var addFileToFavorites = temporarilyNotSupport("addFileToFavorites");
// node_modules/@tarojs/taro-h5/dist/api/open-api/group.js
var getGroupEnterInfo = temporarilyNotSupport("getGroupEnterInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/invoice.js
var chooseInvoiceTitle = temporarilyNotSupport("chooseInvoiceTitle");
var chooseInvoice = temporarilyNotSupport("chooseInvoice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/license-plate.js
var chooseLicensePlate = temporarilyNotSupport("chooseLicensePlate");
// node_modules/@tarojs/taro-h5/dist/api/open-api/login.js
var pluginLogin = temporarilyNotSupport("pluginLogin");
var login = temporarilyNotSupport("login");
var checkSession = temporarilyNotSupport("checkSession");
// node_modules/@tarojs/taro-h5/dist/api/open-api/my-miniprogram.js
var checkIsAddedToMyMiniProgram = temporarilyNotSupport("checkIsAddedToMyMiniProgram");
// node_modules/@tarojs/taro-h5/dist/api/open-api/privacy.js
var requirePrivacyAuthorize = temporarilyNotSupport("requirePrivacyAuthorize");
var openPrivacyContract = temporarilyNotSupport("openPrivacyContract");
var onNeedPrivacyAuthorization = temporarilyNotSupport("onNeedPrivacyAuthorization");
var getPrivacySetting = temporarilyNotSupport("getPrivacySetting");
// node_modules/@tarojs/taro-h5/dist/api/open-api/red-package.js
var showRedPackage = temporarilyNotSupport("showRedPackage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/settings.js
var openSetting = temporarilyNotSupport("openSetting");
var getSetting = temporarilyNotSupport("getSetting");
// node_modules/@tarojs/taro-h5/dist/api/open-api/soter.js
var startSoterAuthentication = temporarilyNotSupport("startSoterAuthentication");
var checkIsSupportSoterAuthentication = temporarilyNotSupport("checkIsSupportSoterAuthentication");
var checkIsSoterEnrolledInDevice = temporarilyNotSupport("checkIsSoterEnrolledInDevice");
// node_modules/@tarojs/taro-h5/dist/api/open-api/subscribe-message.js
var requestSubscribeMessage = temporarilyNotSupport("requestSubscribeMessage");
var requestSubscribeDeviceMessage = temporarilyNotSupport("requestSubscribeDeviceMessage");
// node_modules/@tarojs/taro-h5/dist/api/open-api/user-info.js
var getUserProfile = temporarilyNotSupport("getUserProfile");
var getUserInfo = temporarilyNotSupport("getUserInfo");
// node_modules/@tarojs/taro-h5/dist/api/open-api/werun.js
var shareToWeRun = temporarilyNotSupport("shareToWeRun");
var getWeRunData = temporarilyNotSupport("getWeRunData");
// node_modules/@tarojs/taro-h5/dist/api/payment/index.js
var requestPayment = temporarilyNotSupport("requestPayment");
var requestPluginPayment = temporarilyNotSupport("requestPluginPayment");
var requestOrderPayment = temporarilyNotSupport("requestOrderPayment");
// node_modules/@tarojs/taro-h5/dist/api/qq/index.js
var openQzonePublish = temporarilyNotSupport("openQzonePublish");
var getQQRunData = temporarilyNotSupport("getQQRunData");
var setOfficialDress = temporarilyNotSupport("setOfficialDress");
var setCustomDress = temporarilyNotSupport("setCustomDress");
var updateQQApp = temporarilyNotSupport("updateQQApp");
var addRecentColorSign = temporarilyNotSupport("addRecentColorSign");
var getGuildInfo = temporarilyNotSupport("getGuildInfo");
var applyAddToMyApps = temporarilyNotSupport("applyAddToMyApps");
var isAddedToMyApps = temporarilyNotSupport("isAddedToMyApps");
// node_modules/@tarojs/taro-h5/dist/api/route/index.js
var router = {
    addRouteBuilder: temporarilyNotSupport("addRouteBuilder"),
    getRouteContext: temporarilyNotSupport("getRouteContext"),
    removeRouteBuilder: temporarilyNotSupport("removeRouteBuilder")
};
// node_modules/@tarojs/taro-h5/dist/api/share/index.js
var updateShareMenu = temporarilyNotSupport("updateShareMenu");
var showShareMenu = temporarilyNotSupport("showShareMenu");
var showShareImageMenu = temporarilyNotSupport("showShareImageMenu");
var shareVideoMessage = temporarilyNotSupport("shareVideoMessage");
var shareFileMessage = temporarilyNotSupport("shareFileMessage");
var onCopyUrl = temporarilyNotSupport("onCopyUrl");
var offCopyUrl = temporarilyNotSupport("offCopyUrl");
var hideShareMenu = temporarilyNotSupport("hideShareMenu");
var getShareInfo = temporarilyNotSupport("getShareInfo");
var authPrivateMessage = permanentlyNotSupport("authPrivateMessage");
// node_modules/@tarojs/taro-h5/dist/api/swan/index.js
var setPageInfo = temporarilyNotSupport("setPageInfo");
var ocrIdCard = temporarilyNotSupport("ocrIdCard");
var ocrBankCard = temporarilyNotSupport("ocrBankCard");
var ocrDrivingLicense = temporarilyNotSupport("ocrDrivingLicense");
var ocrVehicleLicense = temporarilyNotSupport("ocrVehicleLicense");
var textReview = temporarilyNotSupport("textReview");
var textToAudio = temporarilyNotSupport("textToAudio");
var imageAudit = temporarilyNotSupport("imageAudit");
var advancedGeneralIdentify = temporarilyNotSupport("advancedGeneralIdentify");
var objectDetectIdentify = temporarilyNotSupport("objectDetectIdentify");
var carClassify = temporarilyNotSupport("carClassify");
var dishClassify = temporarilyNotSupport("dishClassify");
var logoClassify = temporarilyNotSupport("logoClassify");
var animalClassify = temporarilyNotSupport("animalClassify");
var plantClassify = temporarilyNotSupport("plantClassify");
var getSwanId = temporarilyNotSupport("getSwanId");
var requestPolymerPayment = temporarilyNotSupport("requestPolymerPayment");
var navigateToSmartGameProgram = temporarilyNotSupport("navigateToSmartGameProgram");
var navigateToSmartProgram = temporarilyNotSupport("navigateToSmartProgram");
var navigateBackSmartProgram = temporarilyNotSupport("navigateBackSmartProgram");
var preloadSubPackage = temporarilyNotSupport("preloadSubPackage");
// node_modules/@tarojs/taro-h5/dist/api/worker/index.js
var createWorker = temporarilyNotSupport("createWorker");
// node_modules/@tarojs/taro-h5/dist/api/wxml/IntersectionObserver.js
var TaroH5IntersectionObserver = class {
    // selector 
    get container() {
        const container2 = this._component !== null ? findDOM(this._component) || document : document;
        return container2;
    }
    createInst() {
        this.disconnect();
        const { left = 0, top = 0, bottom = 0, right = 0 } = this._rootMargin;
        return new IntersectionObserver((entries)=>{
            entries.forEach((entry)=>{
                const _callback = this._getCallbackByElement(entry.target);
                const result = {
                    boundingClientRect: entry.boundingClientRect,
                    intersectionRatio: entry.intersectionRatio,
                    intersectionRect: entry.intersectionRect,
                    relativeRect: entry.rootBounds || {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    },
                    // entry.time
                    time: Date.now()
                };
                if (!this._isInited) {
                    const [min, max] = [
                        Math.min(this._options.initialRatio, entry.intersectionRatio),
                        Math.max(this._options.initialRatio, entry.intersectionRatio)
                    ];
                    if (this._options.initialRatio === entry.intersectionRatio || !this._options.thresholds.some((value)=>value >= min && value <= max)) {
                        return;
                    }
                }
                _callback && _callback.call(this, result);
            });
            this._isInited = true;
        }, {
            root: this._root,
            rootMargin: [
                `${top}px`,
                `${right}px`,
                `${bottom}px`,
                `${left}px`
            ].join(" "),
            threshold: this._options.thresholds
        });
    }
    disconnect() {
        if (this._observerInst) {
            let listener;
            while(listener = this._listeners.pop()){
                this._observerInst.unobserve(listener.element);
            }
            this._observerInst.disconnect();
        }
    }
    observe(targetSelector, callback) {
        if (this._listeners.length) return;
        if (!this._observerInst) {
            console.warn("Intersection observer will be ignored because no relative nodes are found.");
            return;
        }
        const nodeList = this._options.observeAll ? this.container.querySelectorAll(targetSelector) : [
            this.container.querySelector(targetSelector)
        ];
        Taro.nextTick(()=>{
            nodeList.forEach((element)=>{
                if (!element) return;
                this._observerInst.observe(element);
                this._listeners.push({
                    element,
                    callback
                });
            });
        });
    }
    relativeTo(selector, margins) {
        if (this._listeners.length) {
            console.error('Relative nodes cannot be added after "observe" call in IntersectionObserver');
            return this;
        }
        this._root = this.container.querySelector(selector) || null;
        if (margins) {
            this._rootMargin = margins;
        }
        this._observerInst = this.createInst();
        return this;
    }
    relativeToViewport(margins) {
        return this.relativeTo(".taro_page", margins);
    }
    _getCallbackByElement(element) {
        const listener = this._listeners.find((listener2)=>listener2.element === element);
        return listener ? listener.callback : null;
    }
    constructor(component, options3 = {}){
        this._options = {
            thresholds: [
                0
            ],
            initialRatio: 0,
            observeAll: false
        };
        this._listeners = [];
        this._rootMargin = {};
        this._isInited = false;
        this._component = component;
        Object.assign(this._options, options3);
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/MediaQueryObserver.js
function generateMediaQueryStr(descriptor) {
    const mediaQueryArr = [];
    const descriptorMenu = [
        "width",
        "minWidth",
        "maxWidth",
        "height",
        "minHeight",
        "maxHeight",
        "orientation"
    ];
    for (const item of descriptorMenu){
        if (item !== "orientation" && descriptor[item] && Number(descriptor[item]) >= 0) {
            mediaQueryArr.push(`(${(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.toKebabCase)(item)}: ${Number(descriptor[item])}px)`);
        }
        if (item === "orientation" && descriptor[item]) {
            mediaQueryArr.push(`(${(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.toKebabCase)(item)}: ${descriptor[item]})`);
        }
    }
    return mediaQueryArr.join(" and ");
}
var MediaQueryObserver = class {
    // 
    observe(descriptor, callback) {
        if ((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(callback)) {
            this._mediaQueryObserver = window.matchMedia(generateMediaQueryStr(descriptor));
            this._listener = (ev)=>{
                callback({
                    matches: ev.matches
                });
            };
            callback({
                matches: this._mediaQueryObserver.matches
            });
            if ("addEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.addEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.addListener(this._listener);
            }
        }
    }
    // 
    disconnect() {
        if (this._mediaQueryObserver && this._listener) {
            if ("removeEventListener" in this._mediaQueryObserver) {
                this._mediaQueryObserver.removeEventListener("change", this._listener);
            } else {
                this._mediaQueryObserver.removeListener(this._listener);
            }
        }
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/nodesRef.js
var NodesRef = class {
    context(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            context: true
        }, cb);
        return _selectorQuery;
    }
    node(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            nodeCanvasType: true,
            node: true
        }, cb);
        return _selectorQuery;
    }
    boundingClientRect(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            rect: true,
            size: true
        }, cb);
        return _selectorQuery;
    }
    scrollOffset(cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        _selectorQuery._push(_selector, _component, _single, {
            id: true,
            dataset: true,
            scrollOffset: true
        }, cb);
        return _selectorQuery;
    }
    fields(fields, cb) {
        const { _selector, _component, _single, _selectorQuery } = this;
        const { id, dataset, rect, size, scrollOffset, context, node, properties = [], computedStyle = [] } = fields;
        _selectorQuery._push(_selector, _component, _single, {
            id,
            dataset,
            rect,
            size,
            scrollOffset,
            context,
            node,
            nodeCanvasType: node,
            properties,
            computedStyle
        }, cb);
        return _selectorQuery;
    }
    constructor(selector, querySelectorQuery, single){
        this._component = querySelectorQuery._component;
        this._selector = selector;
        this._selectorQuery = querySelectorQuery;
        this._single = single;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/selectorQuery.js
function filter(fields, dom, selector) {
    if (!dom) return null;
    const isViewport = selector === ".taro_page";
    const { id, dataset, rect, size, scrollOffset, properties = [], computedStyle = [], nodeCanvasType, node, context } = fields;
    const res = {};
    if (nodeCanvasType && node) {
        const tagName = dom.tagName;
        res.node = {
            id: dom.id,
            $taroElement: dom
        };
        if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "";
            res.nodeCanvasType = type;
            const canvas = dom.getElementsByTagName("canvas")[0];
            if (/^(2d|webgl)/i.test(type) && canvas) {
                res.node = canvas;
            } else {
                res.node = null;
            }
        } else if (/^taro-scroll-view-core/i.test(tagName)) {
            res.nodeCanvasType = "";
            res.node = dom;
            dom.scrollTo = dom.mpScrollToMethod;
            dom.scrollIntoView = dom.mpScrollIntoViewMethod;
        } else {
            res.nodeCanvasType = "";
            res.node = dom;
        }
        return res;
    }
    if (context) {
        const tagName = dom.tagName;
        if (/^taro-video-core/i.test(tagName)) {
            return {
                context: dom
            };
        } else if (/^taro-canvas-core/i.test(tagName)) {
            const type = dom.type || "2d";
            const canvas = dom === null || dom === void 0 ? void 0 : dom.querySelector("canvas");
            const ctx = canvas === null || canvas === void 0 ? void 0 : canvas.getContext(type);
            return {
                context: new CanvasContext(canvas, ctx)
            };
        } else if (/^taro-live-player-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 LivePlayerContext");
        } else if (/^taro-editor-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 EditorContext");
        } else if (/^taro-map-core/i.test(tagName)) {
            console.error("\u6682\u65F6\u4E0D\u652F\u6301\u901A\u8FC7 NodesRef.context \u83B7\u53D6 MapContext");
        }
        return;
    }
    if (id) res.id = dom.id;
    if (dataset) res.dataset = Object.assign({}, dom.dataset);
    if (rect || size) {
        const { left, right, top, bottom, width, height } = dom.getBoundingClientRect();
        if (rect) {
            if (!isViewport) {
                res.left = left;
                res.right = right;
                res.top = top;
                res.bottom = bottom;
            } else {
                res.left = 0;
                res.right = 0;
                res.top = 0;
                res.bottom = 0;
            }
        }
        if (size) {
            if (!isViewport) {
                res.width = width;
                res.height = height;
            } else {
                res.width = dom.clientWidth;
                res.height = dom.clientHeight;
            }
        }
    }
    if (scrollOffset) {
        res.scrollLeft = dom.scrollLeft;
        res.scrollTop = dom.scrollTop;
    }
    if (properties.length) {
        properties.forEach((prop)=>{
            const attr = dom.getAttribute(prop);
            if (attr) res[prop] = attr;
        });
    }
    if (computedStyle.length) {
        const styles2 = window.getComputedStyle(dom);
        computedStyle.forEach((key)=>{
            const value = styles2.getPropertyValue(key) || styles2[key];
            if (value) res[key] = value;
        });
    }
    return res;
}
function queryBat(queue, cb) {
    const result = [];
    queue.forEach((item)=>{
        var _a;
        const { selector, single, fields, component } = item;
        const container2 = component !== null ? findDOM(component) || document : document;
        let selectSelf = false;
        if (container2 !== document) {
            const $nodeList = (_a = container2.parentNode) === null || _a === void 0 ? void 0 : _a.querySelectorAll(selector);
            if ($nodeList) {
                for(let i2 = 0, len = $nodeList.length; i2 < len; ++i2){
                    if (container2 === $nodeList[i2]) {
                        selectSelf = true;
                        break;
                    }
                }
            }
        }
        if (single) {
            const el = selectSelf === true ? container2 : container2.querySelector(selector);
            result.push(filter(fields, el, selector));
        } else {
            const $children = container2.querySelectorAll(selector);
            const children = [];
            selectSelf === true && children.push(container2);
            for(let i2 = 0, len = $children.length; i2 < len; ++i2){
                children.push($children[i2]);
            }
            result.push(children.map((dom)=>filter(fields, dom)));
        }
    });
    cb(result);
}
var SelectorQuery = class {
    in(component) {
        this._component = component;
        return this;
    }
    select(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, true);
    }
    selectAll(selector) {
        if (typeof selector === "string") selector = selector.replace(">>>", ">");
        return new NodesRef(selector, this, false);
    }
    selectViewport() {
        return new NodesRef(".taro_page", this, true);
    }
    exec(cb) {
        Taro.nextTick(()=>{
            queryBat(this._queue, (res)=>{
                const _queueCb = this._queueCb;
                res.forEach((item, index)=>{
                    const cb2 = _queueCb[index];
                    (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb2) && cb2.call(this, item);
                });
                (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(cb) && cb.call(this, res);
            });
        });
        return this;
    }
    _push(selector, component, single, fields, callback = null) {
        this._queue.push({
            component,
            selector,
            single,
            fields
        });
        this._queueCb.push(callback);
    }
    constructor(){
        this._defaultWebviewId = null;
        this._webviewId = null;
        this._queue = [];
        this._queueCb = [];
        this._component;
    }
};
// node_modules/@tarojs/taro-h5/dist/api/wxml/index.js
var createSelectorQuery = ()=>{
    return new SelectorQuery();
};
var createIntersectionObserver = (component, options3)=>{
    return new TaroH5IntersectionObserver(component, options3);
};
var createMediaQueryObserver = ()=>{
    return new MediaQueryObserver();
};
// node_modules/@tarojs/taro-h5/dist/api/taro.js
var { Behavior: Behavior2, getEnv: getEnv2, ENV_TYPE: ENV_TYPE2, Link: Link3, interceptors: interceptors2, interceptorify: interceptorify2, Current: Current2, options: options2, eventCenter: eventCenter2, Events: Events2, preload } = Taro;
var taro = {
    // @ts-ignore
    Behavior: Behavior2,
    getEnv: getEnv2,
    ENV_TYPE: ENV_TYPE2,
    Link: Link3,
    interceptors: interceptors2,
    interceptorify: interceptorify2,
    Current: Current2,
    getCurrentInstance: getCurrentInstance2,
    options: options2,
    nextTick: nextTick3,
    eventCenter: eventCenter2,
    Events: Events2,
    preload,
    history,
    navigateBack,
    navigateTo,
    reLaunch,
    redirectTo,
    getCurrentPages,
    switchTab,
    router,
    worklet
};
var requirePlugin = permanentlyNotSupport("requirePlugin");
function getConfig() {
    var _a;
    if (this === null || this === void 0 ? void 0 : this.pxTransformConfig) return this.pxTransformConfig;
    return (_a = taro).config || (_a.config = {});
}
var defaultDesignWidth2 = 750;
var defaultDesignRatio2 = {
    640: 2.34 / 2,
    750: 1,
    828: 1.81 / 2
};
var defaultBaseFontSize2 = 20;
var defaultUnitPrecision2 = 5;
var defaultTargetUnit2 = "rem";
var initPxTransform = function({ designWidth = defaultDesignWidth2, deviceRatio = defaultDesignRatio2, baseFontSize = defaultBaseFontSize2, unitPrecision = defaultUnitPrecision2, targetUnit = defaultTargetUnit2 }) {
    const config = getConfig.call(this);
    config.designWidth = designWidth;
    config.deviceRatio = deviceRatio;
    config.baseFontSize = baseFontSize;
    config.targetUnit = targetUnit;
    config.unitPrecision = unitPrecision;
};
var pxTransform = function(size = 0) {
    const config = getConfig.call(this);
    const baseFontSize = config.baseFontSize || defaultBaseFontSize2;
    const deviceRatio = config.deviceRatio || defaultDesignRatio2;
    const designWidth = ((input = 0)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.isFunction)(config.designWidth) ? config.designWidth(input) : config.designWidth)(size);
    if (!(designWidth in config.deviceRatio)) {
        throw new Error(`deviceRatio \u914D\u7F6E\u4E2D\u4E0D\u5B58\u5728 ${designWidth} \u7684\u8BBE\u7F6E\uFF01`);
    }
    const targetUnit = config.targetUnit || defaultTargetUnit2;
    const unitPrecision = config.unitPrecision || defaultUnitPrecision2;
    const formatSize = ~~size;
    let rootValue = 1 / deviceRatio[designWidth];
    switch(targetUnit){
        case "vw":
            rootValue = designWidth / 100;
            break;
        case "px":
            rootValue *= 2;
            break;
        default:
            rootValue *= baseFontSize * 2;
    }
    let val = formatSize / rootValue;
    if (unitPrecision >= 0 && unitPrecision <= 100) {
        val = Number(val.toFixed(unitPrecision));
    }
    return val + targetUnit;
};
var canIUseWebp = function() {
    const canvas = document.createElement("canvas");
    return canvas.toDataURL("image/webp").indexOf("data:image/webp") === 0;
};
var getAppInfo = function() {
    const config = getConfig.call(this);
    return {
        platform: "web",
        taroVersion: "4.1.11",
        designWidth: config.designWidth
    };
};
taro.requirePlugin = requirePlugin;
taro.getApp = getApp2;
taro.pxTransform = pxTransform;
taro.initPxTransform = initPxTransform;
taro.canIUseWebp = canIUseWebp;
taro.getAppInfo = getAppInfo;
taro.useAddToFavorites = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useAddToFavorites;
taro.useDidHide = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useDidHide;
taro.useDidShow = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useDidShow;
taro.useError = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useError;
taro.useLaunch = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useLaunch;
taro.useLoad = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useLoad;
taro.useOptionMenuClick = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useOptionMenuClick;
taro.useKeyboardHeight = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useKeyboardHeight;
taro.usePageNotFound = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.usePageNotFound;
taro.usePageScroll = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.usePageScroll;
taro.usePullDownRefresh = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.usePullDownRefresh;
taro.usePullIntercept = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.usePullIntercept;
taro.useReachBottom = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useReachBottom;
taro.useReady = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useReady;
taro.useResize = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useResize;
taro.useRouter = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useRouter;
taro.useSaveExitState = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useSaveExitState;
taro.useShareAppMessage = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useShareAppMessage;
taro.useShareTimeline = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useShareTimeline;
taro.useTabItemTap = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useTabItemTap;
taro.useTitleClick = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useTitleClick;
taro.useScope = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useScope;
taro.useUnhandledRejection = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useUnhandledRejection;
taro.useUnload = _chunk_LGX227NH_js__WEBPACK_IMPORTED_MODULE_0__.useUnload;
// node_modules/@tarojs/plugin-platform-h5/dist/runtime/apis/index.js
var list = null;
function canIUse(scheme = "") {
    if (list === null) {
        list = Object.assign(Object.assign(Object.assign({}, _definition_a6aeff58_json__WEBPACK_IMPORTED_MODULE_3__.apis), _definition_a6aeff58_json__WEBPACK_IMPORTED_MODULE_3__.components), {
            canIUse: "*"
        });
    }
    if (!scheme) return false;
    const o = set_default({}, scheme, true);
    return isMatchWith_default(list, o, (a, b)=>{
        if (a === "*" || b === true) return true;
    });
}
// node_modules/@tarojs/components/dist/components/helper.js
function notSupport(name = "", instance = {}) {
    console.error(`H5 \u6682\u4E0D\u652F\u6301 ${name} \u7EC4\u4EF6\uFF01`);
    taro.eventCenter.trigger("__taroNotSupport", {
        name,
        instance,
        type: "component",
        category: "temporarily"
    });
}
function handleStencilNodes(el) {
    var _a;
    (_a = el === null || el === void 0 ? void 0 : el.childNodes) === null || _a === void 0 ? void 0 : _a.forEach((item)=>{
        if (item.nodeType === document.COMMENT_NODE && item["s-cn"]) item["s-cn"] = false;
        if (item.nodeType !== document.COMMENT_NODE && item["s-sr"]) item["s-sr"] = false;
    });
}
// node_modules/@tarojs/components/dist/components/taro-ad-core.js
var Ad = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Ad", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ad-core"
]);
function defineCustomElement$1() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-ad-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-ad-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Ad);
                }
                break;
        }
    });
}
var defineCustomElement3 = defineCustomElement$1;
// node_modules/@tarojs/components/dist/components/taro-ad-custom-core.js
var AdCustom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AdCustom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ad-custom-core"
]);
function defineCustomElement$12() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-ad-custom-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-ad-custom-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AdCustom);
                }
                break;
        }
    });
}
var defineCustomElement4 = defineCustomElement$12;
// node_modules/@tarojs/components/dist/components/taro-animation-video-core.js
var AnimationVideo = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AnimationVideo", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-animation-video-core"
]);
function defineCustomElement$13() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-animation-video-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-animation-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AnimationVideo);
                }
                break;
        }
    });
}
var defineCustomElement5 = defineCustomElement$13;
// node_modules/@tarojs/components/dist/components/taro-animation-view-core.js
var AnimationView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AnimationView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-animation-view-core"
]);
function defineCustomElement$14() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-animation-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-animation-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AnimationView);
                }
                break;
        }
    });
}
var defineCustomElement6 = defineCustomElement$14;
// node_modules/@tarojs/components/dist/components/taro-ar-camera-core.js
var ArCamera = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ArCamera", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-ar-camera-core"
]);
function defineCustomElement$15() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-ar-camera-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-ar-camera-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ArCamera);
                }
                break;
        }
    });
}
var defineCustomElement7 = defineCustomElement$15;
// node_modules/@tarojs/components/dist/components/taro-audio-core.js
var indexCss = "audio{outline:none;max-width:100%}";
var Audio2 = proxyCustomElement(class extends H {
    bindevent() {
        this.audio.addEventListener("timeupdate", (e)=>{
            this.onTimeUpdate.emit({
                duration: e.srcElement.duration,
                currentTime: e.srcElement.duration
            });
        });
        this.audio.addEventListener("ended", ()=>{
            this.onEnded.emit();
        });
        this.audio.addEventListener("play", ()=>{
            this.onPlay.emit();
        });
        this.audio.addEventListener("pause", (e)=>{
            this.onPause.emit(e);
        });
        this.audio.addEventListener("error", (e)=>{
            var _a;
            this.onError.emit({
                errMsg: (_a = e.srcElement.error) === null || _a === void 0 ? void 0 : _a.code
            });
        });
    }
    componentDidLoad() {
        this.bindevent();
    }
    render() {
        const { src, controls, autoplay, loop: loop2, muted, nativeProps } = this;
        return h("audio", Object.assign({
            src,
            controls,
            autoplay,
            loop: loop2,
            muted,
            ref: (audio)=>{
                this.audio = audio;
            }
        }, nativeProps));
    }
    static get style() {
        return indexCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onError = createEvent(this, "error", 7);
        this.onPlay = createEvent(this, "play", 7);
        this.onPause = createEvent(this, "pause", 7);
        this.onTimeUpdate = createEvent(this, "timeupdate", 7);
        this.onEnded = createEvent(this, "ended", 7);
        this.src = void 0;
        this.controls = true;
        this.autoplay = false;
        this.loop = false;
        this.muted = false;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-audio-core",
    {
        "src": [
            1
        ],
        "controls": [
            4
        ],
        "autoplay": [
            4
        ],
        "loop": [
            4
        ],
        "muted": [
            4
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$16() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-audio-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-audio-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Audio2);
                }
                break;
        }
    });
}
var defineCustomElement8 = defineCustomElement$16;
// node_modules/@tarojs/components/dist/components/taro-aweme-data-core.js
var AwemeData = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("AwemeData", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-aweme-data-core"
]);
function defineCustomElement$17() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-aweme-data-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-aweme-data-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, AwemeData);
                }
                break;
        }
    });
}
var defineCustomElement9 = defineCustomElement$17;
// node_modules/@tarojs/components/dist/components/taro-block-core.js
var Block = proxyCustomElement(class extends H {
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-block-core"
]);
// node_modules/@tarojs/components/dist/components/index2.js
function createCommonjsModule(fn, basedir, module2) {
    return module2 = {
        path: basedir,
        exports: {},
        require: function(path, base) {
            return commonjsRequire();
        }
    }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
    throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var classnames = createCommonjsModule(function(module2) {
    (function() {
        var hasOwn = {}.hasOwnProperty;
        function classNames() {
            var classes2 = "";
            for(var i2 = 0; i2 < arguments.length; i2++){
                var arg = arguments[i2];
                if (arg) {
                    classes2 = appendClass(classes2, parseValue3(arg));
                }
            }
            return classes2;
        }
        function parseValue3(arg) {
            if (typeof arg === "string" || typeof arg === "number") {
                return arg;
            }
            if (typeof arg !== "object") {
                return "";
            }
            if (Array.isArray(arg)) {
                return classNames.apply(null, arg);
            }
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
                return arg.toString();
            }
            var classes2 = "";
            for(var key in arg){
                if (hasOwn.call(arg, key) && arg[key]) {
                    classes2 = appendClass(classes2, key);
                }
            }
            return classes2;
        }
        function appendClass(value, newClass) {
            if (!newClass) {
                return value;
            }
            if (value) {
                return value + " " + newClass;
            }
            return value + newClass;
        }
        if (module2.exports) {
            classNames.default = classNames;
            module2.exports = classNames;
        } else {
            window.classNames = classNames;
        }
    })();
});
// node_modules/@tarojs/components/dist/components/taro-button-core.js
var indexCss2 = `.weui-loading{vertical-align:middle;background:url("data:image/svg+xml;charset=utf8, %3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120' viewBox='0 0 100 100'%3E%3Cpath fill='none' d='M0 0h100v100H0z'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23E9E9E9' rx='5' ry='5' transform='translate(0 -30)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23989697' rx='5' ry='5' transform='rotate(30 105.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%239B999A' rx='5' ry='5' transform='rotate(60 75.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23A3A1A2' rx='5' ry='5' transform='rotate(90 65 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23ABA9AA' rx='5' ry='5' transform='rotate(120 58.66 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23B2B2B2' rx='5' ry='5' transform='rotate(150 54.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23BAB8B9' rx='5' ry='5' transform='rotate(180 50 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23C2C0C1' rx='5' ry='5' transform='rotate(-150 45.98 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23CBCBCB' rx='5' ry='5' transform='rotate(-120 41.34 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23D2D2D2' rx='5' ry='5' transform='rotate(-90 35 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23DADADA' rx='5' ry='5' transform='rotate(-60 24.02 65)'/%3E%3Crect width='7' height='20' x='46.5' y='40' fill='%23E2E2E2' rx='5' ry='5' transform='rotate(-30 -5.98 65)'/%3E%3C/svg%3E") 0 0/100% no-repeat;width:20px;height:20px;animation:1s steps(12,end) infinite weuiLoading;display:inline-block}@-webkit-keyframes weuiLoading{0%{transform:rotate(0)}to{transform:rotate(360deg)}}@keyframes weuiLoading{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.weui-btn_loading .weui-loading{margin:-.2em .34em 0 0}.weui-btn_loading.weui-btn_primary,.weui-btn_loading.weui-btn_warn{color:rgba(255,255,255,.6)}.weui-btn_loading.weui-btn_primary{background-color:#179b16}.weui-btn_loading.weui-btn_warn{background-color:#ce3c39}taro-button-core{box-sizing:border-box;appearance:none;text-align:center;color:#000;-webkit-tap-highlight-color:transparent;background-color:#f8f8f8;border-width:0;border-radius:5px;outline:0;width:100%;margin-left:auto;margin-right:auto;padding-left:14px;padding-right:14px;font-size:18px;line-height:2.55556;text-decoration:none;display:block;position:relative;overflow:hidden}taro-button-core:focus{outline:0}taro-button-core:not([disabled]):active{color:rgba(0,0,0,.6);background-color:#dedede}taro-button-core:after{box-sizing:border-box;content:" ";transform-origin:0 0;border:1px solid rgba(0,0,0,.2);border-radius:10px;width:200%;height:200%;position:absolute;top:0;left:0;transform:scale(.5)}taro-button-core+taro-button-core{margin-top:15px}taro-button-core[type=default]{color:#000;background-color:#f8f8f8}taro-button-core[type=default]:not([disabled]):visited{color:#000}taro-button-core[type=default]:not([disabled]):active{color:rgba(0,0,0,.6);background-color:#dedede}taro-button-core[size=mini]{width:auto;padding:0 1.32em;font-size:13px;line-height:2.3;display:inline-block}taro-button-core[plain],taro-button-core[plain][type=default],taro-button-core[plain][type=primary]{background-color:transparent;border-width:1px}taro-button-core[disabled]{color:rgba(255,255,255,.6)}taro-button-core[disabled][type=default]{color:rgba(0,0,0,.3);background-color:#f7f7f7}taro-button-core[disabled][type=primary]{background-color:#9ed99d}taro-button-core[disabled][type=warn]{background-color:#ec8b89}taro-button-core[loading] .weui-loading{margin:-.2em .34em 0 0}taro-button-core[loading][type=primary],taro-button-core[loading][type=warn]{color:rgba(255,255,255,.6)}taro-button-core[loading][type=primary]{background-color:#179b16}taro-button-core[loading][type=warn]{background-color:#ce3c39}taro-button-core[plain][type=primary]{color:#1aad19;border:1px solid #1aad19}taro-button-core[plain][type=primary]:not([disabled]):active{color:rgba(26,173,25,.6);background-color:transparent;border-color:rgba(26,173,25,.6)}taro-button-core[plain][type=primary]:after{border-width:0}taro-button-core[plain][type=warn]{color:#e64340;border:1px solid #e64340}taro-button-core[plain][type=warn]:not([disabled]):active{color:rgba(230,67,64,.6);background-color:transparent;border-color:rgba(230,67,64,.6)}taro-button-core[plain][type=warn]:after{border-width:0}taro-button-core[plain],taro-button-core[plain][type=default]{color:#353535;border:1px solid #353535}taro-button-core[plain]:not([disabled]):active,taro-button-core[plain][type=default]:not([disabled]):active{color:rgba(53,53,53,.6);background-color:transparent;border-color:rgba(53,53,53,.6)}taro-button-core[plain]:after,taro-button-core[plain][type=default]:after{border-width:0}taro-button-core[type=primary]{color:#fff;background-color:#1aad19}taro-button-core[type=primary]:not([disabled]):visited{color:#fff}taro-button-core[type=primary]:not([disabled]):active{color:rgba(255,255,255,.6);background-color:#179b16}taro-button-core[type=warn]{color:#fff;background-color:#e64340}taro-button-core[type=warn]:not([disabled]):visited{color:#fff}taro-button-core[type=warn]:not([disabled]):active{color:rgba(255,255,255,.6);background-color:#ce3c39}taro-button-core[plain][disabled],taro-button-core[plain][disabled][type=primary]{color:rgba(0,0,0,.3);background-color:#f7f7f7;border:1px solid rgba(0,0,0,.2)}`;
var Button = proxyCustomElement(class extends H {
    onClick(e) {
        if (this.disabled) {
            e.stopPropagation();
        }
    }
    onTouchStart() {
        if (this.disabled) {
            return;
        }
        this.touch = true;
        if (this.hoverClass && !this.disabled) {
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
    }
    onTouchEnd() {
        if (this.disabled) {
            return;
        }
        this.touch = false;
        if (this.hoverClass && !this.disabled) {
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
        if (this.formType === "submit") {
            this.onSubmit.emit();
        } else if (this.formType === "reset") {
            this.onReset.emit();
        }
    }
    render() {
        const { disabled, hoverClass, type, size, plain, loading, hover } = this;
        const cls = classnames({
            [`${hoverClass}`]: hover && !disabled
        });
        return h(Host, {
            class: cls,
            type,
            plain,
            loading,
            size
        }, loading && h("i", {
            class: "weui-loading"
        }), h("slot", null));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss2;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSubmit = createEvent(this, "tarobuttonsubmit", 7);
        this.onReset = createEvent(this, "tarobuttonreset", 7);
        this.disabled = void 0;
        this.hoverClass = "button-hover";
        this.type = "";
        this.hoverStartTime = 20;
        this.hoverStayTime = 70;
        this.size = void 0;
        this.plain = void 0;
        this.loading = false;
        this.formType = null;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-button-core",
    {
        "disabled": [
            516
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "type": [
            1
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "size": [
            1
        ],
        "plain": [
            4
        ],
        "loading": [
            4
        ],
        "formType": [
            513,
            "form-type"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            0,
            "click",
            "onClick"
        ],
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$18() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-button-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-button-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Button);
                }
                break;
        }
    });
}
var defineCustomElement10 = defineCustomElement$18;
// node_modules/@tarojs/components/dist/components/taro-camera-core.js
var Camera = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Camera", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-camera-core"
]);
function defineCustomElement$19() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-camera-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-camera-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Camera);
                }
                break;
        }
    });
}
var defineCustomElement11 = defineCustomElement$19;
// node_modules/@tarojs/components/dist/components/taro-canvas-core.js
var indexCss3 = "taro-canvas-core{width:300px;height:150px;display:block;position:relative}";
var LONG_TAP_DELAY = 500;
var Canvas = proxyCustomElement(class extends H {
    componentDidRender() {
        const [canvas] = this.el.children;
        if (!this.height || !this.width) {
            let style = window.getComputedStyle(canvas);
            this.height || (this.height = style.height);
            this.width || (this.width = style.width);
        }
        canvas.height = parseInt(this.height);
        canvas.width = parseInt(this.width);
    }
    render() {
        const { canvasId, nativeProps } = this;
        return h("canvas", Object.assign({
            "canvas-id": canvasId,
            style: {
                width: "100%",
                height: "100%"
            },
            onTouchStart: this.onTouchStart,
            onTouchMove: this.onTouchMove,
            onTouchCancel: this.onTouchEnd,
            onTouchEnd: this.onTouchEnd
        }, nativeProps));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss3;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongTap = createEvent(this, "longtap", 7);
        this.onTouchStart = ()=>{
            this.timer = setTimeout(()=>{
                this.onLongTap.emit();
            }, LONG_TAP_DELAY);
        };
        this.onTouchMove = ()=>{
            clearTimeout(this.timer);
        };
        this.onTouchEnd = ()=>{
            clearTimeout(this.timer);
        };
        this.canvasId = void 0;
        this.height = void 0;
        this.width = void 0;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-canvas-core",
    {
        "canvasId": [
            1,
            "id"
        ],
        "height": [
            1537
        ],
        "width": [
            1537
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$110() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-canvas-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-canvas-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Canvas);
                }
                break;
        }
    });
}
var defineCustomElement12 = defineCustomElement$110;
// node_modules/@tarojs/components/dist/components/taro-channel-live-core.js
var ChannelLive = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ChannelLive", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-channel-live-core"
]);
function defineCustomElement$111() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-channel-live-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-channel-live-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ChannelLive);
                }
                break;
        }
    });
}
var defineCustomElement13 = defineCustomElement$111;
// node_modules/@tarojs/components/dist/components/taro-channel-video-core.js
var ChannelVideo = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ChannelVideo", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-channel-video-core"
]);
function defineCustomElement$112() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-channel-video-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-channel-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ChannelVideo);
                }
                break;
        }
    });
}
var defineCustomElement14 = defineCustomElement$112;
// node_modules/@tarojs/components/dist/components/taro-checkbox-core.js
var indexCss4 = 'page,body{--weui-cellMarginLR:16px;--weui-cellPaddingLR:16px}.weui-cells__group{border:0}.weui-cells__group:first-child{margin-top:0}.weui-cells__group_form{margin-top:24px}.weui-cells__group_form .weui-cells{margin-left:var(--weui-cellMarginLR);margin-right:var(--weui-cellMarginLR)}.weui-cells__group_form .weui-cells:before,.weui-cells__group_form .weui-cells:after{left:var(--weui-cellPaddingLR);right:var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell{padding:16px var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell:before{left:var(--weui-cellPaddingLR);right:var(--weui-cellPaddingLR)}.weui-cells__group_form .weui-cell:not(.weui-cell_vertical) .weui-cell__hd{padding-right:16px}.weui-cells__group_form .weui-cell:not(.weui-cell_vertical) .weui-cell__ft{padding-left:16px}.weui-cells__group_form .weui-cells__title{margin-top:24px;margin-bottom:8px;padding:0 32px}.weui-cells__group_form:first-child .weui-cells__title{margin-top:0}.weui-cells__group_form .weui-cells__tips{padding:0 calc(var(--weui-cellMarginLR) + var(--weui-cellPaddingLR));color:var(--weui-FG-2);margin-top:8px}.weui-cells__group_form .weui-cells__tips a{font-weight:700}.weui-cells__group_form .weui-cells__tips_warn{color:var(--weui-RED)}.weui-cells__group_form .weui-label{max-width:5em;margin-right:8px}.weui-cells__group_form .weui-cell_access:active:after,.weui-cells__group_form .weui-cell_active:active:after{border-radius:8px}.weui-cells__group_form .weui-cell_warn input{color:#e64340}.weui-cells__group_form .weui-icon-warn,.weui-cells__group_form .weui-cell_switch:active:after,.weui-cells__group_form .weui-cell_vcode:active:after,.weui-cells__group_form .weui-cell_readonly:active:after,.weui-cells__group_form .weui-cell_disabled:active:after{display:none}.weui-cells__group_form input,.weui-cells__group_form textarea,.weui-cells__group_form label[for]{-webkit-tap-highlight-color:transparent}.weui-cells__group_form .weui-cell_wrap{align-items:initial;padding-top:8px;padding-bottom:8px}.weui-cells__group_form .weui-cell_wrap .weui-cell__hd{padding-right:0}.weui-cells__group_form .weui-cell_wrap .weui-label{margin-top:8px}.weui-cells__group_form .weui-cell_wrap .weui-cell__bd{flex-wrap:wrap;align-items:center;display:flex}.weui-cells__group_form .weui-cell__control{margin:8px 0 8px 16px}.weui-cells__group_form .weui-cell__control_flex{flex:1;min-width:30vw}.weui-cells__group_form .weui-vcode-btn{color:#000;background-color:#f8f8f8;border-radius:6px;width:auto;height:auto;padding:0 12px;font-size:16px;line-height:2}.weui-cells__group_form .weui-vcode-btn:before{display:none}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap{padding-top:4px;padding-bottom:4px}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap .weui-label{margin-top:12px}.weui-cells__group_form .weui-cell_vcode.weui-cell_wrap .weui-input{min-height:1.88235em;font-size:17px}.weui-cells__group_form .weui-cells_checkbox .weui-check__label:before{left:calc(40px + var(--weui-cellPaddingLR))}.weui-cells__group_form .weui-cell_select{padding:0}.weui-cells__group_form .weui-cell_select-before .weui-cell__hd{padding-right:0}.weui-cells__group_form .weui-cell_switch{padding:12px 16px}.weui-cells__group_form-primary{margin-top:32px}.weui-cells__group_form-primary .weui-cells{background:var(--weui-BG-1);border-radius:8px;overflow:hidden}.weui-cells__group_form-primary .weui-cells:before,.weui-cells__group_form-primary .weui-cells:after{display:none}.weui-cells__group_form-primary .weui-cell_access:active:after,.weui-cells__group_form-primary .weui-cell_active:active:after{border-radius:0}.taro-checkbox{display:inline-block;position:relative}.taro-checkbox_checked{appearance:none;vertical-align:0;color:#1aad19;background-color:#fff;border:1px solid #d1d1d1;border-radius:3px;outline:0;width:23px;height:23px;min-height:0;font-size:23px;display:inline-block;position:relative;top:5px}.taro-checkbox_checked:checked:before{vertical-align:middle;text-decoration:inherit;text-align:center;text-transform:none;font-variant:normal;font-family:weui;font-style:normal;font-weight:400;font-size:inherit;color:inherit;content:"\uEA08";speak:none;display:inline-block;position:absolute;top:50%;left:50%;transform:translate(-50%,-48%)scale(.73)}';
var Checkbox = proxyCustomElement(class extends H {
    watchId(newVal) {
        if (!this.isWillLoadCalled) return;
        if (newVal) this.inputEl.setAttribute("id", newVal);
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidRender() {
        this.id && this.el.removeAttribute("id");
    }
    render() {
        const { checked, name, color, value, disabled, nativeProps } = this;
        return h(Host, {
            class: "weui-cells_checkbox"
        }, h("input", Object.assign({
            ref: (dom)=>{
                if (!dom) return;
                this.inputEl = dom;
                if (this.id) dom.setAttribute("id", this.id);
            },
            type: "checkbox",
            value,
            name,
            class: "taro-checkbox_checked",
            style: {
                color
            },
            checked,
            disabled,
            onChange: this.handleChange
        }, nativeProps)), h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "id": [
                "watchId"
            ]
        };
    }
    static get style() {
        return indexCss4;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "checkboxchange", 7);
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: this.value
            });
        };
        this.name = void 0;
        this.value = "";
        this.color = void 0;
        this.id = void 0;
        this.checked = false;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-checkbox-core",
    {
        "name": [
            1
        ],
        "value": [
            1032
        ],
        "color": [
            1
        ],
        "id": [
            1025
        ],
        "checked": [
            4
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$113() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-checkbox-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-checkbox-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Checkbox);
                }
                break;
        }
    });
}
var defineCustomElement15 = defineCustomElement$113;
// node_modules/@tarojs/components/dist/components/taro-checkbox-group-core.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _CheckboxGroup_value;
var CheckboxGroup = proxyCustomElement(class extends H {
    function(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-CHECKBOX-CORE") return;
        const childList = this.el.querySelectorAll("taro-checkbox-core");
        __classPrivateFieldSet(this, _CheckboxGroup_value, this.getValues(childList), "f");
        this.onChange.emit({
            value: __classPrivateFieldGet(this, _CheckboxGroup_value, "f")
        });
    }
    componentDidLoad() {
        const childList = this.el.querySelectorAll("taro-checkbox-core");
        childList.forEach((element)=>{
            element.setAttribute("name", this.name || this.uniqueName);
        });
        Object.defineProperty(this.el, "value", {
            get: ()=>{
                if (!__classPrivateFieldGet(this, _CheckboxGroup_value, "f")) {
                    const childList2 = this.el.querySelectorAll("taro-checkbox-core");
                    __classPrivateFieldSet(this, _CheckboxGroup_value, this.getValues(childList2), "f");
                }
                return __classPrivateFieldGet(this, _CheckboxGroup_value, "f");
            },
            configurable: true
        });
    }
    getValues(childList) {
        return Array.from(childList).filter((element)=>{
            const checkbox = element.querySelector("input");
            return checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked;
        }).map((element)=>element.value);
    }
    render() {
        return h(Host, null);
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.uniqueName = Date.now().toString(36);
        _CheckboxGroup_value.set(this, void 0);
        this.name = void 0;
    }
}, [
    0,
    "taro-checkbox-group-core",
    {
        "name": [
            8
        ]
    },
    [
        [
            0,
            "checkboxchange",
            "function"
        ]
    ]
]);
_CheckboxGroup_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$114() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-checkbox-group-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-checkbox-group-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CheckboxGroup);
                }
                break;
        }
    });
}
var defineCustomElement16 = defineCustomElement$114;
// node_modules/@tarojs/components/dist/components/taro-comment-detail-core.js
var CommentDetail = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("CommentDetail", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-comment-detail-core"
]);
function defineCustomElement$115() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-comment-detail-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-comment-detail-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CommentDetail);
                }
                break;
        }
    });
}
var defineCustomElement17 = defineCustomElement$115;
// node_modules/@tarojs/components/dist/components/taro-comment-list-core.js
var CommentList = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("CommentList", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-comment-list-core"
]);
function defineCustomElement$116() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-comment-list-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-comment-list-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CommentList);
                }
                break;
        }
    });
}
var defineCustomElement18 = defineCustomElement$116;
// node_modules/@tarojs/components/dist/components/taro-contact-button-core.js
var ContactButton = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ContactButton", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-contact-button-core"
]);
function defineCustomElement$117() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-contact-button-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-contact-button-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ContactButton);
                }
                break;
        }
    });
}
var defineCustomElement19 = defineCustomElement$117;
// node_modules/@tarojs/components/dist/components/taro-cover-image-core.js
var indexCss5 = "taro-cover-image-core{width:320px;height:240px;overflow:hidden}";
var CoverImage = proxyCustomElement(class extends H {
    imageOnLoad() {
        const { width, height } = this.imgRef;
        this.onLoad.emit({
            width,
            height
        });
    }
    imageOnError(e) {
        this.onError.emit(e);
    }
    render() {
        const { src, imageOnLoad, imageOnError, nativeProps } = this;
        return h("img", Object.assign({
            ref: (img)=>this.imgRef = img,
            src,
            onLoad: imageOnLoad.bind(this),
            onError: imageOnError.bind(this)
        }, nativeProps));
    }
    static get style() {
        return indexCss5;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-cover-image-core",
    {
        "src": [
            1
        ],
        "nativeProps": [
            16
        ]
    }
]);
function defineCustomElement$118() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-cover-image-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-cover-image-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CoverImage);
                }
                break;
        }
    });
}
var defineCustomElement20 = defineCustomElement$118;
// node_modules/@tarojs/components/dist/components/taro-cover-view-core.js
var coverViewCss = "taro-cover-view-core{display:block}";
var CoverView = proxyCustomElement(class extends H {
    onTouchStart() {
        if (this.hoverClass) {
            this.touch = true;
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
        this.timeoutEvent = setTimeout(()=>{
            this.onLongPress.emit();
        }, 350);
        this.startTime = Date.now();
    }
    onTouchMove() {
        clearTimeout(this.timeoutEvent);
    }
    onTouchEnd() {
        const spanTime = Date.now() - this.startTime;
        if (spanTime < 350) {
            clearTimeout(this.timeoutEvent);
        }
        if (this.hoverClass) {
            this.touch = false;
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
    }
    render() {
        const cls = classnames({
            [`${this.hoverClass}`]: this.hover
        });
        let attr = {};
        if (!!this.animation) {
            attr["animation"] = this.animation;
            attr["data-animation"] = this.animation;
        }
        return h(Host, Object.assign({
            class: cls
        }, attr), h("slot", null));
    }
    static get style() {
        return coverViewCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.startTime = 0;
        this.animation = void 0;
        this.hoverClass = void 0;
        this.hoverStartTime = 50;
        this.hoverStayTime = 400;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-cover-view-core",
    {
        "animation": [
            1
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$119() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-cover-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-cover-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CoverView);
                }
                break;
        }
    });
}
var defineCustomElement21 = defineCustomElement$119;
// node_modules/@tarojs/components/dist/components/taro-custom-wrapper-core.js
var CustomWrapper = proxyCustomElement(class extends H {
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-custom-wrapper-core"
]);
function defineCustomElement$120() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-custom-wrapper-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-custom-wrapper-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, CustomWrapper);
                }
                break;
        }
    });
}
var defineCustomElement22 = defineCustomElement$120;
// node_modules/@tarojs/components/dist/components/taro-double-tap-gesture-handler-core.js
var DoubleTapGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("DoubleTapGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-double-tap-gesture-handler-core"
]);
function defineCustomElement$121() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-double-tap-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-double-tap-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, DoubleTapGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement23 = defineCustomElement$121;
// node_modules/@tarojs/components/dist/components/taro-draggable-sheet-core.js
var DraggableSheet = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("DraggableSheet", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-draggable-sheet-core"
]);
function defineCustomElement$122() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-draggable-sheet-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-draggable-sheet-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, DraggableSheet);
                }
                break;
        }
    });
}
var defineCustomElement24 = defineCustomElement$122;
// node_modules/@tarojs/components/dist/components/taro-editor-core.js
var Editor = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Editor", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-editor-core"
]);
function defineCustomElement$123() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-editor-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-editor-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Editor);
                }
                break;
        }
    });
}
var defineCustomElement25 = defineCustomElement$123;
// node_modules/@tarojs/components/dist/components/taro-follow-swan-core.js
var FollowSwan = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("FollowSwan", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-follow-swan-core"
]);
function defineCustomElement$124() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-follow-swan-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-follow-swan-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, FollowSwan);
                }
                break;
        }
    });
}
var defineCustomElement26 = defineCustomElement$124;
// node_modules/@tarojs/components/dist/components/taro-force-press-gesture-handler-core.js
var ForcePressGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ForcePressGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-force-press-gesture-handler-core"
]);
function defineCustomElement$125() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-force-press-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-force-press-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ForcePressGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement27 = defineCustomElement$125;
// node_modules/@tarojs/components/dist/components/taro-form-core.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _Form_value;
var Form = proxyCustomElement(class extends H {
    onButtonSubmit(e) {
        e.stopPropagation();
        __classPrivateFieldSet2(this, _Form_value, this.getFormValue(), "f");
        this.onSubmit.emit({
            value: __classPrivateFieldGet2(this, _Form_value, "f")
        });
    }
    onButtonReset(e) {
        e.stopPropagation();
        this.form.reset();
    }
    componentDidLoad() {
        __classPrivateFieldSet2(this, _Form_value, this.getFormValue(), "f");
        Object.defineProperty(this.el, "value", {
            get: ()=>__classPrivateFieldGet2(this, _Form_value, "f"),
            configurable: true
        });
    }
    componentDidRender() {
        if (!this.originalAppendChild) {
            this.originalAppendChild = this.el.appendChild;
            this.originalInsertBefore = this.el.insertBefore;
            this.originalReplaceChild = this.el.replaceChild;
            this.originalRemoveChild = this.el.removeChild;
        }
        if (!this.form) {
            this.el.appendChild = this.originalAppendChild;
            this.el.insertBefore = this.originalInsertBefore;
            this.el.replaceChild = this.originalReplaceChild;
            this.el.removeChild = this.originalRemoveChild;
            return;
        }
        this.el.appendChild = (newChild)=>{
            return this.form.appendChild(newChild);
        };
        this.el.insertBefore = (newChild, refChild)=>{
            return this.form.insertBefore(newChild, refChild);
        };
        this.el.replaceChild = (newChild, oldChild)=>{
            return this.form.replaceChild(newChild, oldChild);
        };
        this.el.removeChild = (oldChild)=>{
            return this.form.removeChild(oldChild);
        };
    }
    getFormValue() {
        const el = this.el;
        const elements = [];
        const tagElements = el.getElementsByTagName("input");
        for(let j = 0; j < tagElements.length; j++){
            elements.push(tagElements[j]);
        }
        const formItem = {};
        const hash = {};
        elements.forEach((item)=>{
            if (typeof item.name !== "string") return;
            if (item.className.indexOf("weui-switch") !== -1) {
                formItem[item.name] = item.checked;
                return;
            }
            if (item.type === "radio") {
                if (item.checked) {
                    hash[item.name] = true;
                    formItem[item.name] = item.value;
                } else {
                    if (!hash[item.name]) {
                        formItem[item.name] = "";
                    }
                }
                return;
            }
            if (item.type === "checkbox") {
                if (item.checked) {
                    if (hash[item.name]) {
                        formItem[item.name].push(item.value);
                    } else {
                        hash[item.name] = true;
                        formItem[item.name] = [
                            item.value
                        ];
                    }
                } else {
                    if (!hash[item.name]) {
                        formItem[item.name] = [];
                    }
                }
                return;
            }
            formItem[item.name] = item.value;
        });
        const textareaElements = el.getElementsByTagName("textarea");
        const textareaEleArr = [];
        for(let i2 = 0; i2 < textareaElements.length; i2++){
            textareaEleArr.push(textareaElements[i2]);
        }
        textareaEleArr.forEach((v)=>{
            if (typeof v.name !== "string") return;
            formItem[v.name] = v.value;
        });
        return formItem;
    }
    render() {
        return h("form", {
            ref: (dom)=>{
                this.form = dom;
            }
        }, h("slot", null));
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSubmit = createEvent(this, "submit", 7);
        _Form_value.set(this, {});
    }
}, [
    4,
    "taro-form-core",
    void 0,
    [
        [
            0,
            "tarobuttonsubmit",
            "onButtonSubmit"
        ],
        [
            0,
            "tarobuttonreset",
            "onButtonReset"
        ]
    ]
]);
_Form_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$126() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-form-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-form-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Form);
                }
                break;
        }
    });
}
var defineCustomElement28 = defineCustomElement$126;
// node_modules/@tarojs/components/dist/components/taro-functional-page-navigator-core.js
var FunctionalPageNavigator = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("FunctionalPageNavigator", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-functional-page-navigator-core"
]);
function defineCustomElement$127() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-functional-page-navigator-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-functional-page-navigator-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, FunctionalPageNavigator);
                }
                break;
        }
    });
}
var defineCustomElement29 = defineCustomElement$127;
// node_modules/@tarojs/components/dist/components/taro-grid-builder-core.js
var GridBuilder = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("GridBuilder", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-grid-builder-core"
]);
function defineCustomElement$128() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-grid-builder-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-grid-builder-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, GridBuilder);
                }
                break;
        }
    });
}
var defineCustomElement30 = defineCustomElement$128;
// node_modules/@tarojs/components/dist/components/taro-grid-view-core.js
var GridView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("GridView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-grid-view-core"
]);
function defineCustomElement$129() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-grid-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-grid-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, GridView);
                }
                break;
        }
    });
}
var defineCustomElement31 = defineCustomElement$129;
// node_modules/@tarojs/components/dist/components/taro-horizontal-drag-gesture-handler-core.js
var HorizontalDragGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("HorizontalDragGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-horizontal-drag-gesture-handler-core"
]);
function defineCustomElement$130() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-horizontal-drag-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-horizontal-drag-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, HorizontalDragGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement32 = defineCustomElement$130;
// node_modules/@tarojs/components/dist/components/taro-icon-core.js
var indexCss6 = '.weui-icon-circle:before{content:"\uEA01"}.weui-icon-download:before{content:"\uEA02"}.weui-icon-info:before{content:"\uEA03"}.weui-icon-safe-success:before{content:"\uEA04"}.weui-icon-safe-warn:before{content:"\uEA05"}.weui-icon-success:before{content:"\uEA06"}.weui-icon-success-circle:before{content:"\uEA07"}.weui-icon-success-no-circle:before{content:"\uEA08"}.weui-icon-waiting:before{content:"\uEA09"}.weui-icon-waiting-circle:before{content:"\uEA0A"}.weui-icon-warn:before{content:"\uEA0B"}.weui-icon-info-circle:before{content:"\uEA0C"}.weui-icon-cancel:before{content:"\uEA0D"}.weui-icon-search:before{content:"\uEA0E"}.weui-icon-clear:before{content:"\uEA0F"}.weui-icon-back:before{content:"\uEA10"}.weui-icon-delete:before{content:"\uEA11"}.weui-icon-success{color:#09bb07;font-size:23px}.weui-icon-waiting{color:#10aeff;font-size:23px}.weui-icon-warn{color:#f43530;font-size:23px}.weui-icon-info{color:#10aeff;font-size:23px}.weui-icon-success-circle,.weui-icon-success-no-circle{color:#09bb07;font-size:23px}.weui-icon-waiting-circle{color:#10aeff;font-size:23px}.weui-icon-circle{color:#c9c9c9;font-size:23px}.weui-icon-download,.weui-icon-info-circle{color:#09bb07;font-size:23px}.weui-icon-safe-success{color:#09bb07}.weui-icon-safe-warn{color:#ffbe00}.weui-icon-cancel{color:#f43530;font-size:22px}.weui-icon-search,.weui-icon-clear{color:#b2b2b2;font-size:14px}.weui-icon-delete.weui-icon_gallery-delete{color:#fff;font-size:22px}.weui-icon_msg{font-size:93px}.weui-icon_msg.weui-icon-warn{color:#f76260}.weui-icon_msg-primary{font-size:93px}.weui-icon_msg-primary.weui-icon-warn{color:#ffbe00}';
var Icon = proxyCustomElement(class extends H {
    render() {
        const { type, size, color } = this;
        const iconType = type === null || type === void 0 ? void 0 : type.replace(/_/g, "-");
        const cls = classnames({
            [`weui-icon-${iconType}`]: true
        });
        const style = {
            "font-size": `${size}px`,
            color
        };
        return h(Host, {
            class: cls,
            style
        });
    }
    static get style() {
        return indexCss6;
    }
    constructor(){
        super();
        this.__registerHost();
        this.type = void 0;
        this.size = "23";
        this.color = void 0;
    }
}, [
    0,
    "taro-icon-core",
    {
        "type": [
            1
        ],
        "size": [
            8
        ],
        "color": [
            1
        ]
    }
]);
function defineCustomElement$131() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-icon-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-icon-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Icon);
                }
                break;
        }
    });
}
var defineCustomElement33 = defineCustomElement$131;
// node_modules/@tarojs/components/dist/components/taro-image-core.js
var indexCss7 = 'img[src=""]{opacity:0}taro-image-core{width:320px;height:240px;font-size:0;display:inline-block;position:relative;overflow:hidden}.taro-img.taro-img__widthfix{height:100%}.taro-img__mode-scaletofill{width:100%;height:100%}.taro-img__mode-aspectfit{max-width:100%;max-height:100%;position:absolute;top:50%;transform:translateY(-50%)}.taro-img__mode-aspectfill{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.taro-img__mode-aspectfill--width{min-width:100%;height:100%}.taro-img__mode-aspectfill--height{width:100%;min-height:100%}.taro-img__mode-widthfix{width:100%}.taro-img__mode-heightfix{height:100%}.taro-img__mode-top{position:absolute;left:50%;transform:translate(-50%)}.taro-img__mode-bottom{position:absolute;bottom:0;left:50%;transform:translate(-50%)}.taro-img__mode-center{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.taro-img__mode-left{position:absolute;top:50%;transform:translateY(-50%)}.taro-img__mode-right{position:absolute;top:50%;right:0;transform:translateY(-50%)}.taro-img__mode-topright{position:absolute;right:0}.taro-img__mode-bottomleft{position:absolute;bottom:0}.taro-img__mode-bottomright{position:absolute;bottom:0;right:0}';
var Image2 = proxyCustomElement(class extends H {
    componentDidLoad() {
        if (!this.lazyLoad) return;
        const lazyImg = new IntersectionObserver((entries)=>{
            if (entries[entries.length - 1].isIntersecting) {
                lazyImg.unobserve(this.imgRef);
                this.didLoad = true;
            }
        }, {
            rootMargin: "300px 0px"
        });
        lazyImg.observe(this.imgRef);
    }
    imageOnLoad() {
        const { width, height, naturalWidth, naturalHeight } = this.imgRef;
        this.onLoad.emit({
            width,
            height
        });
        this.aspectFillMode = naturalWidth > naturalHeight ? "width" : "height";
    }
    imageOnError(e) {
        this.onError.emit(e);
    }
    render() {
        const { src, lazyLoad = false, aspectFillMode = "width", imageOnLoad, imageOnError, nativeProps, didLoad } = this;
        const mode = this.mode || "scaleToFill";
        const cls = classnames({
            "taro-img__widthfix": mode === "widthFix"
        });
        const imgCls = classnames(`taro-img__mode-${mode.toLowerCase().replace(/\s/g, "")}`, {
            [`taro-img__mode-aspectfill--${aspectFillMode}`]: mode === "aspectFill"
        });
        return h(Host, {
            class: cls
        }, src ? h("img", Object.assign({
            ref: (img)=>this.imgRef = img,
            class: imgCls,
            src: lazyLoad && !didLoad ? void 0 : src,
            onLoad: imageOnLoad.bind(this),
            onError: imageOnError.bind(this)
        }, nativeProps)) : "");
    }
    static get style() {
        return indexCss7;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
        this.mode = "scaleToFill";
        this.lazyLoad = false;
        this.nativeProps = {};
        this.aspectFillMode = "width";
        this.didLoad = false;
    }
}, [
    0,
    "taro-image-core",
    {
        "src": [
            1
        ],
        "mode": [
            1
        ],
        "lazyLoad": [
            4,
            "lazy-load"
        ],
        "nativeProps": [
            16
        ],
        "aspectFillMode": [
            32
        ],
        "didLoad": [
            32
        ]
    }
]);
function defineCustomElement$132() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-image-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-image-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Image2);
                }
                break;
        }
    });
}
var defineCustomElement34 = defineCustomElement$132;
// node_modules/@tarojs/components/dist/components/taro-inline-payment-panel-core.js
var InlinePaymentPanel = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("InlinePaymentPanel", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-inline-payment-panel-core"
]);
function defineCustomElement$133() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-inline-payment-panel-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-inline-payment-panel-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, InlinePaymentPanel);
                }
                break;
        }
    });
}
var defineCustomElement35 = defineCustomElement$133;
// node_modules/@tarojs/components/dist/components/taro-input-core.js
var indexCss8 = ".weui-input{-webkit-appearance:none;width:100%;font-size:inherit;color:inherit;background-color:transparent;border:0;outline:0;height:1.47059em;line-height:1.47059}.weui-input::-webkit-outer-spin-button,.weui-input::-webkit-inner-spin-button{-webkit-appearance:none;margin:0}taro-input-core{display:block}taro-input-core input[type=search]::-webkit-search-cancel-button{-webkit-appearance:none;display:none}";
function getTrueType(type, confirmType, password) {
    if (confirmType === "search") type = "search";
    if (password) type = "password";
    if (typeof type === "undefined") {
        return "text";
    }
    if (!type) {
        throw new Error("unexpected type");
    }
    if (type === "digit") type = "number";
    return type;
}
function fixControlledValue(value) {
    return value !== null && value !== void 0 ? value : "";
}
var Input = proxyCustomElement(class extends H {
    focus() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.inputRef.focus();
        })();
    }
    watchAutoFocus(newValue, oldValue) {
        var _a;
        if (!oldValue && newValue) {
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    watchValue(newValue) {
        const value = fixControlledValue(newValue);
        if (this.inputRef.value !== value) {
            this.inputRef.value = value;
        }
    }
    componentDidLoad() {
        var _a, _b, _c, _d, _e;
        if (this.type === "file") {
            this.fileListener = ()=>{
                this.onInput.emit();
            };
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.addEventListener("change", this.fileListener);
        } else {
            (_b = this.inputRef) === null || _b === void 0 ? void 0 : _b.addEventListener("compositionstart", this.handleComposition);
            (_c = this.inputRef) === null || _c === void 0 ? void 0 : _c.addEventListener("compositionend", this.handleComposition);
            (_d = this.inputRef) === null || _d === void 0 ? void 0 : _d.addEventListener("beforeinput", this.handleBeforeInput);
            (_e = this.inputRef) === null || _e === void 0 ? void 0 : _e.addEventListener("textInput", this.handleBeforeInput);
        }
    }
    disconnectedCallback() {
        var _a, _b, _c, _d, _e;
        if (this.type === "file") {
            (_a = this.inputRef) === null || _a === void 0 ? void 0 : _a.removeEventListener("change", this.fileListener);
        } else {
            (_b = this.inputRef) === null || _b === void 0 ? void 0 : _b.removeEventListener("compositionstart", this.handleComposition);
            (_c = this.inputRef) === null || _c === void 0 ? void 0 : _c.removeEventListener("compositionend", this.handleComposition);
            (_d = this.inputRef) === null || _d === void 0 ? void 0 : _d.removeEventListener("beforeinput", this.handleBeforeInput);
            (_e = this.inputRef) === null || _e === void 0 ? void 0 : _e.removeEventListener("textInput", this.handleBeforeInput);
        }
    }
    render() {
        const { value, type, password, placeholder, autoFocus, disabled, maxlength, confirmType, name, readonly, nativeProps } = this;
        return h("input", Object.assign({
            ref: (input)=>{
                this.inputRef = input;
                if (autoFocus && input) input.focus();
            },
            class: "weui-input",
            type: getTrueType(type, confirmType, password),
            placeholder,
            autoFocus,
            disabled,
            maxlength,
            name,
            readonly: readonly ? "readonly" : void 0,
            onInput: this.handleInput,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onKeyDown: this.handleKeyDown,
            onPaste: this.handlePaste,
            onCompositionStart: this.handleComposition,
            onCompositionEnd: this.handleComposition
        }, nativeProps, {
            value: fixControlledValue(value)
        }));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "autoFocus": [
                "watchAutoFocus"
            ],
            "value": [
                "watchValue"
            ]
        };
    }
    static get style() {
        return indexCss8;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onInput = createEvent(this, "input", 7);
        this.onPaste = createEvent(this, "paste", 7);
        this.onFocus = createEvent(this, "focus", 7);
        this.onBlur = createEvent(this, "blur", 7);
        this.onConfirm = createEvent(this, "confirm", 7);
        this.onChange = createEvent(this, "change", 7);
        this.onKeyDown = createEvent(this, "keydown", 7);
        this.isOnComposition = false;
        this.isOnPaste = false;
        this.onInputExcuted = false;
        this.handleInput = (e)=>{
            e.stopPropagation();
            const { type, maxlength, confirmType, password } = this;
            if (!this.isOnComposition && !this.onInputExcuted) {
                let value = e.target.value;
                const inputType = getTrueType(type, confirmType, password);
                this.onInputExcuted = true;
                if (inputType === "number" && value && maxlength > -1 && maxlength <= value.length) {
                    value = value.substring(0, maxlength);
                    e.target.value = value;
                }
                this.value = value;
                this.onInput.emit({
                    value,
                    cursor: value.length
                });
                this.onInputExcuted = false;
            }
        };
        this.handlePaste = (e)=>{
            e.stopPropagation();
            this.isOnPaste = true;
            this.onPaste.emit({
                value: e.target.value
            });
        };
        this.handleFocus = (e)=>{
            e.stopPropagation();
            this.onInputExcuted = false;
            this.onFocus.emit({
                value: e.target.value
            });
        };
        this.handleBlur = (e)=>{
            e.stopPropagation();
            this.onBlur.emit({
                value: e.target.value
            });
        };
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: e.target.value
            });
            if (this.isOnPaste) {
                this.isOnPaste = false;
                this.value = e.target.value;
                this.onInput.emit({
                    value: e.target.value,
                    cursor: e.target.value.length
                });
            }
        };
        this.handleKeyDown = (e)=>{
            e.stopPropagation();
            const { value } = e.target;
            const keyCode = e.keyCode || e.code;
            this.onInputExcuted = false;
            this.onKeyDown.emit({
                value,
                cursor: value.length,
                keyCode
            });
            keyCode === 13 && this.onConfirm.emit({
                value
            });
        };
        this.handleComposition = (e)=>{
            e.stopPropagation();
            if (!(e.target instanceof HTMLInputElement)) return;
            if (e.type === "compositionend") {
                this.isOnComposition = false;
                this.value = e.target.value;
                this.onInput.emit({
                    value: e.target.value,
                    cursor: e.target.value.length
                });
            } else {
                this.isOnComposition = true;
            }
        };
        this.handleBeforeInput = (e)=>{
            if (!e.data) return;
            const isNumber = e.data && /[0-9]/.test(e.data);
            if (this.type === "number" && !isNumber) {
                e.preventDefault();
            }
            if (this.type === "digit" && !isNumber) {
                if (e.data !== "." || e.data === "." && e.target.value.indexOf(".") > -1) {
                    e.preventDefault();
                }
            }
        };
        this.value = "";
        this.type = void 0;
        this.password = false;
        this.placeholder = void 0;
        this.disabled = false;
        this.maxlength = 140;
        this.autoFocus = false;
        this.confirmType = "done";
        this.name = void 0;
        this.readonly = false;
        this.nativeProps = {};
    }
}, [
    0,
    "taro-input-core",
    {
        "value": [
            1025
        ],
        "type": [
            1
        ],
        "password": [
            4
        ],
        "placeholder": [
            1
        ],
        "disabled": [
            4
        ],
        "maxlength": [
            2
        ],
        "autoFocus": [
            4,
            "focus"
        ],
        "confirmType": [
            1,
            "confirm-type"
        ],
        "name": [
            1
        ],
        "readonly": [
            4
        ],
        "nativeProps": [
            16
        ],
        "focus": [
            64
        ]
    }
]);
function defineCustomElement$134() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-input-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-input-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Input);
                }
                break;
        }
    });
}
var defineCustomElement36 = defineCustomElement$134;
// node_modules/@tarojs/components/dist/components/taro-keyboard-accessory-core.js
var KeyboardAccessory = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("KeyboardAccessory", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-keyboard-accessory-core"
]);
function defineCustomElement$135() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-keyboard-accessory-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-keyboard-accessory-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, KeyboardAccessory);
                }
                break;
        }
    });
}
var defineCustomElement37 = defineCustomElement$135;
// node_modules/@tarojs/components/dist/components/taro-label-core.js
var Label = proxyCustomElement(class extends H {
    render() {
        return h("label", {
            htmlFor: this.for
        }, h("slot", null));
    }
    constructor(){
        super();
        this.__registerHost();
        this.for = void 0;
    }
}, [
    4,
    "taro-label-core",
    {
        "for": [
            1
        ]
    }
]);
function defineCustomElement$136() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-label-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-label-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Label);
                }
                break;
        }
    });
}
var defineCustomElement38 = defineCustomElement$136;
// node_modules/@tarojs/components/dist/components/taro-lifestyle-core.js
var Lifestyle = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Lifestyle", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-lifestyle-core"
]);
function defineCustomElement$137() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-lifestyle-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-lifestyle-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Lifestyle);
                }
                break;
        }
    });
}
var defineCustomElement39 = defineCustomElement$137;
// node_modules/@tarojs/components/dist/components/taro-like-core.js
var Like = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Like", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-like-core"
]);
function defineCustomElement$138() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-like-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-like-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Like);
                }
                break;
        }
    });
}
var defineCustomElement40 = defineCustomElement$138;
// node_modules/@tarojs/components/dist/components/taro-list-builder-core.js
var ListBuilder = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ListBuilder", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-list-builder-core"
]);
function defineCustomElement$139() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-list-builder-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-list-builder-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ListBuilder);
                }
                break;
        }
    });
}
var defineCustomElement41 = defineCustomElement$139;
// node_modules/@tarojs/components/dist/components/taro-list-view-core.js
var ListView = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ListView", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-list-view-core"
]);
function defineCustomElement$140() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-list-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-list-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ListView);
                }
                break;
        }
    });
}
var defineCustomElement42 = defineCustomElement$140;
// node_modules/@tarojs/components/dist/components/taro-live-player-core.js
var LivePlayer = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("LivePlayer", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-live-player-core"
]);
function defineCustomElement$141() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-live-player-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-live-player-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, LivePlayer);
                }
                break;
        }
    });
}
var defineCustomElement43 = defineCustomElement$141;
// node_modules/@tarojs/components/dist/components/taro-live-pusher-core.js
var LivePusher = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("LivePusher", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-live-pusher-core"
]);
function defineCustomElement$142() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-live-pusher-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-live-pusher-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, LivePusher);
                }
                break;
        }
    });
}
var defineCustomElement44 = defineCustomElement$142;
// node_modules/@tarojs/components/dist/components/taro-login-core.js
var Login = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Login", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-login-core"
]);
function defineCustomElement$143() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-login-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-login-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Login);
                }
                break;
        }
    });
}
var defineCustomElement45 = defineCustomElement$143;
// node_modules/@tarojs/components/dist/components/taro-long-press-gesture-handler-core.js
var LongPressGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("LongPressGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-long-press-gesture-handler-core"
]);
function defineCustomElement$144() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-long-press-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-long-press-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, LongPressGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement46 = defineCustomElement$144;
// node_modules/@tarojs/components/dist/components/taro-lottie-core.js
var Lottie = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Lottie", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-lottie-core"
]);
function defineCustomElement$145() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-lottie-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-lottie-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Lottie);
                }
                break;
        }
    });
}
var defineCustomElement47 = defineCustomElement$145;
// node_modules/@tarojs/components/dist/components/taro-map-core.js
var import_hammerjs = (0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__toESM)(require_hammer());
var mapCss = ".BMap_cpyCtrl,.anchorBL img,.BMap_bubble_buttons{display:none}";
var Map3 = proxyCustomElement(class extends H {
    componentDidLoad() {
        var _this = this;
        return _async_to_generator(function*() {
            yield _this.loadMapScript();
            yield _this.LoadBmapLibScript();
            if (_this.mapRef) {
                _this.mapRef.addEventListener("touchmove", (e)=>{
                    if (e.cancelable) {
                        e.preventDefault();
                    }
                });
                _this.map = new BMapGL.Map(_this.mapRef);
                _this.map.removeControl(_this.map.getMapType());
                if (_this.latitude < -90 || _this.latitude > 90 || _this.longitude < -180 || _this.longitude > 180 || isNaN(_this.latitude) || isNaN(_this.longitude)) {
                    console.error("\u8BF7\u6B63\u786E\u8BBE\u7F6E\u4E2D\u5FC3\u7ECF\u7EAC\u5EA6");
                    return;
                }
                let scale = isNaN(_this.scale) ? 16 : _this.scale;
                let minScale = isNaN(_this.minScale) ? 3 : _this.minScale;
                let maxScale = isNaN(_this.maxScale) ? 16 : _this.maxScale;
                const point = new BMapGL.Point(_this.longitude, _this.latitude);
                if (minScale < 3 || minScale > 20) {
                    minScale = 3;
                    _this.map.setMinZoom(3);
                } else {
                    _this.map.setMinZoom(minScale);
                }
                if (maxScale > 20 || maxScale < 3) {
                    maxScale = 20;
                    _this.map.setMaxZoom(20);
                } else {
                    _this.map.setMaxZoom(maxScale);
                }
                if (minScale > maxScale) {
                    minScale = 3;
                    _this.map.setMinZoom(3);
                    maxScale = 20;
                    _this.map.setMaxZoom(20);
                }
                if (minScale <= 16 && maxScale >= 16) {
                    if (scale >= minScale && scale <= maxScale) {
                        _this.map.centerAndZoom(point, scale);
                    } else {
                        scale = 16;
                        _this.map.centerAndZoom(point, scale);
                    }
                } else {
                    if (scale >= minScale && scale <= maxScale) {
                        _this.map.centerAndZoom(point, scale);
                    } else if (scale < minScale) {
                        scale = minScale;
                        _this.map.centerAndZoom(point, minScale);
                    } else {
                        scale = maxScale;
                        _this.map.centerAndZoom(point, maxScale);
                    }
                }
                if (Array.isArray(_this.markers)) {
                    _this.addMarkers(_this.markers);
                }
                if (Array.isArray(_this.polyline)) {
                    _this.polyline.forEach((line)=>{
                        if (line.points) {
                            const points = line.points.map((point2)=>new BMapGL.Point(point2.longitude, point2.latitude));
                            const polyline = new BMapGL.Polyline(points, {
                                strokeColor: line.color,
                                strokeWeight: line.width,
                                strokeStyle: line.dottedLine ? "dashed" : "solid",
                                strokeOpacity: 1
                            });
                            _this.map.addOverlay(polyline);
                        }
                    });
                }
                if (Array.isArray(_this.circles)) {
                    _this.circles.forEach((circle)=>{
                        if (circle.latitude && circle.longitude && circle.radius) {
                            const point2 = new BMapGL.Point(circle.longitude, circle.latitude);
                            const circleObj = new BMapGL.Circle(point2, circle.radius, {
                                strokeColor: circle.color,
                                fillColor: circle.fillColor,
                                strokeWeight: circle.strokeWidth
                            });
                            _this.map.addOverlay(circleObj);
                        }
                    });
                }
                if (Array.isArray(_this.polygons)) {
                    _this.polygons.forEach((polygon)=>{
                        const points = polygon.points.map((point2)=>new BMapGL.Point(point2.longitude, point2.latitude));
                        const polygonObj = new BMapGL.Polygon(points, {
                            strokeColor: polygon.strokeColor,
                            fillColor: polygon.fillColor,
                            strokeWeight: polygon.strokeWidth
                        });
                        _this.map.addOverlay(polygonObj);
                    });
                }
                if (_this.layerStyle === 0) {
                    const layerStyle = _this.layerStyle;
                    if (layerStyle) {
                        _this.map.setMapStyleV2({
                            styleId: _this.subkey
                        });
                    }
                } else {
                    const layerStyle = _this.layerStyle ? _this.layerStyle : 1;
                    if (layerStyle === 1) {
                        _this.map.setMapStyleV2({
                            styleId: _this.subkey
                        });
                    }
                }
                const enable3D = _this.enable3D === true ? _this.enable3D : false;
                const enableOverlooking = _this.enableOverlooking === true ? _this.enableOverlooking : false;
                const enableAutoMaxOverlooking = _this.enableAutoMaxOverlooking === true ? _this.enableAutoMaxOverlooking : false;
                const skew = _this.skew ? _this.skew : 0;
                if (enable3D === true) {
                    if (enableOverlooking === true) {
                        if (enableAutoMaxOverlooking === true) {
                            _this.map.setTilt(75);
                        } else {
                            _this.map.setTilt(45);
                        }
                    } else if (skew >= 0 && skew <= 40) {
                        _this.map.setTilt(skew);
                    } else {
                        _this.map.setTilt(0);
                    }
                } else {
                    _this.map.setTilt(0);
                }
                const showCompass = _this.showCompass === true ? _this.showCompass : false;
                if (showCompass === true) {
                    const compassControl = new BMapGL.NavigationControl3D({
                        anchor: BMAP_ANCHOR_TOP_RIGHT,
                        type: 3
                    });
                    _this.map.addControl(compassControl);
                }
                const showScale = _this.showScale === true ? _this.showScale : false;
                if (showScale === true) {
                    const scaleControl = new BMapGL.ScaleControl({
                        anchor: BMAP_ANCHOR_BOTTOM_RIGHT
                    });
                    _this.map.addControl(scaleControl);
                }
                const enableZoom = _this.enableZoom === false ? _this.enableZoom : true;
                if (enableZoom === true) {
                    _this.map.enableScrollWheelZoom(_this.enableZoom);
                }
                if (_this.enableZoom === true && _this.mapRef) {
                    _this.map.enablePinchToZoom();
                } else {
                    _this.map.disablePinchToZoom();
                }
                const enableScroll = _this.enableScroll === false ? _this.enableScroll : true;
                if (enableScroll === true) {
                    _this.map.enableDragging();
                } else {
                    _this.map.disableDragging();
                }
                const rotate = _this.rotate ? _this.rotate : 0;
                if (rotate >= 0 && _this.rotate <= 360) {
                    _this.map.setHeading(_this.rotate);
                } else {
                    _this.map.setHeading(0);
                }
                if (_this.enableRotate === true) {
                    _this.map.enableRotateGestures();
                }
                const enableSatellite = _this.enableSatellite === true ? _this.enableSatellite : false;
                if (enableSatellite === true && _this.mapRef) {
                    const mapTypeControl = new BMapGL.MapTypeControl({
                        mapTypes: [
                            BMAP_NORMAL_MAP,
                            BMAP_SATELLITE_MAP
                        ]
                    });
                    _this.map.addControl(mapTypeControl);
                }
                const enableTraffic = _this.enableTraffic === true ? _this.enableTraffic : false;
                if (enableTraffic === true && _this.mapRef) {
                    _this.map.setTrafficOn();
                }
                const enableBuilding = _this.enableBuilding === false ? _this.enableBuilding : true;
                if (enableBuilding === false) {
                    _this.map.setDisplayOptions({
                        building: false
                    });
                }
            }
            if (_this.map) {
                const hammer = new import_hammerjs.default(_this.mapRef);
                hammer.on("tap", (e)=>{
                    const point = _this.map.pixelToPoint({
                        x: e.center.x,
                        y: e.center.y
                    });
                    _this.onTap.emit({
                        longitude: point.lng,
                        latitude: point.lat
                    });
                });
            }
        })();
    }
    disconnectedCallback() {
        if (this.map) {
            this.map.destroy();
        }
    }
    addMarkers(markers) {
        const existingIds = [];
        markers.forEach((marker)=>{
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
            if (existingIds.includes(marker.id)) {
                console.error("\u8BF7\u8F93\u5165\u4E0D\u540C\u7684marker\u7684id");
                return;
            }
            existingIds.push(marker.id);
            if (marker.latitude && marker.longitude && marker.iconPath && marker.id) {
                if (marker.latitude < -90 || marker.latitude > 90 || marker.longitude < -180 || marker.longitude > 180) {
                    console.error("\u8BF7\u6B63\u786E\u8BBE\u7F6Emarker\u7684\u7ECF\u7EAC\u5EA6");
                    return;
                }
                const pt = new BMapGL.Point(marker.longitude, marker.latitude);
                const markerObj = new BMapGL.Marker(pt, {
                    enableClicking: true
                });
                markerObj.id = marker.id;
                markerObj.alpha = marker.alpha;
                if (marker.zIndex) {
                    markerObj.setZIndex(marker.zIndex);
                }
                if (marker.width && marker.height) {
                    const canvas = document.createElement("canvas");
                    canvas.width = marker.width * 2;
                    canvas.height = marker.height * 2;
                    const ctx = canvas.getContext("2d");
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.src = marker.iconPath;
                    img.onload = function() {
                        ctx.drawImage(img, 0, 0, marker.width * 2, marker.height * 2);
                        const icon = new BMapGL.Icon(canvas.toDataURL(), new BMapGL.Size(marker.width, marker.height), {
                            anchor: new BMapGL.Size(0, 0)
                        });
                        markerObj.setIcon(icon);
                    };
                } else {
                    const img = new Image();
                    img.src = marker.iconPath;
                    img.style.opacity = String(marker.alpha);
                    img.onload = ()=>{
                        const iconSize = new BMapGL.Size(img.width, img.height);
                        const icon = new BMapGL.Icon(img.src, iconSize);
                        icon.imageOffset = new BMapGL.Size(0, 0, marker.alpha || 1);
                        markerObj.setIcon(icon);
                    };
                }
                const rotate = marker.rotate ? marker.rotate : 0;
                if (rotate >= 0 && rotate <= 360) {
                    markerObj.setRotation(rotate);
                }
                const anchorX = (_b = (_a = marker.anchor) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0.5;
                const anchorY = (_d = (_c = marker.anchor) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 1;
                if (anchorX >= 0 && anchorX <= 1 && anchorY >= 0 && anchorY <= 1) {
                    const offsetX = -anchorX * (marker.width || 0);
                    const offsetY = -anchorY * (marker.height || 0);
                    markerObj.setOffset(new BMapGL.Size(offsetX, offsetY));
                } else {
                    const offsetX = -0.5 * (marker.width || 0);
                    const offsetY = -1 * (marker.height || 0);
                    markerObj.setOffset(new BMapGL.Size(offsetX, offsetY));
                }
                if (!marker.callout && marker.title) {
                    const hammer = new import_hammerjs.default(this.mapRef);
                    hammer.on("tap", (e)=>{
                        const touch = e.center;
                        const x = touch.x;
                        const y = touch.y;
                        const threshold = 15;
                        this.markers.forEach((marker2)=>{
                            const mapContainer = document.getElementsByClassName("bmap-container")[0];
                            const mapContainerRect = mapContainer.getBoundingClientRect();
                            const mapOffsetX = mapContainerRect.left;
                            const mapOffsetY = mapContainerRect.top;
                            const point = new BMapGL.Point(marker2.longitude, marker2.latitude);
                            const pixel = this.map.pointToPixel(point);
                            const markerX = pixel.x + mapOffsetX;
                            const markerY = pixel.y + mapOffsetY;
                            const distance = Math.sqrt(Math.pow(x - markerX, 2) + Math.pow(y - markerY, 2));
                            if (distance < threshold && marker2.id === markerObj.id) {
                                const content = `<div style="text-align:center">${marker2.title}</div>`;
                                const infoWindow = new BMapGL.InfoWindow(content);
                                this.map.openInfoWindow(infoWindow, pt);
                            }
                        });
                    });
                }
                if (marker.callout) {
                    const offsetX = ((_e = marker.callout) === null || _e === void 0 ? void 0 : _e.anchorX) ? (_f = marker.callout) === null || _f === void 0 ? void 0 : _f.anchorX : 0;
                    const offsetY = ((_g = marker.callout) === null || _g === void 0 ? void 0 : _g.anchorY) ? (_h = marker.callout) === null || _h === void 0 ? void 0 : _h.anchorY : 0;
                    const callout = new BMapGL.InfoWindow(`<div style="
              padding: ${(_j = marker.callout) === null || _j === void 0 ? void 0 : _j.padding}px;
              color:${(_k = marker.callout) === null || _k === void 0 ? void 0 : _k.color};
              text-align:${(_l = marker.callout) === null || _l === void 0 ? void 0 : _l.textAlign};"
              >
             <p style="font-size:${(_m = marker.callout) === null || _m === void 0 ? void 0 : _m.fontSize}px">${((_o = marker.callout) === null || _o === void 0 ? void 0 : _o.content) || ""}</p>
             </div>`, {
                        width: 200,
                        height: 100,
                        offset: new BMapGL.Size(offsetX - 24, offsetY - 20)
                    });
                    markerObj.callout = callout;
                    this.map.addOverlay(markerObj);
                    if (((_p = marker.callout) === null || _p === void 0 ? void 0 : _p.display) === "ALWAYS") {
                        markerObj.callout.disableCloseOnClick();
                        const point = markerObj.getPosition();
                        markerObj.callout.addEventListener("open", function() {
                            var _a2, _b2, _c2, _d2;
                            const infoWindowElement = document.querySelector(".BMap_bubble_pop");
                            if (infoWindowElement) {
                                let triangle = infoWindowElement.querySelector(".triangle");
                                if (!triangle) {
                                    triangle = document.createElement("div");
                                    triangle.className = "triangle";
                                    infoWindowElement.appendChild(triangle);
                                }
                                const img = document.querySelector(".BMap_bubble_pop>img");
                                if (img) {
                                    img.setAttribute("style", `position: absolute;transform: translate(-50%, 0); top: ${point.lat - 100}px; left: ${point.lng - 20}px;display:none`);
                                }
                                const backgroundcolor = (_a2 = marker.callout) === null || _a2 === void 0 ? void 0 : _a2.bgColor;
                                let borderWidth = ((_b2 = marker.callout) === null || _b2 === void 0 ? void 0 : _b2.borderWidth) || 5;
                                const borderColor = (_c2 = marker.callout) === null || _c2 === void 0 ? void 0 : _c2.borderColor;
                                const borderRadius = (_d2 = marker.callout) === null || _d2 === void 0 ? void 0 : _d2.borderRadius;
                                borderWidth = Math.min(borderWidth, 15);
                                triangle.setAttribute("style", `width:0;height:0;borderLeft:${borderWidth}px solid transparent;borderRight:${borderWidth}px solid transparent;borderTop:${borderWidth}px solid ${borderColor};position:absolute;left:83px;bottom:-${2 * borderWidth}px`);
                                infoWindowElement.setAttribute("style", `background-color:${backgroundcolor};top:${point.lat - 120}px; left:${point.lng - 100}px;position: absolute;border: ${borderWidth}px solid ${borderColor};border-radius:${borderRadius}px; `);
                            }
                        });
                        this.map.openInfoWindow(markerObj.callout, pt);
                    } else {
                        const hammer = new import_hammerjs.default(this.mapRef);
                        hammer.on("tap", (e)=>{
                            const touch = e.center;
                            const x = touch.x;
                            const y = touch.y;
                            const threshold = 15;
                            this.markers.forEach((marker2)=>{
                                const mapContainer = document.getElementsByClassName("bmap-container")[0];
                                const mapContainerRect = mapContainer.getBoundingClientRect();
                                const mapOffsetX = mapContainerRect.left;
                                const mapOffsetY = mapContainerRect.top;
                                const point = new BMapGL.Point(marker2.longitude, marker2.latitude);
                                const pixel = this.map.pointToPixel(point);
                                const markerX = pixel.x + mapOffsetX;
                                const markerY = pixel.y + mapOffsetY;
                                const distance = Math.sqrt(Math.pow(x - markerX, 2) + Math.pow(y - markerY, 2));
                                if (distance < threshold && marker2.id === markerObj.id) {
                                    const point2 = markerObj.getPosition();
                                    markerObj.callout.addEventListener("open", function() {
                                        var _a2, _b2, _c2, _d2;
                                        const infoWindowElement = document.querySelector(".BMap_bubble_pop");
                                        if (infoWindowElement) {
                                            let triangle = infoWindowElement.querySelector(".triangle");
                                            if (!triangle) {
                                                triangle = document.createElement("div");
                                                triangle.className = "triangle";
                                                infoWindowElement.appendChild(triangle);
                                            }
                                            const img = document.querySelector(".BMap_bubble_pop>img");
                                            if (img) {
                                                img.setAttribute("style", `position: absolute;transform: translate(-50%, 0); top: ${point2.lat - 100}px; left: ${point2.lng - 20}px;display:none`);
                                            }
                                            const backgroundcolor = (_a2 = marker2.callout) === null || _a2 === void 0 ? void 0 : _a2.bgColor;
                                            let borderWidth = ((_b2 = marker2.callout) === null || _b2 === void 0 ? void 0 : _b2.borderWidth) || 5;
                                            const borderColor = (_c2 = marker2.callout) === null || _c2 === void 0 ? void 0 : _c2.borderColor;
                                            const borderRadius = (_d2 = marker2.callout) === null || _d2 === void 0 ? void 0 : _d2.borderRadius;
                                            borderWidth = Math.min(borderWidth, 15);
                                            triangle.setAttribute("style", `width:0;height:0;border-left:${borderWidth}px solid transparent;border-right:${borderWidth}px solid transparent;border-top:${borderWidth}px solid ${borderColor};position:absolute;left:83px;bottom:-${2 * borderWidth}px`);
                                            infoWindowElement.setAttribute("style", `background-color:${backgroundcolor};top:${point2.lat - 120}px; left:${point2.lng - 100}px;position: absolute;border: ${borderWidth}px solid ${borderColor};border-radius:${borderRadius}px; `);
                                        }
                                    });
                                    this.map.openInfoWindow(markerObj.callout, pt);
                                } else {
                                    markerObj.callout.enableCloseOnClick();
                                }
                            });
                        });
                    }
                }
                if (marker.label) {
                    const labelContent = marker.label.content || "";
                    const labelOpts = {
                        position: pt,
                        offset: new BMapGL.Size(marker.label.anchorX || 0, marker.label.anchorY || 0)
                    };
                    const label = new BMapGL.Label(labelContent, labelOpts);
                    const borderColor = marker.label.borderColor ? marker.label.borderColor : "white";
                    label.setStyle({
                        color: marker.label.color,
                        fontSize: marker.label.fontSize + "px",
                        borderWidth: marker.label.borderWidth + "px",
                        borderColor,
                        borderRadius: marker.label.borderRadius + "px",
                        background: marker.label.bgColor,
                        padding: marker.label.padding + "px"
                    });
                    markerObj.setLabel(label);
                }
                this.map.addOverlay(markerObj);
            } else {
                console.error("\u8BF7\u68C0\u67E5marker\u7ECF\u7EAC\u5EA6\u548Cmarker\u81EA\u5B9A\u4E49\u56FE\u6807\u8DEF\u5F84\u548Cid\u503C");
            }
        });
    }
    loadMapScript() {
        return new Promise((resolve, reject)=>{
            const script = document.createElement("script");
            script.src = "https://api.map.baidu.com/getscript?v=3.0&type=webgl&ak=Mb1FLBD3gfnY6bup4v6zEWh6MXwsZ9eo";
            script.defer = true;
            script.onload = ()=>resolve();
            script.onerror = reject;
            script.type = "text/javascript";
            document.head.appendChild(script);
        });
    }
    LoadBmapLibScript() {
        return _async_to_generator(function*() {
            return new Promise((resolve, reject)=>{
                const bmapLibScript = document.createElement("script");
                bmapLibScript.src = "//mapopen.bj.bcebos.com/github/BMapGLLib/AreaRestriction/src/AreaRestriction.min.js";
                bmapLibScript.defer = true;
                bmapLibScript.type = "text/javascript";
                bmapLibScript.onload = ()=>{
                    resolve();
                };
                bmapLibScript.onerror = reject;
                document.head.appendChild(bmapLibScript);
            });
        })();
    }
    render() {
        return h(Host, null, h("div", {
            id: "mapContainer",
            ref: (dom)=>{
                if (dom) {
                    this.mapRef = dom;
                }
            },
            style: {
                width: this.width,
                height: this.height
            }
        }));
    }
    get el() {
        return this;
    }
    static get style() {
        return mapCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onTap = createEvent(this, "tap", 7);
        this.currentRotation = 0;
        this._getCenterLocation = (option)=>{
            this.map.getOverlays().forEach((overlay)=>{
                if (overlay instanceof BMapGL.Marker && overlay.isCenterMarker) {
                    this.map.removeOverlay(overlay);
                }
            });
            option.iconPath = "https://img0.baidu.com/it/u=2604176863,3349829508&fm=253&fmt=auto&app=138&f=PNG?w=243&h=243";
            const icon = new BMapGL.Icon(option.iconPath, new BMapGL.Size(20, 30));
            const gcj02Point = [
                this.longitude,
                this.latitude
            ];
            const marker = new BMapGL.Marker(new BMapGL.Point(this.longitude, this.latitude), {
                icon
            });
            marker.isCenterMarker = true;
            this.map.addOverlay(marker);
            return gcj02Point;
        };
        this._setLocMarkerIcon = (option)=>{
            const icon = new BMapGL.Icon(option.iconPath, new BMapGL.Size(20, 30));
            const point = new BMapGL.Point(116.404, 39.915);
            const marker = new BMapGL.Marker(point, {
                icon
            });
            this.map.addOverlay(marker);
        };
        this._translateMarker = (option)=>{
            let latitude = option.destination.latitude;
            const longitude = option.destination.longitude;
            if (latitude < -80 && latitude >= -90) {
                latitude = option.destination.latitude + 10;
            }
            const destinationPoint = new BMapGL.Point(longitude, latitude);
            const obj = {
                flagId: true,
                flagCoordinate: true
            };
            const animationEndResult = {
                errMsg: "animationEnd:ok"
            };
            const overlays = this.map.getOverlays();
            const targetMarker = overlays.find((overlay)=>overlay instanceof BMapGL.Marker && overlay.id === option.markerId);
            if (!targetMarker) {
                console.error(`Marker "${option.markerId}" not found.`);
                obj.flagId = false;
                return obj;
            }
            if (latitude > 90 || latitude < -90 || longitude > 180 || longitude < -180 || isNaN(latitude) || isNaN(longitude)) {
                obj.flagCoordinate = false;
                return obj;
            }
            const startLngLat = targetMarker.getPosition();
            const step = {
                lng: (destinationPoint.lng - startLngLat.lng) / (option.duration / 16),
                lat: (destinationPoint.lat - startLngLat.lat) / (option.duration / 16)
            };
            const startRotation = targetMarker.getRotation();
            const targetRotation = option.rotate;
            if (!this.currentRotation) {
                this.currentRotation = targetRotation;
            } else {
                this.currentRotation += targetRotation;
            }
            const rotationStep = (this.currentRotation - startRotation) / (option.duration / 16);
            let currentLngLat = startLngLat;
            let currentRotation = startRotation;
            if (!option.moveWithRotate && option.autoRotate) {
                let currentFrame = 0;
                const animationInterval = setInterval(()=>{
                    currentLngLat = new BMapGL.Point(currentLngLat.lng + step.lng, currentLngLat.lat + step.lat);
                    targetMarker.setPosition(currentLngLat);
                    currentFrame++;
                    if (currentFrame >= option.duration / 16) {
                        clearInterval(animationInterval);
                        let rotationFrame = 0;
                        const rotationInterval = setInterval(()=>{
                            currentRotation += rotationStep;
                            targetMarker.setRotation(currentRotation);
                            rotationFrame++;
                            if (rotationFrame >= option.duration / 16) {
                                clearInterval(rotationInterval);
                                option === null || option === void 0 ? void 0 : option.animationEnd(animationEndResult);
                            }
                        }, 16);
                    }
                }, 16);
            } else if (option.moveWithRotate && option.autoRotate) {
                let currentFrame = 0;
                const animationInterval = setInterval(()=>{
                    currentLngLat = new BMapGL.Point(currentLngLat.lng + step.lng, currentLngLat.lat + step.lat);
                    targetMarker.setPosition(currentLngLat);
                    currentRotation += rotationStep;
                    targetMarker.setRotation(currentRotation);
                    currentFrame++;
                    if (currentFrame >= option.duration / 16) {
                        clearInterval(animationInterval);
                        option === null || option === void 0 ? void 0 : option.animationEnd(animationEndResult);
                    }
                }, 16);
            } else if (option.moveWithRotate && !option.autoRotate) {
                let currentFrame = 0;
                const animationInterval = setInterval(()=>{
                    currentLngLat = new BMapGL.Point(currentLngLat.lng + step.lng, currentLngLat.lat + step.lat);
                    targetMarker.setPosition(currentLngLat);
                    currentFrame++;
                    if (currentFrame >= option.duration / 16) {
                        clearInterval(animationInterval);
                        option === null || option === void 0 ? void 0 : option.animationEnd(animationEndResult);
                    }
                }, 16);
            }
            return obj;
        };
        this._includePoints = (option)=>{
            const bPoints = option.points.map((point)=>new BMapGL.Point(point.longitude, point.latitude));
            const originalZoom = this.map.getZoom();
            const originalCenter = this.map.getCenter();
            const view = this.map.getViewport(bPoints);
            this.map.centerAndZoom(view.center, view.zoom);
            const bounds = this.map.getBounds();
            let flag = true;
            for(let i2 = 0; i2 < bPoints.length; i2++){
                if (!bounds.containsPoint(bPoints[i2])) {
                    this.map.centerAndZoom(originalCenter, originalZoom);
                    flag = false;
                    break;
                }
            }
            return flag;
        };
        this._getRegion = ()=>{
            const bounds = this.map.getBounds();
            const sw = bounds.getSouthWest();
            const ne = bounds.getNorthEast();
            return {
                southwest: {
                    lat: sw.lat,
                    lng: sw.lng
                },
                northeast: {
                    lat: ne.lat,
                    lng: ne.lng
                }
            };
        };
        this._getRotate = ()=>{
            let rotation = this.rotate;
            if (rotation < 0 || rotation > 360) {
                rotation = 0;
            }
            return rotation;
        };
        this._getSkew = ()=>{
            let Skew = this.skew;
            if (Skew < 0 || Skew > 40) {
                Skew = 0;
            }
            return Skew;
        };
        this._getScale = ()=>{
            const Scale = this.scale;
            return Scale;
        };
        this._setCenterOffset = (option)=>{
            const [x, y] = option.offset;
            const mapSize = this.map.getSize();
            const offsetX = Math.max(0.25 * mapSize.width, Math.min(0.75 * mapSize.width, x * mapSize.width));
            const offsetY = Math.max(0.25 * mapSize.height, Math.min(0.75 * mapSize.height, y * mapSize.height));
            const pixel = new BMapGL.Pixel(offsetX, offsetY);
            const center = this.map.pixelToPoint(pixel);
            this.map.panTo(center);
        };
        this._addMarkers = (option)=>{
            if (option.clear) {
                this.map.clearOverlays(this.markers);
            }
            option.markers.forEach((marker)=>{
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
                if (marker.latitude && marker.longitude && marker.iconPath) {
                    const pt = new BMapGL.Point(marker.longitude, marker.latitude);
                    const markerObj = new BMapGL.Marker(pt, {
                        enableClicking: true
                    });
                    this.map.addOverlay(markerObj);
                    markerObj.id = marker.id;
                    markerObj.alpha = marker.alpha;
                    if (marker.zIndex) {
                        markerObj.setZIndex(marker.zIndex);
                    }
                    if (marker.width && marker.height && marker.iconPath) {
                        const icon = new BMapGL.Icon(marker.iconPath, new BMapGL.Size(marker.width, marker.height));
                        markerObj.setIcon(icon);
                    } else if (marker.iconPath) {
                        const img = new Image();
                        img.src = marker.iconPath;
                        img.style.opacity = String(marker.alpha);
                        img.onload = ()=>{
                            const iconSize = new BMapGL.Size(img.width, img.height);
                            const icon = new BMapGL.Icon(img.src, iconSize);
                            icon.imageOffset = new BMapGL.Size(0, 0, marker.alpha || 1);
                            markerObj.setIcon(icon);
                        };
                    } else {
                        console.error("\u6CA1\u6709\u627E\u5230iconPath\u56FE\u7247\u8DEF\u5F84");
                        return;
                    }
                    const rotate = marker.rotate ? marker.rotate : 0;
                    if (rotate) {
                        markerObj.setRotation(rotate);
                    }
                    if (marker.anchor) {
                        const offsetX = ((_b = (_a = marker.anchor) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0) * (marker.width || 0);
                        const offsetY = ((_d = (_c = marker.anchor) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0) * (marker.height || 0);
                        markerObj.setOffset(new BMapGL.Size(offsetX, offsetY));
                    }
                    if (!marker.callout && marker.title) {
                        const hammer = new import_hammerjs.default(this.mapRef);
                        hammer.on("tap", (e)=>{
                            const touch = e.center;
                            const x = touch.x;
                            const y = touch.y;
                            const threshold = 15;
                            option.markers.forEach((marker2)=>{
                                const mapContainer = document.getElementsByClassName("bmap-container")[0];
                                const mapContainerRect = mapContainer.getBoundingClientRect();
                                const mapOffsetX = mapContainerRect.left;
                                const mapOffsetY = mapContainerRect.top;
                                const point = new BMapGL.Point(marker2.longitude, marker2.latitude);
                                const pixel = this.map.pointToPixel(point);
                                const markerX = pixel.x + mapOffsetX;
                                const markerY = pixel.y + mapOffsetY;
                                const distance = Math.sqrt(Math.pow(x - markerX, 2) + Math.pow(y - markerY, 2));
                                if (distance < threshold && marker2.id === markerObj.id) {
                                    const content = `<div style="text-align:center">${marker2.title}</div>`;
                                    const infoWindow = new BMapGL.InfoWindow(content);
                                    this.map.openInfoWindow(infoWindow, pt);
                                }
                            });
                        });
                    }
                    if (marker.callout) {
                        const offsetX = ((_e = marker.callout) === null || _e === void 0 ? void 0 : _e.anchorX) ? (_f = marker.callout) === null || _f === void 0 ? void 0 : _f.anchorX : 0;
                        const offsetY = ((_g = marker.callout) === null || _g === void 0 ? void 0 : _g.anchorY) ? (_h = marker.callout) === null || _h === void 0 ? void 0 : _h.anchorY : 0;
                        const callout = new BMapGL.InfoWindow(`<div style="
              padding: ${(_j = marker.callout) === null || _j === void 0 ? void 0 : _j.padding}px;
              color:${(_k = marker.callout) === null || _k === void 0 ? void 0 : _k.color};
              text-align:${(_l = marker.callout) === null || _l === void 0 ? void 0 : _l.textAlign};"
              >
             <p style="font-size:${(_m = marker.callout) === null || _m === void 0 ? void 0 : _m.fontSize}px">${((_o = marker.callout) === null || _o === void 0 ? void 0 : _o.content) || ""}</p>
             </div>`, {
                            width: 200,
                            height: 100,
                            offset: new BMapGL.Size(offsetX - 24, offsetY - 20)
                        });
                        markerObj.callout = callout;
                        this.map.addOverlay(markerObj);
                        if (((_p = marker.callout) === null || _p === void 0 ? void 0 : _p.display) === "ALWAYS") {
                            markerObj.callout.disableCloseOnClick();
                            const point = markerObj.getPosition();
                            markerObj.callout.addEventListener("open", function() {
                                var _a2, _b2, _c2, _d2;
                                console.log(markerObj.callout);
                                const infoWindowElement = document.querySelector(".BMap_bubble_pop");
                                if (infoWindowElement) {
                                    let triangle = infoWindowElement.querySelector(".triangle");
                                    if (!triangle) {
                                        triangle = document.createElement("div");
                                        triangle.className = "triangle";
                                        infoWindowElement.appendChild(triangle);
                                    }
                                    const img = document.querySelector(".BMap_bubble_pop>img");
                                    if (img) {
                                        img.setAttribute("style", `position: absolute;transform: translate(-50%, 0); top: ${point.lat - 100}px; left: ${point.lng - 20}px;display:none`);
                                    }
                                    const backgroundcolor = (_a2 = marker.callout) === null || _a2 === void 0 ? void 0 : _a2.bgColor;
                                    let borderWidth = ((_b2 = marker.callout) === null || _b2 === void 0 ? void 0 : _b2.borderWidth) || 5;
                                    const borderColor = (_c2 = marker.callout) === null || _c2 === void 0 ? void 0 : _c2.borderColor;
                                    const borderRadius = (_d2 = marker.callout) === null || _d2 === void 0 ? void 0 : _d2.borderRadius;
                                    borderWidth = Math.min(borderWidth, 15);
                                    triangle.setAttribute("style", `width:0;height:0;border-left:${borderWidth}px solid transparent;border-right:${borderWidth}px solid transparent;border-top:${borderWidth}px solid ${borderColor};position:absolute;left:83px;bottom:-${2 * borderWidth}px`);
                                    infoWindowElement.setAttribute("style", `background-color:${backgroundcolor};top:${point.lat - 120}px; left:${point.lng - 100}px;position: absolute;border: ${borderWidth}px solid ${borderColor};border-radius:${borderRadius}px; `);
                                }
                            });
                            this.map.openInfoWindow(markerObj.callout, pt);
                        } else {
                            const hammer = new import_hammerjs.default(this.mapRef);
                            hammer.on("tap", (e)=>{
                                const touch = e.center;
                                const x = touch.x;
                                const y = touch.y;
                                const threshold = 15;
                                option.markers.forEach((marker2)=>{
                                    const mapContainer = document.getElementsByClassName("bmap-container")[0];
                                    const mapContainerRect = mapContainer.getBoundingClientRect();
                                    const mapOffsetX = mapContainerRect.left;
                                    const mapOffsetY = mapContainerRect.top;
                                    const point = new BMapGL.Point(marker2.longitude, marker2.latitude);
                                    const pixel = this.map.pointToPixel(point);
                                    const markerX = pixel.x + mapOffsetX;
                                    const markerY = pixel.y + mapOffsetY;
                                    const distance = Math.sqrt(Math.pow(x - markerX, 2) + Math.pow(y - markerY, 2));
                                    if (distance < threshold && marker2.id === markerObj.id) {
                                        const point2 = markerObj.getPosition();
                                        markerObj.callout.addEventListener("open", function() {
                                            var _a2, _b2, _c2, _d2;
                                            console.log(markerObj.callout);
                                            const infoWindowElement = document.querySelector(".BMap_bubble_pop");
                                            if (infoWindowElement) {
                                                let triangle = infoWindowElement.querySelector(".triangle");
                                                if (!triangle) {
                                                    triangle = document.createElement("div");
                                                    triangle.className = "triangle";
                                                    infoWindowElement.appendChild(triangle);
                                                }
                                                const img = document.querySelector(".BMap_bubble_pop>img");
                                                if (img) {
                                                    img.setAttribute("style", `position: absolute;transform: translate(-50%, 0); top: ${point2.lat - 100}px; left: ${point2.lng - 20}px;display:none`);
                                                }
                                                const backgroundcolor = (_a2 = marker2.callout) === null || _a2 === void 0 ? void 0 : _a2.bgColor;
                                                let borderWidth = ((_b2 = marker2.callout) === null || _b2 === void 0 ? void 0 : _b2.borderWidth) || 5;
                                                const borderColor = (_c2 = marker2.callout) === null || _c2 === void 0 ? void 0 : _c2.borderColor;
                                                const borderRadius = (_d2 = marker2.callout) === null || _d2 === void 0 ? void 0 : _d2.borderRadius;
                                                borderWidth = Math.min(borderWidth, 15);
                                                triangle.setAttribute("style", `width:0;height:0;border-left:${borderWidth}px solid transparent;border-right:${borderWidth}px solid transparent;border-top:${borderWidth}px solid ${borderColor};position:absolute;left:83px;bottom:-${2 * borderWidth}px`);
                                                infoWindowElement.setAttribute("style", `background-color:${backgroundcolor};top:${point2.lat - 120}px; left:${point2.lng - 100}px;position: absolute;border: ${borderWidth}px solid ${borderColor};border-radius:${borderRadius}px; `);
                                            }
                                        });
                                        this.map.openInfoWindow(markerObj.callout, pt);
                                    } else {
                                        markerObj.callout.enableCloseOnClick();
                                    }
                                });
                            });
                        }
                    }
                    if (marker.label) {
                        const labelContent = marker.label.content || "";
                        const labelOpts = {
                            position: pt,
                            offset: new BMapGL.Size(marker.label.anchorX || 0, marker.label.anchorY || 0)
                        };
                        const label = new BMapGL.Label(labelContent, labelOpts);
                        label.setStyle({
                            color: marker.label.color,
                            fontSize: marker.label.fontSize + "px",
                            borderWidth: marker.label.borderWidth + "px",
                            borderColor: marker.label.borderColor,
                            borderRadius: marker.label.borderRadius + "px",
                            background: marker.label.bgColor,
                            padding: marker.label.padding + "px"
                        });
                        markerObj.setLabel(label);
                    }
                }
            });
        };
        this._removeMarkers = (option)=>{
            const overlays = this.map.getOverlays();
            let newTargetMarker = {};
            option.markerIds.forEach((id)=>{
                const targetMarker = overlays.find((overlay)=>overlay instanceof BMapGL.Marker && String(overlay.id) === id);
                newTargetMarker = targetMarker;
                this.map.removeOverlay(targetMarker);
            });
            return newTargetMarker;
        };
        this._moveAlong = (object2)=>{
            const path = object2.path;
            const targetMarkerId = object2.markerId;
            const duration = object2.duration;
            const autoRotate = object2.autoRotate;
            const targetMarker = this.map.getOverlays().find((overlay)=>overlay instanceof BMapGL.Marker && overlay.id === targetMarkerId);
            const points = path.map((p)=>new BMapGL.Point(p.longitude, p.latitude));
            const obj = {
                flagId: true,
                flagCoordinate: true
            };
            if (!targetMarker) {
                console.error(`Marker "${targetMarkerId}" not found.`);
                obj.flagId = false;
                return obj;
            }
            for(let i2 = 0; i2 < points.length; i2++){
                const point = points[i2];
                if (point.lat < -80 && point.lat >= -90) {
                    point.lat += 10;
                }
                if (point.lng < -180 || point.lng > 180 || point.lat < -90 || point.lat > 90 || isNaN(point.lng) || isNaN(point.lat)) {
                    obj.flagCoordinate = false;
                    return obj;
                }
            }
            if (obj.flagId && obj.flagCoordinate) {
                const startTime = performance.now();
                const animate = (timestamp2)=>{
                    const elapsedTime = timestamp2 - startTime;
                    const progress = Math.min(elapsedTime / duration, 1);
                    const currentPoint = this.getPointOnPath(points, progress);
                    targetMarker.setPosition(currentPoint);
                    if (autoRotate && progress < 1) {
                        const nextPoint = this.getPointOnPath(points, Math.min(progress + 0.01, 1));
                        const rotation = this.calculateRotation(currentPoint, nextPoint);
                        targetMarker.setRotation(rotation);
                    }
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        targetMarker.setPosition(points[points.length - 1]);
                        targetMarker.setRotation(0);
                    }
                };
                requestAnimationFrame(animate);
            }
            return obj;
        };
        this.getPointOnPath = (points, progress)=>{
            const totalLength = this.calculateTotalLength(points);
            const targetLength = totalLength * progress;
            let currentLength = 0;
            for(let i2 = 0; i2 < points.length - 1; i2++){
                const segmentLength = this.map.getDistance(points[i2], points[i2 + 1]);
                if (currentLength + segmentLength >= targetLength) {
                    const ratio = (targetLength - currentLength) / segmentLength;
                    const deltaX = points[i2 + 1].lng - points[i2].lng;
                    const deltaY = points[i2 + 1].lat - points[i2].lat;
                    const newLng = points[i2].lng + deltaX * ratio;
                    const newLat = points[i2].lat + deltaY * ratio;
                    return new BMapGL.Point(newLng, newLat);
                }
                currentLength += segmentLength;
            }
            return points[points.length - 1];
        };
        this.calculateTotalLength = (points)=>{
            let totalLength = 0;
            for(let i2 = 0; i2 < points.length - 1; i2++){
                totalLength += this.map.getDistance(points[i2], points[i2 + 1]);
            }
            return totalLength;
        };
        this.calculateRotation = (currentPoint, nextPoint)=>{
            const dx = nextPoint.lng - currentPoint.lng;
            const dy = nextPoint.lat - currentPoint.lat;
            let angle = Math.atan2(dy, dx) * (180 / Math.PI);
            angle = 90 - angle;
            return angle;
        };
        this._addGroundOverlay = (option)=>{
            const { src, opacity, bounds, visible, id, zIndex } = option;
            let flag = true;
            if (bounds.southwest.longitude >= bounds.northeast.longitude || bounds.southwest.latitude >= bounds.northeast.latitude) {
                flag = false;
                return;
            }
            if (bounds.southwest.latitude > 90 || bounds.southwest.latitude < -90 || bounds.southwest.longitude > 180 || bounds.southwest.longitude < -180 || isNaN(bounds.southwest.latitude) || isNaN(bounds.southwest.longitude)) {
                flag = false;
                return;
            }
            if (bounds.northeast.latitude > 90 || bounds.northeast.latitude < -90 || bounds.northeast.longitude > 180 || bounds.northeast.longitude < -180 || isNaN(bounds.northeast.latitude) || isNaN(bounds.northeast.longitude)) {
                flag = false;
                return;
            }
            const overlayBounds = new BMapGL.Bounds(new BMapGL.Point(bounds.southwest.longitude, bounds.southwest.latitude), new BMapGL.Point(bounds.northeast.longitude, bounds.northeast.latitude));
            function GroundOverlay(bounds2, imageUrl, map, visible2, opacity2, zIndex2, id2) {
                this._bounds = bounds2;
                this._imageUrl = imageUrl;
                this._map = map;
                this._visible = visible2;
                this._opacity = opacity2;
                this._zIndex = zIndex2;
                this._id = id2;
            }
            GroundOverlay.prototype = new BMapGL.Overlay();
            GroundOverlay.prototype.initialize = function(map) {
                if (document.getElementById(this._id)) {
                    const element = document.getElementById(this._id);
                    element === null || element === void 0 ? void 0 : element.remove();
                }
                this._map = map;
                if (!this._div) {
                    const div = document.createElement("div");
                    div.id = this._id;
                    div.style.position = "absolute";
                    div.style.border = "none";
                    div.style.zIndex = this._zIndex;
                    const img = document.createElement("img");
                    img.src = this._imageUrl;
                    const validOpacity = this._opacity < 0 ? "1" : this._opacity;
                    img.style.opacity = validOpacity;
                    div.appendChild(img);
                    this._div = div;
                }
                map.addEventListener("zoomend", ()=>{
                    const swPixel = map.pointToOverlayPixel(this._bounds.getSouthWest());
                    const nePixel = map.pointToOverlayPixel(this._bounds.getNorthEast());
                    const width = nePixel.x - swPixel.x;
                    const height = swPixel.y - nePixel.y;
                    this._div.style.width = width + "px";
                    this._div.style.height = height + "px";
                    const img = this._div.querySelector("img");
                    img.style.width = width + "px";
                    img.style.height = height + "px";
                });
                map.getPanes().labelPane.appendChild(this._div);
                return this._div;
            };
            GroundOverlay.prototype.draw = function() {
                const _northeast = {
                    lat: option.bounds.northeast.latitude,
                    lng: option.bounds.southwest.longitude
                };
                const position = this._map.pointToOverlayPixel(_northeast);
                this._div.style.left = position.x + "px";
                this._div.style.top = position.y + "px";
                const bounds2 = this._map.getBounds();
                const sw = this._map.pointToPixel(bounds2.getSouthWest());
                const ne = this._map.pointToPixel(bounds2.getNorthEast());
                const width = ne.x - sw.x;
                const height = ne.y - sw.y;
                const zoom2 = this._map.getZoom();
                const imageWidth = width * Math.pow(2, 18 - zoom2);
                const imageHeight = height * Math.pow(2, 18 - zoom2);
                this._div.style.width = imageWidth + "px";
                this._div.style.height = imageHeight + "px";
                this._div.style.display = this._visible ? "block" : "none";
                const validOpacity = this._opacity < 0 ? "1" : this._opacity;
                this._div.getElementsByTagName("img")[0].style.opacity = validOpacity;
            };
            const overlay = new GroundOverlay(overlayBounds, src, this.map, visible, opacity, zIndex, id);
            this.map.addOverlay(overlay);
            const overlays = this.map.getOverlays().sort((a, b)=>a._zIndex - b._zIndex);
            this.groundOverlay = overlay;
            overlays.forEach((overlay2)=>overlay2.draw());
            const zoom = this.map.getZoom();
            if (zoom < 20) {
                this.map.setZoom(zoom + 1);
                this.map.setZoom(zoom);
            } else {
                this.map.setZoom(zoom - 1);
                this.map.setZoom(zoom);
            }
            return flag;
        };
        this._updateGroundOverlay = (option)=>{
            const { src, opacity, bounds, visible, id, zIndex } = option;
            let obj;
            let flagId = true;
            let flagCoordinate = true;
            let flagObj = {};
            const overlays = this.map.getOverlays();
            const targetOverlay = overlays.find((overlay)=>overlay._id === id);
            if (!targetOverlay) {
                flagId = false;
                flagObj = {
                    flagId,
                    flagCoordinate
                };
                obj = Object.assign({}, flagObj);
                return obj;
            }
            if (bounds.southwest.longitude >= bounds.northeast.longitude || bounds.southwest.latitude >= bounds.northeast.latitude) {
                flagCoordinate = false;
                flagObj = {
                    flagId,
                    flagCoordinate
                };
                obj = Object.assign({}, flagObj);
            }
            if (bounds.southwest.latitude > 90 || bounds.southwest.latitude < -90 || bounds.southwest.longitude > 180 || bounds.southwest.longitude < -180 || isNaN(bounds.southwest.latitude) || isNaN(bounds.southwest.longitude)) {
                flagCoordinate = false;
                flagObj = {
                    flagId,
                    flagCoordinate
                };
                obj = Object.assign({}, flagObj);
            }
            if (bounds.northeast.latitude > 90 || bounds.northeast.latitude < -90 || bounds.northeast.longitude > 180 || bounds.northeast.longitude < -180 || isNaN(bounds.northeast.latitude) || isNaN(bounds.northeast.longitude)) {
                flagCoordinate = false;
                flagObj = {
                    flagId,
                    flagCoordinate
                };
                obj = Object.assign({}, flagObj);
            }
            if (flagId && flagCoordinate) {
                const targetBounds = new BMapGL.Bounds(new BMapGL.Point(bounds.southwest.longitude, bounds.southwest.latitude), new BMapGL.Point(bounds.northeast.longitude, bounds.northeast.latitude));
                const zoom = this.map.getZoom();
                if (targetOverlay) {
                    const element = document.getElementById(id);
                    if (element) {
                        const imgElement = element.querySelector("img");
                        if (imgElement) {
                            const validOpacity = opacity < 0 ? "1" : opacity;
                            element.style.opacity = validOpacity;
                            imgElement.style.display = visible ? "block" : "none";
                            element.style.zIndex = zIndex;
                            const image = new Image();
                            image.onload = ()=>{
                                imgElement.src = src;
                                const lngSpan = targetBounds.getNorthEast().lng - targetBounds.getSouthWest().lng;
                                const mapWidth = this.map.getSize().width;
                                const updatedImageWidth = mapWidth / Math.pow(2, 18 - zoom) * lngSpan;
                                const imageAspectRatio = image.naturalHeight / image.naturalWidth;
                                const updatedImageHeight = updatedImageWidth * imageAspectRatio;
                                imgElement.style.width = `${updatedImageWidth}px`;
                                imgElement.style.height = `${updatedImageHeight}px`;
                                targetOverlay._bounds = targetBounds;
                                targetOverlay.draw();
                                this.map.panTo(this.map.getCenter());
                                targetOverlay.draw();
                            };
                            image.src = src;
                        }
                    }
                } else {
                    console.error(`\u672A\u627E\u5230id\u4E3A${id}\u7684\u5143\u7D20`);
                }
                flagObj = {
                    flagId,
                    flagCoordinate
                };
                obj = Object.assign({}, flagObj);
                return obj;
            } else {
                return obj;
            }
        };
        this._removeGroundOverlay = (option)=>{
            const overlays = this.map.getOverlays();
            let newTargetOverlay = "";
            const targetOverlay = overlays.find((overlay)=>overlay._id === option.id);
            newTargetOverlay = targetOverlay;
            if (targetOverlay) {
                this.map.removeOverlay(targetOverlay);
            }
            return newTargetOverlay;
        };
        this._setBoundary = (option)=>{
            let nth = option.northeast.latitude;
            let sth = option.southwest.latitude;
            let flag = true;
            if (option.northeast.latitude <= -80 && option.northeast.latitude >= -90) {
                nth = option.northeast.latitude + 10;
            }
            if (option.southwest.latitude <= -80 && option.southwest.latitude >= -90) {
                sth = option.southwest.latitude + 10;
            }
            if (option.northeast.latitude < -90 || option.northeast.latitude > 90 || option.northeast.longitude < -180 || option.northeast.longitude > 180 || isNaN(option.northeast.latitude) || isNaN(option.northeast.longitude) || option.northeast.longitude < option.southwest.longitude || option.northeast.latitude < option.southwest.latitude) {
                flag = false;
                return;
            }
            if (option.southwest.latitude < -90 || option.southwest.latitude > 90 || option.southwest.longitude < -180 || option.southwest.longitude > 180 || isNaN(option.southwest.latitude) || isNaN(option.southwest.longitude)) {
                flag = false;
                return;
            }
            const ne = new BMapGL.Point(option.northeast.longitude, nth);
            const sw = new BMapGL.Point(option.southwest.longitude, sth);
            const bounds = new BMapGL.Bounds(sw, ne);
            const viewport = this.map.getViewport([
                ne,
                sw
            ]);
            this.map.centerAndZoom(new BMapGL.Point(viewport.center.lng, viewport.center.lat), viewport.zoom + 2);
            this.map.addOverlay(new BMapGL.Polygon([
                new BMapGL.Point(bounds.sw.lng, bounds.sw.lat),
                new BMapGL.Point(bounds.sw.lng, bounds.ne.lat),
                new BMapGL.Point(bounds.ne.lng, bounds.ne.lat),
                new BMapGL.Point(bounds.ne.lng, bounds.sw.lat)
            ], {
                fillOpacity: 0
            }));
            BMapGLLib.AreaRestriction.setBounds(this.map, bounds);
            return flag;
        };
        this.latitude = void 0;
        this.longitude = void 0;
        this.scale = void 0;
        this.minScale = void 0;
        this.maxScale = void 0;
        this.markers = void 0;
        this.polyline = void 0;
        this.circles = void 0;
        this.polygons = void 0;
        this.subkey = void 0;
        this.layerStyle = void 0;
        this.rotate = void 0;
        this.skew = void 0;
        this.showCompass = void 0;
        this.showScale = void 0;
        this.enableOverlooking = void 0;
        this.enableZoom = void 0;
        this.enableScroll = void 0;
        this.enableRotate = void 0;
        this.enableSatellite = void 0;
        this.enableTraffic = void 0;
        this.enableBuilding = void 0;
        this.enableAutoMaxOverlooking = void 0;
        this.enable3D = void 0;
        this.width = "100%";
        this.height = "100%";
    }
}, [
    0,
    "taro-map-core",
    {
        "latitude": [
            2
        ],
        "longitude": [
            2
        ],
        "scale": [
            2
        ],
        "minScale": [
            2,
            "min-scale"
        ],
        "maxScale": [
            2,
            "max-scale"
        ],
        "markers": [
            16
        ],
        "polyline": [
            16
        ],
        "circles": [
            16
        ],
        "polygons": [
            16
        ],
        "subkey": [
            1
        ],
        "layerStyle": [
            2,
            "layer-style"
        ],
        "rotate": [
            2
        ],
        "skew": [
            2
        ],
        "showCompass": [
            4,
            "show-compass"
        ],
        "showScale": [
            4,
            "show-scale"
        ],
        "enableOverlooking": [
            4,
            "enable-overlooking"
        ],
        "enableZoom": [
            4,
            "enable-zoom"
        ],
        "enableScroll": [
            4,
            "enable-scroll"
        ],
        "enableRotate": [
            4,
            "enable-rotate"
        ],
        "enableSatellite": [
            4,
            "enable-satellite"
        ],
        "enableTraffic": [
            4,
            "enable-traffic"
        ],
        "enableBuilding": [
            4,
            "enable-building"
        ],
        "enableAutoMaxOverlooking": [
            4,
            "enable-auto-max-overlooking"
        ],
        "enable3D": [
            4,
            "enable-3-d"
        ],
        "width": [
            1
        ],
        "height": [
            1
        ]
    }
]);
function defineCustomElement$146() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-map-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-map-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Map3);
                }
                break;
        }
    });
}
var defineCustomElement48 = defineCustomElement$146;
// node_modules/@tarojs/components/dist/components/taro-match-media-core.js
var MatchMedia = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("MatchMedia", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-match-media-core"
]);
function defineCustomElement$147() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-match-media-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-match-media-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MatchMedia);
                }
                break;
        }
    });
}
var defineCustomElement49 = defineCustomElement$147;
// node_modules/@tarojs/components/dist/components/index3.js
function throttle2(fn, threshold = 250, scope) {
    let lastTime = 0;
    let deferTimer;
    return function(...args) {
        const context = scope || this;
        const now3 = Date.now();
        if (now3 - lastTime > threshold) {
            fn.apply(this, args);
            lastTime = now3;
        } else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(()=>{
                lastTime = now3;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
function debounce2(fn, ms = 250, scope) {
    let timer2;
    return function(...args) {
        const context = scope || this;
        clearTimeout(timer2);
        timer2 = setTimeout(function() {
            fn.apply(context, args);
        }, ms);
    };
}
function isVisible(e) {
    return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
}
function isElement(e) {
    return typeof HTMLElement === "object" ? e instanceof HTMLElement : e && typeof e === "object" && e !== null && e.nodeType === 1 && typeof e.nodeName === "string";
}
// node_modules/@tarojs/components/dist/components/taro-movable-area-core.js
var areaCss = "taro-movable-area-core{width:10px;height:10px;display:block;position:relative}";
var MovableArea = proxyCustomElement(class extends H {
    connectedCallback() {
        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                var _a, _b;
                if (mutation.attributeName === "class" || mutation.attributeName === "style") {
                    const offsetWidth = this.element.offsetWidth;
                    const offsetHeight = this.element.offsetHeight;
                    if (offsetWidth !== ((_a = this.offset) === null || _a === void 0 ? void 0 : _a.width) || offsetHeight !== ((_b = this.offset) === null || _b === void 0 ? void 0 : _b.height)) {
                        this.updateArea();
                    }
                    this.offset = {
                        width: offsetWidth,
                        height: offsetHeight
                    };
                }
            });
        });
        this.observer.observe(this.element, {
            attributes: true
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    componentDidLoad() {
        this.viewsChanged();
    }
    render() {
        return h(Host, {
            onTouchStart: this.handleTouchStart,
            onTouchMove: this.handleTouchMove,
            onTouchEnd: this.handleTouchEnd
        });
    }
    get element() {
        return this;
    }
    static get style() {
        return areaCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.views = [];
        this.scaleLength = 0;
        this.viewsChanged = ()=>{
            this.views = [];
            const elements = this.element.querySelectorAll("taro-movable-view-core");
            Array.from(elements).forEach((element)=>{
                this.views.push(element);
            });
            this.updateArea();
        };
        this.handleTouchStart = (e)=>{
            const touches = e.touches;
            if (!touches || touches.length <= 1) {
                return;
            }
            const gap = {
                width: touches[1].pageX - touches[0].pageX,
                height: touches[1].pageY - touches[0].pageY
            };
            this.scaleLength = Math.sqrt(gap.width * gap.width + gap.height * gap.height);
            if (this.scaleArea) {
                return;
            }
            const find = (target, views)=>{
                const loop2 = (e2, t)=>{
                    if (!(e2 = e2.parentNode)) {
                        return false;
                    }
                    return (!isElement(e2) || e2 !== document.body) && (e2 === t || e2 === t.element || e2.element === t || loop2(e2, t));
                };
                for(let i2 = 0; i2 < views.length; i2++){
                    const view = views[i2];
                    if (target === view["element"] || loop2(target, view)) {
                        return view;
                    }
                }
            };
            const touch1 = find(touches[0].target, this.views);
            const touch2 = find(touches[1].target, this.views);
            this.scaleTarget = touch1 && touch1 === touch2 ? touch1 : void 0;
        };
        this.handleTouchMove = (e)=>{
            const touches = e.touches;
            if (!touches || touches.length <= 1) {
                return;
            }
            e.preventDefault();
            const gap = {
                width: touches[1].pageX - touches[0].pageX,
                height: touches[1].pageY - touches[0].pageY
            };
            if (this.scaleLength > 0) {
                this.updateScale(Math.sqrt(gap.width * gap.width + gap.height * gap.height) / this.scaleLength);
            }
        };
        this.handleTouchEnd = (e)=>{
            var _a, _b;
            if (e.touches && e.touches.length || !e.changedTouches) {
                return;
            }
            this.scaleLength = 0;
            if (this.scaleArea) {
                this.views.forEach((element)=>{
                    var _a2;
                    (_a2 = element["endScale"]) === null || _a2 === void 0 ? void 0 : _a2.call(element);
                });
            } else {
                (_b = (_a = this.scaleTarget) === null || _a === void 0 ? void 0 : _a["endScale"]) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
            this.scaleTarget = void 0;
        };
        this.updateScale = (scale)=>{
            var _a, _b;
            if (!scale || scale === 1) {
                return;
            }
            if (this.scaleArea) {
                this.views.forEach((element)=>{
                    var _a2;
                    (_a2 = element["setScale"]) === null || _a2 === void 0 ? void 0 : _a2.call(element, scale);
                });
            } else {
                (_b = (_a = this.scaleTarget) === null || _a === void 0 ? void 0 : _a["setScale"]) === null || _b === void 0 ? void 0 : _b.call(_a, scale);
            }
        };
        this.updateArea = ()=>{
            const computedStyle = window.getComputedStyle(this.element);
            const clientRect = this.element.getBoundingClientRect();
            const horizontal = [
                "Left",
                "Right"
            ].map((e)=>{
                return parseFloat(computedStyle["border" + e + "Width"]) + parseFloat(computedStyle["padding" + e]);
            });
            const vertical = [
                "Top",
                "Bottom"
            ].map((e)=>{
                return parseFloat(computedStyle["border" + e + "Width"]) + parseFloat(computedStyle["padding" + e]);
            });
            this.views.forEach((element)=>{
                var _a;
                (_a = element["setParent"]) === null || _a === void 0 ? void 0 : _a.call(element, {
                    element: this.element,
                    area: {
                        height: clientRect.height - vertical[0] - vertical[1],
                        width: clientRect.width - horizontal[0] - horizontal[1]
                    }
                });
            });
        };
        this.scaleArea = void 0;
    }
}, [
    0,
    "taro-movable-area-core",
    {
        "scaleArea": [
            4,
            "scale-area"
        ]
    }
]);
function defineCustomElement$148() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-movable-area-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-movable-area-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MovableArea);
                }
                break;
        }
    });
}
var defineCustomElement50 = defineCustomElement$148;
// node_modules/@tarojs/components/dist/components/taro-movable-view-core.js
var viewCss = "taro-movable-view-core{width:10px;height:10px;display:inline-block;position:absolute;top:0;left:0}";
var MovableView = proxyCustomElement(class extends H {
    watchX(newValue) {
        this.setTransform(parseFloat(`${newValue || 0}`), this.translateY);
    }
    watchY(newValue) {
        this.setTransform(this.translateX, parseFloat(`${newValue || 0}`));
    }
    watchScaleMinOrMax() {
        if (!this.scale) return false;
        this.updateScale(this.currentScale, true);
        this.setOriginScale(this.currentScale);
    }
    watchScaleValue(scale) {
        if (!this.scale) {
            return false;
        }
        this.updateScale(scale, true);
        this.setOriginScale(scale);
        return scale;
    }
    /**
   * 
   */ setParent({ element, area }) {
        var _this = this;
        return _async_to_generator(function*() {
            const scale = _this.scale ? _this.scaleValue : 1;
            _this.area = area;
            _this.parent = element;
            _this.updateOffset();
            _this.updateScaleOffset(scale);
            _this.updateBoundary();
            _this.setTransform(Number(_this.x) + _this.scaleOffset.x, Number(_this.y) + _this.scaleOffset.y, scale, "", true);
            _this.setOriginScale(scale);
        })();
    }
    /**
   * 
   */ endScale() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.scaling = false;
            _this.setOriginScale(_this.currentScale);
        })();
    }
    /**
   * 
   */ setScale(scale) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this.scale) {
                return;
            }
            _this.scaling = true;
            _this.updateScale(scale * _this.originScale);
        })();
    }
    connectedCallback() {
        this.observer = new MutationObserver((mutations)=>{
            mutations.forEach((mutation)=>{
                const name = mutation.attributeName;
                if (name && [
                    "class",
                    "style"
                ].includes(name)) {
                    const oldValue = mutation.oldValue;
                    const newValue = mutation.target.getAttribute(name);
                    if (oldValue === newValue) {
                        return;
                    }
                    const filter2 = (input)=>{
                        return input === null || input === void 0 ? void 0 : input.split(";").filter((item)=>{
                            return ![
                                "transform",
                                "will-change"
                            ].find((key)=>{
                                return item.trim().startsWith(key);
                            });
                        }).join(";");
                    };
                    if (name === "style" && filter2(newValue) === filter2(oldValue)) {
                        return;
                    }
                    this.updateOffset();
                    this.updateScaleOffset();
                    this.updateBoundary();
                    this.setTransform(this.translateX, this.translateY);
                }
            });
        });
        this.observer.observe(this.element, {
            attributes: true,
            attributeOldValue: true
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    componentDidLoad() {
        this.element.style.transformOrigin = "center";
        this.xMove = [
            "horizontal",
            "all"
        ].includes(this.direction);
        this.yMove = [
            "vertical",
            "all"
        ].includes(this.direction);
        if (this.friction <= 0) {
            this.friction = 2;
        }
        if (this.x || this.y) {
            const x = parseFloat(`${this.x || 0}`);
            const y = parseFloat(`${this.y || 0}`);
            this.setTransform(x, y);
        }
    }
    render() {
        return h(Host, {
            onTouchStart: this.handleTouchStart,
            onTouchMove: this.handleTouchMove,
            onTouchEnd: this.handleTouchEnd
        });
    }
    get element() {
        return this;
    }
    static get watchers() {
        return {
            "x": [
                "watchX"
            ],
            "y": [
                "watchY"
            ],
            "scaleMin": [
                "watchScaleMinOrMax"
            ],
            "scaleMax": [
                "watchScaleMinOrMax"
            ],
            "scaleValue": [
                "watchScaleValue"
            ]
        };
    }
    static get style() {
        return viewCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onScale = createEvent(this, "scale", 7);
        this.onHTouchMove = createEvent(this, "htouchmove", 7);
        this.onVTouchMove = createEvent(this, "vtouchmove", 7);
        this.translateX = 0;
        this.translateY = 0;
        this.origin = {
            x: 0,
            y: 0
        };
        this.area = {
            width: 0,
            height: 0
        };
        this.originScale = 1;
        this.currentScale = 1;
        this.width = 0;
        this.height = 0;
        this.minX = 0;
        this.minY = 0;
        this.maxX = 0;
        this.maxY = 0;
        this.baseX = 0;
        this.baseY = 0;
        this.offset = {
            x: 0,
            y: 0
        };
        this.scaleOffset = {
            x: 0,
            y: 0
        };
        this.getLimitXY = (x, y)=>{
            let outOfBounds = false;
            x > this.maxX ? (x = this.maxX, outOfBounds = true) : x < this.minX && (x = this.minX, outOfBounds = true);
            y > this.maxY ? (y = this.maxY, outOfBounds = true) : y < this.minY && (y = this.minY, outOfBounds = true);
            return {
                x,
                y,
                outOfBounds
            };
        };
        this.animationTo = (x, y, scale, source, noEmitChange, emitScale, callback)=>{
            if (this.animation) {
                this.setTransform(x, y, scale, source, noEmitChange, emitScale);
                callback === null || callback === void 0 ? void 0 : callback();
            } else {
                this.setTransform(x, y, scale, source, noEmitChange, emitScale);
            }
        };
        this.setTransform = (x, y, scale, source, noEmitChange, emitScale)=>{
            x = Number(x.toFixed(1));
            y = Number(y.toFixed(1));
            scale = Number((scale !== null && scale !== void 0 ? scale : this.currentScale).toFixed(3));
            if (!this.outOfBounds) {
                const limit = this.getLimitXY(x, y);
                x = limit.x;
                y = limit.y;
            }
            const subtract = (e, t)=>{
                return +((1e3 * e - 1e3 * t) / 1e3).toFixed(1);
            };
            const realX = subtract(x, this.scaleOffset.x);
            const realY = subtract(y, this.scaleOffset.y);
            if (this.translateX !== x || this.translateY !== y) {
                !noEmitChange && this.onChange.emit({
                    x: realX,
                    y: realY,
                    source
                });
            }
            if (scale !== this.currentScale) {
                emitScale && this.onScale.emit({
                    scale,
                    x: realX,
                    y: realY
                });
            }
            const transform = `translateX(${x}px) translateY(${y}px) translateZ(0px) scale(${scale})`;
            this.element.style.transform = transform;
            this.element.style.webkitTransform = transform;
            this.translateX = x;
            this.translateY = y;
            this.currentScale = scale;
        };
        this.updateOffset = ()=>{
            const offset = (element, parent)=>{
                if (element === parent || !element.offsetParent) {
                    return {
                        left: 0,
                        top: 0
                    };
                }
                const current2 = offset(element.offsetParent, parent);
                return {
                    left: element.offsetLeft + current2.left,
                    top: element.offsetTop + current2.top
                };
            };
            if (!this.parent) {
                return;
            }
            const current = offset(this.element, this.parent);
            this.offset.x = current.left;
            this.offset.y = current.top;
        };
        this.updateScaleOffset = (scale = this.currentScale)=>{
            const rect = this.element.getBoundingClientRect();
            this.height = rect.height / this.currentScale;
            this.width = rect.width / this.currentScale;
            this.scaleOffset.x = (this.width * scale - this.width) / 2;
            this.scaleOffset.y = (this.height * scale - this.height) / 2;
        };
        this.updateBoundary = ()=>{
            const x1 = 0 - this.offset.x + this.scaleOffset.x;
            const x2 = this.area.width - this.width - this.offset.x - this.scaleOffset.x;
            this.minX = Math.min(x1, x2);
            this.maxX = Math.max(x1, x2);
            const y1 = 0 - this.offset.y + this.scaleOffset.y;
            const y2 = this.area.height - this.height - this.offset.y - this.scaleOffset.y;
            this.minY = Math.min(y1, y2);
            this.maxY = Math.max(y1, y2);
        };
        this.updateScale = (scale, animation, animationCallback)=>{
            if (!this.scale) {
                return;
            }
            const target = this.adjustScale(scale);
            this.updateScaleOffset(target);
            this.updateBoundary();
            const { x, y } = this.getLimitXY(this.translateX, this.translateY);
            if (animation) {
                this.animationTo(x, y, target, "", true, true, animationCallback);
            } else if (!this.updating) {
                this.updating = true;
                requestAnimationFrame(()=>{
                    this.setTransform(x, y, target, "", true, true);
                    this.updating = false;
                });
            }
        };
        this.setOriginScale = (scale)=>{
            this.originScale = scale;
        };
        this.adjustScale = (scale)=>{
            return Math.min(10, this.scaleMax, Math.max(0.5, this.scaleMin, scale));
        };
        this.handleTouchStart = (e)=>{
            const touches = e.touches;
            if (this.disabled || touches.length > 1 || !this.element) {
                return;
            }
            const touch = touches[0];
            this.touching = true;
            this.firstMoveFireEvent = false;
            this.origin.x = touch.screenX;
            this.origin.y = touch.screenY;
            this.baseX = this.translateX;
            this.baseY = this.translateY;
            this.element.style.willChange = "transform";
        };
        this.handleTouchMove = (e)=>{
            const touches = e.touches;
            if (this.disabled || !this.element || this.scaling || !this.touching || touches.length > 1) {
                return;
            }
            if (this.direction !== "horizontal") {
                e.preventDefault();
            }
            const touch = touches[0];
            const x = touch.screenX - this.origin.x;
            const y = touch.screenY - this.origin.y;
            this.setTransform(this.xMove ? x + this.baseX : 0, this.yMove ? y + this.baseY : 0);
            if (!this.firstMoveFireEvent) {
                this.firstMoveFireEvent = true;
                const onTouchMove2 = Math.abs(x) > Math.abs(y) ? this.onHTouchMove : this.onVTouchMove;
                onTouchMove2.emit({
                    originalEvent: e,
                    bubbles: false,
                    capturePhase: false,
                    composed: true,
                    extraFields: {
                        touches: e.touches || {},
                        changedTouches: e.changedTouches || {}
                    }
                });
            }
        };
        this.handleTouchEnd = (e)=>{
            const touch = e.changedTouches[0];
            if (this.disabled || !this.touching || !touch) {
                return;
            }
            this.touching = false;
            const x = touch.screenX - this.origin.x;
            const y = touch.screenY - this.origin.y;
            this.setTransform(this.xMove ? x + this.baseX : 0, this.yMove ? y + this.baseY : 0);
        };
        this.x = 0;
        this.y = 0;
        this.direction = "none";
        this.outOfBounds = false;
        this.inertia = false;
        this.friction = 2;
        this.damping = 20;
        this.disabled = false;
        this.scale = false;
        this.scaleMin = 0.5;
        this.scaleMax = 10;
        this.scaleValue = 1;
        this.animation = true;
    }
}, [
    0,
    "taro-movable-view-core",
    {
        "x": [
            8
        ],
        "y": [
            8
        ],
        "direction": [
            1
        ],
        "outOfBounds": [
            4,
            "out-of-bounds"
        ],
        "inertia": [
            4
        ],
        "friction": [
            2
        ],
        "damping": [
            2
        ],
        "disabled": [
            4
        ],
        "scale": [
            4
        ],
        "scaleMin": [
            2,
            "scale-min"
        ],
        "scaleMax": [
            2,
            "scale-max"
        ],
        "scaleValue": [
            2,
            "scale-value"
        ],
        "animation": [
            4
        ],
        "setParent": [
            64
        ],
        "endScale": [
            64
        ],
        "setScale": [
            64
        ]
    }
]);
function defineCustomElement$149() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-movable-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-movable-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, MovableView);
                }
                break;
        }
    });
}
var defineCustomElement51 = defineCustomElement$149;
// node_modules/@tarojs/components/dist/components/taro-native-slot-core.js
var NativeSlot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NativeSlot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-native-slot-core"
]);
function defineCustomElement$150() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-native-slot-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-native-slot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NativeSlot);
                }
                break;
        }
    });
}
var defineCustomElement52 = defineCustomElement$150;
// node_modules/@tarojs/components/dist/components/taro-navigation-bar-core.js
var NavigationBar = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NavigationBar", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-navigation-bar-core"
]);
function defineCustomElement$151() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-navigation-bar-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-navigation-bar-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NavigationBar);
                }
                break;
        }
    });
}
var defineCustomElement53 = defineCustomElement$151;
// node_modules/@tarojs/components/dist/components/taro-navigator-core.js
var indexCss9 = ".navigator-hover{background:#efefef}";
var Navigator = proxyCustomElement(class extends H {
    onClick() {
        const { openType, onSuccess, onFail, onComplete } = this;
        let promise = Promise.resolve();
        switch(openType){
            case "navigate":
                promise = taro.navigateTo({
                    url: this.url
                });
                break;
            case "redirect":
                promise = taro.redirectTo({
                    url: this.url
                });
                break;
            case "switchTab":
                promise = taro.switchTab({
                    url: this.url
                });
                break;
            case "reLaunch":
                promise = taro.reLaunch({
                    url: this.url
                });
                break;
            case "navigateBack":
                promise = taro.navigateBack({
                    delta: this.delta
                });
                break;
            case "exit":
                promise = Promise.reject(new Error('navigator:fail \u6682\u4E0D\u652F\u6301"openType: exit"'));
                break;
        }
        if (promise) {
            promise.then((res)=>{
                onSuccess.emit(res);
            }).catch((res)=>{
                onFail.emit(res);
            }).finally(()=>{
                onComplete.emit();
            });
        }
    }
    render() {
        const { isHover, hoverClass } = this;
        return h(Host, {
            class: classnames({
                [hoverClass]: isHover
            })
        });
    }
    static get style() {
        return indexCss9;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onSuccess = createEvent(this, "cuccess", 7);
        this.onFail = createEvent(this, "fail", 7);
        this.onComplete = createEvent(this, "complete", 7);
        this.hoverClass = void 0;
        this.url = void 0;
        this.openType = "navigate";
        this.isHover = false;
        this.delta = 0;
    }
}, [
    0,
    "taro-navigator-core",
    {
        "hoverClass": [
            1,
            "hover-class"
        ],
        "url": [
            1
        ],
        "openType": [
            1,
            "open-type"
        ],
        "isHover": [
            4,
            "is-hover"
        ],
        "delta": [
            2
        ]
    },
    [
        [
            0,
            "click",
            "onClick"
        ]
    ]
]);
function defineCustomElement$152() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-navigator-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-navigator-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Navigator);
                }
                break;
        }
    });
}
var defineCustomElement54 = defineCustomElement$152;
// node_modules/@tarojs/components/dist/components/taro-nested-scroll-body-core.js
var NestedScrollBody = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NestedScrollBody", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-nested-scroll-body-core"
]);
function defineCustomElement$153() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-nested-scroll-body-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-nested-scroll-body-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NestedScrollBody);
                }
                break;
        }
    });
}
var defineCustomElement55 = defineCustomElement$153;
// node_modules/@tarojs/components/dist/components/taro-nested-scroll-header-core.js
var NestedScrollHeader = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("NestedScrollHeader", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-nested-scroll-header-core"
]);
function defineCustomElement$154() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-nested-scroll-header-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-nested-scroll-header-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, NestedScrollHeader);
                }
                break;
        }
    });
}
var defineCustomElement56 = defineCustomElement$154;
// node_modules/@tarojs/components/dist/components/taro-official-account-core.js
var OfficialAccount = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("OfficialAccount", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-official-account-core"
]);
function defineCustomElement$155() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-official-account-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-official-account-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, OfficialAccount);
                }
                break;
        }
    });
}
var defineCustomElement57 = defineCustomElement$155;
// node_modules/@tarojs/components/dist/components/taro-open-container-core.js
var OpenContainer = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("OpenContainer", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-open-container-core"
]);
function defineCustomElement$156() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-open-container-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-open-container-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, OpenContainer);
                }
                break;
        }
    });
}
var defineCustomElement58 = defineCustomElement$156;
// node_modules/@tarojs/components/dist/components/taro-open-data-core.js
var OpenData = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("OpenData", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-open-data-core"
]);
function defineCustomElement$157() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-open-data-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-open-data-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, OpenData);
                }
                break;
        }
    });
}
var defineCustomElement59 = defineCustomElement$157;
// node_modules/@tarojs/components/dist/components/taro-page-container-core.js
var PageContainer = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("PageContainer", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-page-container-core"
]);
function defineCustomElement$158() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-page-container-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-page-container-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PageContainer);
                }
                break;
        }
    });
}
var defineCustomElement60 = defineCustomElement$158;
// node_modules/@tarojs/components/dist/components/taro-page-meta-core.js
var PageMeta = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("PageMeta", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-page-meta-core"
]);
function defineCustomElement$159() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-page-meta-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-page-meta-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PageMeta);
                }
                break;
        }
    });
}
var defineCustomElement61 = defineCustomElement$159;
// node_modules/@tarojs/components/dist/components/taro-pan-gesture-handler-core.js
var PanGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("PanGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-pan-gesture-handler-core"
]);
function defineCustomElement$160() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-pan-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-pan-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PanGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement62 = defineCustomElement$160;
// node_modules/@tarojs/components/dist/components/picker-group.js
var TOP = 102;
var LINE_HEIGHT = 34;
var MASK_HEIGHT = LINE_HEIGHT * 7;
var TaroPickerGroup = proxyCustomElement(class extends H {
    getPosition() {
        const transition2 = this.touchEnd ? 0.3 : 0;
        const transformValue = `translate3d(0, ${this.height}px, 0)`;
        const transitionValue = `transform ${transition2}s`;
        return {
            transform: transformValue,
            "-webkit-transform": transformValue,
            transition: transitionValue,
            "-webkit-transition": transitionValue
        };
    }
    formulaUnlimitedScroll(range, absoluteHeight, direction) {
        const { height, updateHeight, columnId } = this;
        const factor = direction === "up" ? 1 : -1;
        this.touchEnd = false;
        updateHeight(-range * factor * LINE_HEIGHT + height, columnId);
        requestAnimationFrame(()=>{
            this.touchEnd = true;
            const index = Math.round(absoluteHeight / -LINE_HEIGHT) + range * factor;
            const relativeHeight = TOP - LINE_HEIGHT * index;
            updateHeight(relativeHeight, columnId, true);
        });
    }
    handleMoveStart(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            _this.startY = clientY;
            _this.preY = clientY;
            _this.hadMove = false;
        })();
    }
    handleMoving(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            const y = clientY;
            const deltaY = y - _this.preY;
            _this.preY = y;
            _this.touchEnd = false;
            if (Math.abs(y - _this.startY) > 10) _this.hadMove = true;
            let newPos = _this.height + deltaY;
            if (_this.mode === "time") {
                if (_this.columnId === "0") {
                    if (newPos > TOP - LINE_HEIGHT * 3) {
                        newPos = TOP - LINE_HEIGHT * 27 + deltaY;
                    }
                    if (newPos < TOP - LINE_HEIGHT * 28) {
                        newPos = TOP - LINE_HEIGHT * 4 + deltaY;
                    }
                } else if (_this.columnId === "1") {
                    if (newPos > TOP - LINE_HEIGHT * 3) {
                        newPos = TOP - LINE_HEIGHT * 63 + deltaY;
                    }
                    if (newPos < TOP - LINE_HEIGHT * 64) {
                        newPos = TOP - LINE_HEIGHT * 4 + deltaY;
                    }
                }
            }
            _this.updateHeight(newPos, _this.columnId);
        })();
    }
    handleMoveEnd(clientY) {
        var _this = this;
        return _async_to_generator(function*() {
            const { mode, range, height, updateHeight, columnId } = _this;
            const max = 0;
            const min = -LINE_HEIGHT * (range.length - 1);
            const endY = clientY;
            _this.touchEnd = true;
            let absoluteHeight;
            if (!_this.hadMove) {
                const windowHeight = window.innerHeight;
                const relativeY = windowHeight - MASK_HEIGHT / 2;
                absoluteHeight = height - TOP - (endY - relativeY);
                if (mode === "time") {
                    if (columnId === "0") {
                        if (absoluteHeight > -LINE_HEIGHT * 2.5) {
                            return _this.formulaUnlimitedScroll(24, absoluteHeight, "up");
                        }
                        if (absoluteHeight < -LINE_HEIGHT * 28.5) {
                            return _this.formulaUnlimitedScroll(24, absoluteHeight, "down");
                        }
                    } else if (columnId === "1") {
                        if (absoluteHeight > -LINE_HEIGHT * 2.5) {
                            return _this.formulaUnlimitedScroll(60, absoluteHeight, "up");
                        }
                        if (absoluteHeight < -LINE_HEIGHT * 64.5) {
                            return _this.formulaUnlimitedScroll(60, absoluteHeight, "down");
                        }
                    }
                }
            } else {
                absoluteHeight = height - TOP;
            }
            if (absoluteHeight > max) absoluteHeight = 0;
            if (absoluteHeight < min) absoluteHeight = min;
            const index = Math.round(absoluteHeight / -LINE_HEIGHT);
            const relativeHeight = TOP - LINE_HEIGHT * index;
            if (_this.mode === "date" && typeof _this.updateDay === "function") {
                if (_this.columnId === "0") {
                    _this.updateDay(+_this.range[index].replace(/[^0-9]/gi, ""), 0);
                }
                if (_this.columnId === "1") {
                    _this.updateDay(+_this.range[index].replace(/[^0-9]/gi, ""), 1);
                }
                if (_this.columnId === "2") {
                    _this.updateDay(+_this.range[index].replace(/[^0-9]/gi, ""), 2);
                }
            }
            updateHeight(relativeHeight, columnId, mode === "time");
            _this.onColumnChange.emit({
                columnId,
                height: relativeHeight
            });
        })();
    }
    onMouseDown(e) {
        this.isMove = true;
        this.handleMoveStart(e.clientY);
    }
    onMouseMove(e) {
        if (!this.isMove) return;
        this.handleMoving(e.clientY);
    }
    onMouseMoveEnd(e) {
        if (!this.isMove) return;
        this.isMove = false;
        this.handleMoveEnd(e.clientY);
    }
    onTouchStart(e) {
        this.handleMoveStart(e.changedTouches[0].clientY);
    }
    onTouchMove(e) {
        this.handleMoving(e.changedTouches[0].clientY);
    }
    onTouchEnd(e) {
        this.handleMoveEnd(e.changedTouches[0].clientY);
    }
    render() {
        const { range, rangeKey } = this;
        const pickerItem = range.map((item)=>{
            const content = rangeKey ? item[rangeKey] : item;
            return h("div", {
                class: "weui-picker__item"
            }, content);
        });
        return h(Host, {
            class: "weui-picker__group"
        }, h("div", {
            class: "weui-picker__mask"
        }), h("div", {
            class: "weui-picker__indicator"
        }), h("div", {
            class: "weui-picker__content",
            style: this.getPosition()
        }, pickerItem));
    }
    constructor(){
        super();
        this.__registerHost();
        this.onColumnChange = createEvent(this, "columnChange", 7);
        this.mode = void 0;
        this.range = [];
        this.rangeKey = void 0;
        this.height = void 0;
        this.columnId = void 0;
        this.updateHeight = void 0;
        this.updateDay = void 0;
        this.startY = void 0;
        this.preY = void 0;
        this.hadMove = void 0;
        this.touchEnd = void 0;
        this.isMove = void 0;
    }
}, [
    0,
    "taro-picker-group",
    {
        "mode": [
            1
        ],
        "range": [
            16
        ],
        "rangeKey": [
            1,
            "range-key"
        ],
        "height": [
            2
        ],
        "columnId": [
            1,
            "column-id"
        ],
        "updateHeight": [
            16
        ],
        "updateDay": [
            16
        ],
        "startY": [
            32
        ],
        "preY": [
            32
        ],
        "hadMove": [
            32
        ],
        "touchEnd": [
            32
        ],
        "isMove": [
            32
        ],
        "handleMoveStart": [
            64
        ],
        "handleMoving": [
            64
        ],
        "handleMoveEnd": [
            64
        ]
    },
    [
        [
            1,
            "mousedown",
            "onMouseDown"
        ],
        [
            3,
            "mousemove",
            "onMouseMove"
        ],
        [
            1,
            "mouseup",
            "onMouseMoveEnd"
        ],
        [
            1,
            "mouseleave",
            "onMouseMoveEnd"
        ],
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            3,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement63() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-picker-group"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-group":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, TaroPickerGroup);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-picker-core.js
function getTimeRange(begin, end) {
    const range = [];
    for(let i2 = begin; i2 <= end; i2++){
        range.push(`${i2 < 10 ? "0" : ""}${i2}`);
    }
    return range;
}
var hoursRange = [
    "20",
    "21",
    "22",
    "23",
    ...getTimeRange(0, 23),
    "00",
    "01",
    "02",
    "03"
];
var minutesRange = [
    "56",
    "57",
    "58",
    "59",
    ...getTimeRange(0, 59),
    "00",
    "01",
    "02",
    "03"
];
function verifyValue(value, range) {
    if (!isNaN(+value) && value >= 0 && value < range.length) return true;
    return false;
}
function verifyTime(value) {
    if (!/^\d{1,2}:\d{1,2}$/.test(value)) return false;
    const time = value.split(":").map((num)=>+num);
    if (time[0] < 0 || time[0] > 23) return false;
    if (time[1] < 0 || time[1] > 59) return false;
    return true;
}
function compareTime(t1, t2) {
    const t1List = t1.split(":").map((i2)=>+i2);
    const t2List = t2.split(":").map((i2)=>+i2);
    if (t1List[0] < t2List[0]) return true;
    if (t1List[0] === t2List[0] && t1List[1] <= t2List[1]) return true;
    return false;
}
function verifyDate(dateStr) {
    if (!dateStr) return false;
    const date2 = new Date(dateStr.replace(/-/g, "/"));
    return isNaN(date2.getMonth()) ? false : date2;
}
function getMaxDay(year, month) {
    if (month === 4 || month === 6 || month === 9 || month === 11) return 30;
    if (month === 2) {
        if (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0) return 29;
        else return 28;
    }
    return 31;
}
function formatValue(value) {
    let res;
    if (Array.isArray(value)) {
        res = value.map((item)=>String(item));
    } else {
        res = value;
    }
    return res;
}
function getDateRange(start, end) {
    const range = [];
    for(let i2 = start; i2 <= end; i2++){
        range.push(i2);
    }
    return range;
}
function getYearRange(start, end) {
    return getDateRange(start, end);
}
function getMonthRange(start, end, year) {
    let rangeStart = 1;
    let rangeEnd = 12;
    if (start.getFullYear() === year) {
        rangeStart = start.getMonth() + 1;
    }
    if (end.getFullYear() === year) {
        rangeEnd = end.getMonth() + 1;
    }
    return getDateRange(rangeStart, rangeEnd);
}
function getDayRange(start, end, year, month) {
    let rangeStart = 1;
    let rangeEnd = getMaxDay(year, month);
    if (start.getFullYear() === year && start.getMonth() + 1 === month) {
        rangeStart = start.getDate();
    }
    if (end.getFullYear() === year && end.getMonth() + 1 === month) {
        rangeEnd = end.getDate();
    }
    return getDateRange(rangeStart, rangeEnd);
}
var indexCss10 = '.weui-mask{z-index:1000;background:rgba(0,0,0,.6);position:fixed;inset:0}.weui-mask_transparent{z-index:1000;position:fixed;inset:0}@keyframes weuiSlideUp{0%{transform:translateY(100%)}to{transform:translate(0,0)}}.weui-animate-slide-up{animation:.3s forwards weuiSlideUp}@keyframes weuiSlideDown{0%{transform:translate(0,0)}to{transform:translateY(100%)}}.weui-animate-slide-down{animation:.3s forwards weuiSlideDown}@keyframes weuiFadeIn{0%{opacity:0}to{opacity:1}}.weui-animate-fade-in{animation:.3s forwards weuiFadeIn}@keyframes weuiFadeOut{0%{opacity:1}to{opacity:0}}.weui-animate-fade-out{animation:.3s forwards weuiFadeOut}.weui-picker{box-sizing:border-box;z-index:5000;background-color:var(--weui-BG-2);width:100%;padding-left:0;padding-left:constant(safe-area-inset-left);padding-left:env(safe-area-inset-left);padding-right:0;padding-right:constant(safe-area-inset-right);padding-right:env(safe-area-inset-right);backface-visibility:hidden;transition:transform .3s;position:fixed;bottom:0;left:0;transform:translateY(100%)}.weui-picker__hd{text-align:center;background-color:#fff;padding:9px 15px;font-size:17px;display:flex;position:relative}.weui-picker__hd:after{content:" ";color:#e5e5e5;transform-origin:0 100%;border-bottom:1px solid #e5e5e5;height:1px;position:absolute;bottom:0;left:0;right:0;transform:scaleY(.5)}.weui-picker__action{color:#1aad19;flex:1;display:block}.weui-picker__action:first-child{text-align:left;color:#888}.weui-picker__action:last-child{text-align:right}.weui-picker__bd{background-color:#fff;height:238px;display:flex;position:relative;overflow:hidden}.weui-picker__group{flex:1;height:100%;position:relative}.weui-picker__mask{z-index:3;background-color:transparent;background-image:linear-gradient(rgba(255,255,255,.95),rgba(255,255,255,.6)),linear-gradient(rgba(255,255,255,.6),rgba(255,255,255,.95));background-position:top,bottom;background-repeat:no-repeat;background-size:100% 102px;background-attachment:scroll,scroll;background-origin:padding-box,padding-box;background-clip:border-box,border-box;width:100%;height:100%;margin:0 auto;position:absolute;top:0;left:0;transform:translateZ(0)}.weui-picker__indicator{z-index:3;width:100%;height:34px;position:absolute;top:102px;left:0}.weui-picker__indicator:before{content:" ";color:#e5e5e5;transform-origin:0 0;border-top:1px solid #e5e5e5;height:1px;position:absolute;top:0;left:0;right:0;transform:scaleY(.5)}.weui-picker__indicator:after{content:" ";color:#e5e5e5;transform-origin:0 100%;border-bottom:1px solid #e5e5e5;height:1px;position:absolute;bottom:0;left:0;right:0;transform:scaleY(.5)}.weui-picker__content{width:100%;position:absolute;top:0;left:0}.weui-picker__item{text-align:center;color:#000;text-overflow:ellipsis;white-space:nowrap;height:34px;padding:0;line-height:34px;overflow:hidden}.weui-picker__item_disabled{color:#999}.weui-picker,.weui-picker__hd{font-size:12px}';
var Picker = proxyCustomElement(class extends H {
    componentWillLoad() {
        this.isWillLoadCalled = true;
        this.handleProps();
    }
    componentDidLoad() {
        if (this.overlay) {
            document.body.appendChild(this.overlay);
        }
    }
    disconnectedCallback() {
        var _a;
        if (this.overlay) {
            (_a = this.overlay.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(this.overlay);
        }
    }
    onPropsChange() {
        if (!this.isWillLoadCalled) return;
        this.handleProps();
    }
    handleProps() {
        const { mode, start, end } = this;
        if (mode === "selector") {
            const value = this.value;
            this.index = [
                verifyValue(value, this.range) ? Math.floor(value) : 0
            ];
        } else if (mode === "multiSelector") {
            const value = this.value;
            this.index = [];
            this.range.forEach((range, index)=>{
                const val = value === null || value === void 0 ? void 0 : value[index];
                const item = verifyValue(val, range) ? Math.floor(val) : 0;
                this.index.push(item);
            });
        } else if (mode === "time") {
            let value = this.value;
            if (!verifyTime(value)) {
                console.warn("time picker value illegal");
                value = "0:0";
            }
            const time = value.split(":").map((n)=>+n);
            this.index = time;
        } else if (mode === "date") {
            const value = this.value;
            let _value = verifyDate(value) || new Date(/* @__PURE__ */ new Date().setHours(0, 0, 0, 0));
            const _start = verifyDate(start) || /* @__PURE__ */ new Date("1970/01/01");
            const _end = verifyDate(end) || /* @__PURE__ */ new Date("2999/01/01");
            if (!(_start <= _end)) {
                throw new Error(`Picker start time must be less than end time.`);
            }
            if (!(_value >= _start && _value <= _end)) {
                _value = _start;
            }
            const currentYear = _value.getFullYear();
            const currentMonth = _value.getMonth() + 1;
            const currentDay = _value.getDate();
            const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear());
            const monthRange = getMonthRange(_start, _end, currentYear);
            const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
            this.index = [
                yearRange.indexOf(currentYear),
                monthRange.indexOf(currentMonth),
                dayRange.indexOf(currentDay)
            ];
            if (!this.pickerDate || this.pickerDate._value.getTime() !== _value.getTime() || this.pickerDate._start.getTime() !== _start.getTime() || this.pickerDate._end.getTime() !== _end.getTime()) {
                this.pickerDate = {
                    _value,
                    _start,
                    _end,
                    _updateValue: [
                        currentYear,
                        currentMonth,
                        currentDay
                    ]
                };
            }
        } else {
            throw new Error(`Picker not support "${mode}" mode.`);
        }
        this.height = this.getHeightByIndex();
        this.pickerValue = this.value;
        if (mode === "date") {
            const val = this.pickerValue;
            if (this.fields === "month") {
                this.pickerValue = val.split("-").slice(0, 2).join("-");
            } else if (this.fields === "year") {
                this.pickerValue = val.split("-")[0];
            }
        }
    }
    render() {
        var _a, _b;
        const { name, mode, fadeOut, hidden } = this;
        let pickerGroup;
        switch(mode){
            case "multiSelector":
                pickerGroup = this.getMultiSelector();
                break;
            case "time":
                pickerGroup = this.getTimeSelector();
                break;
            case "date":
                pickerGroup = this.getDateSelector();
                break;
            default:
                pickerGroup = this.getSelector();
        }
        const clsMask = classnames("weui-mask", "weui-animate-fade-in", {
            "weui-animate-fade-out": fadeOut
        });
        const clsSlider = classnames("weui-picker", "weui-animate-slide-up", {
            "weui-animate-slide-down": fadeOut
        });
        const shouldDivHidden = hidden ? {
            display: "none"
        } : {};
        return h(Host, null, h("div", {
            onClick: this.showPicker
        }, h("slot", null), h("input", {
            type: "hidden",
            name,
            value: formatValue(this.pickerValue)
        })), h("div", {
            class: "weui-picker__overlay",
            style: shouldDivHidden,
            ref: (el)=>{
                this.overlay = el;
            }
        }, h("div", {
            class: clsMask,
            onClick: this.handleCancel
        }), h("div", {
            class: clsSlider
        }, h("div", {
            class: "weui-picker__hd"
        }, h("div", {
            class: "weui-picker__action",
            onClick: this.handleCancel
        }, (_a = this.textProps.cancelText) !== null && _a !== void 0 ? _a : "\u53D6\u6D88"), h("div", {
            class: "weui-picker__action",
            onClick: this.handleChange
        }, (_b = this.textProps.okText) !== null && _b !== void 0 ? _b : "\u786E\u5B9A")), h("div", {
            class: "weui-picker__bd"
        }, pickerGroup), h("input", {
            type: "hidden",
            name,
            value: formatValue(this.pickerValue)
        }))));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "mode": [
                "onPropsChange"
            ],
            "value": [
                "onPropsChange"
            ],
            "range": [
                "onPropsChange"
            ],
            "start": [
                "onPropsChange"
            ],
            "end": [
                "onPropsChange"
            ]
        };
    }
    static get style() {
        return indexCss10;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onColumnChange = createEvent(this, "columnchange", 7);
        this.onCancel = createEvent(this, "cancel", 7);
        this.index = [];
        this.showPicker = ()=>{
            if (this.disabled) return;
            this.height = this.getHeightByIndex();
            this.hidden = false;
        };
        this.getHeightByIndex = ()=>{
            const height = this.index.map((i2)=>{
                let factor = 0;
                if (this.mode === "time") {
                    factor = LINE_HEIGHT * 4;
                }
                return TOP - LINE_HEIGHT * i2 - factor;
            });
            return height;
        };
        this.hidePicker = ()=>{
            this.fadeOut = true;
            setTimeout(()=>{
                this.hidden = true;
                this.fadeOut = false;
            }, 350);
        };
        this.handleChange = ()=>{
            this.hidePicker();
            this.index = this.height.map((h2)=>(TOP - h2) / LINE_HEIGHT);
            let value = this.index.length && this.mode !== "selector" ? this.index : this.index[0];
            if (this.mode === "time") {
                const range = [
                    hoursRange.slice(),
                    minutesRange.slice()
                ];
                const timeArr = this.index.map((n, i2)=>range[i2][n]);
                this.index = timeArr.map((item)=>parseInt(item));
                value = timeArr.join(":");
            }
            if (this.mode === "date") {
                const { _start, _end, _updateValue } = this.pickerDate;
                const currentYear = _updateValue[0];
                const currentMonth = _updateValue[1];
                const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear());
                const monthRange = getMonthRange(_start, _end, currentYear);
                const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
                const year = yearRange[this.index[0]];
                const month = monthRange[this.index[1]];
                const day = dayRange[this.index[2]];
                if (this.fields === "year") {
                    value = [
                        year
                    ];
                } else if (this.fields === "month") {
                    value = [
                        year,
                        month
                    ];
                } else {
                    value = [
                        year,
                        month,
                        day
                    ];
                }
                value = value.map((item)=>{
                    return item < 10 ? `0${item}` : item;
                }).join("-");
            }
            this.value = value;
            this.pickerValue = this.value;
            this.onChange.emit({
                value
            });
        };
        this.handleColumnChange = (e)=>{
            const { columnId, height } = e.detail;
            this.onColumnChange.emit({
                column: Number(columnId),
                value: (TOP - height) / LINE_HEIGHT
            });
        };
        this.handleCancel = ()=>{
            this.hidePicker();
            this.onCancel.emit();
        };
        this.updateHeight = (height, columnId, needRevise = false)=>{
            const temp = [
                ...this.height
            ];
            temp[columnId] = height;
            this.height = temp;
            if (needRevise) {
                let { start, end } = this;
                if (!verifyTime(start)) start = "00:00";
                if (!verifyTime(end)) end = "23:59";
                if (!compareTime(start, end)) return;
                const range = [
                    hoursRange.slice(),
                    minutesRange.slice()
                ];
                const timeList = this.height.map((h2)=>(TOP - h2) / LINE_HEIGHT);
                const timeStr = timeList.map((n, i2)=>range[i2][n]).join(":");
                if (!compareTime(start, timeStr)) {
                    const height2 = start.split(":").map((i2)=>TOP - LINE_HEIGHT * (+i2 + 4));
                    requestAnimationFrame(()=>this.height = height2);
                } else if (!compareTime(timeStr, end)) {
                    const height2 = end.split(":").map((i2)=>TOP - LINE_HEIGHT * (+i2 + 4));
                    requestAnimationFrame(()=>this.height = height2);
                }
            }
        };
        this.updateDay = (value, fields)=>{
            const { _start, _end, _updateValue } = this.pickerDate;
            _updateValue[fields] = value;
            const currentYear = _updateValue[0];
            const currentMonth = _updateValue[1];
            const currentDay = _updateValue[2];
            if (fields === 0) {
                const monthRange = getMonthRange(_start, _end, currentYear);
                const max = monthRange[monthRange.length - 1];
                const min = monthRange[0];
                if (currentMonth > max) _updateValue[1] = max;
                if (currentMonth < min) _updateValue[1] = min;
                const index = monthRange.indexOf(_updateValue[1]);
                const height = TOP - LINE_HEIGHT * index;
                this.updateDay(_updateValue[1], 1);
                this.updateHeight(height, "1");
            } else if (fields === 1) {
                const dayRange = getDayRange(_start, _end, currentYear, currentMonth);
                const max = dayRange[dayRange.length - 1];
                const min = dayRange[0];
                if (currentDay > max) _updateValue[2] = max;
                if (currentDay < min) _updateValue[2] = min;
                const index = dayRange.indexOf(_updateValue[2]);
                const height = TOP - LINE_HEIGHT * index;
                this.updateDay(_updateValue[2], 2);
                this.updateHeight(height, "2");
            }
        };
        this.getSelector = ()=>{
            return h("taro-picker-group", {
                range: this.range,
                rangeKey: this.rangeKey,
                height: this.height[0],
                updateHeight: this.updateHeight,
                columnId: "0"
            });
        };
        this.getMultiSelector = ()=>{
            return this.range.map((range, index)=>{
                return h("taro-picker-group", {
                    range,
                    rangeKey: this.rangeKey,
                    height: this.height[index],
                    updateHeight: this.updateHeight,
                    onColumnChange: this.handleColumnChange,
                    columnId: String(index)
                });
            });
        };
        this.getTimeSelector = ()=>{
            const hourRange = hoursRange.slice();
            const minRange = minutesRange.slice();
            return [
                h("taro-picker-group", {
                    mode: "time",
                    range: hourRange,
                    height: this.height[0],
                    updateHeight: this.updateHeight,
                    columnId: "0"
                }),
                h("taro-picker-group", {
                    mode: "time",
                    range: minRange,
                    height: this.height[1],
                    updateHeight: this.updateHeight,
                    columnId: "1"
                })
            ];
        };
        this.getDateSelector = ()=>{
            const { fields, height } = this;
            const { _start, _end, _updateValue } = this.pickerDate;
            const currentYear = _updateValue[0];
            const currentMonth = _updateValue[1];
            const yearRange = getYearRange(_start.getFullYear(), _end.getFullYear()).map((item)=>`${item}\u5E74`);
            const monthRange = getMonthRange(_start, _end, currentYear).map((item)=>`${item < 10 ? `0${item}` : item}\u6708`);
            const dayRange = getDayRange(_start, _end, currentYear, currentMonth).map((item)=>`${item < 10 ? `0${item}` : item}\u65E5`);
            const renderView = [
                h("taro-picker-group", {
                    mode: "date",
                    range: yearRange,
                    height: height[0],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "0"
                })
            ];
            if (fields === "month" || fields === "day") {
                renderView.push(h("taro-picker-group", {
                    mode: "date",
                    range: monthRange,
                    height: height[1],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "1"
                }));
            }
            if (fields === "day") {
                renderView.push(h("taro-picker-group", {
                    mode: "date",
                    range: dayRange,
                    height: height[2],
                    updateDay: this.updateDay,
                    updateHeight: this.updateHeight,
                    columnId: "2"
                }));
            }
            return renderView;
        };
        this.mode = "selector";
        this.disabled = false;
        this.range = [];
        this.rangeKey = void 0;
        this.value = void 0;
        this.start = "";
        this.end = "";
        this.fields = "day";
        this.name = "";
        this.textProps = {};
        this.pickerValue = [];
        this.height = [];
        this.hidden = true;
        this.fadeOut = false;
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-picker-core",
    {
        "mode": [
            1
        ],
        "disabled": [
            4
        ],
        "range": [
            16
        ],
        "rangeKey": [
            1,
            "range-key"
        ],
        "value": [
            1032
        ],
        "start": [
            1
        ],
        "end": [
            1
        ],
        "fields": [
            1
        ],
        "name": [
            1
        ],
        "textProps": [
            16
        ],
        "pickerValue": [
            32
        ],
        "height": [
            32
        ],
        "hidden": [
            32
        ],
        "fadeOut": [
            32
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$161() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-picker-core",
        "taro-picker-group"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Picker);
                }
                break;
            case "taro-picker-group":
                if (!customElements.get(tagName)) {
                    defineCustomElement63();
                }
                break;
        }
    });
}
var defineCustomElement64 = defineCustomElement$161;
// node_modules/@tarojs/components/dist/components/taro-picker-group.js
var defineCustomElement65 = defineCustomElement63;
// node_modules/@tarojs/components/dist/components/taro-picker-view-column-core.js
var columnCss = ".taro-picker-view-column-container{text-align:center;flex-direction:column;flex:1;display:flex;position:relative;overflow:hidden scroll}.taro-picker-view-column-container::-webkit-scrollbar{display:none}";
var PickerViewColumn = proxyCustomElement(class extends H {
    onTouchStart() {
        this.onSelectStart.emit();
    }
    onTouchEnd() {
        this.handleSelected();
    }
    componentDidLoad() {
        this.handleChange();
    }
    componentDidUpdate() {
        this.handleChange();
    }
    handleChange() {
        const childList = this.el.childNodes;
        let idx = 0;
        let sum = 0;
        for(const index in childList){
            const item = childList[index];
            if (this.initialPosition === index || !item || typeof item.offsetHeight !== "number") {
                break;
            }
            sum += item.offsetHeight;
            idx++;
        }
        this.el.scrollTo({
            top: sum
        });
        if (idx >= childList.length) {
            this.onChange.emit({
                curIndex: this.col,
                selectedIndex: idx - 1
            });
        }
    }
    render() {
        const { paddingVertical = 0 } = this;
        return h(Host, {
            class: "taro-picker-view-column-container",
            style: {
                "padding-top": `${paddingVertical}px`,
                "padding-bottom": `${paddingVertical}px`
            }
        });
    }
    get el() {
        return this;
    }
    static get style() {
        return columnCss;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "onselect", 7);
        this.onSelectStart = createEvent(this, "onselectstart", 7);
        this.onSelectEnd = createEvent(this, "onselectend", 7);
        this.handleSelected = debounce2(()=>{
            const childList = this.el.childNodes;
            let sum = 0;
            let selectedIndex = "0";
            for(const index in childList){
                const item = childList[index];
                const itemHeight = item.offsetHeight;
                if (sum + itemHeight / 2 > this.el.scrollTop) {
                    selectedIndex = index;
                    break;
                }
                sum += itemHeight;
            }
            this.el.scrollTo({
                top: sum,
                behavior: "smooth"
            });
            this.onChange.emit({
                curIndex: this.col,
                selectedIndex
            });
            this.onSelectEnd.emit();
        }, 500);
        this.col = void 0;
        this.initialPosition = "0";
        this.paddingVertical = 0;
        this.isInit = false;
    }
}, [
    0,
    "taro-picker-view-column-core",
    {
        "col": [
            1
        ],
        "initialPosition": [
            1,
            "initial-position"
        ],
        "paddingVertical": [
            2,
            "padding-vertical"
        ],
        "isInit": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$162() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-picker-view-column-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-view-column-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PickerViewColumn);
                }
                break;
        }
    });
}
var defineCustomElement66 = defineCustomElement$162;
// node_modules/@tarojs/components/dist/components/taro-picker-view-core.js
function convertStyle(style) {
    if (style) {
        const regex = /([\w-]*)\s*:\s*([^;]*)/g;
        const properties = {};
        let match2;
        while(match2 = regex.exec(style))properties[`${match2[1]}`] = match2[2].trim();
        return properties;
    }
}
var indexCss11 = ".taro-picker-view-container{display:flex;position:relative}.taro-picker-view-mask-container{pointer-events:none;flex-direction:column;display:flex;position:absolute;inset:0}.taro-picker-view-mask-indicator{border-top:1px solid #ddd;border-bottom:1px solid #ddd;height:50px;display:flex}.taro-picker-view-mask-top{background-image:linear-gradient(rgba(255,255,255,.95),rgba(255,255,255,.6));flex:1}.taro-picker-view-mask-bottom{background:linear-gradient(rgba(255,255,255,.6),rgba(255,255,255,.95));flex:1}";
var PickerView = proxyCustomElement(class extends H {
    onPropsChange() {
        this.handleValueChange();
    }
    onSelect(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        let _curIndex = +e.detail.curIndex;
        let _selectedIndex = +e.detail.selectedIndex;
        this.value[_curIndex] = _selectedIndex;
        this.onChange.emit({
            value: this.value
        });
    }
    onSelectStart(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        this.onPickStart.emit();
    }
    onPickerColEnd(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-PICKER-VIEW-COLUMN-CORE") return;
        this.onPickEnd.emit();
    }
    componentDidLoad() {
        this.handleValueChange();
    }
    handleValueChange() {
        const childList = this.el.querySelectorAll("taro-picker-view-column-core");
        childList.forEach((element, index)=>{
            var _a;
            element.setAttribute("col", `${index}`);
            let selectIndex = 0;
            if (!!this.value && this.value.length > index) {
                selectIndex = this.value[index];
            }
            const pickerHeight = this.el.getBoundingClientRect().height;
            const indicatorHeight = ((_a = this.indicator) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
            const paddingVertical = (pickerHeight - indicatorHeight) / 2;
            element.setAttribute("initial-position", `${selectIndex}`);
            element.setAttribute("padding-vertical", `${paddingVertical}`);
        });
    }
    //  PickerViewColumn 
    componentDidRender() {
        this.el.childNodes.forEach((item)=>{
            const childEle = item;
            if ("TARO-PICKER-VIEW-COLUMN-CORE" !== childEle.tagName && childEle.className !== "taro-picker-view-mask-container") {
                this.el.removeChild(item);
            }
        });
    }
    render() {
        const indicatorCls = classnames("taro-picker-view-mask-indicator", this.indicatorClass);
        const maskTopCls = classnames("taro-picker-view-mask-top", this.maskClass);
        const maskBtmCls = classnames("taro-picker-view-mask-bottom", this.maskClass);
        const indicatorStyle = convertStyle(this.indicatorStyle);
        const maskTopStyle = convertStyle(this.maskStyle);
        const maskBottomStyle = convertStyle(this.maskStyle);
        return h(Host, {
            class: "taro-picker-view-container"
        }, h("slot", null), h("div", {
            class: "taro-picker-view-mask-container"
        }, h("div", {
            class: maskTopCls,
            style: maskTopStyle
        }), h("div", {
            class: indicatorCls,
            style: indicatorStyle,
            ref: (indicator)=>this.indicator = indicator
        }), h("div", {
            class: maskBtmCls,
            style: maskBottomStyle
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "value": [
                "onPropsChange"
            ]
        };
    }
    static get style() {
        return indexCss11;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onPickStart = createEvent(this, "pickstart", 7);
        this.onPickEnd = createEvent(this, "pickend", 7);
        this.indicatorStyle = void 0;
        this.indicatorClass = void 0;
        this.value = void 0;
        this.maskStyle = void 0;
        this.maskClass = void 0;
    }
}, [
    4,
    "taro-picker-view-core",
    {
        "indicatorStyle": [
            1,
            "indicator-style"
        ],
        "indicatorClass": [
            1,
            "indicator-class"
        ],
        "value": [
            16
        ],
        "maskStyle": [
            1,
            "mask-style"
        ],
        "maskClass": [
            1,
            "mask-class"
        ]
    },
    [
        [
            0,
            "onselect",
            "onSelect"
        ],
        [
            0,
            "onselectstart",
            "onSelectStart"
        ],
        [
            0,
            "onselectend",
            "onPickerColEnd"
        ]
    ]
]);
function defineCustomElement$163() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-picker-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-picker-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PickerView);
                }
                break;
        }
    });
}
var defineCustomElement67 = defineCustomElement$163;
// node_modules/@tarojs/components/dist/components/taro-progress-core.js
var indexCss12 = ".weui-progress{align-items:center;display:flex}.weui-progress__bar{background-color:#ebebeb;flex:1;height:3px}.weui-progress__inner-bar{background-color:#09bb07;width:0;height:100%}.weui-progress__opr{margin-left:15px;font-size:0;display:block}";
var Progress = proxyCustomElement(class extends H {
    render() {
        const { percent, showInfo, borderRadius, fontSize, strokeWidth, activeColor, backgroundColor, active } = this;
        const pgPercent = percent > 100 ? 100 : percent < 0 ? 0 : percent;
        const pgHeight = {
            height: strokeWidth + "px",
            backgroundColor
        };
        const transition2 = active ? "width 1s ease-in-out" : "none";
        const pgWidth = {
            width: `${pgPercent}%`,
            transition: transition2,
            WebkitTransition: transition2,
            backgroundColor: activeColor,
            borderRadius: borderRadius ? `${borderRadius}px` : "0px"
        };
        return h(Host, {
            class: "weui-progress"
        }, h("div", {
            class: "weui-progress__bar",
            style: pgHeight
        }, h("div", {
            class: "weui-progress__inner-bar",
            style: pgWidth
        })), showInfo && h("div", {
            class: "weui-progress__opr",
            style: {
                "font-size": `${fontSize}px`
            }
        }, h("span", null, pgPercent, "%")));
    }
    static get style() {
        return indexCss12;
    }
    constructor(){
        super();
        this.__registerHost();
        this.percent = 0;
        this.showInfo = false;
        this.borderRadius = 0;
        this.fontSize = 16;
        this.strokeWidth = 6;
        this.activeColor = "#09BB07";
        this.backgroundColor = "#EBEBEB";
        this.active = false;
    }
}, [
    0,
    "taro-progress-core",
    {
        "percent": [
            2
        ],
        "showInfo": [
            4,
            "show-info"
        ],
        "borderRadius": [
            8,
            "border-radius"
        ],
        "fontSize": [
            8,
            "font-size"
        ],
        "strokeWidth": [
            8,
            "stroke-width"
        ],
        "activeColor": [
            1,
            "active-color"
        ],
        "backgroundColor": [
            1,
            "background-color"
        ],
        "active": [
            4
        ]
    }
]);
function defineCustomElement$164() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-progress-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-progress-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Progress);
                }
                break;
        }
    });
}
var defineCustomElement68 = defineCustomElement$164;
// node_modules/@tarojs/components/dist/components/taro-pull-to-refresh-core.js
var indexCss13 = ".rmc-pull-to-refresh-content{transform-origin:0 0}.rmc-pull-to-refresh-content-wrapper{min-height:100%}.rmc-pull-to-refresh-transition{transition:transform .3s}@keyframes rmc-pull-to-refresh-indicator{50%{opacity:.2}to{opacity:1}}.rmc-pull-to-refresh-indicator{text-align:center;height:30px;line-height:10px}.rmc-pull-to-refresh-indicator>div{background-color:gray;border-radius:100%;width:6px;height:6px;margin:3px;animation:.5s linear infinite both rmc-pull-to-refresh-indicator;display:inline-block}.rmc-pull-to-refresh-indicator>div:nth-child(0){animation-delay:-.1s!important}.rmc-pull-to-refresh-indicator>div:first-child{animation-delay:-.2s!important}.rmc-pull-to-refresh-indicator>div:nth-child(2){animation-delay:-.3s!important}.rmc-pull-to-refresh-down .rmc-pull-to-refresh-indicator{margin-top:-25px}";
function setTransform2(nodeStyle, value) {
    nodeStyle.transform = value;
    nodeStyle.webkitTransform = value;
    nodeStyle.MozTransform = value;
}
var isWebView = typeof navigator !== "undefined" && /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent);
var INDICATOR = {
    activate: "release",
    deactivate: "pull",
    release: "loading",
    finish: "finish"
};
var supportsPassive = false;
try {
    const opts = Object.defineProperty({}, "passive", {
        get () {
            supportsPassive = true;
        }
    });
    window.addEventListener("cancel", ()=>({}), opts);
} catch (e) {}
var willPreventDefault = supportsPassive ? {
    passive: false
} : false;
var PullToRefresh = proxyCustomElement(class extends H {
    get scrollContainer() {
        return this.el.parentElement || this.el.closest(".taro_page_stationed") || document.querySelector(".taro_page_stationed") || document.querySelector(".taro_page") || document.querySelector(".taro_router") || document.querySelector(".taro-tabbar__panel") || document.body;
    }
    statusChange() {
        var _a, _b, _c, _d;
        const pageEl = this.scrollContainer;
        switch(this.currSt){
            case "release":
                (_b = (_a = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _a === void 0 ? void 0 : _a.onPullDownRefresh) === null || _b === void 0 ? void 0 : _b.call(_a);
                break;
            case "deactivate":
                (_d = (_c = pageEl === null || pageEl === void 0 ? void 0 : pageEl.__page) === null || _c === void 0 ? void 0 : _c.onPullIntercept) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    disconnectedCallback() {
        this.destroy();
    }
    componentDidLoad() {
        this.init();
        this._isMounted = true;
        taro.eventCenter.on("__taroStartPullDownRefresh", ({ successHandler, errorHandler })=>{
            try {
                this.triggerPullDownRefresh(true);
                successHandler({
                    errMsg: "startPullDownRefresh: ok"
                });
            } catch (e) {
                errorHandler({
                    errMsg: "startPullDownRefresh: fail"
                });
            }
        });
        taro.eventCenter.on("__taroStopPullDownRefresh", ({ successHandler, errorHandler })=>{
            setTimeout(()=>{
                try {
                    this.triggerPullDownRefresh(false);
                    successHandler({
                        errMsg: "stopPullDownRefresh: ok"
                    });
                } catch (e) {
                    errorHandler({
                        errMsg: "stopPullDownRefresh: fail"
                    });
                }
            }, 0);
        });
    }
    render() {
        const renderRefresh = (cls)=>{
            const { currSt, dragOnEdge, prefixCls } = this;
            const cla = classnames(cls, !dragOnEdge && `${prefixCls}-transition`);
            const showIndicator = currSt === "activate" || currSt === "release";
            return h("div", {
                class: `${prefixCls}-content-wrapper`
            }, h("div", {
                class: cla,
                ref: (el)=>{
                    this.contentRef = el;
                }
            }, showIndicator && h("div", {
                class: `${prefixCls}-indicator`
            }, h("div", null), h("div", null), h("div", null)), h("slot", null)));
        };
        if (this.scrollContainer) {
            return renderRefresh(`${this.prefixCls}-content ${this.prefixCls}-down`);
        }
        return h(Host, {
            class: classnames(this.prefixCls, `${this.prefixCls}-down`)
        }, renderRefresh(`${this.prefixCls}-content`));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "currSt": [
                "statusChange"
            ]
        };
    }
    static get style() {
        return indexCss13;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onRefresh = createEvent(this, "refresh", 7);
        this._ScreenY = 0;
        this._startScreenY = 0;
        this._lastScreenY = 0;
        this._isMounted = false;
        this.triggerPullDownRefresh = (flag)=>{
            if (!this.dragOnEdge && this._isMounted) {
                if (flag) {
                    this._lastScreenY = this.distanceToRefresh + 1;
                    this.currSt = "release";
                    this.setContentStyle(this._lastScreenY);
                } else {
                    this.currSt = "finish";
                    this.reset();
                }
            }
        };
        this.init = ()=>{
            const ele = this.scrollContainer;
            const child = this.el.querySelector(".rmc-pull-to-refresh-content");
            this.el.appendChild = child === null || child === void 0 ? void 0 : child.appendChild.bind(child);
            this.el.insertBefore = child === null || child === void 0 ? void 0 : child.insertBefore.bind(child);
            this.el.replaceChild = child === null || child === void 0 ? void 0 : child.replaceChild.bind(child);
            this.el.removeChild = child === null || child === void 0 ? void 0 : child.removeChild.bind(child);
            this._to = {
                touchstart: this.onTouchStart.bind(this, ele),
                touchmove: this.onTouchMove.bind(this, ele),
                touchend: this.onTouchEnd.bind(this, ele),
                touchcancel: this.onTouchEnd.bind(this, ele)
            };
            Object.keys(this._to).forEach((key)=>{
                ele.addEventListener(key, this._to[key], willPreventDefault);
            });
        };
        this.destroy = ()=>{
            if (!this._to) return;
            const ele = this.scrollContainer;
            Object.keys(this._to).forEach((key)=>{
                ele.removeEventListener(key, this._to[key]);
            });
        };
        this.onTouchStart = (_, e)=>{
            this._ScreenY = this._startScreenY = e.touches[0].screenY;
            this._lastScreenY = this._lastScreenY || 0;
        };
        this.isEdge = (ele)=>{
            const container2 = this.scrollContainer;
            if (container2 && container2 === document.body) {
                const scrollNode = document.scrollingElement ? document.scrollingElement : document.body;
                return scrollNode.scrollTop <= 0;
            }
            return ele.scrollTop <= 0;
        };
        this.damp = (dy)=>{
            if (Math.abs(this._lastScreenY) > this.damping) {
                return 0;
            }
            const ratio = Math.abs(this._ScreenY - this._startScreenY) / window.screen.height;
            dy *= (1 - ratio) * 0.6;
            return dy;
        };
        this.onTouchMove = (ele, e)=>{
            const _screenY = e.touches[0].screenY;
            if (this._startScreenY > _screenY) {
                return;
            }
            if (this.isEdge(ele)) {
                if (!this.dragOnEdge) {
                    this._ScreenY = this._startScreenY = e.touches[0].screenY;
                    this.dragOnEdge = true;
                }
                if (e.cancelable) {
                    e.preventDefault();
                }
                const _diff = Math.round(_screenY - this._ScreenY);
                this._ScreenY = _screenY;
                this._lastScreenY += this.damp(_diff);
                this.setContentStyle(this._lastScreenY);
                if (Math.abs(this._lastScreenY) < this.distanceToRefresh) {
                    if (this.currSt !== "deactivate") {
                        this.currSt = "deactivate";
                    }
                } else {
                    if (this.currSt === "deactivate") {
                        this.currSt = "activate";
                    }
                }
                if (isWebView && e.changedTouches[0].clientY < 0) {
                    this.onTouchEnd();
                }
            }
        };
        this.onTouchEnd = ()=>{
            if (this.dragOnEdge) {
                this.dragOnEdge = false;
            }
            if (this.currSt === "activate") {
                this.currSt = "release";
                this.onRefresh.emit(this);
                this._lastScreenY = this.distanceToRefresh + 1;
                this.setContentStyle(this._lastScreenY);
            } else if (this.currSt === "release") {
                this._lastScreenY = this.distanceToRefresh + 1;
                this.setContentStyle(this._lastScreenY);
            } else {
                this.reset();
            }
        };
        this.reset = ()=>{
            this._lastScreenY = 0;
            this.setContentStyle(0);
        };
        this.setContentStyle = (ty)=>{
            if (this.contentRef) {
                if (ty) {
                    setTransform2(this.contentRef.style, `translate3d(0px,${ty}px,0)`);
                } else {
                    setTransform2(this.contentRef.style, "");
                }
            }
        };
        this.prefixCls = "rmc-pull-to-refresh";
        this.distanceToRefresh = 50;
        this.damping = 100;
        this.indicator = INDICATOR;
        this.currSt = "deactivate";
        this.dragOnEdge = false;
    }
}, [
    4,
    "taro-pull-to-refresh-core",
    {
        "prefixCls": [
            1,
            "prefix-cls"
        ],
        "distanceToRefresh": [
            2,
            "distance-to-refresh"
        ],
        "damping": [
            2
        ],
        "indicator": [
            16
        ],
        "currSt": [
            32
        ],
        "dragOnEdge": [
            32
        ]
    }
]);
function defineCustomElement$165() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-pull-to-refresh-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-pull-to-refresh-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, PullToRefresh);
                }
                break;
        }
    });
}
var defineCustomElement69 = defineCustomElement$165;
// node_modules/@tarojs/components/dist/components/taro-radio-core.js
var Radio = proxyCustomElement(class extends H {
    watchChecked(newVal) {
        if (!this.isWillLoadCalled) return;
        newVal && this.onChange.emit({
            value: this.value
        });
    }
    watchId(newVal) {
        if (!this.isWillLoadCalled) return;
        if (newVal) this.inputEl.setAttribute("id", newVal);
    }
    componentDidRender() {
        this.id && this.el.removeAttribute("id");
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    render() {
        const { checked, name, value, disabled, nativeProps } = this;
        return h(Host, {
            class: "weui-cells_checkbox",
            onClick: this.handleClick
        }, h("input", Object.assign({
            ref: (dom)=>{
                if (!dom) return;
                this.inputEl = dom;
                if (this.id) dom.setAttribute("id", this.id);
            },
            type: "radio",
            name,
            value,
            class: "weui-check",
            checked,
            disabled,
            onChange: (e)=>e.stopPropagation()
        }, nativeProps)), h("i", {
            class: "weui-icon-checked"
        }), h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "checked": [
                "watchChecked"
            ],
            "id": [
                "watchId"
            ]
        };
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "radiochange", 7);
        this.handleClick = (e)=>{
            e.stopPropagation();
            if (this.disabled) return;
            if (!this.checked) this.checked = true;
        };
        this.name = void 0;
        this.value = "";
        this.id = void 0;
        this.checked = false;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    4,
    "taro-radio-core",
    {
        "name": [
            1
        ],
        "value": [
            1
        ],
        "id": [
            1025
        ],
        "checked": [
            1540
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$166() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-radio-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-radio-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Radio);
                }
                break;
        }
    });
}
var defineCustomElement70 = defineCustomElement$166;
// node_modules/@tarojs/components/dist/components/taro-radio-group-core.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _RadioGroup_value;
var RadioGroup = proxyCustomElement(class extends H {
    function(e) {
        e.stopPropagation();
        if (e.target.tagName !== "TARO-RADIO-CORE") return;
        const target = e.target;
        if (target.checked) {
            const childList = this.el.querySelectorAll("taro-radio-core");
            childList.forEach((element)=>{
                if (element !== target) {
                    element.checked = false;
                }
            });
            __classPrivateFieldSet3(this, _RadioGroup_value, e.detail.value, "f");
            this.onChange.emit({
                value: __classPrivateFieldGet3(this, _RadioGroup_value, "f")
            });
        }
    }
    componentDidLoad() {
        const childList = this.el.querySelectorAll("taro-radio-core");
        childList.forEach((element)=>{
            element.setAttribute("name", this.name || this.uniqueName);
        });
        Object.defineProperty(this.el, "value", {
            get: ()=>{
                if (!__classPrivateFieldGet3(this, _RadioGroup_value, "f")) {
                    const childList2 = this.el.querySelectorAll("taro-radio-core");
                    __classPrivateFieldSet3(this, _RadioGroup_value, this.getValues(childList2), "f");
                }
                return __classPrivateFieldGet3(this, _RadioGroup_value, "f");
            },
            configurable: true
        });
    }
    getValues(childList) {
        let val = "";
        Array.from(childList).forEach((element)=>{
            const checkbox = element.querySelector("input");
            if (checkbox === null || checkbox === void 0 ? void 0 : checkbox.checked) {
                val = checkbox.value || "";
            }
        });
        return val;
    }
    render() {
        return h(Host, {
            class: "weui-cells_radiogroup"
        });
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.uniqueName = Date.now().toString(36);
        _RadioGroup_value.set(this, void 0);
        this.name = void 0;
    }
}, [
    0,
    "taro-radio-group-core",
    {
        "name": [
            8
        ]
    },
    [
        [
            0,
            "radiochange",
            "function"
        ]
    ]
]);
_RadioGroup_value = /* @__PURE__ */ new WeakMap();
function defineCustomElement$167() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-radio-group-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-radio-group-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RadioGroup);
                }
                break;
        }
    });
}
var defineCustomElement71 = defineCustomElement$167;
// node_modules/@tarojs/components/dist/components/taro-rich-text-core.js
var indexCss14 = "taro-rich-text-core{user-select:none}taro-rich-text-core[selectable=true],taro-rich-text-core[user-select=true]{user-select:text;display:block}taro-rich-text-core[space]{white-space:pre-wrap}taro-rich-text-core[space=ensp]{word-spacing:.5em}taro-rich-text-core[space=nbsp]{word-spacing:1em}";
var RichText = proxyCustomElement(class extends H {
    render() {
        const { nodes, renderNode } = this;
        if (Array.isArray(nodes)) {
            return h(Host, null, nodes.map((node)=>renderNode(node)));
        } else {
            return h(Host, {
                innerHTML: nodes
            });
        }
    }
    static get style() {
        return indexCss14;
    }
    constructor(){
        super();
        this.__registerHost();
        this.renderNode = (node)=>{
            if ("type" in node && node.type === "text") {
                const content = (node.text || "").replace(/&nbsp;/g, "\xA0");
                return content;
            } else if ("name" in node && node.name) {
                const { name, attrs, children } = node;
                const attributes = {};
                let childList = [];
                if (attrs && typeof attrs === "object") {
                    for(const key in attrs){
                        const val = attrs[key];
                        if (key === "style" && typeof val === "string") {
                            const styles2 = val.split(";").map((item)=>item.trim()).filter((item)=>item);
                            const styleObj = {};
                            styles2.forEach((item)=>{
                                if (!item) return;
                                const res = /(.+): *(.+)/g.exec(item);
                                if (!res) return;
                                const [, name2, value] = res;
                                const styleName = name2.replace(/-([a-z])/g, (...args)=>args[1].toUpperCase());
                                styleObj[styleName] = value;
                            });
                            if (Object.keys(styleObj).length) {
                                attributes.style = styleObj;
                            }
                            continue;
                        }
                        attributes[key] = val;
                    }
                }
                if (children && children.length) {
                    childList = children.map((node2)=>this.renderNode(node2));
                }
                return h(name, attributes, childList);
            }
            return null;
        };
        this.nodes = void 0;
        this.selectable = false;
        this.userSelect = false;
        this.space = void 0;
    }
}, [
    0,
    "taro-rich-text-core",
    {
        "nodes": [
            1
        ],
        "selectable": [
            1028
        ],
        "userSelect": [
            1028,
            "user-select"
        ],
        "space": [
            1
        ]
    }
]);
function defineCustomElement$168() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-rich-text-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-rich-text-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RichText);
                }
                break;
        }
    });
}
var defineCustomElement72 = defineCustomElement$168;
// node_modules/@tarojs/components/dist/components/taro-root-portal-core.js
var RootPortal = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RootPortal", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-root-portal-core"
]);
function defineCustomElement$169() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-root-portal-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-root-portal-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RootPortal);
                }
                break;
        }
    });
}
var defineCustomElement73 = defineCustomElement$169;
// node_modules/@tarojs/components/dist/components/taro-rtc-room-core.js
var RtcRoom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RtcRoom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-rtc-room-core"
]);
function defineCustomElement$170() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-rtc-room-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-rtc-room-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RtcRoom);
                }
                break;
        }
    });
}
var defineCustomElement74 = defineCustomElement$170;
// node_modules/@tarojs/components/dist/components/taro-rtc-room-item-core.js
var RtcRoomItem = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("RtcRoomItem", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-rtc-room-item-core"
]);
function defineCustomElement$171() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-rtc-room-item-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-rtc-room-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, RtcRoomItem);
                }
                break;
        }
    });
}
var defineCustomElement75 = defineCustomElement$171;
// node_modules/@tarojs/components/dist/components/taro-scale-gesture-handler-core.js
var ScaleGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ScaleGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-scale-gesture-handler-core"
]);
function defineCustomElement$172() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-scale-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-scale-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ScaleGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement76 = defineCustomElement$172;
// node_modules/@tarojs/components/dist/components/taro-script-core.js
var Script = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Script", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-script-core"
]);
function defineCustomElement$173() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-script-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-script-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Script);
                }
                break;
        }
    });
}
var defineCustomElement77 = defineCustomElement$173;
// node_modules/@tarojs/components/dist/components/taro-scroll-view-core.js
var indexCss15 = "taro-scroll-view-core{-webkit-overflow-scrolling:touch;width:100%;display:block}.taro-scroll-view__scroll-x{overflow:scroll hidden}.taro-scroll-view__scroll-y{overflow:hidden scroll}.taro-scroll--hidebar::-webkit-scrollbar{display:none}";
function easeOutScroll(from, to, duration = 500, callback) {
    if (from === to || typeof from !== "number") {
        return;
    }
    const change = to - from;
    const sTime = Date.now();
    const isLarger = to >= from;
    function linear(t, b, c, d) {
        return c * t / d + b;
    }
    function step() {
        from = linear(Date.now() - sTime, from, change, duration);
        if (isLarger && from >= to || !isLarger && to >= from) {
            callback(to);
            return;
        }
        callback(from);
        requestAnimationFrame(step);
    }
    step();
}
var ScrollView = proxyCustomElement(class extends H {
    watchScrollLeft(newVal) {
        const left = Number(newVal);
        const { animated } = this;
        this.mpScrollToMethod({
            left,
            animated
        });
    }
    watchScrollTop(newVal) {
        const top = Number(newVal);
        const { animated } = this;
        this.mpScrollToMethod({
            top,
            animated
        });
    }
    watchScrollIntoView(newVal) {
        this.mpScrollIntoViewMethod(newVal);
    }
    handleScroll(e) {
        var _a;
        if (e instanceof CustomEvent) return;
        e.stopPropagation();
        (_a = e.stopImmediatePropagation) === null || _a === void 0 ? void 0 : _a.call(e);
        const { scrollLeft, scrollTop, scrollHeight, scrollWidth } = this.el;
        this._scrollLeft = scrollLeft;
        this._scrollTop = scrollTop;
        this.upperAndLower();
        this.onScroll.emit({
            scrollLeft,
            scrollTop,
            scrollHeight,
            scrollWidth
        });
    }
    handleTouchMove(e) {
        if (e instanceof CustomEvent) return;
        e.stopPropagation();
    }
    mpScrollToMethod(object2) {
        var _this = this;
        return _async_to_generator(function*() {
            let { top, left, duration, animated = false } = object2;
            if (_this.scrollY && typeof top === "number" && !isNaN(top) && top !== _this._scrollTop) {
                if (animated) {
                    easeOutScroll(_this._scrollTop, top, duration, (pos)=>_this.el.scrollTop = pos);
                } else {
                    _this.el.scrollTop = top;
                }
                _this._scrollTop = top;
            }
            if (_this.scrollX && typeof left === "number" && !isNaN(left) && left !== _this._scrollLeft) {
                if (animated) {
                    easeOutScroll(_this._scrollLeft, left, duration, (pos)=>_this.el.scrollLeft = pos);
                } else {
                    _this.el.scrollLeft = left;
                }
                _this._scrollLeft = left;
            }
        })();
    }
    mpScrollIntoViewMethod(selector) {
        var _this = this;
        return _async_to_generator(function*() {
            var _a;
            if (typeof selector === "string" && selector) {
                (_a = document.querySelector(`#${selector}`)) === null || _a === void 0 ? void 0 : _a.scrollIntoView({
                    behavior: _this.animated ? "smooth" : "auto",
                    block: _this.scrollY ? _this.mpScrollIntoViewAlignment || "center" : "center",
                    inline: _this.scrollX ? _this.mpScrollIntoViewAlignment || "start" : "start"
                });
            }
        })();
    }
    componentDidLoad() {
        const top = Number(this.mpScrollTop);
        const left = Number(this.mpScrollLeft);
        const { animated } = this;
        this.mpScrollToMethod({
            top,
            left,
            animated
        });
    }
    componentDidRender() {
        handleStencilNodes(this.el);
    }
    render() {
        const { scrollX, scrollY, enhanced, showScrollbar } = this;
        const cls = classnames({
            "taro-scroll-view__scroll-x": scrollX,
            "taro-scroll-view__scroll-y": scrollY,
            "taro-scroll--hidebar": enhanced === true && showScrollbar === false,
            "taro-scroll--enhanced": enhanced === true
        });
        return h(Host, {
            class: cls
        }, h("slot", null));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "mpScrollLeft": [
                "watchScrollLeft"
            ],
            "mpScrollTop": [
                "watchScrollTop"
            ],
            "mpScrollIntoView": [
                "watchScrollIntoView"
            ]
        };
    }
    static get style() {
        return indexCss15;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onScroll = createEvent(this, "scroll", 3);
        this.onScrollToUpper = createEvent(this, "scrolltoupper", 3);
        this.onScrollToLower = createEvent(this, "scrolltolower", 3);
        this._scrollLeft = 0;
        this._scrollTop = 0;
        this.upperAndLower = debounce2(()=>{
            const { offsetWidth, offsetHeight, scrollLeft, scrollTop, scrollHeight, scrollWidth } = this.el;
            const lowerThreshold = Number(this.lowerThreshold);
            const upperThreshold = Number(this.upperThreshold);
            if (!isNaN(lowerThreshold) && (this.scrollY && offsetHeight + scrollTop + lowerThreshold >= scrollHeight || this.scrollX && offsetWidth + scrollLeft + lowerThreshold >= scrollWidth)) {
                this.onScrollToLower.emit({
                    direction: this.scrollX ? "right" : this.scrollY ? "bottom" : ""
                });
            }
            if (!isNaN(upperThreshold) && (this.scrollY && scrollTop <= upperThreshold || this.scrollX && scrollLeft <= upperThreshold)) {
                this.onScrollToUpper.emit({
                    direction: this.scrollX ? "left" : this.scrollY ? "top" : ""
                });
            }
        }, 200);
        this.scrollX = false;
        this.scrollY = false;
        this.upperThreshold = 50;
        this.lowerThreshold = 50;
        this.mpScrollTop = void 0;
        this.mpScrollLeft = void 0;
        this.mpScrollIntoView = void 0;
        this.mpScrollIntoViewAlignment = void 0;
        this.animated = false;
        this.enhanced = false;
        this.showScrollbar = true;
    }
}, [
    4,
    "taro-scroll-view-core",
    {
        "scrollX": [
            4,
            "scroll-x"
        ],
        "scrollY": [
            4,
            "scroll-y"
        ],
        "upperThreshold": [
            8,
            "upper-threshold"
        ],
        "lowerThreshold": [
            8,
            "lower-threshold"
        ],
        "mpScrollTop": [
            520,
            "scroll-top"
        ],
        "mpScrollLeft": [
            520,
            "scroll-left"
        ],
        "mpScrollIntoView": [
            513,
            "scroll-into-view"
        ],
        "mpScrollIntoViewAlignment": [
            1,
            "scroll-into-view-alignment"
        ],
        "animated": [
            4,
            "scroll-with-animation"
        ],
        "enhanced": [
            4
        ],
        "showScrollbar": [
            4,
            "show-scrollbar"
        ],
        "mpScrollToMethod": [
            64
        ],
        "mpScrollIntoViewMethod": [
            64
        ]
    },
    [
        [
            1,
            "scroll",
            "handleScroll"
        ],
        [
            1,
            "touchmove",
            "handleTouchMove"
        ]
    ]
]);
function defineCustomElement$174() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-scroll-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-scroll-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ScrollView);
                }
                break;
        }
    });
}
var defineCustomElement78 = defineCustomElement$174;
// node_modules/@tarojs/components/dist/components/taro-share-element-core.js
var ShareElement = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("ShareElement", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-share-element-core"
]);
function defineCustomElement$175() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-share-element-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-share-element-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, ShareElement);
                }
                break;
        }
    });
}
var defineCustomElement79 = defineCustomElement$175;
// node_modules/@tarojs/components/dist/components/taro-slider-core.js
var indexCss16 = ".weui-slider{user-select:none;padding:15px 18px}.weui-slider__inner{background-color:#e9e9e9;height:2px;position:relative}.weui-slider__track{background-color:#1aad19;width:0;height:2px}.weui-slider__handler{background-color:#fff;border-radius:50%;width:28px;height:28px;margin-top:-14px;margin-left:-14px;position:absolute;top:50%;left:0;box-shadow:0 0 4px rgba(0,0,0,.2)}.weui-slider-box{align-items:center;display:flex}.weui-slider-box .weui-slider{flex:1}.weui-slider-box__value{color:#888;text-align:center;min-width:24px;margin-left:.5em;font-size:14px}";
var Slider = proxyCustomElement(class extends H {
    function(value) {
        if (!this.isWillLoadCalled) return;
        const { max, min } = this;
        if (value !== null) {
            const val = this.handleValueUpdate(value, min, max);
            this.updateByStep(val);
        }
    }
    componentDidLoad() {
        this.handler.addEventListener("touchstart", this.handleTouchStart);
        this.handler.addEventListener("touchmove", this.handleTouchMove);
        this.handler.addEventListener("touchend", this.handleTouchEnd);
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
        const { value, max, min } = this;
        const val = this.handleValueUpdate(value, min, max);
        this.updateByStep(val);
    }
    //  step  value
    updateByStep(value) {
        const { max, min, step } = this;
        const steps = Math.floor((max - min) / step);
        for(let i2 = 0; i2 <= steps; i2++){
            const current = min + step * i2;
            const next = i2 === steps ? null : min + step * (i2 + 1);
            if (value === current) break;
            if (!next && value > current) {
                value = current;
            }
            if (next && value > current && value < next) {
                if (value - current < step / 2) {
                    value = current;
                } else {
                    value = next;
                }
                break;
            }
        }
        const percent = (value - min) / (max - min) * 100;
        this.value = value;
        this.percent = percent;
    }
    render() {
        const { showValue, backgroundColor, activeColor, blockColor, name, percent, value } = this;
        let blockSize = this.blockSize;
        const innerStyles = {
            backgroundColor
        };
        const percentage = percent > 100 ? 100 : percent;
        const trackStyles = {
            width: `${percentage}%`,
            backgroundColor: activeColor
        };
        if (blockSize < 12) {
            blockSize = 12;
        }
        if (blockSize > 28) {
            blockSize = 28;
        }
        const handlerStyles = {
            left: `${percentage}%`,
            width: `${blockSize}px`,
            height: `${blockSize}px`,
            backgroundColor: blockColor,
            marginTop: `-${Math.floor(blockSize / 2)}px`,
            marginLeft: `-${Math.floor(blockSize / 2)}px`
        };
        return h(Host, {
            class: "weui-slider-box"
        }, h("div", {
            class: "weui-slider"
        }, h("div", {
            class: "weui-slider__inner",
            style: innerStyles,
            ref: (c)=>this.sliderInsRef = c
        }, h("div", {
            style: trackStyles,
            class: "weui-slider__track"
        }), h("div", {
            class: "weui-slider__handler",
            ref: (dom)=>{
                if (dom) this.handler = dom;
            },
            style: handlerStyles
        }), h("input", {
            type: "hidden",
            name,
            value
        }))), showValue && h("div", {
            class: "weui-slider-box__value"
        }, value));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "value": [
                "function"
            ]
        };
    }
    static get style() {
        return indexCss16;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onChanging = createEvent(this, "changing", 7);
        this.handleTouchStart = (e)=>{
            if (this.touching || this.disabled) return;
            this.touching = true;
            this.touchId = e.targetTouches[0].identifier;
            this.totalWidth = this.sliderInsRef.clientWidth || 1;
            this.ogX = e.targetTouches[0].pageX;
            this.ogPercent = this.percent;
        };
        this.handleTouchMove = (e)=>{
            const { disabled, touching, touchId, totalWidth, max, min, ogX, ogPercent } = this;
            if (!touching || disabled) return;
            if (e.targetTouches[0].identifier !== touchId) return;
            e.preventDefault();
            const pageX = e.targetTouches[0].pageX;
            const diffX = pageX - ogX;
            let percent = diffX / totalWidth * 100 + ogPercent;
            percent = this.handleValueUpdate(percent, 0, 100);
            const val = min + percent * 0.01 * (max - min);
            this.updateByStep(val);
            this.onChanging.emit({
                detail: e.detail,
                value: this.value
            });
        };
        this.handleTouchEnd = (e)=>{
            const { disabled, touching } = this;
            if (!touching || disabled) return;
            if (this.percent !== this.ogPercent) {
                this.onChange.emit({
                    detail: e.detail,
                    value: this.value
                });
            }
            this.touching = false;
            this.touchId = null;
            this.ogX = 0;
            this.ogPercent = 0;
        };
        this.handleValueUpdate = (e, min = this.min, max = this.max)=>{
            e = isNaN(e) ? 0 : e;
            return Math.max(min, Math.min(e, max));
        };
        this.min = 0;
        this.max = 100;
        this.step = 1;
        this.disabled = false;
        this.value = 0;
        this.activeColor = "#1aad19";
        this.backgroundColor = "#e9e9e9";
        this.blockSize = 28;
        this.blockColor = "#ffffff";
        this.showValue = false;
        this.name = "";
        this.totalWidth = 1;
        this.touching = false;
        this.ogX = 0;
        this.touchId = null;
        this.percent = 0;
        this.ogPercent = void 0;
        this.isWillLoadCalled = false;
    }
}, [
    0,
    "taro-slider-core",
    {
        "min": [
            2
        ],
        "max": [
            2
        ],
        "step": [
            2
        ],
        "disabled": [
            4
        ],
        "value": [
            1538
        ],
        "activeColor": [
            1,
            "active-color"
        ],
        "backgroundColor": [
            1,
            "background-color"
        ],
        "blockSize": [
            2,
            "block-size"
        ],
        "blockColor": [
            1,
            "block-color"
        ],
        "showValue": [
            4,
            "show-value"
        ],
        "name": [
            1
        ],
        "totalWidth": [
            32
        ],
        "touching": [
            32
        ],
        "ogX": [
            32
        ],
        "touchId": [
            32
        ],
        "percent": [
            32
        ],
        "ogPercent": [
            32
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$176() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-slider-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-slider-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Slider);
                }
                break;
        }
    });
}
var defineCustomElement80 = defineCustomElement$176;
// node_modules/@tarojs/components/dist/components/taro-slot-core.js
var Slot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Slot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-slot-core"
]);
function defineCustomElement$177() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-slot-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-slot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Slot);
                }
                break;
        }
    });
}
var defineCustomElement81 = defineCustomElement$177;
// node_modules/@tarojs/components/dist/components/taro-snapshot-core.js
var Snapshot = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Snapshot", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-snapshot-core"
]);
function defineCustomElement$178() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-snapshot-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-snapshot-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Snapshot);
                }
                break;
        }
    });
}
var defineCustomElement82 = defineCustomElement$178;
// node_modules/@tarojs/components/dist/components/taro-span-core.js
var Span = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Span", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-span-core"
]);
function defineCustomElement$179() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-span-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-span-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Span);
                }
                break;
        }
    });
}
var defineCustomElement83 = defineCustomElement$179;
// node_modules/@tarojs/components/dist/components/taro-sticky-header-core.js
var StickyHeader = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("StickyHeader", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-sticky-header-core"
]);
function defineCustomElement$180() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-sticky-header-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-sticky-header-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, StickyHeader);
                }
                break;
        }
    });
}
var defineCustomElement84 = defineCustomElement$180;
// node_modules/@tarojs/components/dist/components/taro-sticky-section-core.js
var StickySection = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("StickySection", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-sticky-section-core"
]);
function defineCustomElement$181() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-sticky-section-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-sticky-section-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, StickySection);
                }
                break;
        }
    });
}
var defineCustomElement85 = defineCustomElement$181;
// node_modules/swiper/shared/ssr-window.esm.mjs
function isObject4(obj) {
    return obj !== null && typeof obj === "object" && "constructor" in obj && obj.constructor === Object;
}
function extend(target, src) {
    if (target === void 0) {
        target = {};
    }
    if (src === void 0) {
        src = {};
    }
    Object.keys(src).forEach((key)=>{
        if (typeof target[key] === "undefined") target[key] = src[key];
        else if (isObject4(src[key]) && isObject4(target[key]) && Object.keys(src[key]).length > 0) {
            extend(target[key], src[key]);
        }
    });
}
var ssrDocument = {
    body: {},
    addEventListener () {},
    removeEventListener () {},
    activeElement: {
        blur () {},
        nodeName: ""
    },
    querySelector () {
        return null;
    },
    querySelectorAll () {
        return [];
    },
    getElementById () {
        return null;
    },
    createEvent () {
        return {
            initEvent () {}
        };
    },
    createElement () {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute () {},
            getElementsByTagName () {
                return [];
            }
        };
    },
    createElementNS () {
        return {};
    },
    importNode () {
        return null;
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    const doc3 = typeof document !== "undefined" ? document : {};
    extend(doc3, ssrDocument);
    return doc3;
}
var ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState () {},
        pushState () {},
        go () {},
        back () {}
    },
    CustomEvent: function CustomEvent2() {
        return this;
    },
    addEventListener () {},
    removeEventListener () {},
    getComputedStyle () {
        return {
            getPropertyValue () {
                return "";
            }
        };
    },
    Image () {},
    Date () {},
    screen: {},
    setTimeout () {},
    clearTimeout () {},
    matchMedia () {
        return {};
    },
    requestAnimationFrame (callback) {
        if (typeof setTimeout === "undefined") {
            callback();
            return null;
        }
        return setTimeout(callback, 0);
    },
    cancelAnimationFrame (id) {
        if (typeof setTimeout === "undefined") {
            return;
        }
        clearTimeout(id);
    }
};
function getWindow() {
    const win3 = typeof window !== "undefined" ? window : {};
    extend(win3, ssrWindow);
    return win3;
}
// node_modules/swiper/shared/utils.mjs
function classesToTokens(classes2) {
    if (classes2 === void 0) {
        classes2 = "";
    }
    return classes2.trim().split(" ").filter((c)=>!!c.trim());
}
function deleteProps(obj) {
    const object2 = obj;
    Object.keys(object2).forEach((key)=>{
        try {
            object2[key] = null;
        } catch (e) {}
        try {
            delete object2[key];
        } catch (e) {}
    });
}
function nextTick4(callback, delay) {
    if (delay === void 0) {
        delay = 0;
    }
    return setTimeout(callback, delay);
}
function now2() {
    return Date.now();
}
function getComputedStyle2(el) {
    const window2 = getWindow();
    let style;
    if (window2.getComputedStyle) {
        style = window2.getComputedStyle(el, null);
    }
    if (!style && el.currentStyle) {
        style = el.currentStyle;
    }
    if (!style) {
        style = el.style;
    }
    return style;
}
function getTranslate(el, axis) {
    if (axis === void 0) {
        axis = "x";
    }
    const window2 = getWindow();
    let matrix;
    let curTransform;
    let transformMatrix;
    const curStyle = getComputedStyle2(el);
    if (window2.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(",").length > 6) {
            curTransform = curTransform.split(", ").map((a)=>a.replace(",", ".")).join(", ");
        }
        transformMatrix = new window2.WebKitCSSMatrix(curTransform === "none" ? "" : curTransform);
    } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,");
        matrix = transformMatrix.toString().split(",");
    }
    if (axis === "x") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        else curTransform = parseFloat(matrix[4]);
    }
    if (axis === "y") {
        if (window2.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        else curTransform = parseFloat(matrix[5]);
    }
    return curTransform || 0;
}
function isObject5(o) {
    return typeof o === "object" && o !== null && o.constructor && Object.prototype.toString.call(o).slice(8, -1) === "Object";
}
function isNode(node) {
    if (typeof window !== "undefined" && typeof window.HTMLElement !== "undefined") {
        return node instanceof HTMLElement;
    }
    return node && (node.nodeType === 1 || node.nodeType === 11);
}
function extend2() {
    const to = Object(arguments.length <= 0 ? void 0 : arguments[0]);
    const noExtend = [
        "__proto__",
        "constructor",
        "prototype"
    ];
    for(let i2 = 1; i2 < arguments.length; i2 += 1){
        const nextSource = i2 < 0 || arguments.length <= i2 ? void 0 : arguments[i2];
        if (nextSource !== void 0 && nextSource !== null && !isNode(nextSource)) {
            const keysArray = Object.keys(Object(nextSource)).filter((key)=>noExtend.indexOf(key) < 0);
            for(let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1){
                const nextKey = keysArray[nextIndex];
                const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
                if (desc !== void 0 && desc.enumerable) {
                    if (isObject5(to[nextKey]) && isObject5(nextSource[nextKey])) {
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend2(to[nextKey], nextSource[nextKey]);
                        }
                    } else if (!isObject5(to[nextKey]) && isObject5(nextSource[nextKey])) {
                        to[nextKey] = {};
                        if (nextSource[nextKey].__swiper__) {
                            to[nextKey] = nextSource[nextKey];
                        } else {
                            extend2(to[nextKey], nextSource[nextKey]);
                        }
                    } else {
                        to[nextKey] = nextSource[nextKey];
                    }
                }
            }
        }
    }
    return to;
}
function setCSSProperty(el, varName, varValue) {
    el.style.setProperty(varName, varValue);
}
function animateCSSModeScroll(_ref) {
    let { swiper, targetPosition, side } = _ref;
    const window2 = getWindow();
    const startPosition = -swiper.translate;
    let startTime = null;
    let time;
    const duration = swiper.params.speed;
    swiper.wrapperEl.style.scrollSnapType = "none";
    window2.cancelAnimationFrame(swiper.cssModeFrameID);
    const dir = targetPosition > startPosition ? "next" : "prev";
    const isOutOfBound = (current, target)=>{
        return dir === "next" && current >= target || dir === "prev" && current <= target;
    };
    const animate = ()=>{
        time = /* @__PURE__ */ new Date().getTime();
        if (startTime === null) {
            startTime = time;
        }
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = 0.5 - Math.cos(progress * Math.PI) / 2;
        let currentPosition = startPosition + easeProgress * (targetPosition - startPosition);
        if (isOutOfBound(currentPosition, targetPosition)) {
            currentPosition = targetPosition;
        }
        swiper.wrapperEl.scrollTo({
            [side]: currentPosition
        });
        if (isOutOfBound(currentPosition, targetPosition)) {
            swiper.wrapperEl.style.overflow = "hidden";
            swiper.wrapperEl.style.scrollSnapType = "";
            setTimeout(()=>{
                swiper.wrapperEl.style.overflow = "";
                swiper.wrapperEl.scrollTo({
                    [side]: currentPosition
                });
            });
            window2.cancelAnimationFrame(swiper.cssModeFrameID);
            return;
        }
        swiper.cssModeFrameID = window2.requestAnimationFrame(animate);
    };
    animate();
}
function getSlideTransformEl(slideEl) {
    return slideEl.querySelector(".swiper-slide-transform") || slideEl.shadowRoot && slideEl.shadowRoot.querySelector(".swiper-slide-transform") || slideEl;
}
function elementChildren(element, selector) {
    if (selector === void 0) {
        selector = "";
    }
    const children = [
        ...element.children
    ];
    if (element instanceof HTMLSlotElement) {
        children.push(...element.assignedElements());
    }
    if (!selector) {
        return children;
    }
    return children.filter((el)=>el.matches(selector));
}
function elementIsChildOf(el, parent) {
    const isChild = parent.contains(el);
    if (!isChild && parent instanceof HTMLSlotElement) {
        const children = [
            ...parent.assignedElements()
        ];
        return children.includes(el);
    }
    return isChild;
}
function showWarning(text) {
    try {
        console.warn(text);
        return;
    } catch (err) {}
}
function createElement(tag, classes2) {
    if (classes2 === void 0) {
        classes2 = [];
    }
    const el = document.createElement(tag);
    el.classList.add(...Array.isArray(classes2) ? classes2 : classesToTokens(classes2));
    return el;
}
function elementOffset(el) {
    const window2 = getWindow();
    const document2 = getDocument();
    const box = el.getBoundingClientRect();
    const body = document2.body;
    const clientTop = el.clientTop || body.clientTop || 0;
    const clientLeft = el.clientLeft || body.clientLeft || 0;
    const scrollTop = el === window2 ? window2.scrollY : el.scrollTop;
    const scrollLeft = el === window2 ? window2.scrollX : el.scrollLeft;
    return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
    };
}
function elementPrevAll(el, selector) {
    const prevEls = [];
    while(el.previousElementSibling){
        const prev = el.previousElementSibling;
        if (selector) {
            if (prev.matches(selector)) prevEls.push(prev);
        } else prevEls.push(prev);
        el = prev;
    }
    return prevEls;
}
function elementNextAll(el, selector) {
    const nextEls = [];
    while(el.nextElementSibling){
        const next = el.nextElementSibling;
        if (selector) {
            if (next.matches(selector)) nextEls.push(next);
        } else nextEls.push(next);
        el = next;
    }
    return nextEls;
}
function elementStyle(el, prop) {
    const window2 = getWindow();
    return window2.getComputedStyle(el, null).getPropertyValue(prop);
}
function elementIndex(el) {
    let child = el;
    let i2;
    if (child) {
        i2 = 0;
        while((child = child.previousSibling) !== null){
            if (child.nodeType === 1) i2 += 1;
        }
        return i2;
    }
    return void 0;
}
function elementParents(el, selector) {
    const parents = [];
    let parent = el.parentElement;
    while(parent){
        if (selector) {
            if (parent.matches(selector)) parents.push(parent);
        } else {
            parents.push(parent);
        }
        parent = parent.parentElement;
    }
    return parents;
}
function elementTransitionEnd(el, callback) {
    function fireCallBack(e) {
        if (e.target !== el) return;
        callback.call(el, e);
        el.removeEventListener("transitionend", fireCallBack);
    }
    if (callback) {
        el.addEventListener("transitionend", fireCallBack);
    }
}
function elementOuterSize(el, size, includeMargins) {
    const window2 = getWindow();
    if (includeMargins) {
        return el[size === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-right" : "margin-top")) + parseFloat(window2.getComputedStyle(el, null).getPropertyValue(size === "width" ? "margin-left" : "margin-bottom"));
    }
    return el.offsetWidth;
}
function makeElementsArray(el) {
    return (Array.isArray(el) ? el : [
        el
    ]).filter((e)=>!!e);
}
function getRotateFix(swiper) {
    return (v)=>{
        if (Math.abs(v) > 0 && swiper.browser && swiper.browser.need3dFix && Math.abs(v) % 90 === 0) {
            return v + 1e-3;
        }
        return v;
    };
}
// node_modules/swiper/shared/swiper-core.mjs
var support2;
function calcSupport() {
    const window2 = getWindow();
    const document2 = getDocument();
    return {
        smoothScroll: document2.documentElement && document2.documentElement.style && "scrollBehavior" in document2.documentElement.style,
        touch: !!("ontouchstart" in window2 || window2.DocumentTouch && document2 instanceof window2.DocumentTouch)
    };
}
function getSupport() {
    if (!support2) {
        support2 = calcSupport();
    }
    return support2;
}
var deviceCached;
function calcDevice(_temp) {
    let { userAgent } = _temp === void 0 ? {} : _temp;
    const support3 = getSupport();
    const window2 = getWindow();
    const platform2 = window2.navigator.platform;
    const ua = userAgent || window2.navigator.userAgent;
    const device = {
        ios: false,
        android: false
    };
    const screenWidth = window2.screen.width;
    const screenHeight = window2.screen.height;
    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const windows = platform2 === "Win32";
    let macos = platform2 === "MacIntel";
    const iPadScreens = [
        "1024x1366",
        "1366x1024",
        "834x1194",
        "1194x834",
        "834x1112",
        "1112x834",
        "768x1024",
        "1024x768",
        "820x1180",
        "1180x820",
        "810x1080",
        "1080x810"
    ];
    if (!ipad && macos && support3.touch && iPadScreens.indexOf(`${screenWidth}x${screenHeight}`) >= 0) {
        ipad = ua.match(/(Version)\/([\d.]+)/);
        if (!ipad) ipad = [
            0,
            1,
            "13_0_0"
        ];
        macos = false;
    }
    if (android && !windows) {
        device.os = "android";
        device.android = true;
    }
    if (ipad || iphone || ipod) {
        device.os = "ios";
        device.ios = true;
    }
    return device;
}
function getDevice(overrides) {
    if (overrides === void 0) {
        overrides = {};
    }
    if (!deviceCached) {
        deviceCached = calcDevice(overrides);
    }
    return deviceCached;
}
var browser;
function calcBrowser() {
    const window2 = getWindow();
    const device = getDevice();
    let needPerspectiveFix = false;
    function isSafari() {
        const ua = window2.navigator.userAgent.toLowerCase();
        return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0;
    }
    if (isSafari()) {
        const ua = String(window2.navigator.userAgent);
        if (ua.includes("Version/")) {
            const [major, minor] = ua.split("Version/")[1].split(" ")[0].split(".").map((num)=>Number(num));
            needPerspectiveFix = major < 16 || major === 16 && minor < 2;
        }
    }
    const isWebView2 = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(window2.navigator.userAgent);
    const isSafariBrowser = isSafari();
    const need3dFix = isSafariBrowser || isWebView2 && device.ios;
    return {
        isSafari: needPerspectiveFix || isSafariBrowser,
        needPerspectiveFix,
        need3dFix,
        isWebView: isWebView2
    };
}
function getBrowser() {
    if (!browser) {
        browser = calcBrowser();
    }
    return browser;
}
function Resize(_ref) {
    let { swiper, on, emit } = _ref;
    const window2 = getWindow();
    let observer = null;
    let animationFrame = null;
    const resizeHandler = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit("beforeResize");
        emit("resize");
    };
    const createObserver = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        observer = new ResizeObserver((entries)=>{
            animationFrame = window2.requestAnimationFrame(()=>{
                const { width, height } = swiper;
                let newWidth = width;
                let newHeight = height;
                entries.forEach((_ref2)=>{
                    let { contentBoxSize, contentRect, target } = _ref2;
                    if (target && target !== swiper.el) return;
                    newWidth = contentRect ? contentRect.width : (contentBoxSize[0] || contentBoxSize).inlineSize;
                    newHeight = contentRect ? contentRect.height : (contentBoxSize[0] || contentBoxSize).blockSize;
                });
                if (newWidth !== width || newHeight !== height) {
                    resizeHandler();
                }
            });
        });
        observer.observe(swiper.el);
    };
    const removeObserver = ()=>{
        if (animationFrame) {
            window2.cancelAnimationFrame(animationFrame);
        }
        if (observer && observer.unobserve && swiper.el) {
            observer.unobserve(swiper.el);
            observer = null;
        }
    };
    const orientationChangeHandler = ()=>{
        if (!swiper || swiper.destroyed || !swiper.initialized) return;
        emit("orientationchange");
    };
    on("init", ()=>{
        if (swiper.params.resizeObserver && typeof window2.ResizeObserver !== "undefined") {
            createObserver();
            return;
        }
        window2.addEventListener("resize", resizeHandler);
        window2.addEventListener("orientationchange", orientationChangeHandler);
    });
    on("destroy", ()=>{
        removeObserver();
        window2.removeEventListener("resize", resizeHandler);
        window2.removeEventListener("orientationchange", orientationChangeHandler);
    });
}
function Observer(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const observers = [];
    const window2 = getWindow();
    const attach = function(target, options3) {
        if (options3 === void 0) {
            options3 = {};
        }
        const ObserverFunc = window2.MutationObserver || window2.WebkitMutationObserver;
        const observer = new ObserverFunc((mutations)=>{
            if (swiper.__preventObserver__) return;
            if (mutations.length === 1) {
                emit("observerUpdate", mutations[0]);
                return;
            }
            const observerUpdate = function observerUpdate2() {
                emit("observerUpdate", mutations[0]);
            };
            if (window2.requestAnimationFrame) {
                window2.requestAnimationFrame(observerUpdate);
            } else {
                window2.setTimeout(observerUpdate, 0);
            }
        });
        observer.observe(target, {
            attributes: typeof options3.attributes === "undefined" ? true : options3.attributes,
            childList: swiper.isElement || (typeof options3.childList === "undefined" ? true : options3).childList,
            characterData: typeof options3.characterData === "undefined" ? true : options3.characterData
        });
        observers.push(observer);
    };
    const init2 = ()=>{
        if (!swiper.params.observer) return;
        if (swiper.params.observeParents) {
            const containerParents = elementParents(swiper.hostEl);
            for(let i2 = 0; i2 < containerParents.length; i2 += 1){
                attach(containerParents[i2]);
            }
        }
        attach(swiper.hostEl, {
            childList: swiper.params.observeSlideChildren
        });
        attach(swiper.wrapperEl, {
            attributes: false
        });
    };
    const destroy = ()=>{
        observers.forEach((observer)=>{
            observer.disconnect();
        });
        observers.splice(0, observers.length);
    };
    extendParams({
        observer: false,
        observeParents: false,
        observeSlideChildren: false
    });
    on("init", init2);
    on("destroy", destroy);
}
var eventsEmitter = {
    on (events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        const method = priority ? "unshift" : "push";
        events2.split(" ").forEach((event2)=>{
            if (!self2.eventsListeners[event2]) self2.eventsListeners[event2] = [];
            self2.eventsListeners[event2][method](handler);
        });
        return self2;
    },
    once (events2, handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        function onceHandler() {
            self2.off(events2, onceHandler);
            if (onceHandler.__emitterProxy) {
                delete onceHandler.__emitterProxy;
            }
            for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                args[_key] = arguments[_key];
            }
            handler.apply(self2, args);
        }
        onceHandler.__emitterProxy = handler;
        return self2.on(events2, onceHandler, priority);
    },
    onAny (handler, priority) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (typeof handler !== "function") return self2;
        const method = priority ? "unshift" : "push";
        if (self2.eventsAnyListeners.indexOf(handler) < 0) {
            self2.eventsAnyListeners[method](handler);
        }
        return self2;
    },
    offAny (handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsAnyListeners) return self2;
        const index = self2.eventsAnyListeners.indexOf(handler);
        if (index >= 0) {
            self2.eventsAnyListeners.splice(index, 1);
        }
        return self2;
    },
    off (events2, handler) {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsListeners) return self2;
        events2.split(" ").forEach((event2)=>{
            if (typeof handler === "undefined") {
                self2.eventsListeners[event2] = [];
            } else if (self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach((eventHandler, index)=>{
                    if (eventHandler === handler || eventHandler.__emitterProxy && eventHandler.__emitterProxy === handler) {
                        self2.eventsListeners[event2].splice(index, 1);
                    }
                });
            }
        });
        return self2;
    },
    emit () {
        const self2 = this;
        if (!self2.eventsListeners || self2.destroyed) return self2;
        if (!self2.eventsListeners) return self2;
        let events2;
        let data;
        let context;
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        if (typeof args[0] === "string" || Array.isArray(args[0])) {
            events2 = args[0];
            data = args.slice(1, args.length);
            context = self2;
        } else {
            events2 = args[0].events;
            data = args[0].data;
            context = args[0].context || self2;
        }
        data.unshift(context);
        const eventsArray = Array.isArray(events2) ? events2 : events2.split(" ");
        eventsArray.forEach((event2)=>{
            if (self2.eventsAnyListeners && self2.eventsAnyListeners.length) {
                self2.eventsAnyListeners.forEach((eventHandler)=>{
                    eventHandler.apply(context, [
                        event2,
                        ...data
                    ]);
                });
            }
            if (self2.eventsListeners && self2.eventsListeners[event2]) {
                self2.eventsListeners[event2].forEach((eventHandler)=>{
                    eventHandler.apply(context, data);
                });
            }
        });
        return self2;
    }
};
function updateSize() {
    const swiper = this;
    let width;
    let height;
    const el = swiper.el;
    if (typeof swiper.params.width !== "undefined" && swiper.params.width !== null) {
        width = swiper.params.width;
    } else {
        width = el.clientWidth;
    }
    if (typeof swiper.params.height !== "undefined" && swiper.params.height !== null) {
        height = swiper.params.height;
    } else {
        height = el.clientHeight;
    }
    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
        return;
    }
    width = width - parseInt(elementStyle(el, "padding-left") || 0, 10) - parseInt(elementStyle(el, "padding-right") || 0, 10);
    height = height - parseInt(elementStyle(el, "padding-top") || 0, 10) - parseInt(elementStyle(el, "padding-bottom") || 0, 10);
    if (Number.isNaN(width)) width = 0;
    if (Number.isNaN(height)) height = 0;
    Object.assign(swiper, {
        width,
        height,
        size: swiper.isHorizontal() ? width : height
    });
}
function updateSlides() {
    const swiper = this;
    function getDirectionPropertyValue(node, label) {
        return parseFloat(node.getPropertyValue(swiper.getDirectionLabel(label)) || 0);
    }
    const params = swiper.params;
    const { wrapperEl, slidesEl, size: swiperSize, rtlTranslate: rtl, wrongRTL } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = elementChildren(slidesEl, `.${swiper.params.slideClass}, swiper-slide`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];
    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === "function") {
        offsetBefore = params.slidesOffsetBefore.call(swiper);
    }
    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === "function") {
        offsetAfter = params.slidesOffsetAfter.call(swiper);
    }
    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.slidesGrid.length;
    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === "undefined") {
        return;
    }
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiperSize;
    } else if (typeof spaceBetween === "string") {
        spaceBetween = parseFloat(spaceBetween);
    }
    swiper.virtualSize = -spaceBetween;
    slides.forEach((slideEl)=>{
        if (rtl) {
            slideEl.style.marginLeft = "";
        } else {
            slideEl.style.marginRight = "";
        }
        slideEl.style.marginBottom = "";
        slideEl.style.marginTop = "";
    });
    if (params.centeredSlides && params.cssMode) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", "");
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", "");
    }
    const gridEnabled = params.grid && params.grid.rows > 1 && swiper.grid;
    if (gridEnabled) {
        swiper.grid.initSlides(slides);
    } else if (swiper.grid) {
        swiper.grid.unsetSlides();
    }
    let slideSize;
    const shouldResetSlideSize = params.slidesPerView === "auto" && params.breakpoints && Object.keys(params.breakpoints).filter((key)=>{
        return typeof params.breakpoints[key].slidesPerView !== "undefined";
    }).length > 0;
    for(let i2 = 0; i2 < slidesLength; i2 += 1){
        slideSize = 0;
        let slide2;
        if (slides[i2]) slide2 = slides[i2];
        if (gridEnabled) {
            swiper.grid.updateSlide(i2, slide2, slides);
        }
        if (slides[i2] && elementStyle(slide2, "display") === "none") continue;
        if (params.slidesPerView === "auto") {
            if (shouldResetSlideSize) {
                slides[i2].style[swiper.getDirectionLabel("width")] = ``;
            }
            const slideStyles = getComputedStyle(slide2);
            const currentTransform = slide2.style.transform;
            const currentWebKitTransform = slide2.style.webkitTransform;
            if (currentTransform) {
                slide2.style.transform = "none";
            }
            if (currentWebKitTransform) {
                slide2.style.webkitTransform = "none";
            }
            if (params.roundLengths) {
                slideSize = swiper.isHorizontal() ? elementOuterSize(slide2, "width", true) : elementOuterSize(slide2, "height", true);
            } else {
                const width = getDirectionPropertyValue(slideStyles, "width");
                const paddingLeft = getDirectionPropertyValue(slideStyles, "padding-left");
                const paddingRight = getDirectionPropertyValue(slideStyles, "padding-right");
                const marginLeft = getDirectionPropertyValue(slideStyles, "margin-left");
                const marginRight = getDirectionPropertyValue(slideStyles, "margin-right");
                const boxSizing = slideStyles.getPropertyValue("box-sizing");
                if (boxSizing && boxSizing === "border-box") {
                    slideSize = width + marginLeft + marginRight;
                } else {
                    const { clientWidth, offsetWidth } = slide2;
                    slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight + (offsetWidth - clientWidth);
                }
            }
            if (currentTransform) {
                slide2.style.transform = currentTransform;
            }
            if (currentWebKitTransform) {
                slide2.style.webkitTransform = currentWebKitTransform;
            }
            if (params.roundLengths) slideSize = Math.floor(slideSize);
        } else {
            slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;
            if (params.roundLengths) slideSize = Math.floor(slideSize);
            if (slides[i2]) {
                slides[i2].style[swiper.getDirectionLabel("width")] = `${slideSize}px`;
            }
        }
        if (slides[i2]) {
            slides[i2].swiperSlideSize = slideSize;
        }
        slidesSizesGrid.push(slideSize);
        if (params.centeredSlides) {
            slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;
            if (prevSlideSize === 0 && i2 !== 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (i2 === 0) slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
            if (Math.abs(slidePosition) < 1 / 1e3) slidePosition = 0;
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if (index % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
        } else {
            if (params.roundLengths) slidePosition = Math.floor(slidePosition);
            if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
            slidesGrid.push(slidePosition);
            slidePosition = slidePosition + slideSize + spaceBetween;
        }
        swiper.virtualSize += slideSize + spaceBetween;
        prevSlideSize = slideSize;
        index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    if (rtl && wrongRTL && (params.effect === "slide" || params.effect === "coverflow")) {
        wrapperEl.style.width = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (params.setWrapperSize) {
        wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
    }
    if (gridEnabled) {
        swiper.grid.updateWrapperSize(slideSize, snapGrid);
    }
    if (!params.centeredSlides) {
        const newSlidesGrid = [];
        for(let i2 = 0; i2 < snapGrid.length; i2 += 1){
            let slidesGridItem = snapGrid[i2];
            if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
            if (snapGrid[i2] <= swiper.virtualSize - swiperSize) {
                newSlidesGrid.push(slidesGridItem);
            }
        }
        snapGrid = newSlidesGrid;
        if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
            snapGrid.push(swiper.virtualSize - swiperSize);
        }
    }
    if (isVirtual && params.loop) {
        const size = slidesSizesGrid[0] + spaceBetween;
        if (params.slidesPerGroup > 1) {
            const groups = Math.ceil((swiper.virtual.slidesBefore + swiper.virtual.slidesAfter) / params.slidesPerGroup);
            const groupSize = size * params.slidesPerGroup;
            for(let i2 = 0; i2 < groups; i2 += 1){
                snapGrid.push(snapGrid[snapGrid.length - 1] + groupSize);
            }
        }
        for(let i2 = 0; i2 < swiper.virtual.slidesBefore + swiper.virtual.slidesAfter; i2 += 1){
            if (params.slidesPerGroup === 1) {
                snapGrid.push(snapGrid[snapGrid.length - 1] + size);
            }
            slidesGrid.push(slidesGrid[slidesGrid.length - 1] + size);
            swiper.virtualSize += size;
        }
    }
    if (snapGrid.length === 0) snapGrid = [
        0
    ];
    if (spaceBetween !== 0) {
        const key = swiper.isHorizontal() && rtl ? "marginLeft" : swiper.getDirectionLabel("marginRight");
        slides.filter((_, slideIndex)=>{
            if (!params.cssMode || params.loop) return true;
            if (slideIndex === slides.length - 1) {
                return false;
            }
            return true;
        }).forEach((slideEl)=>{
            slideEl.style[key] = `${spaceBetween}px`;
        });
    }
    if (params.centeredSlides && params.centeredSlidesBounds) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue)=>{
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        const maxSnap = allSlidesSize > swiperSize ? allSlidesSize - swiperSize : 0;
        snapGrid = snapGrid.map((snap)=>{
            if (snap <= 0) return -offsetBefore;
            if (snap > maxSnap) return maxSnap + offsetAfter;
            return snap;
        });
    }
    if (params.centerInsufficientSlides) {
        let allSlidesSize = 0;
        slidesSizesGrid.forEach((slideSizeValue)=>{
            allSlidesSize += slideSizeValue + (spaceBetween || 0);
        });
        allSlidesSize -= spaceBetween;
        const offsetSize = (params.slidesOffsetBefore || 0) + (params.slidesOffsetAfter || 0);
        if (allSlidesSize + offsetSize < swiperSize) {
            const allSlidesOffset = (swiperSize - allSlidesSize - offsetSize) / 2;
            snapGrid.forEach((snap, snapIndex)=>{
                snapGrid[snapIndex] = snap - allSlidesOffset;
            });
            slidesGrid.forEach((snap, snapIndex)=>{
                slidesGrid[snapIndex] = snap + allSlidesOffset;
            });
        }
    }
    Object.assign(swiper, {
        slides,
        snapGrid,
        slidesGrid,
        slidesSizesGrid
    });
    if (params.centeredSlides && params.cssMode && !params.centeredSlidesBounds) {
        setCSSProperty(wrapperEl, "--swiper-centered-offset-before", `${-snapGrid[0]}px`);
        setCSSProperty(wrapperEl, "--swiper-centered-offset-after", `${swiper.size / 2 - slidesSizesGrid[slidesSizesGrid.length - 1] / 2}px`);
        const addToSnapGrid = -swiper.snapGrid[0];
        const addToSlidesGrid = -swiper.slidesGrid[0];
        swiper.snapGrid = swiper.snapGrid.map((v)=>v + addToSnapGrid);
        swiper.slidesGrid = swiper.slidesGrid.map((v)=>v + addToSlidesGrid);
    }
    if (slidesLength !== previousSlidesLength) {
        swiper.emit("slidesLengthChange");
    }
    if (snapGrid.length !== previousSnapGridLength) {
        if (swiper.params.watchOverflow) swiper.checkOverflow();
        swiper.emit("snapGridLengthChange");
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
        swiper.emit("slidesGridLengthChange");
    }
    if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
    }
    swiper.emit("slidesUpdated");
    if (!isVirtual && !params.cssMode && (params.effect === "slide" || params.effect === "fade")) {
        const backFaceHiddenClass = `${params.containerModifierClass}backface-hidden`;
        const hasClassBackfaceClassAdded = swiper.el.classList.contains(backFaceHiddenClass);
        if (slidesLength <= params.maxBackfaceHiddenSlides) {
            if (!hasClassBackfaceClassAdded) swiper.el.classList.add(backFaceHiddenClass);
        } else if (hasClassBackfaceClassAdded) {
            swiper.el.classList.remove(backFaceHiddenClass);
        }
    }
}
function updateAutoHeight(speed) {
    const swiper = this;
    const activeSlides = [];
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    let newHeight = 0;
    let i2;
    if (typeof speed === "number") {
        swiper.setTransition(speed);
    } else if (speed === true) {
        swiper.setTransition(swiper.params.speed);
    }
    const getSlideByIndex = (index)=>{
        if (isVirtual) {
            return swiper.slides[swiper.getSlideIndexByData(index)];
        }
        return swiper.slides[index];
    };
    if (swiper.params.slidesPerView !== "auto" && swiper.params.slidesPerView > 1) {
        if (swiper.params.centeredSlides) {
            (swiper.visibleSlides || []).forEach((slide2)=>{
                activeSlides.push(slide2);
            });
        } else {
            for(i2 = 0; i2 < Math.ceil(swiper.params.slidesPerView); i2 += 1){
                const index = swiper.activeIndex + i2;
                if (index > swiper.slides.length && !isVirtual) break;
                activeSlides.push(getSlideByIndex(index));
            }
        }
    } else {
        activeSlides.push(getSlideByIndex(swiper.activeIndex));
    }
    for(i2 = 0; i2 < activeSlides.length; i2 += 1){
        if (typeof activeSlides[i2] !== "undefined") {
            const height = activeSlides[i2].offsetHeight;
            newHeight = height > newHeight ? height : newHeight;
        }
    }
    if (newHeight || newHeight === 0) swiper.wrapperEl.style.height = `${newHeight}px`;
}
function updateSlidesOffset() {
    const swiper = this;
    const slides = swiper.slides;
    const minusOffset = swiper.isElement ? swiper.isHorizontal() ? swiper.wrapperEl.offsetLeft : swiper.wrapperEl.offsetTop : 0;
    for(let i2 = 0; i2 < slides.length; i2 += 1){
        slides[i2].swiperSlideOffset = (swiper.isHorizontal() ? slides[i2].offsetLeft : slides[i2].offsetTop) - minusOffset - swiper.cssOverflowAdjustment();
    }
}
var toggleSlideClasses$1 = (slideEl, condition, className)=>{
    if (condition && !slideEl.classList.contains(className)) {
        slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
        slideEl.classList.remove(className);
    }
};
function updateSlidesProgress(translate2) {
    if (translate2 === void 0) {
        translate2 = this && this.translate || 0;
    }
    const swiper = this;
    const params = swiper.params;
    const { slides, rtlTranslate: rtl, snapGrid } = swiper;
    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === "undefined") swiper.updateSlidesOffset();
    let offsetCenter = -translate2;
    if (rtl) offsetCenter = translate2;
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];
    let spaceBetween = params.spaceBetween;
    if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
        spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
    } else if (typeof spaceBetween === "string") {
        spaceBetween = parseFloat(spaceBetween);
    }
    for(let i2 = 0; i2 < slides.length; i2 += 1){
        const slide2 = slides[i2];
        let slideOffset = slide2.swiperSlideOffset;
        if (params.cssMode && params.centeredSlides) {
            slideOffset -= slides[0].swiperSlideOffset;
        }
        const slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const originalSlideProgress = (offsetCenter - snapGrid[0] + (params.centeredSlides ? swiper.minTranslate() : 0) - slideOffset) / (slide2.swiperSlideSize + spaceBetween);
        const slideBefore = -(offsetCenter - slideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i2];
        const isFullyVisible = slideBefore >= 0 && slideBefore <= swiper.size - swiper.slidesSizesGrid[i2];
        const isVisible2 = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;
        if (isVisible2) {
            swiper.visibleSlides.push(slide2);
            swiper.visibleSlidesIndexes.push(i2);
        }
        toggleSlideClasses$1(slide2, isVisible2, params.slideVisibleClass);
        toggleSlideClasses$1(slide2, isFullyVisible, params.slideFullyVisibleClass);
        slide2.progress = rtl ? -slideProgress : slideProgress;
        slide2.originalProgress = rtl ? -originalSlideProgress : originalSlideProgress;
    }
}
function updateProgress(translate2) {
    const swiper = this;
    if (typeof translate2 === "undefined") {
        const multiplier = swiper.rtlTranslate ? -1 : 1;
        translate2 = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let { progress, isBeginning, isEnd, progressLoop } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
        progress = 0;
        isBeginning = true;
        isEnd = true;
    } else {
        progress = (translate2 - swiper.minTranslate()) / translatesDiff;
        const isBeginningRounded = Math.abs(translate2 - swiper.minTranslate()) < 1;
        const isEndRounded = Math.abs(translate2 - swiper.maxTranslate()) < 1;
        isBeginning = isBeginningRounded || progress <= 0;
        isEnd = isEndRounded || progress >= 1;
        if (isBeginningRounded) progress = 0;
        if (isEndRounded) progress = 1;
    }
    if (params.loop) {
        const firstSlideIndex = swiper.getSlideIndexByData(0);
        const lastSlideIndex = swiper.getSlideIndexByData(swiper.slides.length - 1);
        const firstSlideTranslate = swiper.slidesGrid[firstSlideIndex];
        const lastSlideTranslate = swiper.slidesGrid[lastSlideIndex];
        const translateMax = swiper.slidesGrid[swiper.slidesGrid.length - 1];
        const translateAbs = Math.abs(translate2);
        if (translateAbs >= firstSlideTranslate) {
            progressLoop = (translateAbs - firstSlideTranslate) / translateMax;
        } else {
            progressLoop = (translateAbs + translateMax - lastSlideTranslate) / translateMax;
        }
        if (progressLoop > 1) progressLoop -= 1;
    }
    Object.assign(swiper, {
        progress,
        progressLoop,
        isBeginning,
        isEnd
    });
    if (params.watchSlidesProgress || params.centeredSlides && params.autoHeight) swiper.updateSlidesProgress(translate2);
    if (isBeginning && !wasBeginning) {
        swiper.emit("reachBeginning toEdge");
    }
    if (isEnd && !wasEnd) {
        swiper.emit("reachEnd toEdge");
    }
    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
        swiper.emit("fromEdge");
    }
    swiper.emit("progress", progress);
}
var toggleSlideClasses = (slideEl, condition, className)=>{
    if (condition && !slideEl.classList.contains(className)) {
        slideEl.classList.add(className);
    } else if (!condition && slideEl.classList.contains(className)) {
        slideEl.classList.remove(className);
    }
};
function updateSlidesClasses() {
    const swiper = this;
    const { slides, params, slidesEl, activeIndex } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const getFilteredSlide = (selector)=>{
        return elementChildren(slidesEl, `.${params.slideClass}${selector}, swiper-slide${selector}`)[0];
    };
    let activeSlide;
    let prevSlide;
    let nextSlide;
    if (isVirtual) {
        if (params.loop) {
            let slideIndex = activeIndex - swiper.virtual.slidesBefore;
            if (slideIndex < 0) slideIndex = swiper.virtual.slides.length + slideIndex;
            if (slideIndex >= swiper.virtual.slides.length) slideIndex -= swiper.virtual.slides.length;
            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${slideIndex}"]`);
        } else {
            activeSlide = getFilteredSlide(`[data-swiper-slide-index="${activeIndex}"]`);
        }
    } else {
        if (gridEnabled) {
            activeSlide = slides.filter((slideEl)=>slideEl.column === activeIndex)[0];
            nextSlide = slides.filter((slideEl)=>slideEl.column === activeIndex + 1)[0];
            prevSlide = slides.filter((slideEl)=>slideEl.column === activeIndex - 1)[0];
        } else {
            activeSlide = slides[activeIndex];
        }
    }
    if (activeSlide) {
        if (!gridEnabled) {
            nextSlide = elementNextAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
            if (params.loop && !nextSlide) {
                nextSlide = slides[0];
            }
            prevSlide = elementPrevAll(activeSlide, `.${params.slideClass}, swiper-slide`)[0];
            if (params.loop && !prevSlide === 0) {
                prevSlide = slides[slides.length - 1];
            }
        }
    }
    slides.forEach((slideEl)=>{
        toggleSlideClasses(slideEl, slideEl === activeSlide, params.slideActiveClass);
        toggleSlideClasses(slideEl, slideEl === nextSlide, params.slideNextClass);
        toggleSlideClasses(slideEl, slideEl === prevSlide, params.slidePrevClass);
    });
    swiper.emitSlidesClasses();
}
var processLazyPreloader = (swiper, imageEl)=>{
    if (!swiper || swiper.destroyed || !swiper.params) return;
    const slideSelector = ()=>swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    const slideEl = imageEl.closest(slideSelector());
    if (slideEl) {
        let lazyEl = slideEl.querySelector(`.${swiper.params.lazyPreloaderClass}`);
        if (!lazyEl && swiper.isElement) {
            if (slideEl.shadowRoot) {
                lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
            } else {
                requestAnimationFrame(()=>{
                    if (slideEl.shadowRoot) {
                        lazyEl = slideEl.shadowRoot.querySelector(`.${swiper.params.lazyPreloaderClass}`);
                        if (lazyEl) lazyEl.remove();
                    }
                });
            }
        }
        if (lazyEl) lazyEl.remove();
    }
};
var unlazy = (swiper, index)=>{
    if (!swiper.slides[index]) return;
    const imageEl = swiper.slides[index].querySelector('[loading="lazy"]');
    if (imageEl) imageEl.removeAttribute("loading");
};
var preload2 = (swiper)=>{
    if (!swiper || swiper.destroyed || !swiper.params) return;
    let amount = swiper.params.lazyPreloadPrevNext;
    const len = swiper.slides.length;
    if (!len || !amount || amount < 0) return;
    amount = Math.min(amount, len);
    const slidesPerView = swiper.params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(swiper.params.slidesPerView);
    const activeIndex = swiper.activeIndex;
    if (swiper.params.grid && swiper.params.grid.rows > 1) {
        const activeColumn = activeIndex;
        const preloadColumns = [
            activeColumn - amount
        ];
        preloadColumns.push(...Array.from({
            length: amount
        }).map((_, i2)=>{
            return activeColumn + slidesPerView + i2;
        }));
        swiper.slides.forEach((slideEl, i2)=>{
            if (preloadColumns.includes(slideEl.column)) unlazy(swiper, i2);
        });
        return;
    }
    const slideIndexLastInView = activeIndex + slidesPerView - 1;
    if (swiper.params.rewind || swiper.params.loop) {
        for(let i2 = activeIndex - amount; i2 <= slideIndexLastInView + amount; i2 += 1){
            const realIndex = (i2 % len + len) % len;
            if (realIndex < activeIndex || realIndex > slideIndexLastInView) unlazy(swiper, realIndex);
        }
    } else {
        for(let i2 = Math.max(activeIndex - amount, 0); i2 <= Math.min(slideIndexLastInView + amount, len - 1); i2 += 1){
            if (i2 !== activeIndex && (i2 > slideIndexLastInView || i2 < activeIndex)) {
                unlazy(swiper, i2);
            }
        }
    }
};
function getActiveIndexByTranslate(swiper) {
    const { slidesGrid, params } = swiper;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    let activeIndex;
    for(let i2 = 0; i2 < slidesGrid.length; i2 += 1){
        if (typeof slidesGrid[i2 + 1] !== "undefined") {
            if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1] - (slidesGrid[i2 + 1] - slidesGrid[i2]) / 2) {
                activeIndex = i2;
            } else if (translate2 >= slidesGrid[i2] && translate2 < slidesGrid[i2 + 1]) {
                activeIndex = i2 + 1;
            }
        } else if (translate2 >= slidesGrid[i2]) {
            activeIndex = i2;
        }
    }
    if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === "undefined") activeIndex = 0;
    }
    return activeIndex;
}
function updateActiveIndex(newActiveIndex) {
    const swiper = this;
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const { snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    const getVirtualRealIndex = (aIndex)=>{
        let realIndex2 = aIndex - swiper.virtual.slidesBefore;
        if (realIndex2 < 0) {
            realIndex2 = swiper.virtual.slides.length + realIndex2;
        }
        if (realIndex2 >= swiper.virtual.slides.length) {
            realIndex2 -= swiper.virtual.slides.length;
        }
        return realIndex2;
    };
    if (typeof activeIndex === "undefined") {
        activeIndex = getActiveIndexByTranslate(swiper);
    }
    if (snapGrid.indexOf(translate2) >= 0) {
        snapIndex = snapGrid.indexOf(translate2);
    } else {
        const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
        snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex && !swiper.params.loop) {
        if (snapIndex !== previousSnapIndex) {
            swiper.snapIndex = snapIndex;
            swiper.emit("snapIndexChange");
        }
        return;
    }
    if (activeIndex === previousIndex && swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
        swiper.realIndex = getVirtualRealIndex(activeIndex);
        return;
    }
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    let realIndex;
    if (swiper.virtual && params.virtual.enabled && params.loop) {
        realIndex = getVirtualRealIndex(activeIndex);
    } else if (gridEnabled) {
        const firstSlideInColumn = swiper.slides.filter((slideEl)=>slideEl.column === activeIndex)[0];
        let activeSlideIndex = parseInt(firstSlideInColumn.getAttribute("data-swiper-slide-index"), 10);
        if (Number.isNaN(activeSlideIndex)) {
            activeSlideIndex = Math.max(swiper.slides.indexOf(firstSlideInColumn), 0);
        }
        realIndex = Math.floor(activeSlideIndex / params.grid.rows);
    } else if (swiper.slides[activeIndex]) {
        const slideIndex = swiper.slides[activeIndex].getAttribute("data-swiper-slide-index");
        if (slideIndex) {
            realIndex = parseInt(slideIndex, 10);
        } else {
            realIndex = activeIndex;
        }
    } else {
        realIndex = activeIndex;
    }
    Object.assign(swiper, {
        previousSnapIndex,
        snapIndex,
        previousRealIndex,
        realIndex,
        previousIndex,
        activeIndex
    });
    if (swiper.initialized) {
        preload2(swiper);
    }
    swiper.emit("activeIndexChange");
    swiper.emit("snapIndexChange");
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
        if (previousRealIndex !== realIndex) {
            swiper.emit("realIndexChange");
        }
        swiper.emit("slideChange");
    }
}
function updateClickedSlide(el, path) {
    const swiper = this;
    const params = swiper.params;
    let slide2 = el.closest(`.${params.slideClass}, swiper-slide`);
    if (!slide2 && swiper.isElement && path && path.length > 1 && path.includes(el)) {
        [
            ...path.slice(path.indexOf(el) + 1, path.length)
        ].forEach((pathEl)=>{
            if (!slide2 && pathEl.matches && pathEl.matches(`.${params.slideClass}, swiper-slide`)) {
                slide2 = pathEl;
            }
        });
    }
    let slideFound = false;
    let slideIndex;
    if (slide2) {
        for(let i2 = 0; i2 < swiper.slides.length; i2 += 1){
            if (swiper.slides[i2] === slide2) {
                slideFound = true;
                slideIndex = i2;
                break;
            }
        }
    }
    if (slide2 && slideFound) {
        swiper.clickedSlide = slide2;
        if (swiper.virtual && swiper.params.virtual.enabled) {
            swiper.clickedIndex = parseInt(slide2.getAttribute("data-swiper-slide-index"), 10);
        } else {
            swiper.clickedIndex = slideIndex;
        }
    } else {
        swiper.clickedSlide = void 0;
        swiper.clickedIndex = void 0;
        return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== void 0 && swiper.clickedIndex !== swiper.activeIndex) {
        swiper.slideToClickedSlide();
    }
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(axis) {
    if (axis === void 0) {
        axis = this.isHorizontal() ? "x" : "y";
    }
    const swiper = this;
    const { params, rtlTranslate: rtl, translate: translate2, wrapperEl } = swiper;
    if (params.virtualTranslate) {
        return rtl ? -translate2 : translate2;
    }
    if (params.cssMode) {
        return translate2;
    }
    let currentTranslate = getTranslate(wrapperEl, axis);
    currentTranslate += swiper.cssOverflowAdjustment();
    if (rtl) currentTranslate = -currentTranslate;
    return currentTranslate || 0;
}
function setTranslate(translate2, byController) {
    const swiper = this;
    const { rtlTranslate: rtl, params, wrapperEl, progress } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;
    if (swiper.isHorizontal()) {
        x = rtl ? -translate2 : translate2;
    } else {
        y = translate2;
    }
    if (params.roundLengths) {
        x = Math.floor(x);
        y = Math.floor(y);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;
    if (params.cssMode) {
        wrapperEl[swiper.isHorizontal() ? "scrollLeft" : "scrollTop"] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
        if (swiper.isHorizontal()) {
            x -= swiper.cssOverflowAdjustment();
        } else {
            y -= swiper.cssOverflowAdjustment();
        }
        wrapperEl.style.transform = `translate3d(${x}px, ${y}px, ${z}px)`;
    }
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (translate2 - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== progress) {
        swiper.updateProgress(translate2);
    }
    swiper.emit("setTranslate", swiper.translate, byController);
}
function minTranslate() {
    return -this.snapGrid[0];
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(translate2, speed, runCallbacks, translateBounds, internal) {
    if (translate2 === void 0) {
        translate2 = 0;
    }
    if (speed === void 0) {
        speed = this.params.speed;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (translateBounds === void 0) {
        translateBounds = true;
    }
    const swiper = this;
    const { params, wrapperEl } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    const minTranslate2 = swiper.minTranslate();
    const maxTranslate2 = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate2 > minTranslate2) newTranslate = minTranslate2;
    else if (translateBounds && translate2 < maxTranslate2) newTranslate = maxTranslate2;
    else newTranslate = translate2;
    swiper.updateProgress(newTranslate);
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        if (speed === 0) {
            wrapperEl[isH ? "scrollLeft" : "scrollTop"] = -newTranslate;
        } else {
            if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                    swiper,
                    targetPosition: -newTranslate,
                    side: isH ? "left" : "top"
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? "left" : "top"]: -newTranslate,
                behavior: "smooth"
            });
        }
        return true;
    }
    if (speed === 0) {
        swiper.setTransition(0);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionEnd");
        }
    } else {
        swiper.setTransition(speed);
        swiper.setTranslate(newTranslate);
        if (runCallbacks) {
            swiper.emit("beforeTransitionStart", speed, internal);
            swiper.emit("transitionStart");
        }
        if (!swiper.animating) {
            swiper.animating = true;
            if (!swiper.onTranslateToWrapperTransitionEnd) {
                swiper.onTranslateToWrapperTransitionEnd = function transitionEnd2(e) {
                    if (!swiper || swiper.destroyed) return;
                    if (e.target !== this) return;
                    swiper.wrapperEl.removeEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
                    swiper.onTranslateToWrapperTransitionEnd = null;
                    delete swiper.onTranslateToWrapperTransitionEnd;
                    swiper.animating = false;
                    if (runCallbacks) {
                        swiper.emit("transitionEnd");
                    }
                };
            }
            swiper.wrapperEl.addEventListener("transitionend", swiper.onTranslateToWrapperTransitionEnd);
        }
    }
    return true;
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(duration, byController) {
    const swiper = this;
    if (!swiper.params.cssMode) {
        swiper.wrapperEl.style.transitionDuration = `${duration}ms`;
        swiper.wrapperEl.style.transitionDelay = duration === 0 ? `0ms` : "";
    }
    swiper.emit("setTransition", duration, byController);
}
function transitionEmit(_ref) {
    let { swiper, runCallbacks, direction, step } = _ref;
    const { activeIndex, previousIndex } = swiper;
    let dir = direction;
    if (!dir) {
        if (activeIndex > previousIndex) dir = "next";
        else if (activeIndex < previousIndex) dir = "prev";
        else dir = "reset";
    }
    swiper.emit(`transition${step}`);
    if (runCallbacks && activeIndex !== previousIndex) {
        if (dir === "reset") {
            swiper.emit(`slideResetTransition${step}`);
            return;
        }
        swiper.emit(`slideChangeTransition${step}`);
        if (dir === "next") {
            swiper.emit(`slideNextTransition${step}`);
        } else {
            swiper.emit(`slidePrevTransition${step}`);
        }
    }
}
function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
        swiper.updateAutoHeight();
    }
    transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: "Start"
    });
}
function transitionEnd(runCallbacks, direction) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);
    transitionEmit({
        swiper,
        runCallbacks,
        direction,
        step: "End"
    });
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(index, speed, runCallbacks, internal, initial) {
    if (index === void 0) {
        index = 0;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index === "string") {
        index = parseInt(index, 10);
    }
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;
    const { params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl, enabled } = swiper;
    if (!enabled && !internal && !initial || swiper.destroyed || swiper.animating && params.preventInteractionOnTransition) {
        return false;
    }
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    const translate2 = -snapGrid[snapIndex];
    if (params.normalizeSlideIndex) {
        for(let i2 = 0; i2 < slidesGrid.length; i2 += 1){
            const normalizedTranslate = -Math.floor(translate2 * 100);
            const normalizedGrid = Math.floor(slidesGrid[i2] * 100);
            const normalizedGridNext = Math.floor(slidesGrid[i2 + 1] * 100);
            if (typeof slidesGrid[i2 + 1] !== "undefined") {
                if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext - (normalizedGridNext - normalizedGrid) / 2) {
                    slideIndex = i2;
                } else if (normalizedTranslate >= normalizedGrid && normalizedTranslate < normalizedGridNext) {
                    slideIndex = i2 + 1;
                }
            } else if (normalizedTranslate >= normalizedGrid) {
                slideIndex = i2;
            }
        }
    }
    if (swiper.initialized && slideIndex !== activeIndex) {
        if (!swiper.allowSlideNext && (rtl ? translate2 > swiper.translate && translate2 > swiper.minTranslate() : translate2 < swiper.translate && translate2 < swiper.minTranslate())) {
            return false;
        }
        if (!swiper.allowSlidePrev && translate2 > swiper.translate && translate2 > swiper.maxTranslate()) {
            if ((activeIndex || 0) !== slideIndex) {
                return false;
            }
        }
    }
    if (slideIndex !== (previousIndex || 0) && runCallbacks) {
        swiper.emit("beforeSlideChangeStart");
    }
    swiper.updateProgress(translate2);
    let direction;
    if (slideIndex > activeIndex) direction = "next";
    else if (slideIndex < activeIndex) direction = "prev";
    else direction = "reset";
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    const isInitialVirtual = isVirtual && initial;
    if (!isInitialVirtual && (rtl && -translate2 === swiper.translate || !rtl && translate2 === swiper.translate)) {
        swiper.updateActiveIndex(slideIndex);
        if (params.autoHeight) {
            swiper.updateAutoHeight();
        }
        swiper.updateSlidesClasses();
        if (params.effect !== "slide") {
            swiper.setTranslate(translate2);
        }
        if (direction !== "reset") {
            swiper.transitionStart(runCallbacks, direction);
            swiper.transitionEnd(runCallbacks, direction);
        }
        return false;
    }
    if (params.cssMode) {
        const isH = swiper.isHorizontal();
        const t = rtl ? translate2 : -translate2;
        if (speed === 0) {
            if (isVirtual) {
                swiper.wrapperEl.style.scrollSnapType = "none";
                swiper._immediateVirtual = true;
            }
            if (isVirtual && !swiper._cssModeVirtualInitialSet && swiper.params.initialSlide > 0) {
                swiper._cssModeVirtualInitialSet = true;
                requestAnimationFrame(()=>{
                    wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
                });
            } else {
                wrapperEl[isH ? "scrollLeft" : "scrollTop"] = t;
            }
            if (isVirtual) {
                requestAnimationFrame(()=>{
                    swiper.wrapperEl.style.scrollSnapType = "";
                    swiper._immediateVirtual = false;
                });
            }
        } else {
            if (!swiper.support.smoothScroll) {
                animateCSSModeScroll({
                    swiper,
                    targetPosition: t,
                    side: isH ? "left" : "top"
                });
                return true;
            }
            wrapperEl.scrollTo({
                [isH ? "left" : "top"]: t,
                behavior: "smooth"
            });
        }
        return true;
    }
    swiper.setTransition(speed);
    swiper.setTranslate(translate2);
    swiper.updateActiveIndex(slideIndex);
    swiper.updateSlidesClasses();
    swiper.emit("beforeTransitionStart", speed, internal);
    swiper.transitionStart(runCallbacks, direction);
    if (speed === 0) {
        swiper.transitionEnd(runCallbacks, direction);
    } else if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
            swiper.onSlideToWrapperTransitionEnd = function transitionEnd2(e) {
                if (!swiper || swiper.destroyed) return;
                if (e.target !== this) return;
                swiper.wrapperEl.removeEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
                swiper.onSlideToWrapperTransitionEnd = null;
                delete swiper.onSlideToWrapperTransitionEnd;
                swiper.transitionEnd(runCallbacks, direction);
            };
        }
        swiper.wrapperEl.addEventListener("transitionend", swiper.onSlideToWrapperTransitionEnd);
    }
    return true;
}
function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) {
        index = 0;
    }
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (typeof index === "string") {
        const indexAsNumber = parseInt(index, 10);
        index = indexAsNumber;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    const gridEnabled = swiper.grid && swiper.params.grid && swiper.params.grid.rows > 1;
    let newIndex = index;
    if (swiper.params.loop) {
        if (swiper.virtual && swiper.params.virtual.enabled) {
            newIndex = newIndex + swiper.virtual.slidesBefore;
        } else {
            let targetSlideIndex;
            if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                targetSlideIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
            } else {
                targetSlideIndex = swiper.getSlideIndexByData(newIndex);
            }
            const cols = gridEnabled ? Math.ceil(swiper.slides.length / swiper.params.grid.rows) : swiper.slides.length;
            const { centeredSlides } = swiper.params;
            let slidesPerView = swiper.params.slidesPerView;
            if (slidesPerView === "auto") {
                slidesPerView = swiper.slidesPerViewDynamic();
            } else {
                slidesPerView = Math.ceil(parseFloat(swiper.params.slidesPerView, 10));
                if (centeredSlides && slidesPerView % 2 === 0) {
                    slidesPerView = slidesPerView + 1;
                }
            }
            let needLoopFix = cols - targetSlideIndex < slidesPerView;
            if (centeredSlides) {
                needLoopFix = needLoopFix || targetSlideIndex < Math.ceil(slidesPerView / 2);
            }
            if (internal && centeredSlides && swiper.params.slidesPerView !== "auto" && !gridEnabled) {
                needLoopFix = false;
            }
            if (needLoopFix) {
                const direction = centeredSlides ? targetSlideIndex < swiper.activeIndex ? "prev" : "next" : targetSlideIndex - swiper.activeIndex - 1 < swiper.params.slidesPerView ? "next" : "prev";
                swiper.loopFix({
                    direction,
                    slideTo: true,
                    activeSlideIndex: direction === "next" ? targetSlideIndex + 1 : targetSlideIndex - cols + 1,
                    slideRealIndex: direction === "next" ? swiper.realIndex : void 0
                });
            }
            if (gridEnabled) {
                const slideIndex = newIndex * swiper.params.grid.rows;
                newIndex = swiper.slides.filter((slideEl)=>slideEl.getAttribute("data-swiper-slide-index") * 1 === slideIndex)[0].column;
            } else {
                newIndex = swiper.getSlideIndexByData(newIndex);
            }
        }
    }
    requestAnimationFrame(()=>{
        swiper.slideTo(newIndex, speed, runCallbacks, internal);
    });
    return swiper;
}
function slideNext(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { enabled, params, animating } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    let perGroup = params.slidesPerGroup;
    if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
        perGroup = Math.max(swiper.slidesPerViewDynamic("current", true), 1);
    }
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : perGroup;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: "next"
        });
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
        if (swiper.activeIndex === swiper.slides.length - 1 && params.cssMode) {
            requestAnimationFrame(()=>{
                swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
            });
            return true;
        }
    }
    if (params.rewind && swiper.isEnd) {
        return swiper.slideTo(0, speed, runCallbacks, internal);
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
}
function slidePrev(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    const { params, snapGrid, slidesGrid, rtlTranslate, enabled, animating } = swiper;
    if (!enabled || swiper.destroyed) return swiper;
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    const isVirtual = swiper.virtual && params.virtual.enabled;
    if (params.loop) {
        if (animating && !isVirtual && params.loopPreventsSliding) return false;
        swiper.loopFix({
            direction: "prev"
        });
        swiper._clientLeft = swiper.wrapperEl.clientLeft;
    }
    const translate2 = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
        if (val < 0) return -Math.floor(Math.abs(val));
        return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate2);
    const normalizedSnapGrid = snapGrid.map((val)=>normalize(val));
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === "undefined" && params.cssMode) {
        let prevSnapIndex;
        snapGrid.forEach((snap, snapIndex)=>{
            if (normalizedTranslate >= snap) {
                prevSnapIndex = snapIndex;
            }
        });
        if (typeof prevSnapIndex !== "undefined") {
            prevSnap = snapGrid[prevSnapIndex > 0 ? prevSnapIndex - 1 : prevSnapIndex];
        }
    }
    let prevIndex = 0;
    if (typeof prevSnap !== "undefined") {
        prevIndex = slidesGrid.indexOf(prevSnap);
        if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
        if (params.slidesPerView === "auto" && params.slidesPerGroup === 1 && params.slidesPerGroupAuto) {
            prevIndex = prevIndex - swiper.slidesPerViewDynamic("previous", true) + 1;
            prevIndex = Math.max(prevIndex, 0);
        }
    }
    if (params.rewind && swiper.isBeginning) {
        const lastIndex = swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        return swiper.slideTo(lastIndex, speed, runCallbacks, internal);
    } else if (params.loop && swiper.activeIndex === 0 && params.cssMode) {
        requestAnimationFrame(()=>{
            swiper.slideTo(prevIndex, speed, runCallbacks, internal);
        });
        return true;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
}
function slideReset(speed, runCallbacks, internal) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
}
function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (runCallbacks === void 0) {
        runCallbacks = true;
    }
    if (threshold === void 0) {
        threshold = 0.5;
    }
    const swiper = this;
    if (swiper.destroyed) return;
    if (typeof speed === "undefined") {
        speed = swiper.params.speed;
    }
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    const translate2 = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    if (translate2 >= swiper.snapGrid[snapIndex]) {
        const currentSnap = swiper.snapGrid[snapIndex];
        const nextSnap = swiper.snapGrid[snapIndex + 1];
        if (translate2 - currentSnap > (nextSnap - currentSnap) * threshold) {
            index += swiper.params.slidesPerGroup;
        }
    } else {
        const prevSnap = swiper.snapGrid[snapIndex - 1];
        const currentSnap = swiper.snapGrid[snapIndex];
        if (translate2 - prevSnap <= (currentSnap - prevSnap) * threshold) {
            index -= swiper.params.slidesPerGroup;
        }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
}
function slideToClickedSlide() {
    const swiper = this;
    if (swiper.destroyed) return;
    const { params, slidesEl } = swiper;
    const slidesPerView = params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    const slideSelector = swiper.isElement ? `swiper-slide` : `.${params.slideClass}`;
    if (params.loop) {
        if (swiper.animating) return;
        realIndex = parseInt(swiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
        if (params.centeredSlides) {
            if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
                swiper.loopFix();
                slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
                nextTick4(()=>{
                    swiper.slideTo(slideToIndex);
                });
            } else {
                swiper.slideTo(slideToIndex);
            }
        } else if (slideToIndex > swiper.slides.length - slidesPerView) {
            swiper.loopFix();
            slideToIndex = swiper.getSlideIndex(elementChildren(slidesEl, `${slideSelector}[data-swiper-slide-index="${realIndex}"]`)[0]);
            nextTick4(()=>{
                swiper.slideTo(slideToIndex);
            });
        } else {
            swiper.slideTo(slideToIndex);
        }
    } else {
        swiper.slideTo(slideToIndex);
    }
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(slideRealIndex) {
    const swiper = this;
    const { params, slidesEl } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    const initSlides = ()=>{
        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
        slides.forEach((el, index)=>{
            el.setAttribute("data-swiper-slide-index", index);
        });
    };
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    const slidesPerGroup = params.slidesPerGroup * (gridEnabled ? params.grid.rows : 1);
    const shouldFillGroup = swiper.slides.length % slidesPerGroup !== 0;
    const shouldFillGrid = gridEnabled && swiper.slides.length % params.grid.rows !== 0;
    const addBlankSlides = (amountOfSlides)=>{
        for(let i2 = 0; i2 < amountOfSlides; i2 += 1){
            const slideEl = swiper.isElement ? createElement("swiper-slide", [
                params.slideBlankClass
            ]) : createElement("div", [
                params.slideClass,
                params.slideBlankClass
            ]);
            swiper.slidesEl.append(slideEl);
        }
    };
    if (shouldFillGroup) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = slidesPerGroup - swiper.slides.length % slidesPerGroup;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else {
            showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        }
        initSlides();
    } else if (shouldFillGrid) {
        if (params.loopAddBlankSlides) {
            const slidesToAdd = params.grid.rows - swiper.slides.length % params.grid.rows;
            addBlankSlides(slidesToAdd);
            swiper.recalcSlides();
            swiper.updateSlides();
        } else {
            showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        }
        initSlides();
    } else {
        initSlides();
    }
    swiper.loopFix({
        slideRealIndex,
        direction: params.centeredSlides ? void 0 : "next"
    });
}
function loopFix(_temp) {
    let { slideRealIndex, slideTo: slideTo2 = true, direction, setTranslate: setTranslate2, activeSlideIndex, byController, byMousewheel } = _temp === void 0 ? {} : _temp;
    const swiper = this;
    if (!swiper.params.loop) return;
    swiper.emit("beforeLoopFix");
    const { slides, allowSlidePrev, allowSlideNext, slidesEl, params } = swiper;
    const { centeredSlides } = params;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    if (swiper.virtual && params.virtual.enabled) {
        if (slideTo2) {
            if (!params.centeredSlides && swiper.snapIndex === 0) {
                swiper.slideTo(swiper.virtual.slides.length, 0, false, true);
            } else if (params.centeredSlides && swiper.snapIndex < params.slidesPerView) {
                swiper.slideTo(swiper.virtual.slides.length + swiper.snapIndex, 0, false, true);
            } else if (swiper.snapIndex === swiper.snapGrid.length - 1) {
                swiper.slideTo(swiper.virtual.slidesBefore, 0, false, true);
            }
        }
        swiper.allowSlidePrev = allowSlidePrev;
        swiper.allowSlideNext = allowSlideNext;
        swiper.emit("loopFix");
        return;
    }
    let slidesPerView = params.slidesPerView;
    if (slidesPerView === "auto") {
        slidesPerView = swiper.slidesPerViewDynamic();
    } else {
        slidesPerView = Math.ceil(parseFloat(params.slidesPerView, 10));
        if (centeredSlides && slidesPerView % 2 === 0) {
            slidesPerView = slidesPerView + 1;
        }
    }
    const slidesPerGroup = params.slidesPerGroupAuto ? slidesPerView : params.slidesPerGroup;
    let loopedSlides = slidesPerGroup;
    if (loopedSlides % slidesPerGroup !== 0) {
        loopedSlides += slidesPerGroup - loopedSlides % slidesPerGroup;
    }
    loopedSlides += params.loopAdditionalSlides;
    swiper.loopedSlides = loopedSlides;
    const gridEnabled = swiper.grid && params.grid && params.grid.rows > 1;
    if (slides.length < slidesPerView + loopedSlides) {
        showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters");
    } else if (gridEnabled && params.grid.fill === "row") {
        showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    }
    const prependSlidesIndexes = [];
    const appendSlidesIndexes = [];
    let activeIndex = swiper.activeIndex;
    if (typeof activeSlideIndex === "undefined") {
        activeSlideIndex = swiper.getSlideIndex(slides.filter((el)=>el.classList.contains(params.slideActiveClass))[0]);
    } else {
        activeIndex = activeSlideIndex;
    }
    const isNext = direction === "next" || !direction;
    const isPrev = direction === "prev" || !direction;
    let slidesPrepended = 0;
    let slidesAppended = 0;
    const cols = gridEnabled ? Math.ceil(slides.length / params.grid.rows) : slides.length;
    const activeColIndex = gridEnabled ? slides[activeSlideIndex].column : activeSlideIndex;
    const activeColIndexWithShift = activeColIndex + (centeredSlides && typeof setTranslate2 === "undefined" ? -slidesPerView / 2 + 0.5 : 0);
    if (activeColIndexWithShift < loopedSlides) {
        slidesPrepended = Math.max(loopedSlides - activeColIndexWithShift, slidesPerGroup);
        for(let i2 = 0; i2 < loopedSlides - activeColIndexWithShift; i2 += 1){
            const index = i2 - Math.floor(i2 / cols) * cols;
            if (gridEnabled) {
                const colIndexToPrepend = cols - index - 1;
                for(let i3 = slides.length - 1; i3 >= 0; i3 -= 1){
                    if (slides[i3].column === colIndexToPrepend) prependSlidesIndexes.push(i3);
                }
            } else {
                prependSlidesIndexes.push(cols - index - 1);
            }
        }
    } else if (activeColIndexWithShift + slidesPerView > cols - loopedSlides) {
        slidesAppended = Math.max(activeColIndexWithShift - (cols - loopedSlides * 2), slidesPerGroup);
        for(let i2 = 0; i2 < slidesAppended; i2 += 1){
            const index = i2 - Math.floor(i2 / cols) * cols;
            if (gridEnabled) {
                slides.forEach((slide2, slideIndex)=>{
                    if (slide2.column === index) appendSlidesIndexes.push(slideIndex);
                });
            } else {
                appendSlidesIndexes.push(index);
            }
        }
    }
    swiper.__preventObserver__ = true;
    requestAnimationFrame(()=>{
        swiper.__preventObserver__ = false;
    });
    if (isPrev) {
        prependSlidesIndexes.forEach((index)=>{
            slides[index].swiperLoopMoveDOM = true;
            slidesEl.prepend(slides[index]);
            slides[index].swiperLoopMoveDOM = false;
        });
    }
    if (isNext) {
        appendSlidesIndexes.forEach((index)=>{
            slides[index].swiperLoopMoveDOM = true;
            slidesEl.append(slides[index]);
            slides[index].swiperLoopMoveDOM = false;
        });
    }
    swiper.recalcSlides();
    if (params.slidesPerView === "auto") {
        swiper.updateSlides();
    } else if (gridEnabled && (prependSlidesIndexes.length > 0 && isPrev || appendSlidesIndexes.length > 0 && isNext)) {
        swiper.slides.forEach((slide2, slideIndex)=>{
            swiper.grid.updateSlide(slideIndex, slide2, swiper.slides);
        });
    }
    if (params.watchSlidesProgress) {
        swiper.updateSlidesOffset();
    }
    if (slideTo2) {
        if (prependSlidesIndexes.length > 0 && isPrev) {
            if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex + slidesPrepended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                    swiper.setTranslate(swiper.translate - diff);
                } else {
                    swiper.slideTo(activeIndex + Math.ceil(slidesPrepended), 0, false, true);
                    if (setTranslate2) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                if (setTranslate2) {
                    const shift = gridEnabled ? prependSlidesIndexes.length / params.grid.rows : prependSlidesIndexes.length;
                    swiper.slideTo(swiper.activeIndex + shift, 0, false, true);
                    swiper.touchEventsData.currentTranslate = swiper.translate;
                }
            }
        } else if (appendSlidesIndexes.length > 0 && isNext) {
            if (typeof slideRealIndex === "undefined") {
                const currentSlideTranslate = swiper.slidesGrid[activeIndex];
                const newSlideTranslate = swiper.slidesGrid[activeIndex - slidesAppended];
                const diff = newSlideTranslate - currentSlideTranslate;
                if (byMousewheel) {
                    swiper.setTranslate(swiper.translate - diff);
                } else {
                    swiper.slideTo(activeIndex - slidesAppended, 0, false, true);
                    if (setTranslate2) {
                        swiper.touchEventsData.startTranslate = swiper.touchEventsData.startTranslate - diff;
                        swiper.touchEventsData.currentTranslate = swiper.touchEventsData.currentTranslate - diff;
                    }
                }
            } else {
                const shift = gridEnabled ? appendSlidesIndexes.length / params.grid.rows : appendSlidesIndexes.length;
                swiper.slideTo(swiper.activeIndex - shift, 0, false, true);
            }
        }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.controller && swiper.controller.control && !byController) {
        const loopParams = {
            slideRealIndex,
            direction,
            setTranslate: setTranslate2,
            activeSlideIndex,
            byController: true
        };
        if (Array.isArray(swiper.controller.control)) {
            swiper.controller.control.forEach((c)=>{
                if (!c.destroyed && c.params.loop) c.loopFix(_object_spread_props(_object_spread({}, loopParams), {
                    slideTo: c.params.slidesPerView === params.slidesPerView ? slideTo2 : false
                }));
            });
        } else if (swiper.controller.control instanceof swiper.constructor && swiper.controller.control.params.loop) {
            swiper.controller.control.loopFix(_object_spread_props(_object_spread({}, loopParams), {
                slideTo: swiper.controller.control.params.slidesPerView === params.slidesPerView ? slideTo2 : false
            }));
        }
    }
    swiper.emit("loopFix");
}
function loopDestroy() {
    const swiper = this;
    const { params, slidesEl } = swiper;
    if (!params.loop || swiper.virtual && swiper.params.virtual.enabled) return;
    swiper.recalcSlides();
    const newSlidesOrder = [];
    swiper.slides.forEach((slideEl)=>{
        const index = typeof slideEl.swiperSlideIndex === "undefined" ? slideEl.getAttribute("data-swiper-slide-index") * 1 : slideEl.swiperSlideIndex;
        newSlidesOrder[index] = slideEl;
    });
    swiper.slides.forEach((slideEl)=>{
        slideEl.removeAttribute("data-swiper-slide-index");
    });
    newSlidesOrder.forEach((slideEl)=>{
        slidesEl.append(slideEl);
    });
    swiper.recalcSlides();
    swiper.slideTo(swiper.realIndex, 0);
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(moving) {
    const swiper = this;
    if (!swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) return;
    const el = swiper.params.touchEventsTarget === "container" ? swiper.el : swiper.wrapperEl;
    if (swiper.isElement) {
        swiper.__preventObserver__ = true;
    }
    el.style.cursor = "move";
    el.style.cursor = moving ? "grabbing" : "grab";
    if (swiper.isElement) {
        requestAnimationFrame(()=>{
            swiper.__preventObserver__ = false;
        });
    }
}
function unsetGrabCursor() {
    const swiper = this;
    if (swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
        return;
    }
    if (swiper.isElement) {
        swiper.__preventObserver__ = true;
    }
    swiper[swiper.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "";
    if (swiper.isElement) {
        requestAnimationFrame(()=>{
            swiper.__preventObserver__ = false;
        });
    }
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function closestElement(selector, base) {
    if (base === void 0) {
        base = this;
    }
    function __closestFrom(el) {
        if (!el || el === getDocument() || el === getWindow()) return null;
        if (el.assignedSlot) el = el.assignedSlot;
        const found = el.closest(selector);
        if (!found && !el.getRootNode) {
            return null;
        }
        return found || __closestFrom(el.getRootNode().host);
    }
    return __closestFrom(base);
}
function preventEdgeSwipe(swiper, event2, startX) {
    const window2 = getWindow();
    const { params } = swiper;
    const edgeSwipeDetection = params.edgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold;
    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= window2.innerWidth - edgeSwipeThreshold)) {
        if (edgeSwipeDetection === "prevent") {
            event2.preventDefault();
            return true;
        }
        return false;
    }
    return true;
}
function onTouchStart(event2) {
    const swiper = this;
    const document2 = getDocument();
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    const data = swiper.touchEventsData;
    if (e.type === "pointerdown") {
        if (data.pointerId !== null && data.pointerId !== e.pointerId) {
            return;
        }
        data.pointerId = e.pointerId;
    } else if (e.type === "touchstart" && e.targetTouches.length === 1) {
        data.touchId = e.targetTouches[0].identifier;
    }
    if (e.type === "touchstart") {
        preventEdgeSwipe(swiper, e, e.targetTouches[0].pageX);
        return;
    }
    const { params, touches, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e.pointerType === "mouse") return;
    if (swiper.animating && params.preventInteractionOnTransition) {
        return;
    }
    if (!swiper.animating && params.cssMode && params.loop) {
        swiper.loopFix();
    }
    let targetEl = e.target;
    if (params.touchEventsTarget === "wrapper") {
        if (!elementIsChildOf(targetEl, swiper.wrapperEl)) return;
    }
    if ("which" in e && e.which === 3) return;
    if ("button" in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    const swipingClassHasValue = !!params.noSwipingClass && params.noSwipingClass !== "";
    const eventPath = e.composedPath ? e.composedPath() : e.path;
    if (swipingClassHasValue && e.target && e.target.shadowRoot && eventPath) {
        targetEl = eventPath[0];
    }
    const noSwipingSelector = params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`;
    const isTargetShadow = !!(e.target && e.target.shadowRoot);
    if (params.noSwiping && (isTargetShadow ? closestElement(noSwipingSelector, targetEl) : targetEl.closest(noSwipingSelector))) {
        swiper.allowClick = true;
        return;
    }
    if (params.swipeHandler) {
        if (!targetEl.closest(params.swipeHandler)) return;
    }
    touches.currentX = e.pageX;
    touches.currentY = e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;
    if (!preventEdgeSwipe(swiper, e, startX)) {
        return;
    }
    Object.assign(data, {
        isTouched: true,
        isMoved: false,
        allowTouchCallbacks: true,
        isScrolling: void 0,
        startMoving: void 0
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = now2();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = void 0;
    if (params.threshold > 0) data.allowThresholdMove = false;
    let preventDefault = true;
    if (targetEl.matches(data.focusableElements)) {
        preventDefault = false;
        if (targetEl.nodeName === "SELECT") {
            data.isTouched = false;
        }
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== targetEl && (e.pointerType === "mouse" || e.pointerType !== "mouse" && !targetEl.matches(data.focusableElements))) {
        document2.activeElement.blur();
    }
    const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
    if ((params.touchStartForcePreventDefault || shouldPreventDefault) && !targetEl.isContentEditable) {
        e.preventDefault();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode && swiper.animating && !params.cssMode) {
        swiper.freeMode.onTouchStart();
    }
    swiper.emit("touchStart", e);
}
function onTouchMove(event2) {
    const document2 = getDocument();
    const swiper = this;
    const data = swiper.touchEventsData;
    const { params, touches, rtlTranslate: rtl, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && event2.pointerType === "mouse") return;
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    if (e.type === "pointermove") {
        if (data.touchId !== null) return;
        const id = e.pointerId;
        if (id !== data.pointerId) return;
    }
    let targetTouch;
    if (e.type === "touchmove") {
        targetTouch = [
            ...e.changedTouches
        ].filter((t)=>t.identifier === data.touchId)[0];
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    } else {
        targetTouch = e;
    }
    if (!data.isTouched) {
        if (data.startMoving && data.isScrolling) {
            swiper.emit("touchMoveOpposite", e);
        }
        return;
    }
    const pageX = targetTouch.pageX;
    const pageY = targetTouch.pageY;
    if (e.preventedByNestedSwiper) {
        touches.startX = pageX;
        touches.startY = pageY;
        return;
    }
    if (!swiper.allowTouchMove) {
        if (!e.target.matches(data.focusableElements)) {
            swiper.allowClick = false;
        }
        if (data.isTouched) {
            Object.assign(touches, {
                startX: pageX,
                startY: pageY,
                currentX: pageX,
                currentY: pageY
            });
            data.touchStartTime = now2();
        }
        return;
    }
    if (params.touchReleaseOnEdges && !params.loop) {
        if (swiper.isVertical()) {
            if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
                data.isTouched = false;
                data.isMoved = false;
                return;
            }
        } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
            return;
        }
    }
    if (document2.activeElement && document2.activeElement.matches(data.focusableElements) && document2.activeElement !== e.target && e.pointerType !== "mouse") {
        document2.activeElement.blur();
    }
    if (document2.activeElement) {
        if (e.target === document2.activeElement && e.target.matches(data.focusableElements)) {
            data.isMoved = true;
            swiper.allowClick = false;
            return;
        }
    }
    if (data.allowTouchCallbacks) {
        swiper.emit("touchMove", e);
    }
    touches.previousX = touches.currentX;
    touches.previousY = touches.currentY;
    touches.currentX = pageX;
    touches.currentY = pageY;
    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) return;
    if (typeof data.isScrolling === "undefined") {
        let touchAngle;
        if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
            data.isScrolling = false;
        } else {
            if (diffX * diffX + diffY * diffY >= 25) {
                touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
                data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
            }
        }
    }
    if (data.isScrolling) {
        swiper.emit("touchMoveOpposite", e);
    }
    if (typeof data.startMoving === "undefined") {
        if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
            data.startMoving = true;
        }
    }
    if (data.isScrolling || e.type === "touchmove" && data.preventTouchMoveFromPointerMove) {
        data.isTouched = false;
        return;
    }
    if (!data.startMoving) {
        return;
    }
    swiper.allowClick = false;
    if (!params.cssMode && e.cancelable) {
        e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
        e.stopPropagation();
    }
    let diff = swiper.isHorizontal() ? diffX : diffY;
    let touchesDiff = swiper.isHorizontal() ? touches.currentX - touches.previousX : touches.currentY - touches.previousY;
    if (params.oneWayMovement) {
        diff = Math.abs(diff) * (rtl ? 1 : -1);
        touchesDiff = Math.abs(touchesDiff) * (rtl ? 1 : -1);
    }
    touches.diff = diff;
    diff *= params.touchRatio;
    if (rtl) {
        diff = -diff;
        touchesDiff = -touchesDiff;
    }
    const prevTouchesDirection = swiper.touchesDirection;
    swiper.swipeDirection = diff > 0 ? "prev" : "next";
    swiper.touchesDirection = touchesDiff > 0 ? "prev" : "next";
    const isLoop = swiper.params.loop && !params.cssMode;
    const allowLoopFix = swiper.touchesDirection === "next" && swiper.allowSlideNext || swiper.touchesDirection === "prev" && swiper.allowSlidePrev;
    if (!data.isMoved) {
        if (isLoop && allowLoopFix) {
            swiper.loopFix({
                direction: swiper.swipeDirection
            });
        }
        data.startTranslate = swiper.getTranslate();
        swiper.setTransition(0);
        if (swiper.animating) {
            const evt = new window.CustomEvent("transitionend", {
                bubbles: true,
                cancelable: true,
                detail: {
                    bySwiperTouchMove: true
                }
            });
            swiper.wrapperEl.dispatchEvent(evt);
        }
        data.allowMomentumBounce = false;
        if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
            swiper.setGrabCursor(true);
        }
        swiper.emit("sliderFirstMove", e);
    }
    let loopFixed;
    /* @__PURE__ */ new Date().getTime();
    if (data.isMoved && data.allowThresholdMove && prevTouchesDirection !== swiper.touchesDirection && isLoop && allowLoopFix && Math.abs(diff) >= 1) {
        Object.assign(touches, {
            startX: pageX,
            startY: pageY,
            currentX: pageX,
            currentY: pageY,
            startTranslate: data.currentTranslate
        });
        data.loopSwapReset = true;
        data.startTranslate = data.currentTranslate;
        return;
    }
    swiper.emit("sliderMove", e);
    data.isMoved = true;
    data.currentTranslate = diff + data.startTranslate;
    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
        resistanceRatio = 0;
    }
    if (diff > 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate > (params.centeredSlides ? swiper.minTranslate() - swiper.slidesSizesGrid[swiper.activeIndex + 1] - (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.activeIndex + 1] + swiper.params.spaceBetween : 0) - swiper.params.spaceBetween : swiper.minTranslate())) {
            swiper.loopFix({
                direction: "prev",
                setTranslate: true,
                activeSlideIndex: 0
            });
        }
        if (data.currentTranslate > swiper.minTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
            }
        }
    } else if (diff < 0) {
        if (isLoop && allowLoopFix && !loopFixed && data.allowThresholdMove && data.currentTranslate < (params.centeredSlides ? swiper.maxTranslate() + swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween + (params.slidesPerView !== "auto" && swiper.slides.length - params.slidesPerView >= 2 ? swiper.slidesSizesGrid[swiper.slidesSizesGrid.length - 1] + swiper.params.spaceBetween : 0) : swiper.maxTranslate())) {
            swiper.loopFix({
                direction: "next",
                setTranslate: true,
                activeSlideIndex: swiper.slides.length - (params.slidesPerView === "auto" ? swiper.slidesPerViewDynamic() : Math.ceil(parseFloat(params.slidesPerView, 10)))
            });
        }
        if (data.currentTranslate < swiper.maxTranslate()) {
            disableParentSwiper = false;
            if (params.resistance) {
                data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
            }
        }
    }
    if (disableParentSwiper) {
        e.preventedByNestedSwiper = true;
    }
    if (!swiper.allowSlideNext && swiper.swipeDirection === "next" && data.currentTranslate < data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === "prev" && data.currentTranslate > data.startTranslate) {
        data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && !swiper.allowSlideNext) {
        data.currentTranslate = data.startTranslate;
    }
    if (params.threshold > 0) {
        if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
            if (!data.allowThresholdMove) {
                data.allowThresholdMove = true;
                touches.startX = touches.currentX;
                touches.startY = touches.currentY;
                data.currentTranslate = data.startTranslate;
                touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
                return;
            }
        } else {
            data.currentTranslate = data.startTranslate;
            return;
        }
    }
    if (!params.followFinger || params.cssMode) return;
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode || params.watchSlidesProgress) {
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    if (params.freeMode && params.freeMode.enabled && swiper.freeMode) {
        swiper.freeMode.onTouchMove();
    }
    swiper.updateProgress(data.currentTranslate);
    swiper.setTranslate(data.currentTranslate);
}
function onTouchEnd(event2) {
    const swiper = this;
    const data = swiper.touchEventsData;
    let e = event2;
    if (e.originalEvent) e = e.originalEvent;
    let targetTouch;
    const isTouchEvent = e.type === "touchend" || e.type === "touchcancel";
    if (!isTouchEvent) {
        if (data.touchId !== null) return;
        if (e.pointerId !== data.pointerId) return;
        targetTouch = e;
    } else {
        targetTouch = [
            ...e.changedTouches
        ].filter((t)=>t.identifier === data.touchId)[0];
        if (!targetTouch || targetTouch.identifier !== data.touchId) return;
    }
    if ([
        "pointercancel",
        "pointerout",
        "pointerleave",
        "contextmenu"
    ].includes(e.type)) {
        const proceed = [
            "pointercancel",
            "contextmenu"
        ].includes(e.type) && (swiper.browser.isSafari || swiper.browser.isWebView);
        if (!proceed) {
            return;
        }
    }
    data.pointerId = null;
    data.touchId = null;
    const { params, touches, rtlTranslate: rtl, slidesGrid, enabled } = swiper;
    if (!enabled) return;
    if (!params.simulateTouch && e.pointerType === "mouse") return;
    if (data.allowTouchCallbacks) {
        swiper.emit("touchEnd", e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
        if (data.isMoved && params.grabCursor) {
            swiper.setGrabCursor(false);
        }
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(false);
    }
    const touchEndTime = now2();
    const timeDiff = touchEndTime - data.touchStartTime;
    if (swiper.allowClick) {
        const pathTree = e.path || e.composedPath && e.composedPath();
        swiper.updateClickedSlide(pathTree && pathTree[0] || e.target, pathTree);
        swiper.emit("tap click", e);
        if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
            swiper.emit("doubleTap doubleClick", e);
        }
    }
    data.lastClickTime = now2();
    nextTick4(()=>{
        if (!swiper.destroyed) swiper.allowClick = true;
    });
    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 && !data.loopSwapReset || data.currentTranslate === data.startTranslate && !data.loopSwapReset) {
        data.isTouched = false;
        data.isMoved = false;
        data.startMoving = false;
        return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    let currentPos;
    if (params.followFinger) {
        currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
        currentPos = -data.currentTranslate;
    }
    if (params.cssMode) {
        return;
    }
    if (params.freeMode && params.freeMode.enabled) {
        swiper.freeMode.onTouchEnd({
            currentPos
        });
        return;
    }
    const swipeToLast = currentPos >= -swiper.maxTranslate() && !swiper.params.loop;
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for(let i2 = 0; i2 < slidesGrid.length; i2 += i2 < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup){
        const increment2 = i2 < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
        if (typeof slidesGrid[i2 + increment2] !== "undefined") {
            if (swipeToLast || currentPos >= slidesGrid[i2] && currentPos < slidesGrid[i2 + increment2]) {
                stopIndex = i2;
                groupSize = slidesGrid[i2 + increment2] - slidesGrid[i2];
            }
        } else if (swipeToLast || currentPos >= slidesGrid[i2]) {
            stopIndex = i2;
            groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
        }
    }
    let rewindFirstIndex = null;
    let rewindLastIndex = null;
    if (params.rewind) {
        if (swiper.isBeginning) {
            rewindLastIndex = params.virtual && params.virtual.enabled && swiper.virtual ? swiper.virtual.slides.length - 1 : swiper.slides.length - 1;
        } else if (swiper.isEnd) {
            rewindFirstIndex = 0;
        }
    }
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;
    if (timeDiff > params.longSwipesMs) {
        if (!params.longSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (swiper.swipeDirection === "next") {
            if (ratio >= params.longSwipesRatio) swiper.slideTo(params.rewind && swiper.isEnd ? rewindFirstIndex : stopIndex + increment);
            else swiper.slideTo(stopIndex);
        }
        if (swiper.swipeDirection === "prev") {
            if (ratio > 1 - params.longSwipesRatio) {
                swiper.slideTo(stopIndex + increment);
            } else if (rewindLastIndex !== null && ratio < 0 && Math.abs(ratio) > params.longSwipesRatio) {
                swiper.slideTo(rewindLastIndex);
            } else {
                swiper.slideTo(stopIndex);
            }
        }
    } else {
        if (!params.shortSwipes) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
        if (!isNavButtonTarget) {
            if (swiper.swipeDirection === "next") {
                swiper.slideTo(rewindFirstIndex !== null ? rewindFirstIndex : stopIndex + increment);
            }
            if (swiper.swipeDirection === "prev") {
                swiper.slideTo(rewindLastIndex !== null ? rewindLastIndex : stopIndex);
            }
        } else if (e.target === swiper.navigation.nextEl) {
            swiper.slideTo(stopIndex + increment);
        } else {
            swiper.slideTo(stopIndex);
        }
    }
}
function onResize() {
    const swiper = this;
    const { params, el } = swiper;
    if (el && el.offsetWidth === 0) return;
    if (params.breakpoints) {
        swiper.setBreakpoint();
    }
    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;
    const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();
    const isVirtualLoop = isVirtual && params.loop;
    if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !swiper.isBeginning && !swiper.params.centeredSlides && !isVirtualLoop) {
        swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
        if (swiper.params.loop && !isVirtual) {
            swiper.slideToLoop(swiper.realIndex, 0, false, true);
        } else {
            swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
    }
    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
        clearTimeout(swiper.autoplay.resizeTimeout);
        swiper.autoplay.resizeTimeout = setTimeout(()=>{
            if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
                swiper.autoplay.resume();
            }
        }, 500);
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
    }
}
function onClick(e) {
    const swiper = this;
    if (!swiper.enabled) return;
    if (!swiper.allowClick) {
        if (swiper.params.preventClicks) e.preventDefault();
        if (swiper.params.preventClicksPropagation && swiper.animating) {
            e.stopPropagation();
            e.stopImmediatePropagation();
        }
    }
}
function onScroll() {
    const swiper = this;
    const { wrapperEl, rtlTranslate, enabled } = swiper;
    if (!enabled) return;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
        swiper.translate = -wrapperEl.scrollLeft;
    } else {
        swiper.translate = -wrapperEl.scrollTop;
    }
    if (swiper.translate === 0) swiper.translate = 0;
    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
        newProgress = 0;
    } else {
        newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }
    if (newProgress !== swiper.progress) {
        swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }
    swiper.emit("setTranslate", swiper.translate, false);
}
function onLoad(e) {
    const swiper = this;
    processLazyPreloader(swiper, e.target);
    if (swiper.params.cssMode || swiper.params.slidesPerView !== "auto" && !swiper.params.autoHeight) {
        return;
    }
    swiper.update();
}
function onDocumentTouchStart() {
    const swiper = this;
    if (swiper.documentTouchHandlerProceeded) return;
    swiper.documentTouchHandlerProceeded = true;
    if (swiper.params.touchReleaseOnEdges) {
        swiper.el.style.touchAction = "auto";
    }
}
var events = (swiper, method)=>{
    const document2 = getDocument();
    const { params, el, wrapperEl, device } = swiper;
    const capture = !!params.nested;
    const domMethod = method === "on" ? "addEventListener" : "removeEventListener";
    const swiperMethod = method;
    if (!el || typeof el === "string") return;
    document2[domMethod]("touchstart", swiper.onDocumentTouchStart, {
        passive: false,
        capture
    });
    el[domMethod]("touchstart", swiper.onTouchStart, {
        passive: false
    });
    el[domMethod]("pointerdown", swiper.onTouchStart, {
        passive: false
    });
    document2[domMethod]("touchmove", swiper.onTouchMove, {
        passive: false,
        capture
    });
    document2[domMethod]("pointermove", swiper.onTouchMove, {
        passive: false,
        capture
    });
    document2[domMethod]("touchend", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerup", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointercancel", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("touchcancel", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerout", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("pointerleave", swiper.onTouchEnd, {
        passive: true
    });
    document2[domMethod]("contextmenu", swiper.onTouchEnd, {
        passive: true
    });
    if (params.preventClicks || params.preventClicksPropagation) {
        el[domMethod]("click", swiper.onClick, true);
    }
    if (params.cssMode) {
        wrapperEl[domMethod]("scroll", swiper.onScroll);
    }
    if (params.updateOnWindowResize) {
        swiper[swiperMethod](device.ios || device.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, true);
    } else {
        swiper[swiperMethod]("observerUpdate", onResize, true);
    }
    el[domMethod]("load", swiper.onLoad, {
        capture: true
    });
};
function attachEvents() {
    const swiper = this;
    const { params } = swiper;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    swiper.onDocumentTouchStart = onDocumentTouchStart.bind(swiper);
    if (params.cssMode) {
        swiper.onScroll = onScroll.bind(swiper);
    }
    swiper.onClick = onClick.bind(swiper);
    swiper.onLoad = onLoad.bind(swiper);
    events(swiper, "on");
}
function detachEvents() {
    const swiper = this;
    events(swiper, "off");
}
var events$1 = {
    attachEvents,
    detachEvents
};
var isGridEnabled = (swiper, params)=>{
    return swiper.grid && params.grid && params.grid.rows > 1;
};
function setBreakpoint() {
    const swiper = this;
    const { realIndex, initialized, params, el } = swiper;
    const breakpoints2 = params.breakpoints;
    if (!breakpoints2 || breakpoints2 && Object.keys(breakpoints2).length === 0) return;
    const breakpoint = swiper.getBreakpoint(breakpoints2, swiper.params.breakpointsBase, swiper.el);
    if (!breakpoint || swiper.currentBreakpoint === breakpoint) return;
    const breakpointOnlyParams = breakpoint in breakpoints2 ? breakpoints2[breakpoint] : void 0;
    const breakpointParams = breakpointOnlyParams || swiper.originalParams;
    const wasMultiRow = isGridEnabled(swiper, params);
    const isMultiRow = isGridEnabled(swiper, breakpointParams);
    const wasGrabCursor = swiper.params.grabCursor;
    const isGrabCursor = breakpointParams.grabCursor;
    const wasEnabled = params.enabled;
    if (wasMultiRow && !isMultiRow) {
        el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
        swiper.emitContainerClasses();
    } else if (!wasMultiRow && isMultiRow) {
        el.classList.add(`${params.containerModifierClass}grid`);
        if (breakpointParams.grid.fill && breakpointParams.grid.fill === "column" || !breakpointParams.grid.fill && params.grid.fill === "column") {
            el.classList.add(`${params.containerModifierClass}grid-column`);
        }
        swiper.emitContainerClasses();
    }
    if (wasGrabCursor && !isGrabCursor) {
        swiper.unsetGrabCursor();
    } else if (!wasGrabCursor && isGrabCursor) {
        swiper.setGrabCursor();
    }
    [
        "navigation",
        "pagination",
        "scrollbar"
    ].forEach((prop)=>{
        if (typeof breakpointParams[prop] === "undefined") return;
        const wasModuleEnabled = params[prop] && params[prop].enabled;
        const isModuleEnabled = breakpointParams[prop] && breakpointParams[prop].enabled;
        if (wasModuleEnabled && !isModuleEnabled) {
            swiper[prop].disable();
        }
        if (!wasModuleEnabled && isModuleEnabled) {
            swiper[prop].enable();
        }
    });
    const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
    const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);
    const wasLoop = params.loop;
    if (directionChanged && initialized) {
        swiper.changeDirection();
    }
    extend2(swiper.params, breakpointParams);
    const isEnabled = swiper.params.enabled;
    const hasLoop = swiper.params.loop;
    Object.assign(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
    });
    if (wasEnabled && !isEnabled) {
        swiper.disable();
    } else if (!wasEnabled && isEnabled) {
        swiper.enable();
    }
    swiper.currentBreakpoint = breakpoint;
    swiper.emit("_beforeBreakpoint", breakpointParams);
    if (initialized) {
        if (needsReLoop) {
            swiper.loopDestroy();
            swiper.loopCreate(realIndex);
            swiper.updateSlides();
        } else if (!wasLoop && hasLoop) {
            swiper.loopCreate(realIndex);
            swiper.updateSlides();
        } else if (wasLoop && !hasLoop) {
            swiper.loopDestroy();
        }
    }
    swiper.emit("breakpoint", breakpointParams);
}
function getBreakpoint(breakpoints2, base, containerEl) {
    if (base === void 0) {
        base = "window";
    }
    if (!breakpoints2 || base === "container" && !containerEl) return void 0;
    let breakpoint = false;
    const window2 = getWindow();
    const currentHeight = base === "window" ? window2.innerHeight : containerEl.clientHeight;
    const points = Object.keys(breakpoints2).map((point)=>{
        if (typeof point === "string" && point.indexOf("@") === 0) {
            const minRatio = parseFloat(point.substr(1));
            const value = currentHeight * minRatio;
            return {
                value,
                point
            };
        }
        return {
            value: point,
            point
        };
    });
    points.sort((a, b)=>parseInt(a.value, 10) - parseInt(b.value, 10));
    for(let i2 = 0; i2 < points.length; i2 += 1){
        const { point, value } = points[i2];
        if (base === "window") {
            if (window2.matchMedia(`(min-width: ${value}px)`).matches) {
                breakpoint = point;
            }
        } else if (value <= containerEl.clientWidth) {
            breakpoint = point;
        }
    }
    return breakpoint || "max";
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(entries, prefix) {
    const resultClasses = [];
    entries.forEach((item)=>{
        if (typeof item === "object") {
            Object.keys(item).forEach((classNames)=>{
                if (item[classNames]) {
                    resultClasses.push(prefix + classNames);
                }
            });
        } else if (typeof item === "string") {
            resultClasses.push(prefix + item);
        }
    });
    return resultClasses;
}
function addClasses() {
    const swiper = this;
    const { classNames, params, rtl, el, device } = swiper;
    const suffixes = prepareClasses([
        "initialized",
        params.direction,
        {
            "free-mode": swiper.params.freeMode && params.freeMode.enabled
        },
        {
            "autoheight": params.autoHeight
        },
        {
            "rtl": rtl
        },
        {
            "grid": params.grid && params.grid.rows > 1
        },
        {
            "grid-column": params.grid && params.grid.rows > 1 && params.grid.fill === "column"
        },
        {
            "android": device.android
        },
        {
            "ios": device.ios
        },
        {
            "css-mode": params.cssMode
        },
        {
            "centered": params.cssMode && params.centeredSlides
        },
        {
            "watch-progress": params.watchSlidesProgress
        }
    ], params.containerModifierClass);
    classNames.push(...suffixes);
    el.classList.add(...classNames);
    swiper.emitContainerClasses();
}
function removeClasses() {
    const swiper = this;
    const { el, classNames } = swiper;
    if (!el || typeof el === "string") return;
    el.classList.remove(...classNames);
    swiper.emitContainerClasses();
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const swiper = this;
    const { isLocked: wasLocked, params } = swiper;
    const { slidesOffsetBefore } = params;
    if (slidesOffsetBefore) {
        const lastSlideIndex = swiper.slides.length - 1;
        const lastSlideRightEdge = swiper.slidesGrid[lastSlideIndex] + swiper.slidesSizesGrid[lastSlideIndex] + slidesOffsetBefore * 2;
        swiper.isLocked = swiper.size > lastSlideRightEdge;
    } else {
        swiper.isLocked = swiper.snapGrid.length === 1;
    }
    if (params.allowSlideNext === true) {
        swiper.allowSlideNext = !swiper.isLocked;
    }
    if (params.allowSlidePrev === true) {
        swiper.allowSlidePrev = !swiper.isLocked;
    }
    if (wasLocked && wasLocked !== swiper.isLocked) {
        swiper.isEnd = false;
    }
    if (wasLocked !== swiper.isLocked) {
        swiper.emit(swiper.isLocked ? "lock" : "unlock");
    }
}
var checkOverflow$1 = {
    checkOverflow
};
var defaults = {
    init: true,
    direction: "horizontal",
    oneWayMovement: false,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    resizeObserver: true,
    nested: false,
    createElements: false,
    eventsPrefix: "swiper",
    enabled: true,
    focusableElements: "input, select, option, textarea, button, video, label",
    // Overrides
    width: null,
    height: null,
    //
    preventInteractionOnTransition: false,
    // ssr
    userAgent: null,
    url: null,
    // To support iOS's swipe-to-go-back gesture (when being used in-app).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: "slide",
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: void 0,
    breakpointsBase: "window",
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: false,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: true,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 5,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // loop
    loop: false,
    loopAddBlankSlides: true,
    loopAdditionalSlides: 0,
    loopPreventsSliding: true,
    // rewind
    rewind: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    maxBackfaceHiddenSlides: 10,
    // NS
    containerModifierClass: "swiper-",
    // NEW
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    // Callbacks
    runCallbacksOnInit: true,
    // Internals
    _emitClasses: false
};
function moduleExtendParams(params, allModulesParams) {
    return function extendParams(obj) {
        if (obj === void 0) {
            obj = {};
        }
        const moduleParamName = Object.keys(obj)[0];
        const moduleParams = obj[moduleParamName];
        if (typeof moduleParams !== "object" || moduleParams === null) {
            extend2(allModulesParams, obj);
            return;
        }
        if (params[moduleParamName] === true) {
            params[moduleParamName] = {
                enabled: true
            };
        }
        if (moduleParamName === "navigation" && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].prevEl && !params[moduleParamName].nextEl) {
            params[moduleParamName].auto = true;
        }
        if ([
            "pagination",
            "scrollbar"
        ].indexOf(moduleParamName) >= 0 && params[moduleParamName] && params[moduleParamName].enabled && !params[moduleParamName].el) {
            params[moduleParamName].auto = true;
        }
        if (!(moduleParamName in params && "enabled" in moduleParams)) {
            extend2(allModulesParams, obj);
            return;
        }
        if (typeof params[moduleParamName] === "object" && !("enabled" in params[moduleParamName])) {
            params[moduleParamName].enabled = true;
        }
        if (!params[moduleParamName]) params[moduleParamName] = {
            enabled: false
        };
        extend2(allModulesParams, obj);
    };
}
var prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
};
var extendedDefaults = {};
var Swiper = class _Swiper {
    getDirectionLabel(property) {
        if (this.isHorizontal()) {
            return property;
        }
        return ({
            "width": "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            "marginRight": "marginBottom"
        })[property];
    }
    getSlideIndex(slideEl) {
        const { slidesEl, params } = this;
        const slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
        const firstSlideIndex = elementIndex(slides[0]);
        return elementIndex(slideEl) - firstSlideIndex;
    }
    getSlideIndexByData(index) {
        return this.getSlideIndex(this.slides.filter((slideEl)=>slideEl.getAttribute("data-swiper-slide-index") * 1 === index)[0]);
    }
    recalcSlides() {
        const swiper = this;
        const { slidesEl, params } = swiper;
        swiper.slides = elementChildren(slidesEl, `.${params.slideClass}, swiper-slide`);
    }
    enable() {
        const swiper = this;
        if (swiper.enabled) return;
        swiper.enabled = true;
        if (swiper.params.grabCursor) {
            swiper.setGrabCursor();
        }
        swiper.emit("enable");
    }
    disable() {
        const swiper = this;
        if (!swiper.enabled) return;
        swiper.enabled = false;
        if (swiper.params.grabCursor) {
            swiper.unsetGrabCursor();
        }
        swiper.emit("disable");
    }
    setProgress(progress, speed) {
        const swiper = this;
        progress = Math.min(Math.max(progress, 0), 1);
        const min = swiper.minTranslate();
        const max = swiper.maxTranslate();
        const current = (max - min) * progress + min;
        swiper.translateTo(current, typeof speed === "undefined" ? 0 : speed);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    emitContainerClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const cls = swiper.el.className.split(" ").filter((className)=>{
            return className.indexOf("swiper") === 0 || className.indexOf(swiper.params.containerModifierClass) === 0;
        });
        swiper.emit("_containerClasses", cls.join(" "));
    }
    getSlideClasses(slideEl) {
        const swiper = this;
        if (swiper.destroyed) return "";
        return slideEl.className.split(" ").filter((className)=>{
            return className.indexOf("swiper-slide") === 0 || className.indexOf(swiper.params.slideClass) === 0;
        }).join(" ");
    }
    emitSlidesClasses() {
        const swiper = this;
        if (!swiper.params._emitClasses || !swiper.el) return;
        const updates = [];
        swiper.slides.forEach((slideEl)=>{
            const classNames = swiper.getSlideClasses(slideEl);
            updates.push({
                slideEl,
                classNames
            });
            swiper.emit("_slideClass", slideEl, classNames);
        });
        swiper.emit("_slideClasses", updates);
    }
    slidesPerViewDynamic(view, exact) {
        if (view === void 0) {
            view = "current";
        }
        if (exact === void 0) {
            exact = false;
        }
        const swiper = this;
        const { params, slides, slidesGrid, slidesSizesGrid, size: swiperSize, activeIndex } = swiper;
        let spv = 1;
        if (typeof params.slidesPerView === "number") return params.slidesPerView;
        if (params.centeredSlides) {
            let slideSize = slides[activeIndex] ? Math.ceil(slides[activeIndex].swiperSlideSize) : 0;
            let breakLoop;
            for(let i2 = activeIndex + 1; i2 < slides.length; i2 += 1){
                if (slides[i2] && !breakLoop) {
                    slideSize += Math.ceil(slides[i2].swiperSlideSize);
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
            for(let i2 = activeIndex - 1; i2 >= 0; i2 -= 1){
                if (slides[i2] && !breakLoop) {
                    slideSize += slides[i2].swiperSlideSize;
                    spv += 1;
                    if (slideSize > swiperSize) breakLoop = true;
                }
            }
        } else {
            if (view === "current") {
                for(let i2 = activeIndex + 1; i2 < slides.length; i2 += 1){
                    const slideInView = exact ? slidesGrid[i2] + slidesSizesGrid[i2] - slidesGrid[activeIndex] < swiperSize : slidesGrid[i2] - slidesGrid[activeIndex] < swiperSize;
                    if (slideInView) {
                        spv += 1;
                    }
                }
            } else {
                for(let i2 = activeIndex - 1; i2 >= 0; i2 -= 1){
                    const slideInView = slidesGrid[activeIndex] - slidesGrid[i2] < swiperSize;
                    if (slideInView) {
                        spv += 1;
                    }
                }
            }
        }
        return spv;
    }
    update() {
        const swiper = this;
        if (!swiper || swiper.destroyed) return;
        const { snapGrid, params } = swiper;
        if (params.breakpoints) {
            swiper.setBreakpoint();
        }
        [
            ...swiper.el.querySelectorAll('[loading="lazy"]')
        ].forEach((imageEl)=>{
            if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
            }
        });
        swiper.updateSize();
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        function setTranslate2() {
            const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
            const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
            swiper.setTranslate(newTranslate);
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
        let translated;
        if (params.freeMode && params.freeMode.enabled && !params.cssMode) {
            setTranslate2();
            if (params.autoHeight) {
                swiper.updateAutoHeight();
            }
        } else {
            if ((params.slidesPerView === "auto" || params.slidesPerView > 1) && swiper.isEnd && !params.centeredSlides) {
                const slides = swiper.virtual && params.virtual.enabled ? swiper.virtual.slides : swiper.slides;
                translated = swiper.slideTo(slides.length - 1, 0, false, true);
            } else {
                translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
            }
            if (!translated) {
                setTranslate2();
            }
        }
        if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
            swiper.checkOverflow();
        }
        swiper.emit("update");
    }
    changeDirection(newDirection, needUpdate) {
        if (needUpdate === void 0) {
            needUpdate = true;
        }
        const swiper = this;
        const currentDirection = swiper.params.direction;
        if (!newDirection) {
            newDirection = currentDirection === "horizontal" ? "vertical" : "horizontal";
        }
        if (newDirection === currentDirection || newDirection !== "horizontal" && newDirection !== "vertical") {
            return swiper;
        }
        swiper.el.classList.remove(`${swiper.params.containerModifierClass}${currentDirection}`);
        swiper.el.classList.add(`${swiper.params.containerModifierClass}${newDirection}`);
        swiper.emitContainerClasses();
        swiper.params.direction = newDirection;
        swiper.slides.forEach((slideEl)=>{
            if (newDirection === "vertical") {
                slideEl.style.width = "";
            } else {
                slideEl.style.height = "";
            }
        });
        swiper.emit("changeDirection");
        if (needUpdate) swiper.update();
        return swiper;
    }
    changeLanguageDirection(direction) {
        const swiper = this;
        if (swiper.rtl && direction === "rtl" || !swiper.rtl && direction === "ltr") return;
        swiper.rtl = direction === "rtl";
        swiper.rtlTranslate = swiper.params.direction === "horizontal" && swiper.rtl;
        if (swiper.rtl) {
            swiper.el.classList.add(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = "rtl";
        } else {
            swiper.el.classList.remove(`${swiper.params.containerModifierClass}rtl`);
            swiper.el.dir = "ltr";
        }
        swiper.update();
    }
    mount(element) {
        const swiper = this;
        if (swiper.mounted) return true;
        let el = element || swiper.params.el;
        if (typeof el === "string") {
            el = document.querySelector(el);
        }
        if (!el) {
            return false;
        }
        el.swiper = swiper;
        if (el.parentNode && el.parentNode.host && el.parentNode.host.nodeName === swiper.params.swiperElementNodeName.toUpperCase()) {
            swiper.isElement = true;
        }
        const getWrapperSelector = ()=>{
            return `.${(swiper.params.wrapperClass || "").trim().split(" ").join(".")}`;
        };
        const getWrapper = ()=>{
            if (el && el.shadowRoot && el.shadowRoot.querySelector) {
                const res = el.shadowRoot.querySelector(getWrapperSelector());
                return res;
            }
            return elementChildren(el, getWrapperSelector())[0];
        };
        let wrapperEl = getWrapper();
        if (!wrapperEl && swiper.params.createElements) {
            wrapperEl = createElement("div", swiper.params.wrapperClass);
            el.append(wrapperEl);
            elementChildren(el, `.${swiper.params.slideClass}`).forEach((slideEl)=>{
                wrapperEl.append(slideEl);
            });
        }
        Object.assign(swiper, {
            el,
            wrapperEl,
            slidesEl: swiper.isElement && !el.parentNode.host.slideSlots ? el.parentNode.host : wrapperEl,
            hostEl: swiper.isElement ? el.parentNode.host : el,
            mounted: true,
            // RTL
            rtl: el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl",
            rtlTranslate: swiper.params.direction === "horizontal" && (el.dir.toLowerCase() === "rtl" || elementStyle(el, "direction") === "rtl"),
            wrongRTL: elementStyle(wrapperEl, "display") === "-webkit-box"
        });
        return true;
    }
    init(el) {
        const swiper = this;
        if (swiper.initialized) return swiper;
        const mounted = swiper.mount(el);
        if (mounted === false) return swiper;
        swiper.emit("beforeInit");
        if (swiper.params.breakpoints) {
            swiper.setBreakpoint();
        }
        swiper.addClasses();
        swiper.updateSize();
        swiper.updateSlides();
        if (swiper.params.watchOverflow) {
            swiper.checkOverflow();
        }
        if (swiper.params.grabCursor && swiper.enabled) {
            swiper.setGrabCursor();
        }
        if (swiper.params.loop && swiper.virtual && swiper.params.virtual.enabled) {
            swiper.slideTo(swiper.params.initialSlide + swiper.virtual.slidesBefore, 0, swiper.params.runCallbacksOnInit, false, true);
        } else {
            swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit, false, true);
        }
        if (swiper.params.loop) {
            swiper.loopCreate();
        }
        swiper.attachEvents();
        const lazyElements = [
            ...swiper.el.querySelectorAll('[loading="lazy"]')
        ];
        if (swiper.isElement) {
            lazyElements.push(...swiper.hostEl.querySelectorAll('[loading="lazy"]'));
        }
        lazyElements.forEach((imageEl)=>{
            if (imageEl.complete) {
                processLazyPreloader(swiper, imageEl);
            } else {
                imageEl.addEventListener("load", (e)=>{
                    processLazyPreloader(swiper, e.target);
                });
            }
        });
        preload2(swiper);
        swiper.initialized = true;
        preload2(swiper);
        swiper.emit("init");
        swiper.emit("afterInit");
        return swiper;
    }
    destroy(deleteInstance, cleanStyles) {
        if (deleteInstance === void 0) {
            deleteInstance = true;
        }
        if (cleanStyles === void 0) {
            cleanStyles = true;
        }
        const swiper = this;
        const { params, el, wrapperEl, slides } = swiper;
        if (typeof swiper.params === "undefined" || swiper.destroyed) {
            return null;
        }
        swiper.emit("beforeDestroy");
        swiper.initialized = false;
        swiper.detachEvents();
        if (params.loop) {
            swiper.loopDestroy();
        }
        if (cleanStyles) {
            swiper.removeClasses();
            if (el && typeof el !== "string") {
                el.removeAttribute("style");
            }
            if (wrapperEl) {
                wrapperEl.removeAttribute("style");
            }
            if (slides && slides.length) {
                slides.forEach((slideEl)=>{
                    slideEl.classList.remove(params.slideVisibleClass, params.slideFullyVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass);
                    slideEl.removeAttribute("style");
                    slideEl.removeAttribute("data-swiper-slide-index");
                });
            }
        }
        swiper.emit("destroy");
        Object.keys(swiper.eventsListeners).forEach((eventName)=>{
            swiper.off(eventName);
        });
        if (deleteInstance !== false) {
            if (swiper.el && typeof swiper.el !== "string") {
                swiper.el.swiper = null;
            }
            deleteProps(swiper);
        }
        swiper.destroyed = true;
        return null;
    }
    static extendDefaults(newDefaults) {
        extend2(extendedDefaults, newDefaults);
    }
    static get extendedDefaults() {
        return extendedDefaults;
    }
    static get defaults() {
        return defaults;
    }
    static installModule(mod) {
        if (!_Swiper.prototype.__modules__) _Swiper.prototype.__modules__ = [];
        const modules2 = _Swiper.prototype.__modules__;
        if (typeof mod === "function" && modules2.indexOf(mod) < 0) {
            modules2.push(mod);
        }
    }
    static use(module2) {
        if (Array.isArray(module2)) {
            module2.forEach((m)=>_Swiper.installModule(m));
            return _Swiper;
        }
        _Swiper.installModule(module2);
        return _Swiper;
    }
    constructor(){
        let el;
        let params;
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        if (args.length === 1 && args[0].constructor && Object.prototype.toString.call(args[0]).slice(8, -1) === "Object") {
            params = args[0];
        } else {
            [el, params] = args;
        }
        if (!params) params = {};
        params = extend2({}, params);
        if (el && !params.el) params.el = el;
        const document2 = getDocument();
        if (params.el && typeof params.el === "string" && document2.querySelectorAll(params.el).length > 1) {
            const swipers = [];
            document2.querySelectorAll(params.el).forEach((containerEl)=>{
                const newParams = extend2({}, params, {
                    el: containerEl
                });
                swipers.push(new _Swiper(newParams));
            });
            return swipers;
        }
        const swiper = this;
        swiper.__swiper__ = true;
        swiper.support = getSupport();
        swiper.device = getDevice({
            userAgent: params.userAgent
        });
        swiper.browser = getBrowser();
        swiper.eventsListeners = {};
        swiper.eventsAnyListeners = [];
        swiper.modules = [
            ...swiper.__modules__
        ];
        if (params.modules && Array.isArray(params.modules)) {
            swiper.modules.push(...params.modules);
        }
        const allModulesParams = {};
        swiper.modules.forEach((mod)=>{
            mod({
                params,
                swiper,
                extendParams: moduleExtendParams(params, allModulesParams),
                on: swiper.on.bind(swiper),
                once: swiper.once.bind(swiper),
                off: swiper.off.bind(swiper),
                emit: swiper.emit.bind(swiper)
            });
        });
        const swiperParams = extend2({}, defaults, allModulesParams);
        swiper.params = extend2({}, swiperParams, extendedDefaults, params);
        swiper.originalParams = extend2({}, swiper.params);
        swiper.passedParams = extend2({}, params);
        if (swiper.params && swiper.params.on) {
            Object.keys(swiper.params.on).forEach((eventName)=>{
                swiper.on(eventName, swiper.params.on[eventName]);
            });
        }
        if (swiper.params && swiper.params.onAny) {
            swiper.onAny(swiper.params.onAny);
        }
        Object.assign(swiper, {
            enabled: swiper.params.enabled,
            el,
            // Classes
            classNames: [],
            // Slides
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            // isDirection
            isHorizontal () {
                return swiper.params.direction === "horizontal";
            },
            isVertical () {
                return swiper.params.direction === "vertical";
            },
            // Indexes
            activeIndex: 0,
            realIndex: 0,
            //
            isBeginning: true,
            isEnd: false,
            // Props
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: false,
            cssOverflowAdjustment () {
                return Math.trunc(this.translate / Math.pow(2, 23)) * Math.pow(2, 23);
            },
            // Locks
            allowSlideNext: swiper.params.allowSlideNext,
            allowSlidePrev: swiper.params.allowSlidePrev,
            // Touch Events
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                // Form elements to match
                focusableElements: swiper.params.focusableElements,
                // Last click time
                lastClickTime: 0,
                clickTimeout: void 0,
                // Velocities
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            // Clicks
            allowClick: true,
            // Touches
            allowTouchMove: swiper.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            // Images
            imagesToLoad: [],
            imagesLoaded: 0
        });
        swiper.emit("_swiper");
        if (swiper.params.init) {
            swiper.init();
        }
        return swiper;
    }
};
Object.keys(prototypes).forEach((prototypeGroup)=>{
    Object.keys(prototypes[prototypeGroup]).forEach((protoMethod)=>{
        Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
    });
});
Swiper.use([
    Resize,
    Observer
]);
// node_modules/swiper/modules/virtual.mjs
function Virtual(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    extendParams({
        virtual: {
            enabled: false,
            slides: [],
            cache: true,
            renderSlide: null,
            renderExternal: null,
            renderExternalUpdate: true,
            addSlidesBefore: 0,
            addSlidesAfter: 0
        }
    });
    let cssModeTimeout;
    const document2 = getDocument();
    swiper.virtual = {
        cache: {},
        from: void 0,
        to: void 0,
        slides: [],
        offset: 0,
        slidesGrid: []
    };
    const tempDOM = document2.createElement("div");
    function renderSlide(slide2, index) {
        const params = swiper.params.virtual;
        if (params.cache && swiper.virtual.cache[index]) {
            return swiper.virtual.cache[index];
        }
        let slideEl;
        if (params.renderSlide) {
            slideEl = params.renderSlide.call(swiper, slide2, index);
            if (typeof slideEl === "string") {
                tempDOM.innerHTML = slideEl;
                slideEl = tempDOM.children[0];
            }
        } else if (swiper.isElement) {
            slideEl = createElement("swiper-slide");
        } else {
            slideEl = createElement("div", swiper.params.slideClass);
        }
        slideEl.setAttribute("data-swiper-slide-index", index);
        if (!params.renderSlide) {
            slideEl.innerHTML = slide2;
        }
        if (params.cache) {
            swiper.virtual.cache[index] = slideEl;
        }
        return slideEl;
    }
    function update2(force, beforeInit) {
        const { slidesPerView, slidesPerGroup, centeredSlides, loop: isLoop, initialSlide } = swiper.params;
        if (beforeInit && !isLoop && initialSlide > 0) {
            return;
        }
        const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
        const { from: previousFrom, to: previousTo, slides, slidesGrid: previousSlidesGrid, offset: previousOffset } = swiper.virtual;
        if (!swiper.params.cssMode) {
            swiper.updateActiveIndex();
        }
        const activeIndex = swiper.activeIndex || 0;
        let offsetProp;
        if (swiper.rtlTranslate) offsetProp = "right";
        else offsetProp = swiper.isHorizontal() ? "left" : "top";
        let slidesAfter;
        let slidesBefore;
        if (centeredSlides) {
            slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
            slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        } else {
            slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesAfter;
            slidesBefore = (isLoop ? slidesPerView : slidesPerGroup) + addSlidesBefore;
        }
        let from = activeIndex - slidesBefore;
        let to = activeIndex + slidesAfter;
        if (!isLoop) {
            from = Math.max(from, 0);
            to = Math.min(to, slides.length - 1);
        }
        let offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
        if (isLoop && activeIndex >= slidesBefore) {
            from -= slidesBefore;
            if (!centeredSlides) offset += swiper.slidesGrid[0];
        } else if (isLoop && activeIndex < slidesBefore) {
            from = -slidesBefore;
            if (centeredSlides) offset += swiper.slidesGrid[0];
        }
        Object.assign(swiper.virtual, {
            from,
            to,
            offset,
            slidesGrid: swiper.slidesGrid,
            slidesBefore,
            slidesAfter
        });
        function onRendered() {
            swiper.updateSlides();
            swiper.updateProgress();
            swiper.updateSlidesClasses();
            emit("virtualUpdate");
        }
        if (previousFrom === from && previousTo === to && !force) {
            if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
                swiper.slides.forEach((slideEl)=>{
                    slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
                });
            }
            swiper.updateProgress();
            emit("virtualUpdate");
            return;
        }
        if (swiper.params.virtual.renderExternal) {
            swiper.params.virtual.renderExternal.call(swiper, {
                offset,
                from,
                to,
                slides: function getSlides() {
                    const slidesToRender = [];
                    for(let i2 = from; i2 <= to; i2 += 1){
                        slidesToRender.push(slides[i2]);
                    }
                    return slidesToRender;
                }()
            });
            if (swiper.params.virtual.renderExternalUpdate) {
                onRendered();
            } else {
                emit("virtualUpdate");
            }
            return;
        }
        const prependIndexes = [];
        const appendIndexes = [];
        const getSlideIndex = (index)=>{
            let slideIndex = index;
            if (index < 0) {
                slideIndex = slides.length + index;
            } else if (slideIndex >= slides.length) {
                slideIndex = slideIndex - slides.length;
            }
            return slideIndex;
        };
        if (force) {
            swiper.slides.filter((el)=>el.matches(`.${swiper.params.slideClass}, swiper-slide`)).forEach((slideEl)=>{
                slideEl.remove();
            });
        } else {
            for(let i2 = previousFrom; i2 <= previousTo; i2 += 1){
                if (i2 < from || i2 > to) {
                    const slideIndex = getSlideIndex(i2);
                    swiper.slides.filter((el)=>el.matches(`.${swiper.params.slideClass}[data-swiper-slide-index="${slideIndex}"], swiper-slide[data-swiper-slide-index="${slideIndex}"]`)).forEach((slideEl)=>{
                        slideEl.remove();
                    });
                }
            }
        }
        const loopFrom = isLoop ? -slides.length : 0;
        const loopTo = isLoop ? slides.length * 2 : slides.length;
        for(let i2 = loopFrom; i2 < loopTo; i2 += 1){
            if (i2 >= from && i2 <= to) {
                const slideIndex = getSlideIndex(i2);
                if (typeof previousTo === "undefined" || force) {
                    appendIndexes.push(slideIndex);
                } else {
                    if (i2 > previousTo) appendIndexes.push(slideIndex);
                    if (i2 < previousFrom) prependIndexes.push(slideIndex);
                }
            }
        }
        appendIndexes.forEach((index)=>{
            swiper.slidesEl.append(renderSlide(slides[index], index));
        });
        if (isLoop) {
            for(let i2 = prependIndexes.length - 1; i2 >= 0; i2 -= 1){
                const index = prependIndexes[i2];
                swiper.slidesEl.prepend(renderSlide(slides[index], index));
            }
        } else {
            prependIndexes.sort((a, b)=>b - a);
            prependIndexes.forEach((index)=>{
                swiper.slidesEl.prepend(renderSlide(slides[index], index));
            });
        }
        elementChildren(swiper.slidesEl, ".swiper-slide, swiper-slide").forEach((slideEl)=>{
            slideEl.style[offsetProp] = `${offset - Math.abs(swiper.cssOverflowAdjustment())}px`;
        });
        onRendered();
    }
    function appendSlide2(slides) {
        if (typeof slides === "object" && "length" in slides) {
            for(let i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.push(slides[i2]);
            }
        } else {
            swiper.virtual.slides.push(slides);
        }
        update2(true);
    }
    function prependSlide2(slides) {
        const activeIndex = swiper.activeIndex;
        let newActiveIndex = activeIndex + 1;
        let numberOfNewSlides = 1;
        if (Array.isArray(slides)) {
            for(let i2 = 0; i2 < slides.length; i2 += 1){
                if (slides[i2]) swiper.virtual.slides.unshift(slides[i2]);
            }
            newActiveIndex = activeIndex + slides.length;
            numberOfNewSlides = slides.length;
        } else {
            swiper.virtual.slides.unshift(slides);
        }
        if (swiper.params.virtual.cache) {
            const cache = swiper.virtual.cache;
            const newCache = {};
            Object.keys(cache).forEach((cachedIndex)=>{
                const cachedEl = cache[cachedIndex];
                const cachedElIndex = cachedEl.getAttribute("data-swiper-slide-index");
                if (cachedElIndex) {
                    cachedEl.setAttribute("data-swiper-slide-index", parseInt(cachedElIndex, 10) + numberOfNewSlides);
                }
                newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = cachedEl;
            });
            swiper.virtual.cache = newCache;
        }
        update2(true);
        swiper.slideTo(newActiveIndex, 0);
    }
    function removeSlide2(slidesIndexes) {
        if (typeof slidesIndexes === "undefined" || slidesIndexes === null) return;
        let activeIndex = swiper.activeIndex;
        if (Array.isArray(slidesIndexes)) {
            for(let i2 = slidesIndexes.length - 1; i2 >= 0; i2 -= 1){
                if (swiper.params.virtual.cache) {
                    delete swiper.virtual.cache[slidesIndexes[i2]];
                    Object.keys(swiper.virtual.cache).forEach((key)=>{
                        if (key > slidesIndexes) {
                            swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                            swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
                            delete swiper.virtual.cache[key];
                        }
                    });
                }
                swiper.virtual.slides.splice(slidesIndexes[i2], 1);
                if (slidesIndexes[i2] < activeIndex) activeIndex -= 1;
                activeIndex = Math.max(activeIndex, 0);
            }
        } else {
            if (swiper.params.virtual.cache) {
                delete swiper.virtual.cache[slidesIndexes];
                Object.keys(swiper.virtual.cache).forEach((key)=>{
                    if (key > slidesIndexes) {
                        swiper.virtual.cache[key - 1] = swiper.virtual.cache[key];
                        swiper.virtual.cache[key - 1].setAttribute("data-swiper-slide-index", key - 1);
                        delete swiper.virtual.cache[key];
                    }
                });
            }
            swiper.virtual.slides.splice(slidesIndexes, 1);
            if (slidesIndexes < activeIndex) activeIndex -= 1;
            activeIndex = Math.max(activeIndex, 0);
        }
        update2(true);
        swiper.slideTo(activeIndex, 0);
    }
    function removeAllSlides2() {
        swiper.virtual.slides = [];
        if (swiper.params.virtual.cache) {
            swiper.virtual.cache = {};
        }
        update2(true);
        swiper.slideTo(0, 0);
    }
    on("beforeInit", ()=>{
        if (!swiper.params.virtual.enabled) return;
        let domSlidesAssigned;
        if (typeof swiper.passedParams.virtual.slides === "undefined") {
            const slides = [
                ...swiper.slidesEl.children
            ].filter((el)=>el.matches(`.${swiper.params.slideClass}, swiper-slide`));
            if (slides && slides.length) {
                swiper.virtual.slides = [
                    ...slides
                ];
                domSlidesAssigned = true;
                slides.forEach((slideEl, slideIndex)=>{
                    slideEl.setAttribute("data-swiper-slide-index", slideIndex);
                    swiper.virtual.cache[slideIndex] = slideEl;
                    slideEl.remove();
                });
            }
        }
        if (!domSlidesAssigned) {
            swiper.virtual.slides = swiper.params.virtual.slides;
        }
        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
        update2(false, true);
    });
    on("setTranslate", ()=>{
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode && !swiper._immediateVirtual) {
            clearTimeout(cssModeTimeout);
            cssModeTimeout = setTimeout(()=>{
                update2();
            }, 100);
        } else {
            update2();
        }
    });
    on("init update resize", ()=>{
        if (!swiper.params.virtual.enabled) return;
        if (swiper.params.cssMode) {
            setCSSProperty(swiper.wrapperEl, "--swiper-virtual-size", `${swiper.virtualSize}px`);
        }
    });
    Object.assign(swiper.virtual, {
        appendSlide: appendSlide2,
        prependSlide: prependSlide2,
        removeSlide: removeSlide2,
        removeAllSlides: removeAllSlides2,
        update: update2
    });
}
// node_modules/swiper/modules/keyboard.mjs
function Keyboard(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const document2 = getDocument();
    const window2 = getWindow();
    swiper.keyboard = {
        enabled: false
    };
    extendParams({
        keyboard: {
            enabled: false,
            onlyInViewport: true,
            pageUpDown: true
        }
    });
    function handle(event2) {
        if (!swiper.enabled) return;
        const { rtlTranslate: rtl } = swiper;
        let e = event2;
        if (e.originalEvent) e = e.originalEvent;
        const kc = e.keyCode || e.charCode;
        const pageUpDown = swiper.params.keyboard.pageUpDown;
        const isPageUp = pageUpDown && kc === 33;
        const isPageDown = pageUpDown && kc === 34;
        const isArrowLeft = kc === 37;
        const isArrowRight = kc === 39;
        const isArrowUp = kc === 38;
        const isArrowDown = kc === 40;
        if (!swiper.allowSlideNext && (swiper.isHorizontal() && isArrowRight || swiper.isVertical() && isArrowDown || isPageDown)) {
            return false;
        }
        if (!swiper.allowSlidePrev && (swiper.isHorizontal() && isArrowLeft || swiper.isVertical() && isArrowUp || isPageUp)) {
            return false;
        }
        if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
            return void 0;
        }
        if (document2.activeElement && document2.activeElement.nodeName && (document2.activeElement.nodeName.toLowerCase() === "input" || document2.activeElement.nodeName.toLowerCase() === "textarea")) {
            return void 0;
        }
        if (swiper.params.keyboard.onlyInViewport && (isPageUp || isPageDown || isArrowLeft || isArrowRight || isArrowUp || isArrowDown)) {
            let inView = false;
            if (elementParents(swiper.el, `.${swiper.params.slideClass}, swiper-slide`).length > 0 && elementParents(swiper.el, `.${swiper.params.slideActiveClass}`).length === 0) {
                return void 0;
            }
            const el = swiper.el;
            const swiperWidth = el.clientWidth;
            const swiperHeight = el.clientHeight;
            const windowWidth = window2.innerWidth;
            const windowHeight = window2.innerHeight;
            const swiperOffset = elementOffset(el);
            if (rtl) swiperOffset.left -= el.scrollLeft;
            const swiperCoord = [
                [
                    swiperOffset.left,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top
                ],
                [
                    swiperOffset.left,
                    swiperOffset.top + swiperHeight
                ],
                [
                    swiperOffset.left + swiperWidth,
                    swiperOffset.top + swiperHeight
                ]
            ];
            for(let i2 = 0; i2 < swiperCoord.length; i2 += 1){
                const point = swiperCoord[i2];
                if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
                    if (point[0] === 0 && point[1] === 0) continue;
                    inView = true;
                }
            }
            if (!inView) return void 0;
        }
        if (swiper.isHorizontal()) {
            if (isPageUp || isPageDown || isArrowLeft || isArrowRight) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if ((isPageDown || isArrowRight) && !rtl || (isPageUp || isArrowLeft) && rtl) swiper.slideNext();
            if ((isPageUp || isArrowLeft) && !rtl || (isPageDown || isArrowRight) && rtl) swiper.slidePrev();
        } else {
            if (isPageUp || isPageDown || isArrowUp || isArrowDown) {
                if (e.preventDefault) e.preventDefault();
                else e.returnValue = false;
            }
            if (isPageDown || isArrowDown) swiper.slideNext();
            if (isPageUp || isArrowUp) swiper.slidePrev();
        }
        emit("keyPress", kc);
        return void 0;
    }
    function enable() {
        if (swiper.keyboard.enabled) return;
        document2.addEventListener("keydown", handle);
        swiper.keyboard.enabled = true;
    }
    function disable() {
        if (!swiper.keyboard.enabled) return;
        document2.removeEventListener("keydown", handle);
        swiper.keyboard.enabled = false;
    }
    on("init", ()=>{
        if (swiper.params.keyboard.enabled) {
            enable();
        }
    });
    on("destroy", ()=>{
        if (swiper.keyboard.enabled) {
            disable();
        }
    });
    Object.assign(swiper.keyboard, {
        enable,
        disable
    });
}
// node_modules/swiper/modules/mousewheel.mjs
function Mousewheel(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const window2 = getWindow();
    extendParams({
        mousewheel: {
            enabled: false,
            releaseOnEdges: false,
            invert: false,
            forceToAxis: false,
            sensitivity: 1,
            eventsTarget: "container",
            thresholdDelta: null,
            thresholdTime: null,
            noMousewheelClass: "swiper-no-mousewheel"
        }
    });
    swiper.mousewheel = {
        enabled: false
    };
    let timeout;
    let lastScrollTime = now2();
    let lastEventBeforeSnap;
    const recentWheelEvents = [];
    function normalize(e) {
        const PIXEL_STEP = 10;
        const LINE_HEIGHT2 = 40;
        const PAGE_HEIGHT = 800;
        let sX = 0;
        let sY = 0;
        let pX = 0;
        let pY = 0;
        if ("detail" in e) {
            sY = e.detail;
        }
        if ("wheelDelta" in e) {
            sY = -e.wheelDelta / 120;
        }
        if ("wheelDeltaY" in e) {
            sY = -e.wheelDeltaY / 120;
        }
        if ("wheelDeltaX" in e) {
            sX = -e.wheelDeltaX / 120;
        }
        if ("axis" in e && e.axis === e.HORIZONTAL_AXIS) {
            sX = sY;
            sY = 0;
        }
        pX = sX * PIXEL_STEP;
        pY = sY * PIXEL_STEP;
        if ("deltaY" in e) {
            pY = e.deltaY;
        }
        if ("deltaX" in e) {
            pX = e.deltaX;
        }
        if (e.shiftKey && !pX) {
            pX = pY;
            pY = 0;
        }
        if ((pX || pY) && e.deltaMode) {
            if (e.deltaMode === 1) {
                pX *= LINE_HEIGHT2;
                pY *= LINE_HEIGHT2;
            } else {
                pX *= PAGE_HEIGHT;
                pY *= PAGE_HEIGHT;
            }
        }
        if (pX && !sX) {
            sX = pX < 1 ? -1 : 1;
        }
        if (pY && !sY) {
            sY = pY < 1 ? -1 : 1;
        }
        return {
            spinX: sX,
            spinY: sY,
            pixelX: pX,
            pixelY: pY
        };
    }
    function handleMouseEnter() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = true;
    }
    function handleMouseLeave() {
        if (!swiper.enabled) return;
        swiper.mouseEntered = false;
    }
    function animateSlider(newEvent) {
        if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {
            return false;
        }
        if (swiper.params.mousewheel.thresholdTime && now2() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {
            return false;
        }
        if (newEvent.delta >= 6 && now2() - lastScrollTime < 60) {
            return true;
        }
        if (newEvent.direction < 0) {
            if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
                swiper.slideNext();
                emit("scroll", newEvent.raw);
            }
        } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
            swiper.slidePrev();
            emit("scroll", newEvent.raw);
        }
        lastScrollTime = new window2.Date().getTime();
        return false;
    }
    function releaseScroll(newEvent) {
        const params = swiper.params.mousewheel;
        if (newEvent.direction < 0) {
            if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
                return true;
            }
        } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
            return true;
        }
        return false;
    }
    function handle(event2) {
        let e = event2;
        let disableParentSwiper = true;
        if (!swiper.enabled) return;
        if (event2.target.closest(`.${swiper.params.mousewheel.noMousewheelClass}`)) return;
        const params = swiper.params.mousewheel;
        if (swiper.params.cssMode) {
            e.preventDefault();
        }
        let targetEl = swiper.el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
        }
        const targetElContainsTarget = targetEl && targetEl.contains(e.target);
        if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;
        if (e.originalEvent) e = e.originalEvent;
        let delta = 0;
        const rtlFactor = swiper.rtlTranslate ? -1 : 1;
        const data = normalize(e);
        if (params.forceToAxis) {
            if (swiper.isHorizontal()) {
                if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;
                else return true;
            } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;
            else return true;
        } else {
            delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
        }
        if (delta === 0) return true;
        if (params.invert) delta = -delta;
        let positions = swiper.getTranslate() + delta * params.sensitivity;
        if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();
        if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();
        disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());
        if (disableParentSwiper && swiper.params.nested) e.stopPropagation();
        if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {
            const newEvent = {
                time: now2(),
                delta: Math.abs(delta),
                direction: Math.sign(delta),
                raw: event2
            };
            if (recentWheelEvents.length >= 2) {
                recentWheelEvents.shift();
            }
            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
            recentWheelEvents.push(newEvent);
            if (prevEvent) {
                if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {
                    animateSlider(newEvent);
                }
            } else {
                animateSlider(newEvent);
            }
            if (releaseScroll(newEvent)) {
                return true;
            }
        } else {
            const newEvent = {
                time: now2(),
                delta: Math.abs(delta),
                direction: Math.sign(delta)
            };
            const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;
            if (!ignoreWheelEvents) {
                lastEventBeforeSnap = void 0;
                let position = swiper.getTranslate() + delta * params.sensitivity;
                const wasBeginning = swiper.isBeginning;
                const wasEnd = swiper.isEnd;
                if (position >= swiper.minTranslate()) position = swiper.minTranslate();
                if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();
                swiper.setTransition(0);
                swiper.setTranslate(position);
                swiper.updateProgress();
                swiper.updateActiveIndex();
                swiper.updateSlidesClasses();
                if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
                    swiper.updateSlidesClasses();
                }
                if (swiper.params.loop) {
                    swiper.loopFix({
                        direction: newEvent.direction < 0 ? "next" : "prev",
                        byMousewheel: true
                    });
                }
                if (swiper.params.freeMode.sticky) {
                    clearTimeout(timeout);
                    timeout = void 0;
                    if (recentWheelEvents.length >= 15) {
                        recentWheelEvents.shift();
                    }
                    const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : void 0;
                    const firstEvent = recentWheelEvents[0];
                    recentWheelEvents.push(newEvent);
                    if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
                        recentWheelEvents.splice(0);
                    } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {
                        const snapToThreshold = delta > 0 ? 0.8 : 0.2;
                        lastEventBeforeSnap = newEvent;
                        recentWheelEvents.splice(0);
                        timeout = nextTick4(()=>{
                            if (swiper.destroyed || !swiper.params) return;
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                        }, 0);
                    }
                    if (!timeout) {
                        timeout = nextTick4(()=>{
                            if (swiper.destroyed || !swiper.params) return;
                            const snapToThreshold = 0.5;
                            lastEventBeforeSnap = newEvent;
                            recentWheelEvents.splice(0);
                            swiper.slideToClosest(swiper.params.speed, true, void 0, snapToThreshold);
                        }, 500);
                    }
                }
                if (!ignoreWheelEvents) emit("scroll", e);
                if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
                if (params.releaseOnEdges && (position === swiper.minTranslate() || position === swiper.maxTranslate())) {
                    return true;
                }
            }
        }
        if (e.preventDefault) e.preventDefault();
        else e.returnValue = false;
        return false;
    }
    function events2(method) {
        let targetEl = swiper.el;
        if (swiper.params.mousewheel.eventsTarget !== "container") {
            targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);
        }
        targetEl[method]("mouseenter", handleMouseEnter);
        targetEl[method]("mouseleave", handleMouseLeave);
        targetEl[method]("wheel", handle);
    }
    function enable() {
        if (swiper.params.cssMode) {
            swiper.wrapperEl.removeEventListener("wheel", handle);
            return true;
        }
        if (swiper.mousewheel.enabled) return false;
        events2("addEventListener");
        swiper.mousewheel.enabled = true;
        return true;
    }
    function disable() {
        if (swiper.params.cssMode) {
            swiper.wrapperEl.addEventListener(event, handle);
            return true;
        }
        if (!swiper.mousewheel.enabled) return false;
        events2("removeEventListener");
        swiper.mousewheel.enabled = false;
        return true;
    }
    on("init", ()=>{
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
            disable();
        }
        if (swiper.params.mousewheel.enabled) enable();
    });
    on("destroy", ()=>{
        if (swiper.params.cssMode) {
            enable();
        }
        if (swiper.mousewheel.enabled) disable();
    });
    Object.assign(swiper.mousewheel, {
        enable,
        disable
    });
}
// node_modules/swiper/shared/create-element-if-not-defined.mjs
function createElementIfNotDefined(swiper, originalParams, params, checkProps) {
    if (swiper.params.createElements) {
        Object.keys(checkProps).forEach((key)=>{
            if (!params[key] && params.auto === true) {
                let element = elementChildren(swiper.el, `.${checkProps[key]}`)[0];
                if (!element) {
                    element = createElement("div", checkProps[key]);
                    element.className = checkProps[key];
                    swiper.el.append(element);
                }
                params[key] = element;
                originalParams[key] = element;
            }
        });
    }
    return params;
}
// node_modules/swiper/modules/navigation.mjs
function Navigation(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    extendParams({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: false,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    });
    swiper.navigation = {
        nextEl: null,
        prevEl: null
    };
    function getEl(el) {
        let res;
        if (el && typeof el === "string" && swiper.isElement) {
            res = swiper.el.querySelector(el) || swiper.hostEl.querySelector(el);
            if (res) return res;
        }
        if (el) {
            if (typeof el === "string") res = [
                ...document.querySelectorAll(el)
            ];
            if (swiper.params.uniqueNavElements && typeof el === "string" && res && res.length > 1 && swiper.el.querySelectorAll(el).length === 1) {
                res = swiper.el.querySelector(el);
            } else if (res && res.length === 1) {
                res = res[0];
            }
        }
        if (el && !res) return el;
        return res;
    }
    function toggleEl(el, disabled) {
        const params = swiper.params.navigation;
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            if (subEl) {
                subEl.classList[disabled ? "add" : "remove"](...params.disabledClass.split(" "));
                if (subEl.tagName === "BUTTON") subEl.disabled = disabled;
                if (swiper.params.watchOverflow && swiper.enabled) {
                    subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
                }
            }
        });
    }
    function update2() {
        const { nextEl, prevEl } = swiper.navigation;
        if (swiper.params.loop) {
            toggleEl(prevEl, false);
            toggleEl(nextEl, false);
            return;
        }
        toggleEl(prevEl, swiper.isBeginning && !swiper.params.rewind);
        toggleEl(nextEl, swiper.isEnd && !swiper.params.rewind);
    }
    function onPrevClick(e) {
        e.preventDefault();
        if (swiper.isBeginning && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slidePrev();
        emit("navigationPrev");
    }
    function onNextClick(e) {
        e.preventDefault();
        if (swiper.isEnd && !swiper.params.loop && !swiper.params.rewind) return;
        swiper.slideNext();
        emit("navigationNext");
    }
    function init2() {
        const params = swiper.params.navigation;
        swiper.params.navigation = createElementIfNotDefined(swiper, swiper.originalParams.navigation, swiper.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        });
        if (!(params.nextEl || params.prevEl)) return;
        let nextEl = getEl(params.nextEl);
        let prevEl = getEl(params.prevEl);
        Object.assign(swiper.navigation, {
            nextEl,
            prevEl
        });
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const initButton = (el, dir)=>{
            if (el) {
                el.addEventListener("click", dir === "next" ? onNextClick : onPrevClick);
            }
            if (!swiper.enabled && el) {
                el.classList.add(...params.lockClass.split(" "));
            }
        };
        nextEl.forEach((el)=>initButton(el, "next"));
        prevEl.forEach((el)=>initButton(el, "prev"));
    }
    function destroy() {
        let { nextEl, prevEl } = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const destroyButton = (el, dir)=>{
            el.removeEventListener("click", dir === "next" ? onNextClick : onPrevClick);
            el.classList.remove(...swiper.params.navigation.disabledClass.split(" "));
        };
        nextEl.forEach((el)=>destroyButton(el, "next"));
        prevEl.forEach((el)=>destroyButton(el, "prev"));
    }
    on("init", ()=>{
        if (swiper.params.navigation.enabled === false) {
            disable();
        } else {
            init2();
            update2();
        }
    });
    on("toEdge fromEdge lock unlock", ()=>{
        update2();
    });
    on("destroy", ()=>{
        destroy();
    });
    on("enable disable", ()=>{
        let { nextEl, prevEl } = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        if (swiper.enabled) {
            update2();
            return;
        }
        [
            ...nextEl,
            ...prevEl
        ].filter((el)=>!!el).forEach((el)=>el.classList.add(swiper.params.navigation.lockClass));
    });
    on("click", (_s, e)=>{
        let { nextEl, prevEl } = swiper.navigation;
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        const targetEl = e.target;
        let targetIsButton = prevEl.includes(targetEl) || nextEl.includes(targetEl);
        if (swiper.isElement && !targetIsButton) {
            const path = e.path || e.composedPath && e.composedPath();
            if (path) {
                targetIsButton = path.find((pathEl)=>nextEl.includes(pathEl) || prevEl.includes(pathEl));
            }
        }
        if (swiper.params.navigation.hideOnClick && !targetIsButton) {
            if (swiper.pagination && swiper.params.pagination && swiper.params.pagination.clickable && (swiper.pagination.el === targetEl || swiper.pagination.el.contains(targetEl))) return;
            let isHidden;
            if (nextEl.length) {
                isHidden = nextEl[0].classList.contains(swiper.params.navigation.hiddenClass);
            } else if (prevEl.length) {
                isHidden = prevEl[0].classList.contains(swiper.params.navigation.hiddenClass);
            }
            if (isHidden === true) {
                emit("navigationShow");
            } else {
                emit("navigationHide");
            }
            [
                ...nextEl,
                ...prevEl
            ].filter((el)=>!!el).forEach((el)=>el.classList.toggle(swiper.params.navigation.hiddenClass));
        }
    });
    const enable = ()=>{
        swiper.el.classList.remove(...swiper.params.navigation.navigationDisabledClass.split(" "));
        init2();
        update2();
    };
    const disable = ()=>{
        swiper.el.classList.add(...swiper.params.navigation.navigationDisabledClass.split(" "));
        destroy();
    };
    Object.assign(swiper.navigation, {
        enable,
        disable,
        update: update2,
        init: init2,
        destroy
    });
}
// node_modules/swiper/shared/classes-to-selector.mjs
function classesToSelector(classes2) {
    if (classes2 === void 0) {
        classes2 = "";
    }
    return `.${classes2.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}`;
}
// node_modules/swiper/modules/pagination.mjs
function Pagination(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const pfx = "swiper-pagination";
    extendParams({
        pagination: {
            el: null,
            bulletElement: "span",
            clickable: false,
            hideOnClick: false,
            renderBullet: null,
            renderProgressbar: null,
            renderFraction: null,
            renderCustom: null,
            progressbarOpposite: false,
            type: "bullets",
            // 'bullets' or 'progressbar' or 'fraction' or 'custom'
            dynamicBullets: false,
            dynamicMainBullets: 1,
            formatFractionCurrent: (number2)=>number2,
            formatFractionTotal: (number2)=>number2,
            bulletClass: `${pfx}-bullet`,
            bulletActiveClass: `${pfx}-bullet-active`,
            modifierClass: `${pfx}-`,
            currentClass: `${pfx}-current`,
            totalClass: `${pfx}-total`,
            hiddenClass: `${pfx}-hidden`,
            progressbarFillClass: `${pfx}-progressbar-fill`,
            progressbarOppositeClass: `${pfx}-progressbar-opposite`,
            clickableClass: `${pfx}-clickable`,
            lockClass: `${pfx}-lock`,
            horizontalClass: `${pfx}-horizontal`,
            verticalClass: `${pfx}-vertical`,
            paginationDisabledClass: `${pfx}-disabled`
        }
    });
    swiper.pagination = {
        el: null,
        bullets: []
    };
    let bulletSize;
    let dynamicBulletIndex = 0;
    function isPaginationDisabled() {
        return !swiper.params.pagination.el || !swiper.pagination.el || Array.isArray(swiper.pagination.el) && swiper.pagination.el.length === 0;
    }
    function setSideBullets(bulletEl, position) {
        const { bulletActiveClass } = swiper.params.pagination;
        if (!bulletEl) return;
        bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
        if (bulletEl) {
            bulletEl.classList.add(`${bulletActiveClass}-${position}`);
            bulletEl = bulletEl[`${position === "prev" ? "previous" : "next"}ElementSibling`];
            if (bulletEl) {
                bulletEl.classList.add(`${bulletActiveClass}-${position}-${position}`);
            }
        }
    }
    function getMoveDirection(prevIndex, nextIndex, length) {
        prevIndex = prevIndex % length;
        nextIndex = nextIndex % length;
        if (nextIndex === prevIndex + 1) {
            return "next";
        } else if (nextIndex === prevIndex - 1) {
            return "previous";
        }
        return;
    }
    function onBulletClick(e) {
        const bulletEl = e.target.closest(classesToSelector(swiper.params.pagination.bulletClass));
        if (!bulletEl) {
            return;
        }
        e.preventDefault();
        const index = elementIndex(bulletEl) * swiper.params.slidesPerGroup;
        if (swiper.params.loop) {
            if (swiper.realIndex === index) return;
            const moveDirection = getMoveDirection(swiper.realIndex, index, swiper.slides.length);
            if (moveDirection === "next") {
                swiper.slideNext();
            } else if (moveDirection === "previous") {
                swiper.slidePrev();
            } else {
                swiper.slideToLoop(index);
            }
        } else {
            swiper.slideTo(index);
        }
    }
    function update2() {
        const rtl = swiper.rtl;
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        let el = swiper.pagination.el;
        el = makeElementsArray(el);
        let current;
        let previousIndex;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
        const total = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        if (swiper.params.loop) {
            previousIndex = swiper.previousRealIndex || 0;
            current = swiper.params.slidesPerGroup > 1 ? Math.floor(swiper.realIndex / swiper.params.slidesPerGroup) : swiper.realIndex;
        } else if (typeof swiper.snapIndex !== "undefined") {
            current = swiper.snapIndex;
            previousIndex = swiper.previousSnapIndex;
        } else {
            previousIndex = swiper.previousIndex || 0;
            current = swiper.activeIndex || 0;
        }
        if (params.type === "bullets" && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
            const bullets = swiper.pagination.bullets;
            let firstIndex;
            let lastIndex;
            let midIndex;
            if (params.dynamicBullets) {
                bulletSize = elementOuterSize(bullets[0], swiper.isHorizontal() ? "width" : "height", true);
                el.forEach((subEl)=>{
                    subEl.style[swiper.isHorizontal() ? "width" : "height"] = `${bulletSize * (params.dynamicMainBullets + 4)}px`;
                });
                if (params.dynamicMainBullets > 1 && previousIndex !== void 0) {
                    dynamicBulletIndex += current - (previousIndex || 0);
                    if (dynamicBulletIndex > params.dynamicMainBullets - 1) {
                        dynamicBulletIndex = params.dynamicMainBullets - 1;
                    } else if (dynamicBulletIndex < 0) {
                        dynamicBulletIndex = 0;
                    }
                }
                firstIndex = Math.max(current - dynamicBulletIndex, 0);
                lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
                midIndex = (lastIndex + firstIndex) / 2;
            }
            bullets.forEach((bulletEl)=>{
                const classesToRemove = [
                    ...[
                        "",
                        "-next",
                        "-next-next",
                        "-prev",
                        "-prev-prev",
                        "-main"
                    ].map((suffix)=>`${params.bulletActiveClass}${suffix}`)
                ].map((s)=>typeof s === "string" && s.includes(" ") ? s.split(" ") : s).flat();
                bulletEl.classList.remove(...classesToRemove);
            });
            if (el.length > 1) {
                bullets.forEach((bullet)=>{
                    const bulletIndex = elementIndex(bullet);
                    if (bulletIndex === current) {
                        bullet.classList.add(...params.bulletActiveClass.split(" "));
                    } else if (swiper.isElement) {
                        bullet.setAttribute("part", "bullet");
                    }
                    if (params.dynamicBullets) {
                        if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                            bullet.classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                        }
                        if (bulletIndex === firstIndex) {
                            setSideBullets(bullet, "prev");
                        }
                        if (bulletIndex === lastIndex) {
                            setSideBullets(bullet, "next");
                        }
                    }
                });
            } else {
                const bullet = bullets[current];
                if (bullet) {
                    bullet.classList.add(...params.bulletActiveClass.split(" "));
                }
                if (swiper.isElement) {
                    bullets.forEach((bulletEl, bulletIndex)=>{
                        bulletEl.setAttribute("part", bulletIndex === current ? "bullet-active" : "bullet");
                    });
                }
                if (params.dynamicBullets) {
                    const firstDisplayedBullet = bullets[firstIndex];
                    const lastDisplayedBullet = bullets[lastIndex];
                    for(let i2 = firstIndex; i2 <= lastIndex; i2 += 1){
                        if (bullets[i2]) {
                            bullets[i2].classList.add(...`${params.bulletActiveClass}-main`.split(" "));
                        }
                    }
                    setSideBullets(firstDisplayedBullet, "prev");
                    setSideBullets(lastDisplayedBullet, "next");
                }
            }
            if (params.dynamicBullets) {
                const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
                const bulletsOffset = (bulletSize * dynamicBulletsLength - bulletSize) / 2 - midIndex * bulletSize;
                const offsetProp = rtl ? "right" : "left";
                bullets.forEach((bullet)=>{
                    bullet.style[swiper.isHorizontal() ? offsetProp : "top"] = `${bulletsOffset}px`;
                });
            }
        }
        el.forEach((subEl, subElIndex)=>{
            if (params.type === "fraction") {
                subEl.querySelectorAll(classesToSelector(params.currentClass)).forEach((fractionEl)=>{
                    fractionEl.textContent = params.formatFractionCurrent(current + 1);
                });
                subEl.querySelectorAll(classesToSelector(params.totalClass)).forEach((totalEl)=>{
                    totalEl.textContent = params.formatFractionTotal(total);
                });
            }
            if (params.type === "progressbar") {
                let progressbarDirection;
                if (params.progressbarOpposite) {
                    progressbarDirection = swiper.isHorizontal() ? "vertical" : "horizontal";
                } else {
                    progressbarDirection = swiper.isHorizontal() ? "horizontal" : "vertical";
                }
                const scale = (current + 1) / total;
                let scaleX = 1;
                let scaleY = 1;
                if (progressbarDirection === "horizontal") {
                    scaleX = scale;
                } else {
                    scaleY = scale;
                }
                subEl.querySelectorAll(classesToSelector(params.progressbarFillClass)).forEach((progressEl)=>{
                    progressEl.style.transform = `translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`;
                    progressEl.style.transitionDuration = `${swiper.params.speed}ms`;
                });
            }
            if (params.type === "custom" && params.renderCustom) {
                subEl.innerHTML = params.renderCustom(swiper, current + 1, total);
                if (subElIndex === 0) emit("paginationRender", subEl);
            } else {
                if (subElIndex === 0) emit("paginationRender", subEl);
                emit("paginationUpdate", subEl);
            }
            if (swiper.params.watchOverflow && swiper.enabled) {
                subEl.classList[swiper.isLocked ? "add" : "remove"](params.lockClass);
            }
        });
    }
    function render() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.grid && swiper.params.grid.rows > 1 ? swiper.slides.length / Math.ceil(swiper.params.grid.rows) : swiper.slides.length;
        let el = swiper.pagination.el;
        el = makeElementsArray(el);
        let paginationHTML = "";
        if (params.type === "bullets") {
            let numberOfBullets = swiper.params.loop ? Math.ceil(slidesLength / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
            if (swiper.params.freeMode && swiper.params.freeMode.enabled && numberOfBullets > slidesLength) {
                numberOfBullets = slidesLength;
            }
            for(let i2 = 0; i2 < numberOfBullets; i2 += 1){
                if (params.renderBullet) {
                    paginationHTML += params.renderBullet.call(swiper, i2, params.bulletClass);
                } else {
                    paginationHTML += `<${params.bulletElement} ${swiper.isElement ? 'part="bullet"' : ""} class="${params.bulletClass}"></${params.bulletElement}>`;
                }
            }
        }
        if (params.type === "fraction") {
            if (params.renderFraction) {
                paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
            } else {
                paginationHTML = `<span class="${params.currentClass}"></span> / <span class="${params.totalClass}"></span>`;
            }
        }
        if (params.type === "progressbar") {
            if (params.renderProgressbar) {
                paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
            } else {
                paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
            }
        }
        swiper.pagination.bullets = [];
        el.forEach((subEl)=>{
            if (params.type !== "custom") {
                subEl.innerHTML = paginationHTML || "";
            }
            if (params.type === "bullets") {
                swiper.pagination.bullets.push(...subEl.querySelectorAll(classesToSelector(params.bulletClass)));
            }
        });
        if (params.type !== "custom") {
            emit("paginationRender", el[0]);
        }
    }
    function init2() {
        swiper.params.pagination = createElementIfNotDefined(swiper, swiper.originalParams.pagination, swiper.params.pagination, {
            el: "swiper-pagination"
        });
        const params = swiper.params.pagination;
        if (!params.el) return;
        let el;
        if (typeof params.el === "string" && swiper.isElement) {
            el = swiper.el.querySelector(params.el);
        }
        if (!el && typeof params.el === "string") {
            el = [
                ...document.querySelectorAll(params.el)
            ];
        }
        if (!el) {
            el = params.el;
        }
        if (!el || el.length === 0) return;
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && Array.isArray(el) && el.length > 1) {
            el = [
                ...swiper.el.querySelectorAll(params.el)
            ];
            if (el.length > 1) {
                el = el.filter((subEl)=>{
                    if (elementParents(subEl, ".swiper")[0] !== swiper.el) return false;
                    return true;
                })[0];
            }
        }
        if (Array.isArray(el) && el.length === 1) el = el[0];
        Object.assign(swiper.pagination, {
            el
        });
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            if (params.type === "bullets" && params.clickable) {
                subEl.classList.add(...(params.clickableClass || "").split(" "));
            }
            subEl.classList.add(params.modifierClass + params.type);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
            if (params.type === "bullets" && params.dynamicBullets) {
                subEl.classList.add(`${params.modifierClass}${params.type}-dynamic`);
                dynamicBulletIndex = 0;
                if (params.dynamicMainBullets < 1) {
                    params.dynamicMainBullets = 1;
                }
            }
            if (params.type === "progressbar" && params.progressbarOpposite) {
                subEl.classList.add(params.progressbarOppositeClass);
            }
            if (params.clickable) {
                subEl.addEventListener("click", onBulletClick);
            }
            if (!swiper.enabled) {
                subEl.classList.add(params.lockClass);
            }
        });
    }
    function destroy() {
        const params = swiper.params.pagination;
        if (isPaginationDisabled()) return;
        let el = swiper.pagination.el;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl)=>{
                subEl.classList.remove(params.hiddenClass);
                subEl.classList.remove(params.modifierClass + params.type);
                subEl.classList.remove(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
                if (params.clickable) {
                    subEl.classList.remove(...(params.clickableClass || "").split(" "));
                    subEl.removeEventListener("click", onBulletClick);
                }
            });
        }
        if (swiper.pagination.bullets) swiper.pagination.bullets.forEach((subEl)=>subEl.classList.remove(...params.bulletActiveClass.split(" ")));
    }
    on("changeDirection", ()=>{
        if (!swiper.pagination || !swiper.pagination.el) return;
        const params = swiper.params.pagination;
        let { el } = swiper.pagination;
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.classList.remove(params.horizontalClass, params.verticalClass);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        });
    });
    on("init", ()=>{
        if (swiper.params.pagination.enabled === false) {
            disable();
        } else {
            init2();
            render();
            update2();
        }
    });
    on("activeIndexChange", ()=>{
        if (typeof swiper.snapIndex === "undefined") {
            update2();
        }
    });
    on("snapIndexChange", ()=>{
        update2();
    });
    on("snapGridLengthChange", ()=>{
        render();
        update2();
    });
    on("destroy", ()=>{
        destroy();
    });
    on("enable disable", ()=>{
        let { el } = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl)=>subEl.classList[swiper.enabled ? "remove" : "add"](swiper.params.pagination.lockClass));
        }
    });
    on("lock unlock", ()=>{
        update2();
    });
    on("click", (_s, e)=>{
        const targetEl = e.target;
        const el = makeElementsArray(swiper.pagination.el);
        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && el && el.length > 0 && !targetEl.classList.contains(swiper.params.pagination.bulletClass)) {
            if (swiper.navigation && (swiper.navigation.nextEl && targetEl === swiper.navigation.nextEl || swiper.navigation.prevEl && targetEl === swiper.navigation.prevEl)) return;
            const isHidden = el[0].classList.contains(swiper.params.pagination.hiddenClass);
            if (isHidden === true) {
                emit("paginationShow");
            } else {
                emit("paginationHide");
            }
            el.forEach((subEl)=>subEl.classList.toggle(swiper.params.pagination.hiddenClass));
        }
    });
    const enable = ()=>{
        swiper.el.classList.remove(swiper.params.pagination.paginationDisabledClass);
        let { el } = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl)=>subEl.classList.remove(swiper.params.pagination.paginationDisabledClass));
        }
        init2();
        render();
        update2();
    };
    const disable = ()=>{
        swiper.el.classList.add(swiper.params.pagination.paginationDisabledClass);
        let { el } = swiper.pagination;
        if (el) {
            el = makeElementsArray(el);
            el.forEach((subEl)=>subEl.classList.add(swiper.params.pagination.paginationDisabledClass));
        }
        destroy();
    };
    Object.assign(swiper.pagination, {
        enable,
        disable,
        render,
        update: update2,
        init: init2,
        destroy
    });
}
// node_modules/swiper/modules/scrollbar.mjs
function Scrollbar(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const document2 = getDocument();
    let isTouched = false;
    let timeout = null;
    let dragTimeout = null;
    let dragStartPos;
    let dragSize;
    let trackSize;
    let divider;
    extendParams({
        scrollbar: {
            el: null,
            dragSize: "auto",
            hide: false,
            draggable: false,
            snapOnRelease: true,
            lockClass: "swiper-scrollbar-lock",
            dragClass: "swiper-scrollbar-drag",
            scrollbarDisabledClass: "swiper-scrollbar-disabled",
            horizontalClass: `swiper-scrollbar-horizontal`,
            verticalClass: `swiper-scrollbar-vertical`
        }
    });
    swiper.scrollbar = {
        el: null,
        dragEl: null
    };
    function setTranslate2() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const { scrollbar, rtlTranslate: rtl } = swiper;
        const { dragEl, el } = scrollbar;
        const params = swiper.params.scrollbar;
        const progress = swiper.params.loop ? swiper.progressLoop : swiper.progress;
        let newSize = dragSize;
        let newPos = (trackSize - dragSize) * progress;
        if (rtl) {
            newPos = -newPos;
            if (newPos > 0) {
                newSize = dragSize - newPos;
                newPos = 0;
            } else if (-newPos + dragSize > trackSize) {
                newSize = trackSize + newPos;
            }
        } else if (newPos < 0) {
            newSize = dragSize + newPos;
            newPos = 0;
        } else if (newPos + dragSize > trackSize) {
            newSize = trackSize - newPos;
        }
        if (swiper.isHorizontal()) {
            dragEl.style.transform = `translate3d(${newPos}px, 0, 0)`;
            dragEl.style.width = `${newSize}px`;
        } else {
            dragEl.style.transform = `translate3d(0px, ${newPos}px, 0)`;
            dragEl.style.height = `${newSize}px`;
        }
        if (params.hide) {
            clearTimeout(timeout);
            el.style.opacity = 1;
            timeout = setTimeout(()=>{
                el.style.opacity = 0;
                el.style.transitionDuration = "400ms";
            }, 1e3);
        }
    }
    function setTransition2(duration) {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        swiper.scrollbar.dragEl.style.transitionDuration = `${duration}ms`;
    }
    function updateSize2() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        const { scrollbar } = swiper;
        const { dragEl, el } = scrollbar;
        dragEl.style.width = "";
        dragEl.style.height = "";
        trackSize = swiper.isHorizontal() ? el.offsetWidth : el.offsetHeight;
        divider = swiper.size / (swiper.virtualSize + swiper.params.slidesOffsetBefore - (swiper.params.centeredSlides ? swiper.snapGrid[0] : 0));
        if (swiper.params.scrollbar.dragSize === "auto") {
            dragSize = trackSize * divider;
        } else {
            dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
        }
        if (swiper.isHorizontal()) {
            dragEl.style.width = `${dragSize}px`;
        } else {
            dragEl.style.height = `${dragSize}px`;
        }
        if (divider >= 1) {
            el.style.display = "none";
        } else {
            el.style.display = "";
        }
        if (swiper.params.scrollbar.hide) {
            el.style.opacity = 0;
        }
        if (swiper.params.watchOverflow && swiper.enabled) {
            scrollbar.el.classList[swiper.isLocked ? "add" : "remove"](swiper.params.scrollbar.lockClass);
        }
    }
    function getPointerPosition(e) {
        return swiper.isHorizontal() ? e.clientX : e.clientY;
    }
    function setDragPosition(e) {
        const { scrollbar, rtlTranslate: rtl } = swiper;
        const { el } = scrollbar;
        let positionRatio;
        positionRatio = (getPointerPosition(e) - elementOffset(el)[swiper.isHorizontal() ? "left" : "top"] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
        positionRatio = Math.max(Math.min(positionRatio, 1), 0);
        if (rtl) {
            positionRatio = 1 - positionRatio;
        }
        const position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
        swiper.updateProgress(position);
        swiper.setTranslate(position);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
    }
    function onDragStart(e) {
        const params = swiper.params.scrollbar;
        const { scrollbar, wrapperEl } = swiper;
        const { el, dragEl } = scrollbar;
        isTouched = true;
        dragStartPos = e.target === dragEl ? getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? "left" : "top"] : null;
        e.preventDefault();
        e.stopPropagation();
        wrapperEl.style.transitionDuration = "100ms";
        dragEl.style.transitionDuration = "100ms";
        setDragPosition(e);
        clearTimeout(dragTimeout);
        el.style.transitionDuration = "0ms";
        if (params.hide) {
            el.style.opacity = 1;
        }
        if (swiper.params.cssMode) {
            swiper.wrapperEl.style["scroll-snap-type"] = "none";
        }
        emit("scrollbarDragStart", e);
    }
    function onDragMove(e) {
        const { scrollbar, wrapperEl } = swiper;
        const { el, dragEl } = scrollbar;
        if (!isTouched) return;
        if (e.preventDefault && e.cancelable) e.preventDefault();
        else e.returnValue = false;
        setDragPosition(e);
        wrapperEl.style.transitionDuration = "0ms";
        el.style.transitionDuration = "0ms";
        dragEl.style.transitionDuration = "0ms";
        emit("scrollbarDragMove", e);
    }
    function onDragEnd(e) {
        const params = swiper.params.scrollbar;
        const { scrollbar, wrapperEl } = swiper;
        const { el } = scrollbar;
        if (!isTouched) return;
        isTouched = false;
        if (swiper.params.cssMode) {
            swiper.wrapperEl.style["scroll-snap-type"] = "";
            wrapperEl.style.transitionDuration = "";
        }
        if (params.hide) {
            clearTimeout(dragTimeout);
            dragTimeout = nextTick4(()=>{
                el.style.opacity = 0;
                el.style.transitionDuration = "400ms";
            }, 1e3);
        }
        emit("scrollbarDragEnd", e);
        if (params.snapOnRelease) {
            swiper.slideToClosest();
        }
    }
    function events2(method) {
        const { scrollbar, params } = swiper;
        const el = scrollbar.el;
        if (!el) return;
        const target = el;
        const activeListener = params.passiveListeners ? {
            passive: false,
            capture: false
        } : false;
        const passiveListener = params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        if (!target) return;
        const eventMethod = method === "on" ? "addEventListener" : "removeEventListener";
        target[eventMethod]("pointerdown", onDragStart, activeListener);
        document2[eventMethod]("pointermove", onDragMove, activeListener);
        document2[eventMethod]("pointerup", onDragEnd, passiveListener);
    }
    function enableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events2("on");
    }
    function disableDraggable() {
        if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
        events2("off");
    }
    function init2() {
        const { scrollbar, el: swiperEl } = swiper;
        swiper.params.scrollbar = createElementIfNotDefined(swiper, swiper.originalParams.scrollbar, swiper.params.scrollbar, {
            el: "swiper-scrollbar"
        });
        const params = swiper.params.scrollbar;
        if (!params.el) return;
        let el;
        if (typeof params.el === "string" && swiper.isElement) {
            el = swiper.el.querySelector(params.el);
        }
        if (!el && typeof params.el === "string") {
            el = document2.querySelectorAll(params.el);
            if (!el.length) return;
        } else if (!el) {
            el = params.el;
        }
        if (swiper.params.uniqueNavElements && typeof params.el === "string" && el.length > 1 && swiperEl.querySelectorAll(params.el).length === 1) {
            el = swiperEl.querySelector(params.el);
        }
        if (el.length > 0) el = el[0];
        el.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        let dragEl;
        if (el) {
            dragEl = el.querySelector(classesToSelector(swiper.params.scrollbar.dragClass));
            if (!dragEl) {
                dragEl = createElement("div", swiper.params.scrollbar.dragClass);
                el.append(dragEl);
            }
        }
        Object.assign(scrollbar, {
            el,
            dragEl
        });
        if (params.draggable) {
            enableDraggable();
        }
        if (el) {
            el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
        }
    }
    function destroy() {
        const params = swiper.params.scrollbar;
        const el = swiper.scrollbar.el;
        if (el) {
            el.classList.remove(...classesToTokens(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass));
        }
        disableDraggable();
    }
    on("changeDirection", ()=>{
        if (!swiper.scrollbar || !swiper.scrollbar.el) return;
        const params = swiper.params.scrollbar;
        let { el } = swiper.scrollbar;
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.classList.remove(params.horizontalClass, params.verticalClass);
            subEl.classList.add(swiper.isHorizontal() ? params.horizontalClass : params.verticalClass);
        });
    });
    on("init", ()=>{
        if (swiper.params.scrollbar.enabled === false) {
            disable();
        } else {
            init2();
            updateSize2();
            setTranslate2();
        }
    });
    on("update resize observerUpdate lock unlock changeDirection", ()=>{
        updateSize2();
    });
    on("setTranslate", ()=>{
        setTranslate2();
    });
    on("setTransition", (_s, duration)=>{
        setTransition2(duration);
    });
    on("enable disable", ()=>{
        const { el } = swiper.scrollbar;
        if (el) {
            el.classList[swiper.enabled ? "remove" : "add"](...classesToTokens(swiper.params.scrollbar.lockClass));
        }
    });
    on("destroy", ()=>{
        destroy();
    });
    const enable = ()=>{
        swiper.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        if (swiper.scrollbar.el) {
            swiper.scrollbar.el.classList.remove(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        }
        init2();
        updateSize2();
        setTranslate2();
    };
    const disable = ()=>{
        swiper.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        if (swiper.scrollbar.el) {
            swiper.scrollbar.el.classList.add(...classesToTokens(swiper.params.scrollbar.scrollbarDisabledClass));
        }
        destroy();
    };
    Object.assign(swiper.scrollbar, {
        enable,
        disable,
        updateSize: updateSize2,
        setTranslate: setTranslate2,
        init: init2,
        destroy
    });
}
// node_modules/swiper/modules/parallax.mjs
function Parallax(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        parallax: {
            enabled: false
        }
    });
    const elementsSelector = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]";
    const setTransform3 = (el, progress)=>{
        const { rtl } = swiper;
        const rtlFactor = rtl ? -1 : 1;
        const p = el.getAttribute("data-swiper-parallax") || "0";
        let x = el.getAttribute("data-swiper-parallax-x");
        let y = el.getAttribute("data-swiper-parallax-y");
        const scale = el.getAttribute("data-swiper-parallax-scale");
        const opacity = el.getAttribute("data-swiper-parallax-opacity");
        const rotate = el.getAttribute("data-swiper-parallax-rotate");
        if (x || y) {
            x = x || "0";
            y = y || "0";
        } else if (swiper.isHorizontal()) {
            x = p;
            y = "0";
        } else {
            y = p;
            x = "0";
        }
        if (x.indexOf("%") >= 0) {
            x = `${parseInt(x, 10) * progress * rtlFactor}%`;
        } else {
            x = `${x * progress * rtlFactor}px`;
        }
        if (y.indexOf("%") >= 0) {
            y = `${parseInt(y, 10) * progress}%`;
        } else {
            y = `${y * progress}px`;
        }
        if (typeof opacity !== "undefined" && opacity !== null) {
            const currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
            el.style.opacity = currentOpacity;
        }
        let transform = `translate3d(${x}, ${y}, 0px)`;
        if (typeof scale !== "undefined" && scale !== null) {
            const currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
            transform += ` scale(${currentScale})`;
        }
        if (rotate && typeof rotate !== "undefined" && rotate !== null) {
            const currentRotate = rotate * progress * -1;
            transform += ` rotate(${currentRotate}deg)`;
        }
        el.style.transform = transform;
    };
    const setTranslate2 = ()=>{
        const { el, slides, progress, snapGrid, isElement: isElement2 } = swiper;
        const elements = elementChildren(el, elementsSelector);
        if (swiper.isElement) {
            elements.push(...elementChildren(swiper.hostEl, elementsSelector));
        }
        elements.forEach((subEl)=>{
            setTransform3(subEl, progress);
        });
        slides.forEach((slideEl, slideIndex)=>{
            let slideProgress = slideEl.progress;
            if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== "auto") {
                slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
            }
            slideProgress = Math.min(Math.max(slideProgress, -1), 1);
            slideEl.querySelectorAll(`${elementsSelector}, [data-swiper-parallax-rotate]`).forEach((subEl)=>{
                setTransform3(subEl, slideProgress);
            });
        });
    };
    const setTransition2 = function(duration) {
        if (duration === void 0) {
            duration = swiper.params.speed;
        }
        const { el, hostEl } = swiper;
        const elements = [
            ...el.querySelectorAll(elementsSelector)
        ];
        if (swiper.isElement) {
            elements.push(...hostEl.querySelectorAll(elementsSelector));
        }
        elements.forEach((parallaxEl)=>{
            let parallaxDuration = parseInt(parallaxEl.getAttribute("data-swiper-parallax-duration"), 10) || duration;
            if (duration === 0) parallaxDuration = 0;
            parallaxEl.style.transitionDuration = `${parallaxDuration}ms`;
        });
    };
    on("beforeInit", ()=>{
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
    });
    on("init", ()=>{
        if (!swiper.params.parallax.enabled) return;
        setTranslate2();
    });
    on("setTranslate", ()=>{
        if (!swiper.params.parallax.enabled) return;
        setTranslate2();
    });
    on("setTransition", (_swiper, duration)=>{
        if (!swiper.params.parallax.enabled) return;
        setTransition2(duration);
    });
}
// node_modules/swiper/modules/zoom.mjs
function Zoom(_ref) {
    let { swiper, extendParams, on, emit } = _ref;
    const window2 = getWindow();
    extendParams({
        zoom: {
            enabled: false,
            limitToOriginalSize: false,
            maxRatio: 3,
            minRatio: 1,
            toggle: true,
            containerClass: "swiper-zoom-container",
            zoomedSlideClass: "swiper-slide-zoomed"
        }
    });
    swiper.zoom = {
        enabled: false
    };
    let currentScale = 1;
    let isScaling = false;
    let fakeGestureTouched;
    let fakeGestureMoved;
    const evCache = [];
    const gesture = {
        originX: 0,
        originY: 0,
        slideEl: void 0,
        slideWidth: void 0,
        slideHeight: void 0,
        imageEl: void 0,
        imageWrapEl: void 0,
        maxRatio: 3
    };
    const image = {
        isTouched: void 0,
        isMoved: void 0,
        currentX: void 0,
        currentY: void 0,
        minX: void 0,
        minY: void 0,
        maxX: void 0,
        maxY: void 0,
        width: void 0,
        height: void 0,
        startX: void 0,
        startY: void 0,
        touchesStart: {},
        touchesCurrent: {}
    };
    const velocity = {
        x: void 0,
        y: void 0,
        prevPositionX: void 0,
        prevPositionY: void 0,
        prevTime: void 0
    };
    let scale = 1;
    Object.defineProperty(swiper.zoom, "scale", {
        get () {
            return scale;
        },
        set (value) {
            if (scale !== value) {
                const imageEl = gesture.imageEl;
                const slideEl = gesture.slideEl;
                emit("zoomChange", value, imageEl, slideEl);
            }
            scale = value;
        }
    });
    function getDistanceBetweenTouches() {
        if (evCache.length < 2) return 1;
        const x1 = evCache[0].pageX;
        const y1 = evCache[0].pageY;
        const x2 = evCache[1].pageX;
        const y2 = evCache[1].pageY;
        const distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
        return distance;
    }
    function getMaxRatio() {
        const params = swiper.params.zoom;
        const maxRatio = gesture.imageWrapEl.getAttribute("data-swiper-zoom") || params.maxRatio;
        if (params.limitToOriginalSize && gesture.imageEl && gesture.imageEl.naturalWidth) {
            const imageMaxRatio = gesture.imageEl.naturalWidth / gesture.imageEl.offsetWidth;
            return Math.min(imageMaxRatio, maxRatio);
        }
        return maxRatio;
    }
    function getScaleOrigin() {
        if (evCache.length < 2) return {
            x: null,
            y: null
        };
        const box = gesture.imageEl.getBoundingClientRect();
        return [
            (evCache[0].pageX + (evCache[1].pageX - evCache[0].pageX) / 2 - box.x - window2.scrollX) / currentScale,
            (evCache[0].pageY + (evCache[1].pageY - evCache[0].pageY) / 2 - box.y - window2.scrollY) / currentScale
        ];
    }
    function getSlideSelector() {
        return swiper.isElement ? `swiper-slide` : `.${swiper.params.slideClass}`;
    }
    function eventWithinSlide(e) {
        const slideSelector = getSlideSelector();
        if (e.target.matches(slideSelector)) return true;
        if (swiper.slides.filter((slideEl)=>slideEl.contains(e.target)).length > 0) return true;
        return false;
    }
    function eventWithinZoomContainer(e) {
        const selector = `.${swiper.params.zoom.containerClass}`;
        if (e.target.matches(selector)) return true;
        if ([
            ...swiper.hostEl.querySelectorAll(selector)
        ].filter((containerEl)=>containerEl.contains(e.target)).length > 0) return true;
        return false;
    }
    function onGestureStart(e) {
        if (e.pointerType === "mouse") {
            evCache.splice(0, evCache.length);
        }
        if (!eventWithinSlide(e)) return;
        const params = swiper.params.zoom;
        fakeGestureTouched = false;
        fakeGestureMoved = false;
        evCache.push(e);
        if (evCache.length < 2) {
            return;
        }
        fakeGestureTouched = true;
        gesture.scaleStart = getDistanceBetweenTouches();
        if (!gesture.slideEl) {
            gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
            if (!gesture.slideEl) gesture.slideEl = swiper.slides[swiper.activeIndex];
            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
            if (imageEl) {
                imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
            }
            gesture.imageEl = imageEl;
            if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
            } else {
                gesture.imageWrapEl = void 0;
            }
            if (!gesture.imageWrapEl) {
                gesture.imageEl = void 0;
                return;
            }
            gesture.maxRatio = getMaxRatio();
        }
        if (gesture.imageEl) {
            const [originX, originY] = getScaleOrigin();
            gesture.originX = originX;
            gesture.originY = originY;
            gesture.imageEl.style.transitionDuration = "0ms";
        }
        isScaling = true;
    }
    function onGestureChange(e) {
        if (!eventWithinSlide(e)) return;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);
        if (pointerIndex >= 0) evCache[pointerIndex] = e;
        if (evCache.length < 2) {
            return;
        }
        fakeGestureMoved = true;
        gesture.scaleMove = getDistanceBetweenTouches();
        if (!gesture.imageEl) {
            return;
        }
        zoom.scale = gesture.scaleMove / gesture.scaleStart * currentScale;
        if (zoom.scale > gesture.maxRatio) {
            zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
        }
        if (zoom.scale < params.minRatio) {
            zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
        }
        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    }
    function onGestureEnd(e) {
        if (!eventWithinSlide(e)) return;
        if (e.pointerType === "mouse" && e.type === "pointerout") return;
        const params = swiper.params.zoom;
        const zoom = swiper.zoom;
        const pointerIndex = evCache.findIndex((cachedEv)=>cachedEv.pointerId === e.pointerId);
        if (pointerIndex >= 0) evCache.splice(pointerIndex, 1);
        if (!fakeGestureTouched || !fakeGestureMoved) {
            return;
        }
        fakeGestureTouched = false;
        fakeGestureMoved = false;
        if (!gesture.imageEl) return;
        zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
        gesture.imageEl.style.transitionDuration = `${swiper.params.speed}ms`;
        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
        currentScale = zoom.scale;
        isScaling = false;
        if (zoom.scale > 1 && gesture.slideEl) {
            gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
        } else if (zoom.scale <= 1 && gesture.slideEl) {
            gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
        }
        if (zoom.scale === 1) {
            gesture.originX = 0;
            gesture.originY = 0;
            gesture.slideEl = void 0;
        }
    }
    let allowTouchMoveTimeout;
    function allowTouchMove() {
        swiper.touchEventsData.preventTouchMoveFromPointerMove = false;
    }
    function preventTouchMove() {
        clearTimeout(allowTouchMoveTimeout);
        swiper.touchEventsData.preventTouchMoveFromPointerMove = true;
        allowTouchMoveTimeout = setTimeout(()=>{
            if (swiper.destroyed) return;
            allowTouchMove();
        });
    }
    function onTouchStart2(e) {
        const device = swiper.device;
        if (!gesture.imageEl) return;
        if (image.isTouched) return;
        if (device.android && e.cancelable) e.preventDefault();
        image.isTouched = true;
        const event2 = evCache.length > 0 ? evCache[0] : e;
        image.touchesStart.x = event2.pageX;
        image.touchesStart.y = event2.pageY;
    }
    function onTouchMove2(e) {
        if (!eventWithinSlide(e) || !eventWithinZoomContainer(e)) {
            return;
        }
        const zoom = swiper.zoom;
        if (!gesture.imageEl) {
            return;
        }
        if (!image.isTouched || !gesture.slideEl) {
            return;
        }
        if (!image.isMoved) {
            image.width = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
            image.height = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
            image.startX = getTranslate(gesture.imageWrapEl, "x") || 0;
            image.startY = getTranslate(gesture.imageWrapEl, "y") || 0;
            gesture.slideWidth = gesture.slideEl.offsetWidth;
            gesture.slideHeight = gesture.slideEl.offsetHeight;
            gesture.imageWrapEl.style.transitionDuration = "0ms";
        }
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.touchesCurrent.x = evCache.length > 0 ? evCache[0].pageX : e.pageX;
        image.touchesCurrent.y = evCache.length > 0 ? evCache[0].pageY : e.pageY;
        const touchesDiff = Math.max(Math.abs(image.touchesCurrent.x - image.touchesStart.x), Math.abs(image.touchesCurrent.y - image.touchesStart.y));
        if (touchesDiff > 5) {
            swiper.allowClick = false;
        }
        if (!image.isMoved && !isScaling) {
            if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
                image.isTouched = false;
                allowTouchMove();
                return;
            }
            if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
                image.isTouched = false;
                allowTouchMove();
                return;
            }
        }
        if (e.cancelable) {
            e.preventDefault();
        }
        e.stopPropagation();
        preventTouchMove();
        image.isMoved = true;
        const scaleRatio = (zoom.scale - currentScale) / (gesture.maxRatio - swiper.params.zoom.minRatio);
        const { originX, originY } = gesture;
        image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX + scaleRatio * (image.width - originX * 2);
        image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY + scaleRatio * (image.height - originY * 2);
        if (image.currentX < image.minX) {
            image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
        }
        if (image.currentX > image.maxX) {
            image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
        }
        if (image.currentY < image.minY) {
            image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
        }
        if (image.currentY > image.maxY) {
            image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
        }
        if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
        if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
        if (!velocity.prevTime) velocity.prevTime = Date.now();
        velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
        velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
        if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
        if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
        velocity.prevPositionX = image.touchesCurrent.x;
        velocity.prevPositionY = image.touchesCurrent.y;
        velocity.prevTime = Date.now();
        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
    }
    function onTouchEnd2() {
        const zoom = swiper.zoom;
        if (!gesture.imageEl) return;
        if (!image.isTouched || !image.isMoved) {
            image.isTouched = false;
            image.isMoved = false;
            return;
        }
        image.isTouched = false;
        image.isMoved = false;
        let momentumDurationX = 300;
        let momentumDurationY = 300;
        const momentumDistanceX = velocity.x * momentumDurationX;
        const newPositionX = image.currentX + momentumDistanceX;
        const momentumDistanceY = velocity.y * momentumDurationY;
        const newPositionY = image.currentY + momentumDistanceY;
        if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
        if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
        const momentumDuration = Math.max(momentumDurationX, momentumDurationY);
        image.currentX = newPositionX;
        image.currentY = newPositionY;
        const scaledWidth = image.width * zoom.scale;
        const scaledHeight = image.height * zoom.scale;
        image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
        image.maxX = -image.minX;
        image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
        image.maxY = -image.minY;
        image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
        image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
        gesture.imageWrapEl.style.transitionDuration = `${momentumDuration}ms`;
        gesture.imageWrapEl.style.transform = `translate3d(${image.currentX}px, ${image.currentY}px,0)`;
    }
    function onTransitionEnd() {
        const zoom = swiper.zoom;
        if (gesture.slideEl && swiper.activeIndex !== swiper.slides.indexOf(gesture.slideEl)) {
            if (gesture.imageEl) {
                gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
            }
            if (gesture.imageWrapEl) {
                gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
            }
            gesture.slideEl.classList.remove(`${swiper.params.zoom.zoomedSlideClass}`);
            zoom.scale = 1;
            currentScale = 1;
            gesture.slideEl = void 0;
            gesture.imageEl = void 0;
            gesture.imageWrapEl = void 0;
            gesture.originX = 0;
            gesture.originY = 0;
        }
    }
    function zoomIn(e) {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
        if (!gesture.slideEl) {
            if (e && e.target) {
                gesture.slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
            }
            if (!gesture.slideEl) {
                if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                    gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
                } else {
                    gesture.slideEl = swiper.slides[swiper.activeIndex];
                }
            }
            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
            if (imageEl) {
                imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
            }
            gesture.imageEl = imageEl;
            if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
            } else {
                gesture.imageWrapEl = void 0;
            }
        }
        if (!gesture.imageEl || !gesture.imageWrapEl) return;
        if (swiper.params.cssMode) {
            swiper.wrapperEl.style.overflow = "hidden";
            swiper.wrapperEl.style.touchAction = "none";
        }
        gesture.slideEl.classList.add(`${params.zoomedSlideClass}`);
        let touchX;
        let touchY;
        let offsetX;
        let offsetY;
        let diffX;
        let diffY;
        let translateX;
        let translateY;
        let imageWidth;
        let imageHeight;
        let scaledWidth;
        let scaledHeight;
        let translateMinX;
        let translateMinY;
        let translateMaxX;
        let translateMaxY;
        let slideWidth;
        let slideHeight;
        if (typeof image.touchesStart.x === "undefined" && e) {
            touchX = e.pageX;
            touchY = e.pageY;
        } else {
            touchX = image.touchesStart.x;
            touchY = image.touchesStart.y;
        }
        const forceZoomRatio = typeof e === "number" ? e : null;
        if (currentScale === 1 && forceZoomRatio) {
            touchX = void 0;
            touchY = void 0;
            image.touchesStart.x = void 0;
            image.touchesStart.y = void 0;
        }
        const maxRatio = getMaxRatio();
        zoom.scale = forceZoomRatio || maxRatio;
        currentScale = forceZoomRatio || maxRatio;
        if (e && !(currentScale === 1 && forceZoomRatio)) {
            slideWidth = gesture.slideEl.offsetWidth;
            slideHeight = gesture.slideEl.offsetHeight;
            offsetX = elementOffset(gesture.slideEl).left + window2.scrollX;
            offsetY = elementOffset(gesture.slideEl).top + window2.scrollY;
            diffX = offsetX + slideWidth / 2 - touchX;
            diffY = offsetY + slideHeight / 2 - touchY;
            imageWidth = gesture.imageEl.offsetWidth || gesture.imageEl.clientWidth;
            imageHeight = gesture.imageEl.offsetHeight || gesture.imageEl.clientHeight;
            scaledWidth = imageWidth * zoom.scale;
            scaledHeight = imageHeight * zoom.scale;
            translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
            translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
            translateMaxX = -translateMinX;
            translateMaxY = -translateMinY;
            translateX = diffX * zoom.scale;
            translateY = diffY * zoom.scale;
            if (translateX < translateMinX) {
                translateX = translateMinX;
            }
            if (translateX > translateMaxX) {
                translateX = translateMaxX;
            }
            if (translateY < translateMinY) {
                translateY = translateMinY;
            }
            if (translateY > translateMaxY) {
                translateY = translateMaxY;
            }
        } else {
            translateX = 0;
            translateY = 0;
        }
        if (forceZoomRatio && zoom.scale === 1) {
            gesture.originX = 0;
            gesture.originY = 0;
        }
        gesture.imageWrapEl.style.transitionDuration = "300ms";
        gesture.imageWrapEl.style.transform = `translate3d(${translateX}px, ${translateY}px,0)`;
        gesture.imageEl.style.transitionDuration = "300ms";
        gesture.imageEl.style.transform = `translate3d(0,0,0) scale(${zoom.scale})`;
    }
    function zoomOut() {
        const zoom = swiper.zoom;
        const params = swiper.params.zoom;
        if (!gesture.slideEl) {
            if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
                gesture.slideEl = elementChildren(swiper.slidesEl, `.${swiper.params.slideActiveClass}`)[0];
            } else {
                gesture.slideEl = swiper.slides[swiper.activeIndex];
            }
            let imageEl = gesture.slideEl.querySelector(`.${params.containerClass}`);
            if (imageEl) {
                imageEl = imageEl.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0];
            }
            gesture.imageEl = imageEl;
            if (imageEl) {
                gesture.imageWrapEl = elementParents(gesture.imageEl, `.${params.containerClass}`)[0];
            } else {
                gesture.imageWrapEl = void 0;
            }
        }
        if (!gesture.imageEl || !gesture.imageWrapEl) return;
        if (swiper.params.cssMode) {
            swiper.wrapperEl.style.overflow = "";
            swiper.wrapperEl.style.touchAction = "";
        }
        zoom.scale = 1;
        currentScale = 1;
        image.touchesStart.x = void 0;
        image.touchesStart.y = void 0;
        gesture.imageWrapEl.style.transitionDuration = "300ms";
        gesture.imageWrapEl.style.transform = "translate3d(0,0,0)";
        gesture.imageEl.style.transitionDuration = "300ms";
        gesture.imageEl.style.transform = "translate3d(0,0,0) scale(1)";
        gesture.slideEl.classList.remove(`${params.zoomedSlideClass}`);
        gesture.slideEl = void 0;
        gesture.originX = 0;
        gesture.originY = 0;
    }
    function zoomToggle(e) {
        const zoom = swiper.zoom;
        if (zoom.scale && zoom.scale !== 1) {
            zoomOut();
        } else {
            zoomIn(e);
        }
    }
    function getListeners() {
        const passiveListener = swiper.params.passiveListeners ? {
            passive: true,
            capture: false
        } : false;
        const activeListenerWithCapture = swiper.params.passiveListeners ? {
            passive: false,
            capture: true
        } : true;
        return {
            passiveListener,
            activeListenerWithCapture
        };
    }
    function enable() {
        const zoom = swiper.zoom;
        if (zoom.enabled) return;
        zoom.enabled = true;
        const { passiveListener, activeListenerWithCapture } = getListeners();
        swiper.wrapperEl.addEventListener("pointerdown", onGestureStart, passiveListener);
        swiper.wrapperEl.addEventListener("pointermove", onGestureChange, activeListenerWithCapture);
        [
            "pointerup",
            "pointercancel",
            "pointerout"
        ].forEach((eventName)=>{
            swiper.wrapperEl.addEventListener(eventName, onGestureEnd, passiveListener);
        });
        swiper.wrapperEl.addEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
    }
    function disable() {
        const zoom = swiper.zoom;
        if (!zoom.enabled) return;
        zoom.enabled = false;
        const { passiveListener, activeListenerWithCapture } = getListeners();
        swiper.wrapperEl.removeEventListener("pointerdown", onGestureStart, passiveListener);
        swiper.wrapperEl.removeEventListener("pointermove", onGestureChange, activeListenerWithCapture);
        [
            "pointerup",
            "pointercancel",
            "pointerout"
        ].forEach((eventName)=>{
            swiper.wrapperEl.removeEventListener(eventName, onGestureEnd, passiveListener);
        });
        swiper.wrapperEl.removeEventListener("pointermove", onTouchMove2, activeListenerWithCapture);
    }
    on("init", ()=>{
        if (swiper.params.zoom.enabled) {
            enable();
        }
    });
    on("destroy", ()=>{
        disable();
    });
    on("touchStart", (_s, e)=>{
        if (!swiper.zoom.enabled) return;
        onTouchStart2(e);
    });
    on("touchEnd", (_s, e)=>{
        if (!swiper.zoom.enabled) return;
        onTouchEnd2();
    });
    on("doubleTap", (_s, e)=>{
        if (!swiper.animating && swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
            zoomToggle(e);
        }
    });
    on("transitionEnd", ()=>{
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
            onTransitionEnd();
        }
    });
    on("slideChange", ()=>{
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
            onTransitionEnd();
        }
    });
    Object.assign(swiper.zoom, {
        enable,
        disable,
        in: zoomIn,
        out: zoomOut,
        toggle: zoomToggle
    });
}
// node_modules/swiper/modules/controller.mjs
function Controller(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        controller: {
            control: void 0,
            inverse: false,
            by: "slide"
        }
    });
    swiper.controller = {
        control: void 0
    };
    function LinearSpline(x, y) {
        const binarySearch = /* @__PURE__ */ function search() {
            let maxIndex;
            let minIndex;
            let guess;
            return (array2, val)=>{
                minIndex = -1;
                maxIndex = array2.length;
                while(maxIndex - minIndex > 1){
                    guess = maxIndex + minIndex >> 1;
                    if (array2[guess] <= val) {
                        minIndex = guess;
                    } else {
                        maxIndex = guess;
                    }
                }
                return maxIndex;
            };
        }();
        this.x = x;
        this.y = y;
        this.lastIndex = x.length - 1;
        let i1;
        let i3;
        this.interpolate = function interpolate(x2) {
            if (!x2) return 0;
            i3 = binarySearch(this.x, x2);
            i1 = i3 - 1;
            return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
        };
        return this;
    }
    function getInterpolateFunction(c) {
        swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);
    }
    function setTranslate2(_t, byController) {
        const controlled = swiper.controller.control;
        let multiplier;
        let controlledTranslate;
        const Swiper3 = swiper.constructor;
        function setControlledTranslate(c) {
            if (c.destroyed) return;
            const translate2 = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
            if (swiper.params.controller.by === "slide") {
                getInterpolateFunction(c);
                controlledTranslate = -swiper.controller.spline.interpolate(-translate2);
            }
            if (!controlledTranslate || swiper.params.controller.by === "container") {
                multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
                if (Number.isNaN(multiplier) || !Number.isFinite(multiplier)) {
                    multiplier = 1;
                }
                controlledTranslate = (translate2 - swiper.minTranslate()) * multiplier + c.minTranslate();
            }
            if (swiper.params.controller.inverse) {
                controlledTranslate = c.maxTranslate() - controlledTranslate;
            }
            c.updateProgress(controlledTranslate);
            c.setTranslate(controlledTranslate, swiper);
            c.updateActiveIndex();
            c.updateSlidesClasses();
        }
        if (Array.isArray(controlled)) {
            for(let i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
                    setControlledTranslate(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper3 && byController !== controlled) {
            setControlledTranslate(controlled);
        }
    }
    function setTransition2(duration, byController) {
        const Swiper3 = swiper.constructor;
        const controlled = swiper.controller.control;
        let i2;
        function setControlledTransition(c) {
            if (c.destroyed) return;
            c.setTransition(duration, swiper);
            if (duration !== 0) {
                c.transitionStart();
                if (c.params.autoHeight) {
                    nextTick4(()=>{
                        c.updateAutoHeight();
                    });
                }
                elementTransitionEnd(c.wrapperEl, ()=>{
                    if (!controlled) return;
                    c.transitionEnd();
                });
            }
        }
        if (Array.isArray(controlled)) {
            for(i2 = 0; i2 < controlled.length; i2 += 1){
                if (controlled[i2] !== byController && controlled[i2] instanceof Swiper3) {
                    setControlledTransition(controlled[i2]);
                }
            }
        } else if (controlled instanceof Swiper3 && byController !== controlled) {
            setControlledTransition(controlled);
        }
    }
    function removeSpline() {
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
            swiper.controller.spline = void 0;
            delete swiper.controller.spline;
        }
    }
    on("beforeInit", ()=>{
        if (typeof window !== "undefined" && // eslint-disable-line
        (typeof swiper.params.controller.control === "string" || swiper.params.controller.control instanceof HTMLElement)) {
            const controlElements = typeof swiper.params.controller.control === "string" ? [
                ...document.querySelectorAll(swiper.params.controller.control)
            ] : [
                swiper.params.controller.control
            ];
            controlElements.forEach((controlElement)=>{
                if (!swiper.controller.control) swiper.controller.control = [];
                if (controlElement && controlElement.swiper) {
                    swiper.controller.control.push(controlElement.swiper);
                } else if (controlElement) {
                    const eventName = `${swiper.params.eventsPrefix}init`;
                    const onControllerSwiper = (e)=>{
                        swiper.controller.control.push(e.detail[0]);
                        swiper.update();
                        controlElement.removeEventListener(eventName, onControllerSwiper);
                    };
                    controlElement.addEventListener(eventName, onControllerSwiper);
                }
            });
            return;
        }
        swiper.controller.control = swiper.params.controller.control;
    });
    on("update", ()=>{
        removeSpline();
    });
    on("resize", ()=>{
        removeSpline();
    });
    on("observerUpdate", ()=>{
        removeSpline();
    });
    on("setTranslate", (_s, translate2, byController)=>{
        if (!swiper.controller.control || swiper.controller.control.destroyed) return;
        swiper.controller.setTranslate(translate2, byController);
    });
    on("setTransition", (_s, duration, byController)=>{
        if (!swiper.controller.control || swiper.controller.control.destroyed) return;
        swiper.controller.setTransition(duration, byController);
    });
    Object.assign(swiper.controller, {
        setTranslate: setTranslate2,
        setTransition: setTransition2
    });
}
// node_modules/swiper/modules/a11y.mjs
function A11y(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        a11y: {
            enabled: true,
            notificationClass: "swiper-notification",
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            paginationBulletMessage: "Go to slide {{index}}",
            slideLabelMessage: "{{index}} / {{slidesLength}}",
            containerMessage: null,
            containerRoleDescriptionMessage: null,
            containerRole: null,
            itemRoleDescriptionMessage: null,
            slideRole: "group",
            id: null,
            scrollOnFocus: true
        }
    });
    swiper.a11y = {
        clicked: false
    };
    let liveRegion = null;
    let preventFocusHandler;
    let focusTargetSlideEl;
    let visibilityChangedTimestamp = /* @__PURE__ */ new Date().getTime();
    function notify(message) {
        const notification = liveRegion;
        if (notification.length === 0) return;
        notification.innerHTML = "";
        notification.innerHTML = message;
    }
    function getRandomNumber(size) {
        if (size === void 0) {
            size = 16;
        }
        const randomChar = ()=>Math.round(16 * Math.random()).toString(16);
        return "x".repeat(size).replace(/x/g, randomChar);
    }
    function makeElFocusable(el) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("tabIndex", "0");
        });
    }
    function makeElNotFocusable(el) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("tabIndex", "-1");
        });
    }
    function addElRole(el, role) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("role", role);
        });
    }
    function addElRoleDescription(el, description) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-roledescription", description);
        });
    }
    function addElControls(el, controls) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-controls", controls);
        });
    }
    function addElLabel(el, label) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-label", label);
        });
    }
    function addElId(el, id) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("id", id);
        });
    }
    function addElLive(el, live) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-live", live);
        });
    }
    function disableEl(el) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-disabled", true);
        });
    }
    function enableEl(el) {
        el = makeElementsArray(el);
        el.forEach((subEl)=>{
            subEl.setAttribute("aria-disabled", false);
        });
    }
    function onEnterOrSpaceKey(e) {
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        const params = swiper.params.a11y;
        const targetEl = e.target;
        if (swiper.pagination && swiper.pagination.el && (targetEl === swiper.pagination.el || swiper.pagination.el.contains(e.target))) {
            if (!e.target.matches(classesToSelector(swiper.params.pagination.bulletClass))) return;
        }
        if (swiper.navigation && swiper.navigation.prevEl && swiper.navigation.nextEl) {
            const prevEls = makeElementsArray(swiper.navigation.prevEl);
            const nextEls = makeElementsArray(swiper.navigation.nextEl);
            if (nextEls.includes(targetEl)) {
                if (!(swiper.isEnd && !swiper.params.loop)) {
                    swiper.slideNext();
                }
                if (swiper.isEnd) {
                    notify(params.lastSlideMessage);
                } else {
                    notify(params.nextSlideMessage);
                }
            }
            if (prevEls.includes(targetEl)) {
                if (!(swiper.isBeginning && !swiper.params.loop)) {
                    swiper.slidePrev();
                }
                if (swiper.isBeginning) {
                    notify(params.firstSlideMessage);
                } else {
                    notify(params.prevSlideMessage);
                }
            }
        }
        if (swiper.pagination && targetEl.matches(classesToSelector(swiper.params.pagination.bulletClass))) {
            targetEl.click();
        }
    }
    function updateNavigation() {
        if (swiper.params.loop || swiper.params.rewind || !swiper.navigation) return;
        const { nextEl, prevEl } = swiper.navigation;
        if (prevEl) {
            if (swiper.isBeginning) {
                disableEl(prevEl);
                makeElNotFocusable(prevEl);
            } else {
                enableEl(prevEl);
                makeElFocusable(prevEl);
            }
        }
        if (nextEl) {
            if (swiper.isEnd) {
                disableEl(nextEl);
                makeElNotFocusable(nextEl);
            } else {
                enableEl(nextEl);
                makeElFocusable(nextEl);
            }
        }
    }
    function hasPagination() {
        return swiper.pagination && swiper.pagination.bullets && swiper.pagination.bullets.length;
    }
    function hasClickablePagination() {
        return hasPagination() && swiper.params.pagination.clickable;
    }
    function updatePagination() {
        const params = swiper.params.a11y;
        if (!hasPagination()) return;
        swiper.pagination.bullets.forEach((bulletEl)=>{
            if (swiper.params.pagination.clickable) {
                makeElFocusable(bulletEl);
                if (!swiper.params.pagination.renderBullet) {
                    addElRole(bulletEl, "button");
                    addElLabel(bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, elementIndex(bulletEl) + 1));
                }
            }
            if (bulletEl.matches(classesToSelector(swiper.params.pagination.bulletActiveClass))) {
                bulletEl.setAttribute("aria-current", "true");
            } else {
                bulletEl.removeAttribute("aria-current");
            }
        });
    }
    const initNavEl = (el, wrapperId, message)=>{
        makeElFocusable(el);
        if (el.tagName !== "BUTTON") {
            addElRole(el, "button");
            el.addEventListener("keydown", onEnterOrSpaceKey);
        }
        addElLabel(el, message);
        addElControls(el, wrapperId);
    };
    const handlePointerDown = (e)=>{
        if (focusTargetSlideEl && focusTargetSlideEl !== e.target && !focusTargetSlideEl.contains(e.target)) {
            preventFocusHandler = true;
        }
        swiper.a11y.clicked = true;
    };
    const handlePointerUp = ()=>{
        preventFocusHandler = false;
        requestAnimationFrame(()=>{
            requestAnimationFrame(()=>{
                if (!swiper.destroyed) {
                    swiper.a11y.clicked = false;
                }
            });
        });
    };
    const onVisibilityChange = (e)=>{
        visibilityChangedTimestamp = /* @__PURE__ */ new Date().getTime();
    };
    const handleFocus = (e)=>{
        if (swiper.a11y.clicked || !swiper.params.a11y.scrollOnFocus) return;
        if (/* @__PURE__ */ new Date().getTime() - visibilityChangedTimestamp < 100) return;
        const slideEl = e.target.closest(`.${swiper.params.slideClass}, swiper-slide`);
        if (!slideEl || !swiper.slides.includes(slideEl)) return;
        focusTargetSlideEl = slideEl;
        const isActive = swiper.slides.indexOf(slideEl) === swiper.activeIndex;
        const isVisible2 = swiper.params.watchSlidesProgress && swiper.visibleSlides && swiper.visibleSlides.includes(slideEl);
        if (isActive || isVisible2) return;
        if (e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
        if (swiper.isHorizontal()) {
            swiper.el.scrollLeft = 0;
        } else {
            swiper.el.scrollTop = 0;
        }
        requestAnimationFrame(()=>{
            if (preventFocusHandler) return;
            if (swiper.params.loop) {
                swiper.slideToLoop(parseInt(slideEl.getAttribute("data-swiper-slide-index")), 0);
            } else {
                swiper.slideTo(swiper.slides.indexOf(slideEl), 0);
            }
            preventFocusHandler = false;
        });
    };
    const initSlides = ()=>{
        const params = swiper.params.a11y;
        if (params.itemRoleDescriptionMessage) {
            addElRoleDescription(swiper.slides, params.itemRoleDescriptionMessage);
        }
        if (params.slideRole) {
            addElRole(swiper.slides, params.slideRole);
        }
        const slidesLength = swiper.slides.length;
        if (params.slideLabelMessage) {
            swiper.slides.forEach((slideEl, index)=>{
                const slideIndex = swiper.params.loop ? parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10) : index;
                const ariaLabelMessage = params.slideLabelMessage.replace(/\{\{index\}\}/, slideIndex + 1).replace(/\{\{slidesLength\}\}/, slidesLength);
                addElLabel(slideEl, ariaLabelMessage);
            });
        }
    };
    const init2 = ()=>{
        const params = swiper.params.a11y;
        swiper.el.append(liveRegion);
        const containerEl = swiper.el;
        if (params.containerRoleDescriptionMessage) {
            addElRoleDescription(containerEl, params.containerRoleDescriptionMessage);
        }
        if (params.containerMessage) {
            addElLabel(containerEl, params.containerMessage);
        }
        if (params.containerRole) {
            addElRole(containerEl, params.containerRole);
        }
        const wrapperEl = swiper.wrapperEl;
        const wrapperId = params.id || wrapperEl.getAttribute("id") || `swiper-wrapper-${getRandomNumber(16)}`;
        const live = swiper.params.autoplay && swiper.params.autoplay.enabled ? "off" : "polite";
        addElId(wrapperEl, wrapperId);
        addElLive(wrapperEl, live);
        initSlides();
        let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        if (nextEl) {
            nextEl.forEach((el)=>initNavEl(el, wrapperId, params.nextSlideMessage));
        }
        if (prevEl) {
            prevEl.forEach((el)=>initNavEl(el, wrapperId, params.prevSlideMessage));
        }
        if (hasClickablePagination()) {
            const paginationEl = makeElementsArray(swiper.pagination.el);
            paginationEl.forEach((el)=>{
                el.addEventListener("keydown", onEnterOrSpaceKey);
            });
        }
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
        swiper.el.addEventListener("focus", handleFocus, true);
        swiper.el.addEventListener("focus", handleFocus, true);
        swiper.el.addEventListener("pointerdown", handlePointerDown, true);
        swiper.el.addEventListener("pointerup", handlePointerUp, true);
    };
    function destroy() {
        if (liveRegion) liveRegion.remove();
        let { nextEl, prevEl } = swiper.navigation ? swiper.navigation : {};
        nextEl = makeElementsArray(nextEl);
        prevEl = makeElementsArray(prevEl);
        if (nextEl) {
            nextEl.forEach((el)=>el.removeEventListener("keydown", onEnterOrSpaceKey));
        }
        if (prevEl) {
            prevEl.forEach((el)=>el.removeEventListener("keydown", onEnterOrSpaceKey));
        }
        if (hasClickablePagination()) {
            const paginationEl = makeElementsArray(swiper.pagination.el);
            paginationEl.forEach((el)=>{
                el.removeEventListener("keydown", onEnterOrSpaceKey);
            });
        }
        const document2 = getDocument();
        document2.removeEventListener("visibilitychange", onVisibilityChange);
        if (swiper.el && typeof swiper.el !== "string") {
            swiper.el.removeEventListener("focus", handleFocus, true);
            swiper.el.removeEventListener("pointerdown", handlePointerDown, true);
            swiper.el.removeEventListener("pointerup", handlePointerUp, true);
        }
    }
    on("beforeInit", ()=>{
        liveRegion = createElement("span", swiper.params.a11y.notificationClass);
        liveRegion.setAttribute("aria-live", "assertive");
        liveRegion.setAttribute("aria-atomic", "true");
    });
    on("afterInit", ()=>{
        if (!swiper.params.a11y.enabled) return;
        init2();
    });
    on("slidesLengthChange snapGridLengthChange slidesGridLengthChange", ()=>{
        if (!swiper.params.a11y.enabled) return;
        initSlides();
    });
    on("fromEdge toEdge afterInit lock unlock", ()=>{
        if (!swiper.params.a11y.enabled) return;
        updateNavigation();
    });
    on("paginationUpdate", ()=>{
        if (!swiper.params.a11y.enabled) return;
        updatePagination();
    });
    on("destroy", ()=>{
        if (!swiper.params.a11y.enabled) return;
        destroy();
    });
}
// node_modules/swiper/modules/history.mjs
function History(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        history: {
            enabled: false,
            root: "",
            replaceState: false,
            key: "slides",
            keepQuery: false
        }
    });
    let initialized = false;
    let paths = {};
    const slugify = (text)=>{
        return text.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, "");
    };
    const getPathValues = (urlOverride)=>{
        const window2 = getWindow();
        let location2;
        if (urlOverride) {
            location2 = new URL(urlOverride);
        } else {
            location2 = window2.location;
        }
        const pathArray = location2.pathname.slice(1).split("/").filter((part)=>part !== "");
        const total = pathArray.length;
        const key = pathArray[total - 2];
        const value = pathArray[total - 1];
        return {
            key,
            value
        };
    };
    const setHistory2 = (key, index)=>{
        const window2 = getWindow();
        if (!initialized || !swiper.params.history.enabled) return;
        let location2;
        if (swiper.params.url) {
            location2 = new URL(swiper.params.url);
        } else {
            location2 = window2.location;
        }
        const slide2 = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${index}"]`) : swiper.slides[index];
        let value = slugify(slide2.getAttribute("data-history"));
        if (swiper.params.history.root.length > 0) {
            let root2 = swiper.params.history.root;
            if (root2[root2.length - 1] === "/") root2 = root2.slice(0, root2.length - 1);
            value = `${root2}/${key ? `${key}/` : ""}${value}`;
        } else if (!location2.pathname.includes(key)) {
            value = `${key ? `${key}/` : ""}${value}`;
        }
        if (swiper.params.history.keepQuery) {
            value += location2.search;
        }
        const currentState = window2.history.state;
        if (currentState && currentState.value === value) {
            return;
        }
        if (swiper.params.history.replaceState) {
            window2.history.replaceState({
                value
            }, null, value);
        } else {
            window2.history.pushState({
                value
            }, null, value);
        }
    };
    const scrollToSlide = (speed, value, runCallbacks)=>{
        if (value) {
            for(let i2 = 0, length = swiper.slides.length; i2 < length; i2 += 1){
                const slide2 = swiper.slides[i2];
                const slideHistory = slugify(slide2.getAttribute("data-history"));
                if (slideHistory === value) {
                    const index = swiper.getSlideIndex(slide2);
                    swiper.slideTo(index, speed, runCallbacks);
                }
            }
        } else {
            swiper.slideTo(0, speed, runCallbacks);
        }
    };
    const setHistoryPopState = ()=>{
        paths = getPathValues(swiper.params.url);
        scrollToSlide(swiper.params.speed, paths.value, false);
    };
    const init2 = ()=>{
        const window2 = getWindow();
        if (!swiper.params.history) return;
        if (!window2.history || !window2.history.pushState) {
            swiper.params.history.enabled = false;
            swiper.params.hashNavigation.enabled = true;
            return;
        }
        initialized = true;
        paths = getPathValues(swiper.params.url);
        if (!paths.key && !paths.value) {
            if (!swiper.params.history.replaceState) {
                window2.addEventListener("popstate", setHistoryPopState);
            }
            return;
        }
        scrollToSlide(0, paths.value, swiper.params.runCallbacksOnInit);
        if (!swiper.params.history.replaceState) {
            window2.addEventListener("popstate", setHistoryPopState);
        }
    };
    const destroy = ()=>{
        const window2 = getWindow();
        if (!swiper.params.history.replaceState) {
            window2.removeEventListener("popstate", setHistoryPopState);
        }
    };
    on("init", ()=>{
        if (swiper.params.history.enabled) {
            init2();
        }
    });
    on("destroy", ()=>{
        if (swiper.params.history.enabled) {
            destroy();
        }
    });
    on("transitionEnd _freeModeNoMomentumRelease", ()=>{
        if (initialized) {
            setHistory2(swiper.params.history.key, swiper.activeIndex);
        }
    });
    on("slideChange", ()=>{
        if (initialized && swiper.params.cssMode) {
            setHistory2(swiper.params.history.key, swiper.activeIndex);
        }
    });
}
// node_modules/swiper/modules/hash-navigation.mjs
function HashNavigation(_ref) {
    let { swiper, extendParams, emit, on } = _ref;
    let initialized = false;
    const document2 = getDocument();
    const window2 = getWindow();
    extendParams({
        hashNavigation: {
            enabled: false,
            replaceState: false,
            watchState: false,
            getSlideIndex (_s, hash) {
                if (swiper.virtual && swiper.params.virtual.enabled) {
                    const slideWithHash = swiper.slides.filter((slideEl)=>slideEl.getAttribute("data-hash") === hash)[0];
                    if (!slideWithHash) return 0;
                    const index = parseInt(slideWithHash.getAttribute("data-swiper-slide-index"), 10);
                    return index;
                }
                return swiper.getSlideIndex(elementChildren(swiper.slidesEl, `.${swiper.params.slideClass}[data-hash="${hash}"], swiper-slide[data-hash="${hash}"]`)[0]);
            }
        }
    });
    const onHashChange = ()=>{
        emit("hashChange");
        const newHash = document2.location.hash.replace("#", "");
        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") : "";
        if (newHash !== activeSlideHash) {
            const newIndex = swiper.params.hashNavigation.getSlideIndex(swiper, newHash);
            if (typeof newIndex === "undefined" || Number.isNaN(newIndex)) return;
            swiper.slideTo(newIndex);
        }
    };
    const setHash = ()=>{
        if (!initialized || !swiper.params.hashNavigation.enabled) return;
        const activeSlideEl = swiper.virtual && swiper.params.virtual.enabled ? swiper.slidesEl.querySelector(`[data-swiper-slide-index="${swiper.activeIndex}"]`) : swiper.slides[swiper.activeIndex];
        const activeSlideHash = activeSlideEl ? activeSlideEl.getAttribute("data-hash") || activeSlideEl.getAttribute("data-history") : "";
        if (swiper.params.hashNavigation.replaceState && window2.history && window2.history.replaceState) {
            window2.history.replaceState(null, null, `#${activeSlideHash}` || "");
            emit("hashSet");
        } else {
            document2.location.hash = activeSlideHash || "";
            emit("hashSet");
        }
    };
    const init2 = ()=>{
        if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) return;
        initialized = true;
        const hash = document2.location.hash.replace("#", "");
        if (hash) {
            const speed = 0;
            const index = swiper.params.hashNavigation.getSlideIndex(swiper, hash);
            swiper.slideTo(index || 0, speed, swiper.params.runCallbacksOnInit, true);
        }
        if (swiper.params.hashNavigation.watchState) {
            window2.addEventListener("hashchange", onHashChange);
        }
    };
    const destroy = ()=>{
        if (swiper.params.hashNavigation.watchState) {
            window2.removeEventListener("hashchange", onHashChange);
        }
    };
    on("init", ()=>{
        if (swiper.params.hashNavigation.enabled) {
            init2();
        }
    });
    on("destroy", ()=>{
        if (swiper.params.hashNavigation.enabled) {
            destroy();
        }
    });
    on("transitionEnd _freeModeNoMomentumRelease", ()=>{
        if (initialized) {
            setHash();
        }
    });
    on("slideChange", ()=>{
        if (initialized && swiper.params.cssMode) {
            setHash();
        }
    });
}
// node_modules/swiper/modules/autoplay.mjs
function Autoplay(_ref) {
    let { swiper, extendParams, on, emit, params } = _ref;
    swiper.autoplay = {
        running: false,
        paused: false,
        timeLeft: 0
    };
    extendParams({
        autoplay: {
            enabled: false,
            delay: 3e3,
            waitForTransition: true,
            disableOnInteraction: false,
            stopOnLastSlide: false,
            reverseDirection: false,
            pauseOnMouseEnter: false
        }
    });
    let timeout;
    let raf;
    let autoplayDelayTotal = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayDelayCurrent = params && params.autoplay ? params.autoplay.delay : 3e3;
    let autoplayTimeLeft;
    let autoplayStartTime = /* @__PURE__ */ new Date().getTime();
    let wasPaused;
    let isTouched;
    let pausedByTouch;
    let touchStartTimeout;
    let slideChanged;
    let pausedByInteraction;
    let pausedByPointerEnter;
    function onTransitionEnd(e) {
        if (!swiper || swiper.destroyed || !swiper.wrapperEl) return;
        if (e.target !== swiper.wrapperEl) return;
        swiper.wrapperEl.removeEventListener("transitionend", onTransitionEnd);
        if (pausedByPointerEnter || e.detail && e.detail.bySwiperTouchMove) {
            return;
        }
        resume();
    }
    const calcTimeLeft = ()=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (swiper.autoplay.paused) {
            wasPaused = true;
        } else if (wasPaused) {
            autoplayDelayCurrent = autoplayTimeLeft;
            wasPaused = false;
        }
        const timeLeft = swiper.autoplay.paused ? autoplayTimeLeft : autoplayStartTime + autoplayDelayCurrent - /* @__PURE__ */ new Date().getTime();
        swiper.autoplay.timeLeft = timeLeft;
        emit("autoplayTimeLeft", timeLeft, timeLeft / autoplayDelayTotal);
        raf = requestAnimationFrame(()=>{
            calcTimeLeft();
        });
    };
    const getSlideDelay = ()=>{
        let activeSlideEl;
        if (swiper.virtual && swiper.params.virtual.enabled) {
            activeSlideEl = swiper.slides.filter((slideEl)=>slideEl.classList.contains("swiper-slide-active"))[0];
        } else {
            activeSlideEl = swiper.slides[swiper.activeIndex];
        }
        if (!activeSlideEl) return void 0;
        const currentSlideDelay = parseInt(activeSlideEl.getAttribute("data-swiper-autoplay"), 10);
        return currentSlideDelay;
    };
    const run = (delayForce)=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        cancelAnimationFrame(raf);
        calcTimeLeft();
        let delay = typeof delayForce === "undefined" ? swiper.params.autoplay.delay : delayForce;
        autoplayDelayTotal = swiper.params.autoplay.delay;
        autoplayDelayCurrent = swiper.params.autoplay.delay;
        const currentSlideDelay = getSlideDelay();
        if (!Number.isNaN(currentSlideDelay) && currentSlideDelay > 0 && typeof delayForce === "undefined") {
            delay = currentSlideDelay;
            autoplayDelayTotal = currentSlideDelay;
            autoplayDelayCurrent = currentSlideDelay;
        }
        autoplayTimeLeft = delay;
        const speed = swiper.params.speed;
        const proceed = ()=>{
            if (!swiper || swiper.destroyed) return;
            if (swiper.params.autoplay.reverseDirection) {
                if (!swiper.isBeginning || swiper.params.loop || swiper.params.rewind) {
                    swiper.slidePrev(speed, true, true);
                    emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(swiper.slides.length - 1, speed, true, true);
                    emit("autoplay");
                }
            } else {
                if (!swiper.isEnd || swiper.params.loop || swiper.params.rewind) {
                    swiper.slideNext(speed, true, true);
                    emit("autoplay");
                } else if (!swiper.params.autoplay.stopOnLastSlide) {
                    swiper.slideTo(0, speed, true, true);
                    emit("autoplay");
                }
            }
            if (swiper.params.cssMode) {
                autoplayStartTime = /* @__PURE__ */ new Date().getTime();
                requestAnimationFrame(()=>{
                    run();
                });
            }
        };
        if (delay > 0) {
            clearTimeout(timeout);
            timeout = setTimeout(()=>{
                proceed();
            }, delay);
        } else {
            requestAnimationFrame(()=>{
                proceed();
            });
        }
        return delay;
    };
    const start = ()=>{
        autoplayStartTime = /* @__PURE__ */ new Date().getTime();
        swiper.autoplay.running = true;
        run();
        emit("autoplayStart");
    };
    const stop = ()=>{
        swiper.autoplay.running = false;
        clearTimeout(timeout);
        cancelAnimationFrame(raf);
        emit("autoplayStop");
    };
    const pause = (internal, reset)=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        clearTimeout(timeout);
        if (!internal) {
            pausedByInteraction = true;
        }
        const proceed = ()=>{
            emit("autoplayPause");
            if (swiper.params.autoplay.waitForTransition) {
                swiper.wrapperEl.addEventListener("transitionend", onTransitionEnd);
            } else {
                resume();
            }
        };
        swiper.autoplay.paused = true;
        if (reset) {
            if (slideChanged) {
                autoplayTimeLeft = swiper.params.autoplay.delay;
            }
            slideChanged = false;
            proceed();
            return;
        }
        const delay = autoplayTimeLeft || swiper.params.autoplay.delay;
        autoplayTimeLeft = delay - (/* @__PURE__ */ new Date().getTime() - autoplayStartTime);
        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop) return;
        if (autoplayTimeLeft < 0) autoplayTimeLeft = 0;
        proceed();
    };
    const resume = ()=>{
        if (swiper.isEnd && autoplayTimeLeft < 0 && !swiper.params.loop || swiper.destroyed || !swiper.autoplay.running) return;
        autoplayStartTime = /* @__PURE__ */ new Date().getTime();
        if (pausedByInteraction) {
            pausedByInteraction = false;
            run(autoplayTimeLeft);
        } else {
            run();
        }
        swiper.autoplay.paused = false;
        emit("autoplayResume");
    };
    const onVisibilityChange = ()=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        const document2 = getDocument();
        if (document2.visibilityState === "hidden") {
            pausedByInteraction = true;
            pause(true);
        }
        if (document2.visibilityState === "visible") {
            resume();
        }
    };
    const onPointerEnter = (e)=>{
        if (e.pointerType !== "mouse") return;
        pausedByInteraction = true;
        pausedByPointerEnter = true;
        if (swiper.animating || swiper.autoplay.paused) return;
        pause(true);
    };
    const onPointerLeave = (e)=>{
        if (e.pointerType !== "mouse") return;
        pausedByPointerEnter = false;
        if (swiper.autoplay.paused) {
            resume();
        }
    };
    const attachMouseEvents = ()=>{
        if (swiper.params.autoplay.pauseOnMouseEnter) {
            swiper.el.addEventListener("pointerenter", onPointerEnter);
            swiper.el.addEventListener("pointerleave", onPointerLeave);
        }
    };
    const detachMouseEvents = ()=>{
        if (swiper.el && typeof swiper.el !== "string") {
            swiper.el.removeEventListener("pointerenter", onPointerEnter);
            swiper.el.removeEventListener("pointerleave", onPointerLeave);
        }
    };
    const attachDocumentEvents = ()=>{
        const document2 = getDocument();
        document2.addEventListener("visibilitychange", onVisibilityChange);
    };
    const detachDocumentEvents = ()=>{
        const document2 = getDocument();
        document2.removeEventListener("visibilitychange", onVisibilityChange);
    };
    on("init", ()=>{
        if (swiper.params.autoplay.enabled) {
            attachMouseEvents();
            attachDocumentEvents();
            start();
        }
    });
    on("destroy", ()=>{
        detachMouseEvents();
        detachDocumentEvents();
        if (swiper.autoplay.running) {
            stop();
        }
    });
    on("_freeModeStaticRelease", ()=>{
        if (pausedByTouch || pausedByInteraction) {
            resume();
        }
    });
    on("_freeModeNoMomentumRelease", ()=>{
        if (!swiper.params.autoplay.disableOnInteraction) {
            pause(true, true);
        } else {
            stop();
        }
    });
    on("beforeTransitionStart", (_s, speed, internal)=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (internal || !swiper.params.autoplay.disableOnInteraction) {
            pause(true, true);
        } else {
            stop();
        }
    });
    on("sliderFirstMove", ()=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        if (swiper.params.autoplay.disableOnInteraction) {
            stop();
            return;
        }
        isTouched = true;
        pausedByTouch = false;
        pausedByInteraction = false;
        touchStartTimeout = setTimeout(()=>{
            pausedByInteraction = true;
            pausedByTouch = true;
            pause(true);
        }, 200);
    });
    on("touchEnd", ()=>{
        if (swiper.destroyed || !swiper.autoplay.running || !isTouched) return;
        clearTimeout(touchStartTimeout);
        clearTimeout(timeout);
        if (swiper.params.autoplay.disableOnInteraction) {
            pausedByTouch = false;
            isTouched = false;
            return;
        }
        if (pausedByTouch && swiper.params.cssMode) resume();
        pausedByTouch = false;
        isTouched = false;
    });
    on("slideChange", ()=>{
        if (swiper.destroyed || !swiper.autoplay.running) return;
        slideChanged = true;
    });
    Object.assign(swiper.autoplay, {
        start,
        stop,
        pause,
        resume
    });
}
// node_modules/swiper/modules/thumbs.mjs
function Thumb(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        thumbs: {
            swiper: null,
            multipleActiveThumbs: true,
            autoScrollOffset: 0,
            slideThumbActiveClass: "swiper-slide-thumb-active",
            thumbsContainerClass: "swiper-thumbs"
        }
    });
    let initialized = false;
    let swiperCreated = false;
    swiper.thumbs = {
        swiper: null
    };
    function onThumbClick() {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        const clickedIndex = thumbsSwiper.clickedIndex;
        const clickedSlide = thumbsSwiper.clickedSlide;
        if (clickedSlide && clickedSlide.classList.contains(swiper.params.thumbs.slideThumbActiveClass)) return;
        if (typeof clickedIndex === "undefined" || clickedIndex === null) return;
        let slideToIndex;
        if (thumbsSwiper.params.loop) {
            slideToIndex = parseInt(thumbsSwiper.clickedSlide.getAttribute("data-swiper-slide-index"), 10);
        } else {
            slideToIndex = clickedIndex;
        }
        if (swiper.params.loop) {
            swiper.slideToLoop(slideToIndex);
        } else {
            swiper.slideTo(slideToIndex);
        }
    }
    function init2() {
        const { thumbs: thumbsParams } = swiper.params;
        if (initialized) return false;
        initialized = true;
        const SwiperClass = swiper.constructor;
        if (thumbsParams.swiper instanceof SwiperClass) {
            swiper.thumbs.swiper = thumbsParams.swiper;
            Object.assign(swiper.thumbs.swiper.originalParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            Object.assign(swiper.thumbs.swiper.params, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            swiper.thumbs.swiper.update();
        } else if (isObject5(thumbsParams.swiper)) {
            const thumbsSwiperParams = Object.assign({}, thumbsParams.swiper);
            Object.assign(thumbsSwiperParams, {
                watchSlidesProgress: true,
                slideToClickedSlide: false
            });
            swiper.thumbs.swiper = new SwiperClass(thumbsSwiperParams);
            swiperCreated = true;
        }
        swiper.thumbs.swiper.el.classList.add(swiper.params.thumbs.thumbsContainerClass);
        swiper.thumbs.swiper.on("tap", onThumbClick);
        return true;
    }
    function update2(initial) {
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        const slidesPerView = thumbsSwiper.params.slidesPerView === "auto" ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;
        let thumbsToActivate = 1;
        const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;
        if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
            thumbsToActivate = swiper.params.slidesPerView;
        }
        if (!swiper.params.thumbs.multipleActiveThumbs) {
            thumbsToActivate = 1;
        }
        thumbsToActivate = Math.floor(thumbsToActivate);
        thumbsSwiper.slides.forEach((slideEl)=>slideEl.classList.remove(thumbActiveClass));
        if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
            for(let i2 = 0; i2 < thumbsToActivate; i2 += 1){
                elementChildren(thumbsSwiper.slidesEl, `[data-swiper-slide-index="${swiper.realIndex + i2}"]`).forEach((slideEl)=>{
                    slideEl.classList.add(thumbActiveClass);
                });
            }
        } else {
            for(let i2 = 0; i2 < thumbsToActivate; i2 += 1){
                if (thumbsSwiper.slides[swiper.realIndex + i2]) {
                    thumbsSwiper.slides[swiper.realIndex + i2].classList.add(thumbActiveClass);
                }
            }
        }
        const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
        const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
        if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
            const currentThumbsIndex = thumbsSwiper.activeIndex;
            let newThumbsIndex;
            let direction;
            if (thumbsSwiper.params.loop) {
                const newThumbsSlide = thumbsSwiper.slides.filter((slideEl)=>slideEl.getAttribute("data-swiper-slide-index") === `${swiper.realIndex}`)[0];
                newThumbsIndex = thumbsSwiper.slides.indexOf(newThumbsSlide);
                direction = swiper.activeIndex > swiper.previousIndex ? "next" : "prev";
            } else {
                newThumbsIndex = swiper.realIndex;
                direction = newThumbsIndex > swiper.previousIndex ? "next" : "prev";
            }
            if (useOffset) {
                newThumbsIndex += direction === "next" ? autoScrollOffset : -1 * autoScrollOffset;
            }
            if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
                if (thumbsSwiper.params.centeredSlides) {
                    if (newThumbsIndex > currentThumbsIndex) {
                        newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
                    } else {
                        newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
                    }
                } else if (newThumbsIndex > currentThumbsIndex && thumbsSwiper.params.slidesPerGroup === 1) ;
                thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : void 0);
            }
        }
    }
    on("beforeInit", ()=>{
        const { thumbs } = swiper.params;
        if (!thumbs || !thumbs.swiper) return;
        if (typeof thumbs.swiper === "string" || thumbs.swiper instanceof HTMLElement) {
            const document2 = getDocument();
            const getThumbsElementAndInit = ()=>{
                const thumbsElement = typeof thumbs.swiper === "string" ? document2.querySelector(thumbs.swiper) : thumbs.swiper;
                if (thumbsElement && thumbsElement.swiper) {
                    thumbs.swiper = thumbsElement.swiper;
                    init2();
                    update2(true);
                } else if (thumbsElement) {
                    const eventName = `${swiper.params.eventsPrefix}init`;
                    const onThumbsSwiper = (e)=>{
                        thumbs.swiper = e.detail[0];
                        thumbsElement.removeEventListener(eventName, onThumbsSwiper);
                        init2();
                        update2(true);
                        thumbs.swiper.update();
                        swiper.update();
                    };
                    thumbsElement.addEventListener(eventName, onThumbsSwiper);
                }
                return thumbsElement;
            };
            const watchForThumbsToAppear = ()=>{
                if (swiper.destroyed) return;
                const thumbsElement = getThumbsElementAndInit();
                if (!thumbsElement) {
                    requestAnimationFrame(watchForThumbsToAppear);
                }
            };
            requestAnimationFrame(watchForThumbsToAppear);
        } else {
            init2();
            update2(true);
        }
    });
    on("slideChange update resize observerUpdate", ()=>{
        update2();
    });
    on("setTransition", (_s, duration)=>{
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        thumbsSwiper.setTransition(duration);
    });
    on("beforeDestroy", ()=>{
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper || thumbsSwiper.destroyed) return;
        if (swiperCreated) {
            thumbsSwiper.destroy();
        }
    });
    Object.assign(swiper.thumbs, {
        init: init2,
        update: update2
    });
}
// node_modules/swiper/modules/free-mode.mjs
function freeMode(_ref) {
    let { swiper, extendParams, emit, once } = _ref;
    extendParams({
        freeMode: {
            enabled: false,
            momentum: true,
            momentumRatio: 1,
            momentumBounce: true,
            momentumBounceRatio: 1,
            momentumVelocityRatio: 1,
            sticky: false,
            minimumVelocity: 0.02
        }
    });
    function onTouchStart2() {
        if (swiper.params.cssMode) return;
        const translate2 = swiper.getTranslate();
        swiper.setTranslate(translate2);
        swiper.setTransition(0);
        swiper.touchEventsData.velocities.length = 0;
        swiper.freeMode.onTouchEnd({
            currentPos: swiper.rtl ? swiper.translate : -swiper.translate
        });
    }
    function onTouchMove2() {
        if (swiper.params.cssMode) return;
        const { touchEventsData: data, touches } = swiper;
        if (data.velocities.length === 0) {
            data.velocities.push({
                position: touches[swiper.isHorizontal() ? "startX" : "startY"],
                time: data.touchStartTime
            });
        }
        data.velocities.push({
            position: touches[swiper.isHorizontal() ? "currentX" : "currentY"],
            time: now2()
        });
    }
    function onTouchEnd2(_ref2) {
        let { currentPos } = _ref2;
        if (swiper.params.cssMode) return;
        const { params, wrapperEl, rtlTranslate: rtl, snapGrid, touchEventsData: data } = swiper;
        const touchEndTime = now2();
        const timeDiff = touchEndTime - data.touchStartTime;
        if (currentPos < -swiper.minTranslate()) {
            swiper.slideTo(swiper.activeIndex);
            return;
        }
        if (currentPos > -swiper.maxTranslate()) {
            if (swiper.slides.length < snapGrid.length) {
                swiper.slideTo(snapGrid.length - 1);
            } else {
                swiper.slideTo(swiper.slides.length - 1);
            }
            return;
        }
        if (params.freeMode.momentum) {
            if (data.velocities.length > 1) {
                const lastMoveEvent = data.velocities.pop();
                const velocityEvent = data.velocities.pop();
                const distance = lastMoveEvent.position - velocityEvent.position;
                const time = lastMoveEvent.time - velocityEvent.time;
                swiper.velocity = distance / time;
                swiper.velocity /= 2;
                if (Math.abs(swiper.velocity) < params.freeMode.minimumVelocity) {
                    swiper.velocity = 0;
                }
                if (time > 150 || now2() - lastMoveEvent.time > 300) {
                    swiper.velocity = 0;
                }
            } else {
                swiper.velocity = 0;
            }
            swiper.velocity *= params.freeMode.momentumVelocityRatio;
            data.velocities.length = 0;
            let momentumDuration = 1e3 * params.freeMode.momentumRatio;
            const momentumDistance = swiper.velocity * momentumDuration;
            let newPosition = swiper.translate + momentumDistance;
            if (rtl) newPosition = -newPosition;
            let doBounce = false;
            let afterBouncePosition;
            const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeMode.momentumBounceRatio;
            let needsLoopFix;
            if (newPosition < swiper.maxTranslate()) {
                if (params.freeMode.momentumBounce) {
                    if (newPosition + swiper.maxTranslate() < -bounceAmount) {
                        newPosition = swiper.maxTranslate() - bounceAmount;
                    }
                    afterBouncePosition = swiper.maxTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.maxTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (newPosition > swiper.minTranslate()) {
                if (params.freeMode.momentumBounce) {
                    if (newPosition - swiper.minTranslate() > bounceAmount) {
                        newPosition = swiper.minTranslate() + bounceAmount;
                    }
                    afterBouncePosition = swiper.minTranslate();
                    doBounce = true;
                    data.allowMomentumBounce = true;
                } else {
                    newPosition = swiper.minTranslate();
                }
                if (params.loop && params.centeredSlides) needsLoopFix = true;
            } else if (params.freeMode.sticky) {
                let nextSlide;
                for(let j = 0; j < snapGrid.length; j += 1){
                    if (snapGrid[j] > -newPosition) {
                        nextSlide = j;
                        break;
                    }
                }
                if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === "next") {
                    newPosition = snapGrid[nextSlide];
                } else {
                    newPosition = snapGrid[nextSlide - 1];
                }
                newPosition = -newPosition;
            }
            if (needsLoopFix) {
                once("transitionEnd", ()=>{
                    swiper.loopFix();
                });
            }
            if (swiper.velocity !== 0) {
                if (rtl) {
                    momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
                } else {
                    momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
                }
                if (params.freeMode.sticky) {
                    const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
                    const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
                    if (moveDistance < currentSlideSize) {
                        momentumDuration = params.speed;
                    } else if (moveDistance < 2 * currentSlideSize) {
                        momentumDuration = params.speed * 1.5;
                    } else {
                        momentumDuration = params.speed * 2.5;
                    }
                }
            } else if (params.freeMode.sticky) {
                swiper.slideToClosest();
                return;
            }
            if (params.freeMode.momentumBounce && doBounce) {
                swiper.updateProgress(afterBouncePosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                swiper.animating = true;
                elementTransitionEnd(wrapperEl, ()=>{
                    if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
                    emit("momentumBounce");
                    swiper.setTransition(params.speed);
                    setTimeout(()=>{
                        swiper.setTranslate(afterBouncePosition);
                        elementTransitionEnd(wrapperEl, ()=>{
                            if (!swiper || swiper.destroyed) return;
                            swiper.transitionEnd();
                        });
                    }, 0);
                });
            } else if (swiper.velocity) {
                emit("_freeModeNoMomentumRelease");
                swiper.updateProgress(newPosition);
                swiper.setTransition(momentumDuration);
                swiper.setTranslate(newPosition);
                swiper.transitionStart(true, swiper.swipeDirection);
                if (!swiper.animating) {
                    swiper.animating = true;
                    elementTransitionEnd(wrapperEl, ()=>{
                        if (!swiper || swiper.destroyed) return;
                        swiper.transitionEnd();
                    });
                }
            } else {
                swiper.updateProgress(newPosition);
            }
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        } else if (params.freeMode.sticky) {
            swiper.slideToClosest();
            return;
        } else if (params.freeMode) {
            emit("_freeModeNoMomentumRelease");
        }
        if (!params.freeMode.momentum || timeDiff >= params.longSwipesMs) {
            emit("_freeModeStaticRelease");
            swiper.updateProgress();
            swiper.updateActiveIndex();
            swiper.updateSlidesClasses();
        }
    }
    Object.assign(swiper, {
        freeMode: {
            onTouchStart: onTouchStart2,
            onTouchMove: onTouchMove2,
            onTouchEnd: onTouchEnd2
        }
    });
}
// node_modules/swiper/modules/grid.mjs
function Grid(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        grid: {
            rows: 1,
            fill: "column"
        }
    });
    let slidesNumberEvenToRows;
    let slidesPerRow;
    let numFullColumns;
    let wasMultiRow;
    const getSpaceBetween = ()=>{
        let spaceBetween = swiper.params.spaceBetween;
        if (typeof spaceBetween === "string" && spaceBetween.indexOf("%") >= 0) {
            spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * swiper.size;
        } else if (typeof spaceBetween === "string") {
            spaceBetween = parseFloat(spaceBetween);
        }
        return spaceBetween;
    };
    const initSlides = (slides)=>{
        const { slidesPerView } = swiper.params;
        const { rows, fill } = swiper.params.grid;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
        numFullColumns = Math.floor(slidesLength / rows);
        if (Math.floor(slidesLength / rows) === slidesLength / rows) {
            slidesNumberEvenToRows = slidesLength;
        } else {
            slidesNumberEvenToRows = Math.ceil(slidesLength / rows) * rows;
        }
        if (slidesPerView !== "auto" && fill === "row") {
            slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, slidesPerView * rows);
        }
        slidesPerRow = slidesNumberEvenToRows / rows;
    };
    const unsetSlides = ()=>{
        if (swiper.slides) {
            swiper.slides.forEach((slide2)=>{
                if (slide2.swiperSlideGridSet) {
                    slide2.style.height = "";
                    slide2.style[swiper.getDirectionLabel("margin-top")] = "";
                }
            });
        }
    };
    const updateSlide = (i2, slide2, slides)=>{
        const { slidesPerGroup } = swiper.params;
        const spaceBetween = getSpaceBetween();
        const { rows, fill } = swiper.params.grid;
        const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : slides.length;
        let newSlideOrderIndex;
        let column;
        let row;
        if (fill === "row" && slidesPerGroup > 1) {
            const groupIndex = Math.floor(i2 / (slidesPerGroup * rows));
            const slideIndexInGroup = i2 - rows * slidesPerGroup * groupIndex;
            const columnsInGroup = groupIndex === 0 ? slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * rows * slidesPerGroup) / rows), slidesPerGroup);
            row = Math.floor(slideIndexInGroup / columnsInGroup);
            column = slideIndexInGroup - row * columnsInGroup + groupIndex * slidesPerGroup;
            newSlideOrderIndex = column + row * slidesNumberEvenToRows / rows;
            slide2.style.order = newSlideOrderIndex;
        } else if (fill === "column") {
            column = Math.floor(i2 / rows);
            row = i2 - column * rows;
            if (column > numFullColumns || column === numFullColumns && row === rows - 1) {
                row += 1;
                if (row >= rows) {
                    row = 0;
                    column += 1;
                }
            }
        } else {
            row = Math.floor(i2 / slidesPerRow);
            column = i2 - row * slidesPerRow;
        }
        slide2.row = row;
        slide2.column = column;
        slide2.style.height = `calc((100% - ${(rows - 1) * spaceBetween}px) / ${rows})`;
        slide2.style[swiper.getDirectionLabel("margin-top")] = row !== 0 ? spaceBetween && `${spaceBetween}px` : "";
        slide2.swiperSlideGridSet = true;
    };
    const updateWrapperSize = (slideSize, snapGrid)=>{
        const { centeredSlides, roundLengths } = swiper.params;
        const spaceBetween = getSpaceBetween();
        const { rows } = swiper.params.grid;
        swiper.virtualSize = (slideSize + spaceBetween) * slidesNumberEvenToRows;
        swiper.virtualSize = Math.ceil(swiper.virtualSize / rows) - spaceBetween;
        if (!swiper.params.cssMode) {
            swiper.wrapperEl.style[swiper.getDirectionLabel("width")] = `${swiper.virtualSize + spaceBetween}px`;
        }
        if (centeredSlides) {
            const newSlidesGrid = [];
            for(let i2 = 0; i2 < snapGrid.length; i2 += 1){
                let slidesGridItem = snapGrid[i2];
                if (roundLengths) slidesGridItem = Math.floor(slidesGridItem);
                if (snapGrid[i2] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
            }
            snapGrid.splice(0, snapGrid.length);
            snapGrid.push(...newSlidesGrid);
        }
    };
    const onInit = ()=>{
        wasMultiRow = swiper.params.grid && swiper.params.grid.rows > 1;
    };
    const onUpdate = ()=>{
        const { params, el } = swiper;
        const isMultiRow = params.grid && params.grid.rows > 1;
        if (wasMultiRow && !isMultiRow) {
            el.classList.remove(`${params.containerModifierClass}grid`, `${params.containerModifierClass}grid-column`);
            numFullColumns = 1;
            swiper.emitContainerClasses();
        } else if (!wasMultiRow && isMultiRow) {
            el.classList.add(`${params.containerModifierClass}grid`);
            if (params.grid.fill === "column") {
                el.classList.add(`${params.containerModifierClass}grid-column`);
            }
            swiper.emitContainerClasses();
        }
        wasMultiRow = isMultiRow;
    };
    on("init", onInit);
    on("update", onUpdate);
    swiper.grid = {
        initSlides,
        unsetSlides,
        updateSlide,
        updateWrapperSize
    };
}
// node_modules/swiper/modules/manipulation.mjs
function appendSlide(slides) {
    const swiper = this;
    const { params, slidesEl } = swiper;
    if (params.loop) {
        swiper.loopDestroy();
    }
    const appendElement = (slideEl)=>{
        if (typeof slideEl === "string") {
            const tempDOM = document.createElement("div");
            tempDOM.innerHTML = slideEl;
            slidesEl.append(tempDOM.children[0]);
            tempDOM.innerHTML = "";
        } else {
            slidesEl.append(slideEl);
        }
    };
    if (typeof slides === "object" && "length" in slides) {
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) appendElement(slides[i2]);
        }
    } else {
        appendElement(slides);
    }
    swiper.recalcSlides();
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
        swiper.update();
    }
}
function prependSlide(slides) {
    const swiper = this;
    const { params, activeIndex, slidesEl } = swiper;
    if (params.loop) {
        swiper.loopDestroy();
    }
    let newActiveIndex = activeIndex + 1;
    const prependElement = (slideEl)=>{
        if (typeof slideEl === "string") {
            const tempDOM = document.createElement("div");
            tempDOM.innerHTML = slideEl;
            slidesEl.prepend(tempDOM.children[0]);
            tempDOM.innerHTML = "";
        } else {
            slidesEl.prepend(slideEl);
        }
    };
    if (typeof slides === "object" && "length" in slides) {
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) prependElement(slides[i2]);
        }
        newActiveIndex = activeIndex + slides.length;
    } else {
        prependElement(slides);
    }
    swiper.recalcSlides();
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
        swiper.update();
    }
    swiper.slideTo(newActiveIndex, 0, false);
}
function addSlide(index, slides) {
    const swiper = this;
    const { params, activeIndex, slidesEl } = swiper;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
        swiper.recalcSlides();
    }
    const baseLength = swiper.slides.length;
    if (index <= 0) {
        swiper.prependSlide(slides);
        return;
    }
    if (index >= baseLength) {
        swiper.appendSlide(slides);
        return;
    }
    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    const slidesBuffer = [];
    for(let i2 = baseLength - 1; i2 >= index; i2 -= 1){
        const currentSlide = swiper.slides[i2];
        currentSlide.remove();
        slidesBuffer.unshift(currentSlide);
    }
    if (typeof slides === "object" && "length" in slides) {
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            if (slides[i2]) slidesEl.append(slides[i2]);
        }
        newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
        slidesEl.append(slides);
    }
    for(let i2 = 0; i2 < slidesBuffer.length; i2 += 1){
        slidesEl.append(slidesBuffer[i2]);
    }
    swiper.recalcSlides();
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
function removeSlide(slidesIndexes) {
    const swiper = this;
    const { params, activeIndex } = swiper;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
        activeIndexBuffer -= swiper.loopedSlides;
        swiper.loopDestroy();
    }
    let newActiveIndex = activeIndexBuffer;
    let indexToRemove;
    if (typeof slidesIndexes === "object" && "length" in slidesIndexes) {
        for(let i2 = 0; i2 < slidesIndexes.length; i2 += 1){
            indexToRemove = slidesIndexes[i2];
            if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
            if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        }
        newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
        indexToRemove = slidesIndexes;
        if (swiper.slides[indexToRemove]) swiper.slides[indexToRemove].remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
        newActiveIndex = Math.max(newActiveIndex, 0);
    }
    swiper.recalcSlides();
    if (params.loop) {
        swiper.loopCreate();
    }
    if (!params.observer || swiper.isElement) {
        swiper.update();
    }
    if (params.loop) {
        swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
        swiper.slideTo(newActiveIndex, 0, false);
    }
}
function removeAllSlides() {
    const swiper = this;
    const slidesIndexes = [];
    for(let i2 = 0; i2 < swiper.slides.length; i2 += 1){
        slidesIndexes.push(i2);
    }
    swiper.removeSlide(slidesIndexes);
}
function Manipulation(_ref) {
    let { swiper } = _ref;
    Object.assign(swiper, {
        appendSlide: appendSlide.bind(swiper),
        prependSlide: prependSlide.bind(swiper),
        addSlide: addSlide.bind(swiper),
        removeSlide: removeSlide.bind(swiper),
        removeAllSlides: removeAllSlides.bind(swiper)
    });
}
// node_modules/swiper/shared/effect-init.mjs
function effectInit(params) {
    const { effect, swiper, on, setTranslate: setTranslate2, setTransition: setTransition2, overwriteParams, perspective, recreateShadows, getEffectParams } = params;
    on("beforeInit", ()=>{
        if (swiper.params.effect !== effect) return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);
        if (perspective && perspective()) {
            swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
        }
        const overwriteParamsResult = overwriteParams ? overwriteParams() : {};
        Object.assign(swiper.params, overwriteParamsResult);
        Object.assign(swiper.originalParams, overwriteParamsResult);
    });
    on("setTranslate", ()=>{
        if (swiper.params.effect !== effect) return;
        setTranslate2();
    });
    on("setTransition", (_s, duration)=>{
        if (swiper.params.effect !== effect) return;
        setTransition2(duration);
    });
    on("transitionEnd", ()=>{
        if (swiper.params.effect !== effect) return;
        if (recreateShadows) {
            if (!getEffectParams || !getEffectParams().slideShadows) return;
            swiper.slides.forEach((slideEl)=>{
                slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl)=>shadowEl.remove());
            });
            recreateShadows();
        }
    });
    let requireUpdateOnVirtual;
    on("virtualUpdate", ()=>{
        if (swiper.params.effect !== effect) return;
        if (!swiper.slides.length) {
            requireUpdateOnVirtual = true;
        }
        requestAnimationFrame(()=>{
            if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {
                setTranslate2();
                requireUpdateOnVirtual = false;
            }
        });
    });
}
// node_modules/swiper/shared/effect-target.mjs
function effectTarget(effectParams, slideEl) {
    const transformEl = getSlideTransformEl(slideEl);
    if (transformEl !== slideEl) {
        transformEl.style.backfaceVisibility = "hidden";
        transformEl.style["-webkit-backface-visibility"] = "hidden";
    }
    return transformEl;
}
// node_modules/swiper/shared/effect-virtual-transition-end.mjs
function effectVirtualTransitionEnd(_ref) {
    let { swiper, duration, transformElements, allSlides } = _ref;
    const { activeIndex } = swiper;
    const getSlide = (el)=>{
        if (!el.parentElement) {
            const slide2 = swiper.slides.filter((slideEl)=>slideEl.shadowRoot && slideEl.shadowRoot === el.parentNode)[0];
            return slide2;
        }
        return el.parentElement;
    };
    if (swiper.params.virtualTranslate && duration !== 0) {
        let eventTriggered = false;
        let transitionEndTarget;
        if (allSlides) {
            transitionEndTarget = transformElements;
        } else {
            transitionEndTarget = transformElements.filter((transformEl)=>{
                const el = transformEl.classList.contains("swiper-slide-transform") ? getSlide(transformEl) : transformEl;
                return swiper.getSlideIndex(el) === activeIndex;
            });
        }
        transitionEndTarget.forEach((el)=>{
            elementTransitionEnd(el, ()=>{
                if (eventTriggered) return;
                if (!swiper || swiper.destroyed) return;
                eventTriggered = true;
                swiper.animating = false;
                const evt = new window.CustomEvent("transitionend", {
                    bubbles: true,
                    cancelable: true
                });
                swiper.wrapperEl.dispatchEvent(evt);
            });
        });
    }
}
// node_modules/swiper/modules/effect-fade.mjs
function EffectFade(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        fadeEffect: {
            crossFade: false
        }
    });
    const setTranslate2 = ()=>{
        const { slides } = swiper;
        const params = swiper.params.fadeEffect;
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            const slideEl = swiper.slides[i2];
            const offset = slideEl.swiperSlideOffset;
            let tx = -offset;
            if (!swiper.params.virtualTranslate) tx -= swiper.translate;
            let ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
            }
            const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(slideEl.progress), 0) : 1 + Math.min(Math.max(slideEl.progress, -1), 0);
            const targetEl = effectTarget(params, slideEl);
            targetEl.style.opacity = slideOpacity;
            targetEl.style.transform = `translate3d(${tx}px, ${ty}px, 0px)`;
        }
    };
    const setTransition2 = (duration)=>{
        const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));
        transformElements.forEach((el)=>{
            el.style.transitionDuration = `${duration}ms`;
        });
        effectVirtualTransitionEnd({
            swiper,
            duration,
            transformElements,
            allSlides: true
        });
    };
    effectInit({
        effect: "fade",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        overwriteParams: ()=>({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
    });
}
// node_modules/swiper/modules/effect-cube.mjs
function EffectCube(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        cubeEffect: {
            slideShadows: true,
            shadow: true,
            shadowOffset: 20,
            shadowScale: 0.94
        }
    });
    const createSlideShadows = (slideEl, progress, isHorizontal)=>{
        let shadowBefore = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
        let shadowAfter = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
        if (!shadowBefore) {
            shadowBefore = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "left" : "top"}`.split(" "));
            slideEl.append(shadowBefore);
        }
        if (!shadowAfter) {
            shadowAfter = createElement("div", `swiper-slide-shadow-cube swiper-slide-shadow-${isHorizontal ? "right" : "bottom"}`.split(" "));
            slideEl.append(shadowAfter);
        }
        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = ()=>{
        const isHorizontal = swiper.isHorizontal();
        swiper.slides.forEach((slideEl)=>{
            const progress = Math.max(Math.min(slideEl.progress, 1), -1);
            createSlideShadows(slideEl, progress, isHorizontal);
        });
    };
    const setTranslate2 = ()=>{
        const { el, wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize, browser: browser2 } = swiper;
        const r = getRotateFix(swiper);
        const params = swiper.params.cubeEffect;
        const isHorizontal = swiper.isHorizontal();
        const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
        let wrapperRotate = 0;
        let cubeShadowEl;
        if (params.shadow) {
            if (isHorizontal) {
                cubeShadowEl = swiper.wrapperEl.querySelector(".swiper-cube-shadow");
                if (!cubeShadowEl) {
                    cubeShadowEl = createElement("div", "swiper-cube-shadow");
                    swiper.wrapperEl.append(cubeShadowEl);
                }
                cubeShadowEl.style.height = `${swiperWidth}px`;
            } else {
                cubeShadowEl = el.querySelector(".swiper-cube-shadow");
                if (!cubeShadowEl) {
                    cubeShadowEl = createElement("div", "swiper-cube-shadow");
                    el.append(cubeShadowEl);
                }
            }
        }
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            const slideEl = slides[i2];
            let slideIndex = i2;
            if (isVirtual) {
                slideIndex = parseInt(slideEl.getAttribute("data-swiper-slide-index"), 10);
            }
            let slideAngle = slideIndex * 90;
            let round = Math.floor(slideAngle / 360);
            if (rtl) {
                slideAngle = -slideAngle;
                round = Math.floor(-slideAngle / 360);
            }
            const progress = Math.max(Math.min(slideEl.progress, 1), -1);
            let tx = 0;
            let ty = 0;
            let tz = 0;
            if (slideIndex % 4 === 0) {
                tx = -round * 4 * swiperSize;
                tz = 0;
            } else if ((slideIndex - 1) % 4 === 0) {
                tx = 0;
                tz = -round * 4 * swiperSize;
            } else if ((slideIndex - 2) % 4 === 0) {
                tx = swiperSize + round * 4 * swiperSize;
                tz = swiperSize;
            } else if ((slideIndex - 3) % 4 === 0) {
                tx = -swiperSize;
                tz = 3 * swiperSize + swiperSize * 4 * round;
            }
            if (rtl) {
                tx = -tx;
            }
            if (!isHorizontal) {
                ty = tx;
                tx = 0;
            }
            const transform = `rotateX(${r(isHorizontal ? 0 : -slideAngle)}deg) rotateY(${r(isHorizontal ? slideAngle : 0)}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
            if (progress <= 1 && progress > -1) {
                wrapperRotate = slideIndex * 90 + progress * 90;
                if (rtl) wrapperRotate = -slideIndex * 90 - progress * 90;
            }
            slideEl.style.transform = transform;
            if (params.slideShadows) {
                createSlideShadows(slideEl, progress, isHorizontal);
            }
        }
        wrapperEl.style.transformOrigin = `50% 50% -${swiperSize / 2}px`;
        wrapperEl.style["-webkit-transform-origin"] = `50% 50% -${swiperSize / 2}px`;
        if (params.shadow) {
            if (isHorizontal) {
                cubeShadowEl.style.transform = `translate3d(0px, ${swiperWidth / 2 + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${params.shadowScale})`;
            } else {
                const shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
                const multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
                const scale1 = params.shadowScale;
                const scale2 = params.shadowScale / multiplier;
                const offset = params.shadowOffset;
                cubeShadowEl.style.transform = `scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${swiperHeight / 2 + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-89.99deg)`;
            }
        }
        const zFactor = (browser2.isSafari || browser2.isWebView) && browser2.needPerspectiveFix ? -swiperSize / 2 : 0;
        wrapperEl.style.transform = `translate3d(0px,0,${zFactor}px) rotateX(${r(swiper.isHorizontal() ? 0 : wrapperRotate)}deg) rotateY(${r(swiper.isHorizontal() ? -wrapperRotate : 0)}deg)`;
        wrapperEl.style.setProperty("--swiper-cube-translate-z", `${zFactor}px`);
    };
    const setTransition2 = (duration)=>{
        const { el, slides } = swiper;
        slides.forEach((slideEl)=>{
            slideEl.style.transitionDuration = `${duration}ms`;
            slideEl.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((subEl)=>{
                subEl.style.transitionDuration = `${duration}ms`;
            });
        });
        if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
            const shadowEl = el.querySelector(".swiper-cube-shadow");
            if (shadowEl) shadowEl.style.transitionDuration = `${duration}ms`;
        }
    };
    effectInit({
        effect: "cube",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        recreateShadows,
        getEffectParams: ()=>swiper.params.cubeEffect,
        perspective: ()=>true,
        overwriteParams: ()=>({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                resistanceRatio: 0,
                spaceBetween: 0,
                centeredSlides: false,
                virtualTranslate: true
            })
    });
}
// node_modules/swiper/shared/create-shadow.mjs
function createShadow(suffix, slideEl, side) {
    const shadowClass = `swiper-slide-shadow${side ? `-${side}` : ""}${suffix ? ` swiper-slide-shadow-${suffix}` : ""}`;
    const shadowContainer = getSlideTransformEl(slideEl);
    let shadowEl = shadowContainer.querySelector(`.${shadowClass.split(" ").join(".")}`);
    if (!shadowEl) {
        shadowEl = createElement("div", shadowClass.split(" "));
        shadowContainer.append(shadowEl);
    }
    return shadowEl;
}
// node_modules/swiper/modules/effect-flip.mjs
function EffectFlip(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        flipEffect: {
            slideShadows: true,
            limitRotation: true
        }
    });
    const createSlideShadows = (slideEl, progress)=>{
        let shadowBefore = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
        let shadowAfter = swiper.isHorizontal() ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
        if (!shadowBefore) {
            shadowBefore = createShadow("flip", slideEl, swiper.isHorizontal() ? "left" : "top");
        }
        if (!shadowAfter) {
            shadowAfter = createShadow("flip", slideEl, swiper.isHorizontal() ? "right" : "bottom");
        }
        if (shadowBefore) shadowBefore.style.opacity = Math.max(-progress, 0);
        if (shadowAfter) shadowAfter.style.opacity = Math.max(progress, 0);
    };
    const recreateShadows = ()=>{
        swiper.params.flipEffect;
        swiper.slides.forEach((slideEl)=>{
            let progress = slideEl.progress;
            if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min(slideEl.progress, 1), -1);
            }
            createSlideShadows(slideEl, progress);
        });
    };
    const setTranslate2 = ()=>{
        const { slides, rtlTranslate: rtl } = swiper;
        const params = swiper.params.flipEffect;
        const rotateFix = getRotateFix(swiper);
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            const slideEl = slides[i2];
            let progress = slideEl.progress;
            if (swiper.params.flipEffect.limitRotation) {
                progress = Math.max(Math.min(slideEl.progress, 1), -1);
            }
            const offset = slideEl.swiperSlideOffset;
            const rotate = -180 * progress;
            let rotateY = rotate;
            let rotateX = 0;
            let tx = swiper.params.cssMode ? -offset - swiper.translate : -offset;
            let ty = 0;
            if (!swiper.isHorizontal()) {
                ty = tx;
                tx = 0;
                rotateX = -rotateY;
                rotateY = 0;
            } else if (rtl) {
                rotateY = -rotateY;
            }
            slideEl.style.zIndex = -Math.abs(Math.round(progress)) + slides.length;
            if (params.slideShadows) {
                createSlideShadows(slideEl, progress);
            }
            const transform = `translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateFix(rotateX)}deg) rotateY(${rotateFix(rotateY)}deg)`;
            const targetEl = effectTarget(params, slideEl);
            targetEl.style.transform = transform;
        }
    };
    const setTransition2 = (duration)=>{
        const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));
        transformElements.forEach((el)=>{
            el.style.transitionDuration = `${duration}ms`;
            el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl)=>{
                shadowEl.style.transitionDuration = `${duration}ms`;
            });
        });
        effectVirtualTransitionEnd({
            swiper,
            duration,
            transformElements
        });
    };
    effectInit({
        effect: "flip",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        recreateShadows,
        getEffectParams: ()=>swiper.params.flipEffect,
        perspective: ()=>true,
        overwriteParams: ()=>({
                slidesPerView: 1,
                slidesPerGroup: 1,
                watchSlidesProgress: true,
                spaceBetween: 0,
                virtualTranslate: !swiper.params.cssMode
            })
    });
}
// node_modules/swiper/modules/effect-coverflow.mjs
function EffectCoverflow(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        coverflowEffect: {
            rotate: 50,
            stretch: 0,
            depth: 100,
            scale: 1,
            modifier: 1,
            slideShadows: true
        }
    });
    const setTranslate2 = ()=>{
        const { width: swiperWidth, height: swiperHeight, slides, slidesSizesGrid } = swiper;
        const params = swiper.params.coverflowEffect;
        const isHorizontal = swiper.isHorizontal();
        const transform = swiper.translate;
        const center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
        const rotate = isHorizontal ? params.rotate : -params.rotate;
        const translate2 = params.depth;
        const r = getRotateFix(swiper);
        for(let i2 = 0, length = slides.length; i2 < length; i2 += 1){
            const slideEl = slides[i2];
            const slideSize = slidesSizesGrid[i2];
            const slideOffset = slideEl.swiperSlideOffset;
            const centerOffset = (center - slideOffset - slideSize / 2) / slideSize;
            const offsetMultiplier = typeof params.modifier === "function" ? params.modifier(centerOffset) : centerOffset * params.modifier;
            let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
            let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
            let translateZ = -translate2 * Math.abs(offsetMultiplier);
            let stretch = params.stretch;
            if (typeof stretch === "string" && stretch.indexOf("%") !== -1) {
                stretch = parseFloat(params.stretch) / 100 * slideSize;
            }
            let translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
            let translateX = isHorizontal ? stretch * offsetMultiplier : 0;
            let scale = 1 - (1 - params.scale) * Math.abs(offsetMultiplier);
            if (Math.abs(translateX) < 1e-3) translateX = 0;
            if (Math.abs(translateY) < 1e-3) translateY = 0;
            if (Math.abs(translateZ) < 1e-3) translateZ = 0;
            if (Math.abs(rotateY) < 1e-3) rotateY = 0;
            if (Math.abs(rotateX) < 1e-3) rotateX = 0;
            if (Math.abs(scale) < 1e-3) scale = 0;
            const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${r(rotateX)}deg) rotateY(${r(rotateY)}deg) scale(${scale})`;
            const targetEl = effectTarget(params, slideEl);
            targetEl.style.transform = slideTransform;
            slideEl.style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
            if (params.slideShadows) {
                let shadowBeforeEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-left") : slideEl.querySelector(".swiper-slide-shadow-top");
                let shadowAfterEl = isHorizontal ? slideEl.querySelector(".swiper-slide-shadow-right") : slideEl.querySelector(".swiper-slide-shadow-bottom");
                if (!shadowBeforeEl) {
                    shadowBeforeEl = createShadow("coverflow", slideEl, isHorizontal ? "left" : "top");
                }
                if (!shadowAfterEl) {
                    shadowAfterEl = createShadow("coverflow", slideEl, isHorizontal ? "right" : "bottom");
                }
                if (shadowBeforeEl) shadowBeforeEl.style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
                if (shadowAfterEl) shadowAfterEl.style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
            }
        }
    };
    const setTransition2 = (duration)=>{
        const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));
        transformElements.forEach((el)=>{
            el.style.transitionDuration = `${duration}ms`;
            el.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach((shadowEl)=>{
                shadowEl.style.transitionDuration = `${duration}ms`;
            });
        });
    };
    effectInit({
        effect: "coverflow",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        perspective: ()=>true,
        overwriteParams: ()=>({
                watchSlidesProgress: true
            })
    });
}
// node_modules/swiper/modules/effect-creative.mjs
function EffectCreative(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        creativeEffect: {
            limitProgress: 1,
            shadowPerProgress: false,
            progressMultiplier: 1,
            perspective: true,
            prev: {
                translate: [
                    0,
                    0,
                    0
                ],
                rotate: [
                    0,
                    0,
                    0
                ],
                opacity: 1,
                scale: 1
            },
            next: {
                translate: [
                    0,
                    0,
                    0
                ],
                rotate: [
                    0,
                    0,
                    0
                ],
                opacity: 1,
                scale: 1
            }
        }
    });
    const getTranslateValue = (value)=>{
        if (typeof value === "string") return value;
        return `${value}px`;
    };
    const setTranslate2 = ()=>{
        const { slides, wrapperEl, slidesSizesGrid } = swiper;
        const params = swiper.params.creativeEffect;
        const { progressMultiplier: multiplier } = params;
        const isCenteredSlides = swiper.params.centeredSlides;
        const rotateFix = getRotateFix(swiper);
        if (isCenteredSlides) {
            const margin = slidesSizesGrid[0] / 2 - swiper.params.slidesOffsetBefore || 0;
            wrapperEl.style.transform = `translateX(calc(50% - ${margin}px))`;
        }
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            const slideEl = slides[i2];
            const slideProgress = slideEl.progress;
            const progress = Math.min(Math.max(slideEl.progress, -params.limitProgress), params.limitProgress);
            let originalProgress = progress;
            if (!isCenteredSlides) {
                originalProgress = Math.min(Math.max(slideEl.originalProgress, -params.limitProgress), params.limitProgress);
            }
            const offset = slideEl.swiperSlideOffset;
            const t = [
                swiper.params.cssMode ? -offset - swiper.translate : -offset,
                0,
                0
            ];
            const r = [
                0,
                0,
                0
            ];
            let custom = false;
            if (!swiper.isHorizontal()) {
                t[1] = t[0];
                t[0] = 0;
            }
            let data = {
                translate: [
                    0,
                    0,
                    0
                ],
                rotate: [
                    0,
                    0,
                    0
                ],
                scale: 1,
                opacity: 1
            };
            if (progress < 0) {
                data = params.next;
                custom = true;
            } else if (progress > 0) {
                data = params.prev;
                custom = true;
            }
            t.forEach((value, index)=>{
                t[index] = `calc(${value}px + (${getTranslateValue(data.translate[index])} * ${Math.abs(progress * multiplier)}))`;
            });
            r.forEach((value, index)=>{
                let val = data.rotate[index] * Math.abs(progress * multiplier);
                r[index] = val;
            });
            slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
            const translateString = t.join(", ");
            const rotateString = `rotateX(${rotateFix(r[0])}deg) rotateY(${rotateFix(r[1])}deg) rotateZ(${rotateFix(r[2])}deg)`;
            const scaleString = originalProgress < 0 ? `scale(${1 + (1 - data.scale) * originalProgress * multiplier})` : `scale(${1 - (1 - data.scale) * originalProgress * multiplier})`;
            const opacityString = originalProgress < 0 ? 1 + (1 - data.opacity) * originalProgress * multiplier : 1 - (1 - data.opacity) * originalProgress * multiplier;
            const transform = `translate3d(${translateString}) ${rotateString} ${scaleString}`;
            if (custom && data.shadow || !custom) {
                let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                if (!shadowEl && data.shadow) {
                    shadowEl = createShadow("creative", slideEl);
                }
                if (shadowEl) {
                    const shadowOpacity = params.shadowPerProgress ? progress * (1 / params.limitProgress) : progress;
                    shadowEl.style.opacity = Math.min(Math.max(Math.abs(shadowOpacity), 0), 1);
                }
            }
            const targetEl = effectTarget(params, slideEl);
            targetEl.style.transform = transform;
            targetEl.style.opacity = opacityString;
            if (data.origin) {
                targetEl.style.transformOrigin = data.origin;
            }
        }
    };
    const setTransition2 = (duration)=>{
        const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));
        transformElements.forEach((el)=>{
            el.style.transitionDuration = `${duration}ms`;
            el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl)=>{
                shadowEl.style.transitionDuration = `${duration}ms`;
            });
        });
        effectVirtualTransitionEnd({
            swiper,
            duration,
            transformElements,
            allSlides: true
        });
    };
    effectInit({
        effect: "creative",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        perspective: ()=>swiper.params.creativeEffect.perspective,
        overwriteParams: ()=>({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
    });
}
// node_modules/swiper/modules/effect-cards.mjs
function EffectCards(_ref) {
    let { swiper, extendParams, on } = _ref;
    extendParams({
        cardsEffect: {
            slideShadows: true,
            rotate: true,
            perSlideRotate: 2,
            perSlideOffset: 8
        }
    });
    const setTranslate2 = ()=>{
        const { slides, activeIndex, rtlTranslate: rtl } = swiper;
        const params = swiper.params.cardsEffect;
        const { startTranslate, isTouched } = swiper.touchEventsData;
        const currentTranslate = rtl ? -swiper.translate : swiper.translate;
        for(let i2 = 0; i2 < slides.length; i2 += 1){
            const slideEl = slides[i2];
            const slideProgress = slideEl.progress;
            const progress = Math.min(Math.max(slideProgress, -4), 4);
            let offset = slideEl.swiperSlideOffset;
            if (swiper.params.centeredSlides && !swiper.params.cssMode) {
                swiper.wrapperEl.style.transform = `translateX(${swiper.minTranslate()}px)`;
            }
            if (swiper.params.centeredSlides && swiper.params.cssMode) {
                offset -= slides[0].swiperSlideOffset;
            }
            let tX = swiper.params.cssMode ? -offset - swiper.translate : -offset;
            let tY = 0;
            const tZ = -100 * Math.abs(progress);
            let scale = 1;
            let rotate = -params.perSlideRotate * progress;
            let tXAdd = params.perSlideOffset - Math.abs(progress) * 0.75;
            const slideIndex = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.from + i2 : i2;
            const isSwipeToNext = (slideIndex === activeIndex || slideIndex === activeIndex - 1) && progress > 0 && progress < 1 && (isTouched || swiper.params.cssMode) && currentTranslate < startTranslate;
            const isSwipeToPrev = (slideIndex === activeIndex || slideIndex === activeIndex + 1) && progress < 0 && progress > -1 && (isTouched || swiper.params.cssMode) && currentTranslate > startTranslate;
            if (isSwipeToNext || isSwipeToPrev) {
                const subProgress = Math.pow(1 - Math.abs((Math.abs(progress) - 0.5) / 0.5), 0.5);
                rotate += -28 * progress * subProgress;
                scale += -0.5 * subProgress;
                tXAdd += 96 * subProgress;
                tY = `${-25 * subProgress * Math.abs(progress)}%`;
            }
            if (progress < 0) {
                tX = `calc(${tX}px ${rtl ? "-" : "+"} (${tXAdd * Math.abs(progress)}%))`;
            } else if (progress > 0) {
                tX = `calc(${tX}px ${rtl ? "-" : "+"} (-${tXAdd * Math.abs(progress)}%))`;
            } else {
                tX = `${tX}px`;
            }
            if (!swiper.isHorizontal()) {
                const prevY = tY;
                tY = tX;
                tX = prevY;
            }
            const scaleString = progress < 0 ? `${1 + (1 - scale) * progress}` : `${1 - (1 - scale) * progress}`;
            const transform = `
        translate3d(${tX}, ${tY}, ${tZ}px)
        rotateZ(${params.rotate ? rtl ? -rotate : rotate : 0}deg)
        scale(${scaleString})
      `;
            if (params.slideShadows) {
                let shadowEl = slideEl.querySelector(".swiper-slide-shadow");
                if (!shadowEl) {
                    shadowEl = createShadow("cards", slideEl);
                }
                if (shadowEl) shadowEl.style.opacity = Math.min(Math.max((Math.abs(progress) - 0.5) / 0.5, 0), 1);
            }
            slideEl.style.zIndex = -Math.abs(Math.round(slideProgress)) + slides.length;
            const targetEl = effectTarget(params, slideEl);
            targetEl.style.transform = transform;
        }
    };
    const setTransition2 = (duration)=>{
        const transformElements = swiper.slides.map((slideEl)=>getSlideTransformEl(slideEl));
        transformElements.forEach((el)=>{
            el.style.transitionDuration = `${duration}ms`;
            el.querySelectorAll(".swiper-slide-shadow").forEach((shadowEl)=>{
                shadowEl.style.transitionDuration = `${duration}ms`;
            });
        });
        effectVirtualTransitionEnd({
            swiper,
            duration,
            transformElements
        });
    };
    effectInit({
        effect: "cards",
        swiper,
        on,
        setTranslate: setTranslate2,
        setTransition: setTransition2,
        perspective: ()=>true,
        overwriteParams: ()=>({
                watchSlidesProgress: true,
                virtualTranslate: !swiper.params.cssMode
            })
    });
}
// node_modules/swiper/swiper-bundle.mjs
var modules = [
    Virtual,
    Keyboard,
    Mousewheel,
    Navigation,
    Pagination,
    Scrollbar,
    Parallax,
    Zoom,
    Controller,
    A11y,
    History,
    HashNavigation,
    Autoplay,
    Thumb,
    freeMode,
    Grid,
    Manipulation,
    EffectFade,
    EffectCube,
    EffectFlip,
    EffectCoverflow,
    EffectCreative,
    EffectCards
];
Swiper.use(modules);
// node_modules/@tarojs/components/dist/components/taro-swiper-core.js
var indexCss17 = "@font-face{font-family:swiper-icons;src:url('data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA');font-weight:400;font-style:normal}:root{--swiper-theme-color:#007aff}:host{position:relative;display:block;margin-left:auto;margin-right:auto;z-index:1}.swiper{margin-left:auto;margin-right:auto;position:relative;overflow:hidden;list-style:none;padding:0;z-index:1;display:block}.swiper-vertical>.swiper-wrapper{flex-direction:column}.swiper-wrapper{position:relative;width:100%;height:100%;z-index:1;display:flex;transition-property:transform;transition-timing-function:var(--swiper-wrapper-transition-timing-function,initial);box-sizing:content-box}.swiper-android .swiper-slide,.swiper-ios .swiper-slide,.swiper-wrapper{transform:translate3d(0px,0,0)}.swiper-horizontal{touch-action:pan-y}.swiper-vertical{touch-action:pan-x}.swiper-slide{flex-shrink:0;width:100%;height:100%;position:relative;transition-property:transform;display:block}.swiper-slide-invisible-blank{visibility:hidden}.swiper-autoheight,.swiper-autoheight .swiper-slide{height:auto}.swiper-autoheight .swiper-wrapper{align-items:flex-start;transition-property:transform,height}.swiper-backface-hidden .swiper-slide{transform:translateZ(0);-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-3d.swiper-css-mode .swiper-wrapper{perspective:1200px}.swiper-3d .swiper-wrapper{transform-style:preserve-3d}.swiper-3d{perspective:1200px}.swiper-3d .swiper-cube-shadow,.swiper-3d .swiper-slide{transform-style:preserve-3d}.swiper-css-mode>.swiper-wrapper{overflow:auto;scrollbar-width:none;-ms-overflow-style:none}.swiper-css-mode>.swiper-wrapper::-webkit-scrollbar{display:none}.swiper-css-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:start start}.swiper-css-mode.swiper-horizontal>.swiper-wrapper{scroll-snap-type:x mandatory}.swiper-css-mode.swiper-vertical>.swiper-wrapper{scroll-snap-type:y mandatory}.swiper-css-mode.swiper-free-mode>.swiper-wrapper{scroll-snap-type:none}.swiper-css-mode.swiper-free-mode>.swiper-wrapper>.swiper-slide{scroll-snap-align:none}.swiper-css-mode.swiper-centered>.swiper-wrapper::before{content:'';flex-shrink:0;order:9999}.swiper-css-mode.swiper-centered>.swiper-wrapper>.swiper-slide{scroll-snap-align:center center;scroll-snap-stop:always}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper>.swiper-slide:first-child{margin-inline-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-horizontal>.swiper-wrapper::before{height:100%;min-height:1px;width:var(--swiper-centered-offset-after)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper>.swiper-slide:first-child{margin-block-start:var(--swiper-centered-offset-before)}.swiper-css-mode.swiper-centered.swiper-vertical>.swiper-wrapper::before{width:100%;min-width:1px;height:var(--swiper-centered-offset-after)}.swiper-3d .swiper-slide-shadow,.swiper-3d .swiper-slide-shadow-bottom,.swiper-3d .swiper-slide-shadow-left,.swiper-3d .swiper-slide-shadow-right,.swiper-3d .swiper-slide-shadow-top{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:10}.swiper-3d .swiper-slide-shadow{background:rgba(0,0,0,.15)}.swiper-3d .swiper-slide-shadow-left{background-image:linear-gradient(to left,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-right{background-image:linear-gradient(to right,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-top{background-image:linear-gradient(to top,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-3d .swiper-slide-shadow-bottom{background-image:linear-gradient(to bottom,rgba(0,0,0,.5),rgba(0,0,0,0))}.swiper-lazy-preloader{width:42px;height:42px;position:absolute;left:50%;top:50%;margin-left:-21px;margin-top:-21px;z-index:10;transform-origin:50%;box-sizing:border-box;border:4px solid var(--swiper-preloader-color,var(--swiper-theme-color));border-radius:50%;border-top-color:transparent}.swiper-watch-progress .swiper-slide-visible .swiper-lazy-preloader,.swiper:not(.swiper-watch-progress) .swiper-lazy-preloader{animation:swiper-preloader-spin 1s infinite linear}.swiper-lazy-preloader-white{--swiper-preloader-color:#fff}.swiper-lazy-preloader-black{--swiper-preloader-color:#000}@keyframes swiper-preloader-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}.swiper-virtual .swiper-slide{-webkit-backface-visibility:hidden;transform:translateZ(0)}.swiper-virtual.swiper-css-mode .swiper-wrapper::after{content:'';position:absolute;left:0;top:0;pointer-events:none}.swiper-virtual.swiper-css-mode.swiper-horizontal .swiper-wrapper::after{height:1px;width:var(--swiper-virtual-size)}.swiper-virtual.swiper-css-mode.swiper-vertical .swiper-wrapper::after{width:1px;height:var(--swiper-virtual-size)}:root{--swiper-navigation-size:44px}.swiper-button-next,.swiper-button-prev{position:absolute;top:var(--swiper-navigation-top-offset,50%);width:calc(var(--swiper-navigation-size)/ 44 * 27);height:var(--swiper-navigation-size);margin-top:calc(0px - (var(--swiper-navigation-size)/ 2));z-index:10;cursor:pointer;display:flex;align-items:center;justify-content:center;color:var(--swiper-navigation-color,var(--swiper-theme-color))}.swiper-button-next.swiper-button-disabled,.swiper-button-prev.swiper-button-disabled{opacity:.35;cursor:auto;pointer-events:none}.swiper-button-next.swiper-button-hidden,.swiper-button-prev.swiper-button-hidden{opacity:0;cursor:auto;pointer-events:none}.swiper-navigation-disabled .swiper-button-next,.swiper-navigation-disabled .swiper-button-prev{display:none!important}.swiper-button-next svg,.swiper-button-prev svg{width:100%;height:100%;object-fit:contain;transform-origin:center}.swiper-rtl .swiper-button-next svg,.swiper-rtl .swiper-button-prev svg{transform:rotate(180deg)}.swiper-button-prev,.swiper-rtl .swiper-button-next{left:var(--swiper-navigation-sides-offset,10px);right:auto}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-lock{display:none}.swiper-button-next:after,.swiper-button-prev:after{font-family:swiper-icons;font-size:var(--swiper-navigation-size);text-transform:none!important;letter-spacing:0;font-variant:initial;line-height:1}.swiper-button-prev:after,.swiper-rtl .swiper-button-next:after{content:'prev'}.swiper-button-next,.swiper-rtl .swiper-button-prev{right:var(--swiper-navigation-sides-offset,10px);left:auto}.swiper-button-next:after,.swiper-rtl .swiper-button-prev:after{content:'next'}.swiper-pagination{position:absolute;text-align:center;transition:.3s opacity;transform:translate3d(0,0,0);z-index:10}.swiper-pagination.swiper-pagination-hidden{opacity:0}.swiper-pagination-disabled>.swiper-pagination,.swiper-pagination.swiper-pagination-disabled{display:none!important}.swiper-horizontal>.swiper-pagination-bullets,.swiper-pagination-bullets.swiper-pagination-horizontal,.swiper-pagination-custom,.swiper-pagination-fraction{bottom:var(--swiper-pagination-bottom,8px);top:var(--swiper-pagination-top,auto);left:0;width:100%}.swiper-pagination-bullets-dynamic{overflow:hidden;font-size:0}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transform:scale(.33);position:relative}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main{transform:scale(1)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev{transform:scale(.33)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next{transform:scale(.66)}.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next{transform:scale(.33)}.swiper-pagination-bullet{width:var(--swiper-pagination-bullet-width,var(--swiper-pagination-bullet-size,8px));height:var(--swiper-pagination-bullet-height,var(--swiper-pagination-bullet-size,8px));display:inline-block;border-radius:var(--swiper-pagination-bullet-border-radius,50%);background:var(--swiper-pagination-bullet-inactive-color,#000);opacity:var(--swiper-pagination-bullet-inactive-opacity, .2)}button.swiper-pagination-bullet{border:none;margin:0;padding:0;box-shadow:none;-webkit-appearance:none;appearance:none}.swiper-pagination-clickable .swiper-pagination-bullet{cursor:pointer}.swiper-pagination-bullet:only-child{display:none!important}.swiper-pagination-bullet-active{opacity:var(--swiper-pagination-bullet-opacity, 1);background:var(--swiper-pagination-color,var(--swiper-theme-color))}.swiper-pagination-vertical.swiper-pagination-bullets,.swiper-vertical>.swiper-pagination-bullets{right:var(--swiper-pagination-right,8px);left:var(--swiper-pagination-left,auto);top:50%;transform:translate3d(0px,-50%,0)}.swiper-pagination-vertical.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets .swiper-pagination-bullet{margin:var(--swiper-pagination-bullet-vertical-gap,6px) 0;display:block}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{top:50%;transform:translateY(-50%);width:8px}.swiper-pagination-vertical.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-vertical>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{display:inline-block;transition:.2s transform,.2s top}.swiper-horizontal>.swiper-pagination-bullets .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets .swiper-pagination-bullet{margin:0 var(--swiper-pagination-bullet-horizontal-gap,4px)}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic{left:50%;transform:translateX(-50%);white-space:nowrap}.swiper-horizontal>.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet,.swiper-pagination-horizontal.swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s left}.swiper-horizontal.swiper-rtl>.swiper-pagination-bullets-dynamic .swiper-pagination-bullet{transition:.2s transform,.2s right}.swiper-pagination-fraction{color:var(--swiper-pagination-fraction-color,inherit)}.swiper-pagination-progressbar{background:var(--swiper-pagination-progressbar-bg-color,rgba(0,0,0,.25));position:absolute}.swiper-pagination-progressbar .swiper-pagination-progressbar-fill{background:var(--swiper-pagination-color,var(--swiper-theme-color));position:absolute;left:0;top:0;width:100%;height:100%;transform:scale(0);transform-origin:left top}.swiper-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill{transform-origin:right top}.swiper-horizontal>.swiper-pagination-progressbar,.swiper-pagination-progressbar.swiper-pagination-horizontal,.swiper-pagination-progressbar.swiper-pagination-vertical.swiper-pagination-progressbar-opposite,.swiper-vertical>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite{width:100%;height:var(--swiper-pagination-progressbar-size,4px);left:0;top:0}.swiper-horizontal>.swiper-pagination-progressbar.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-horizontal.swiper-pagination-progressbar-opposite,.swiper-pagination-progressbar.swiper-pagination-vertical,.swiper-vertical>.swiper-pagination-progressbar{width:var(--swiper-pagination-progressbar-size,4px);height:100%;left:0;top:0}.swiper-pagination-lock{display:none}.swiper-scrollbar{border-radius:var(--swiper-scrollbar-border-radius,10px);position:relative;touch-action:none;background:var(--swiper-scrollbar-bg-color,rgba(0,0,0,.1))}.swiper-scrollbar-disabled>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-disabled{display:none!important}.swiper-horizontal>.swiper-scrollbar,.swiper-scrollbar.swiper-scrollbar-horizontal{position:absolute;left:var(--swiper-scrollbar-sides-offset,1%);bottom:var(--swiper-scrollbar-bottom,4px);top:var(--swiper-scrollbar-top,auto);z-index:50;height:var(--swiper-scrollbar-size,4px);width:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar.swiper-scrollbar-vertical,.swiper-vertical>.swiper-scrollbar{position:absolute;left:var(--swiper-scrollbar-left,auto);right:var(--swiper-scrollbar-right,4px);top:var(--swiper-scrollbar-sides-offset,1%);z-index:50;width:var(--swiper-scrollbar-size,4px);height:calc(100% - 2 * var(--swiper-scrollbar-sides-offset,1%))}.swiper-scrollbar-drag{height:100%;width:100%;position:relative;background:var(--swiper-scrollbar-drag-bg-color,rgba(0,0,0,.5));border-radius:var(--swiper-scrollbar-border-radius,10px);left:0;top:0}.swiper-scrollbar-cursor-drag{cursor:move}.swiper-scrollbar-lock{display:none}.swiper-zoom-container{width:100%;height:100%;display:flex;justify-content:center;align-items:center;text-align:center}.swiper-zoom-container>canvas,.swiper-zoom-container>img,.swiper-zoom-container>svg{max-width:100%;max-height:100%;object-fit:contain}.swiper-slide-zoomed{cursor:move;touch-action:none}.swiper .swiper-notification{position:absolute;left:0;top:0;pointer-events:none;opacity:0;z-index:-1000}.swiper-free-mode>.swiper-wrapper{transition-timing-function:ease-out;margin:0 auto}.swiper-grid>.swiper-wrapper{flex-wrap:wrap}.swiper-grid-column>.swiper-wrapper{flex-wrap:wrap;flex-direction:column}.swiper-fade.swiper-free-mode .swiper-slide{transition-timing-function:ease-out}.swiper-fade .swiper-slide{pointer-events:none;transition-property:opacity}.swiper-fade .swiper-slide .swiper-slide{pointer-events:none}.swiper-fade .swiper-slide-active{pointer-events:auto}.swiper-fade .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper.swiper-cube{overflow:visible}.swiper-cube .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;visibility:hidden;transform-origin:0 0;width:100%;height:100%}.swiper-cube .swiper-slide .swiper-slide{pointer-events:none}.swiper-cube.swiper-rtl .swiper-slide{transform-origin:100% 0}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-cube .swiper-slide-active,.swiper-cube .swiper-slide-next,.swiper-cube .swiper-slide-prev{pointer-events:auto;visibility:visible}.swiper-cube .swiper-cube-shadow{position:absolute;left:0;bottom:0px;width:100%;height:100%;opacity:.6;z-index:0}.swiper-cube .swiper-cube-shadow:before{content:'';background:#000;position:absolute;left:0;top:0;bottom:0;right:0;filter:blur(50px)}.swiper-cube .swiper-slide-next+.swiper-slide{pointer-events:auto;visibility:visible}.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-bottom,.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-left,.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-right,.swiper-cube .swiper-slide-shadow-cube.swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper.swiper-flip{overflow:visible}.swiper-flip .swiper-slide{pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1}.swiper-flip .swiper-slide .swiper-slide{pointer-events:none}.swiper-flip .swiper-slide-active,.swiper-flip .swiper-slide-active .swiper-slide-active{pointer-events:auto}.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-bottom,.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-left,.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-right,.swiper-flip .swiper-slide-shadow-flip.swiper-slide-shadow-top{z-index:0;-webkit-backface-visibility:hidden;backface-visibility:hidden}.swiper-creative .swiper-slide{-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;transition-property:transform,opacity,height}.swiper.swiper-cards{overflow:visible}.swiper-cards .swiper-slide{transform-origin:center bottom;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden}taro-swiper-core{height:150px;display:block}taro-swiper-core .swiper-container{height:100%;position:relative;overflow:visible}";
var __classPrivateFieldGet4 = function(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet4 = function(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var _Swiper_id;
var _Swiper_source;
var _Swiper_swiperResetting;
var _Swiper_domChangeByOutSide;
var _Swiper_lastSwiperActiveIndex;
var INSTANCE_ID = 0;
var ONE_ADDITIONAL_SLIDES_THRESHOLD = 5;
var TWO_ADDITIONAL_SLIDES_THRESHOLD = 7;
var Swiper2 = proxyCustomElement(class extends H {
    watchCurrent(newVal) {
        if (this.currentItemId || !this.isWillLoadCalled || !this.swiper) return;
        const n = parseInt(newVal, 10);
        if (isNaN(n) || n === this.swiper.realIndex) return;
        __classPrivateFieldSet4(this, _Swiper_source, "", "f");
        if (this.circular) {
            this.swiper.slideToLoop(n);
            this.autoplay && this.swiper.autoplay.pause();
            this.swiper.loopFix();
            this.autoplay && this.swiper.autoplay.start();
        } else {
            this.swiper.slideTo(n);
        }
    }
    watchCurrentItemId(newVal) {
        if (!this.swiperWrapper || !this.isWillLoadCalled) return;
        let itemIdIndex = 0;
        this.getSlidersList().forEach((swiperItem, index)=>{
            const itemId = swiperItem.getAttribute("item-id");
            if (itemId === newVal) {
                if (this.circular) {
                    itemIdIndex = Number(swiperItem.getAttribute("data-swiper-slide-index"));
                } else {
                    itemIdIndex = index;
                }
            }
        });
        if (itemIdIndex === this.swiper.realIndex) return;
        __classPrivateFieldSet4(this, _Swiper_source, "", "f");
        if (this.circular) {
            this.swiper.slideToLoop(itemIdIndex);
            this.swiper.loopFix();
            this.autoplay && this.swiper.autoplay.start();
        } else {
            this.swiper.slideTo(itemIdIndex);
        }
    }
    watchAutoplay(newVal) {
        if (!this.isWillLoadCalled || !this.swiper) return;
        const swiperAutoplay = this.swiper.autoplay;
        if (swiperAutoplay) {
            if (swiperAutoplay.running === newVal) return;
            if (newVal) {
                if (this.swiper.params && typeof this.swiper.params.autoplay === "object") {
                    if (this.swiper.params.autoplay.disableOnInteraction === true) {
                        this.swiper.params.autoplay.disableOnInteraction = false;
                    }
                    this.swiper.params.autoplay.delay = this.interval;
                }
                swiperAutoplay.start();
            } else {
                swiperAutoplay.stop();
            }
        }
    }
    watchDuration(newVal) {
        if (!this.swiper || !this.isWillLoadCalled) return;
        this.swiper.params.speed = newVal;
    }
    watchInterval(newVal) {
        if (!this.swiper || !this.isWillLoadCalled) return;
        if (typeof this.swiper.params.autoplay === "object") {
            this.swiper.params.autoplay.delay = newVal;
        }
    }
    watchSwiperWrapper(newVal) {
        if (!this.isWillLoadCalled || !this.swiper) return;
        if (!newVal) return;
        const beforeDomOperation = ()=>{
            __classPrivateFieldSet4(this, _Swiper_domChangeByOutSide, true, "f");
            this.swiper.loopDestroy();
            this.swiper.params.loop = false;
        };
        this.el.appendChild = (newChild)=>{
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, true, "f");
            if (!__classPrivateFieldGet4(this, _Swiper_domChangeByOutSide, "f") && this.circular) {
                beforeDomOperation();
            }
            return newVal.appendChild(newChild);
        };
        this.el.insertBefore = (newChild, refChild)=>{
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, true, "f");
            if (!__classPrivateFieldGet4(this, _Swiper_domChangeByOutSide, "f") && this.circular) {
                beforeDomOperation();
            }
            return newVal.insertBefore(newChild, refChild);
        };
        this.el.replaceChild = (newChild, oldChild)=>{
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, true, "f");
            if (!__classPrivateFieldGet4(this, _Swiper_domChangeByOutSide, "f") && this.circular) {
                beforeDomOperation();
            }
            return newVal.replaceChild(newChild, oldChild);
        };
        this.el.removeChild = (oldChild)=>{
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, true, "f");
            if (!__classPrivateFieldGet4(this, _Swiper_domChangeByOutSide, "f") && this.circular) {
                beforeDomOperation();
            }
            return newVal.removeChild(oldChild);
        };
    }
    watchCircular() {
        if (!this.swiper || !this.isWillLoadCalled) return;
        this.reset();
    }
    watchDisplayMultipleItems() {
        if (!this.swiper || !this.isWillLoadCalled) return;
        this.reset();
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidLoad() {
        this.handleInit();
        if (!this.swiper || !this.swiperWrapper) return;
        this.observer = new MutationObserver(this.handleSwiperSizeDebounce);
        this.observer.observe(this.swiperWrapper, {
            childList: true
        });
    }
    disconnectedCallback() {
        var _a;
        (_a = this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();
    }
    handleInit(reset = false) {
        const { autoplay, circular, current, currentItemId, displayMultipleItems, duration, interval, effectsProps, vertical } = this;
        let initialSlide = current;
        if (reset) {
            initialSlide = __classPrivateFieldGet4(this, _Swiper_lastSwiperActiveIndex, "f");
        } else {
            if (currentItemId) {
                let itemIdIndex = 0;
                this.getSlidersList().forEach((swiperItem, index)=>{
                    if (swiperItem.itemId && swiperItem.itemId === currentItemId) {
                        itemIdIndex = index;
                    }
                });
                initialSlide = itemIdIndex;
            }
        }
        const loopAdditionalSlides = this.getLoopAdditionalSlides();
        const centeredSlides = displayMultipleItems === 1 && this.getNeedFixLoop();
        const slidesPerView = displayMultipleItems;
        const that = this;
        const options3 = Object.assign(Object.assign({
            pagination: {
                el: `.taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination`
            },
            direction: vertical ? "vertical" : "horizontal",
            loop: circular,
            slidesPerView,
            initialSlide,
            loopAdditionalSlides,
            speed: duration,
            observeParents: true,
            observer: true,
            centeredSlides,
            zoom: this.zoom,
            nested: true,
            touchReleaseOnEdges: true,
            threshold: 0
        }, effectsProps), {
            on: {
                transitionEnd (e) {
                    if (__classPrivateFieldGet4(that, _Swiper_swiperResetting, "f") || __classPrivateFieldGet4(that, _Swiper_lastSwiperActiveIndex, "f") === this.realIndex) return;
                    __classPrivateFieldSet4(that, _Swiper_lastSwiperActiveIndex, this.realIndex, "f");
                    that.getNeedFixLoop() && e.loopFix();
                    that.autoplay && e.autoplay.start();
                    const currentItemId2 = that.getCurrentItemId(e);
                    that.onAnimationFinish.emit({
                        current: this.realIndex,
                        source: __classPrivateFieldGet4(that, _Swiper_source, "f"),
                        currentItemId: currentItemId2
                    });
                    __classPrivateFieldSet4(that, _Swiper_source, "autoplay", "f");
                },
                touchMove () {
                    __classPrivateFieldSet4(that, _Swiper_source, "touch", "f");
                },
                slideChange (e) {
                    if (__classPrivateFieldGet4(that, _Swiper_swiperResetting, "f") || __classPrivateFieldGet4(that, _Swiper_lastSwiperActiveIndex, "f") === this.realIndex) return;
                    const currentItemId2 = that.getCurrentItemId(e);
                    that.onChange.emit({
                        current: this.realIndex,
                        source: __classPrivateFieldGet4(that, _Swiper_source, "f"),
                        currentItemId: currentItemId2
                    });
                },
                init: (e)=>{
                    that.getNeedFixLoop() && e.loopFix();
                    that.autoplay && e.autoplay.start();
                },
                touchEnd: (e)=>{
                    __classPrivateFieldSet4(that, _Swiper_source, "touch", "f");
                    that.autoplay && e.autoplay.start();
                },
                touchStart: (e)=>{
                    __classPrivateFieldSet4(that, _Swiper_source, "touch", "f");
                    that.autoplay && e.autoplay.pause();
                },
                autoplay (e) {
                    e.animating = false;
                    __classPrivateFieldSet4(that, _Swiper_source, "autoplay", "f");
                }
            }
        });
        if (autoplay) {
            options3.autoplay = {
                delay: interval,
                disableOnInteraction: false
            };
        }
        this.swiper = new Swiper(`.taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container`, options3);
        if (this.getNeedFixLoop()) {
            const minTranslate2 = this.swiper.minTranslate.bind(this.swiper);
            const maxTranslate2 = this.swiper.maxTranslate.bind(this.swiper);
            if (centeredSlides && this.getSlidersList().length < 4) {
                this.swiper.minTranslate = ()=>minTranslate2() + this.parseMargin()[1];
                this.swiper.maxTranslate = ()=>maxTranslate2() - this.parseMargin()[0];
            } else {
                this.swiper.minTranslate = ()=>minTranslate2() - this.parseMargin()[0];
                this.swiper.maxTranslate = ()=>maxTranslate2() + this.parseMargin()[1];
            }
        }
        this.swiperWrapper = this.swiper.wrapperEl;
    }
    // Note: loop  additionalSlides  loopFix  additionalSlides  additionalSlides  swiper-item  bug
    //  swiper-item  5  additionalSlides 5  7  1  additionalSlides 7  2  additionalSlides
    getLoopAdditionalSlides() {
        const slidersLength = this.getSlidersList().length;
        if (!this.el || !this.getNeedFixLoop() || slidersLength < ONE_ADDITIONAL_SLIDES_THRESHOLD) return 0;
        if (slidersLength <= TWO_ADDITIONAL_SLIDES_THRESHOLD) return 1;
        return 2;
    }
    getCurrentItemId(swiper) {
        const slides = swiper.slides;
        const activeIndex = swiper.activeIndex;
        const currentSlide = slides[activeIndex];
        return currentSlide.getAttribute("item-id");
    }
    render() {
        const { vertical, indicatorDots, indicatorColor, indicatorActiveColor } = this;
        const [pM, nM] = this.parseMargin();
        const swiperContainerStyleList = [
            "overflow: visible;",
            vertical ? `margin-top: ${pM}px; margin-bottom: ${nM}px;` : `margin-right: ${nM}px; margin-left: ${pM}px;`,
            this.full ? "height: 100%;" : ""
        ];
        const swiperPaginationStyleList = [
            indicatorDots ? "opacity: 1;" : "display: none;",
            "font-size: 0;"
        ];
        const hostStyle = {
            overflow: "hidden"
        };
        if (this.full) {
            hostStyle.height = "100%";
        }
        return h(Host, {
            class: `taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")}`,
            style: hostStyle
        }, h("div", {
            class: "swiper-container"
        }, h("style", {
            type: "text/css"
        }, `
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet { background: ${indicatorColor} }
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination > .swiper-pagination-bullet-active { background: ${indicatorActiveColor} }
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container { ${swiperContainerStyleList.join("")} }
              .taro-swiper-${__classPrivateFieldGet4(this, _Swiper_id, "f")} > .swiper-container > .swiper-pagination { ${swiperPaginationStyleList.join("")} }
            `), h("div", {
            class: "swiper-wrapper"
        }, h("slot", null)), h("div", {
            class: "swiper-pagination"
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "current": [
                "watchCurrent"
            ],
            "currentItemId": [
                "watchCurrentItemId"
            ],
            "autoplay": [
                "watchAutoplay"
            ],
            "duration": [
                "watchDuration"
            ],
            "interval": [
                "watchInterval"
            ],
            "swiperWrapper": [
                "watchSwiperWrapper"
            ],
            "circular": [
                "watchCircular"
            ],
            "displayMultipleItems": [
                "watchDisplayMultipleItems"
            ]
        };
    }
    static get style() {
        return indexCss17;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.onAnimationFinish = createEvent(this, "animationfinish", 7);
        _Swiper_id.set(this, INSTANCE_ID++);
        _Swiper_source.set(this, "autoplay");
        _Swiper_swiperResetting.set(this, false);
        _Swiper_domChangeByOutSide.set(this, false);
        _Swiper_lastSwiperActiveIndex.set(this, 0);
        this.handleSwiperSizeDebounce = debounce2(()=>{
            if (!this.swiper || !this.isWillLoadCalled) return;
            if (this.circular) {
                if (__classPrivateFieldGet4(this, _Swiper_domChangeByOutSide, "f")) {
                    this.reset();
                    __classPrivateFieldSet4(this, _Swiper_domChangeByOutSide, false, "f");
                    __classPrivateFieldSet4(this, _Swiper_swiperResetting, false, "f");
                }
            } else {
                this.swiper.update();
                __classPrivateFieldSet4(this, _Swiper_swiperResetting, false, "f");
            }
        }, 50);
        this.reset = ()=>{
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, true, "f");
            __classPrivateFieldSet4(this, _Swiper_lastSwiperActiveIndex, this.swiper.realIndex, "f");
            this.swiper.destroy();
            this.handleInit(true);
            __classPrivateFieldSet4(this, _Swiper_swiperResetting, false, "f");
        };
        this.getSlidersList = ()=>this.el.querySelectorAll("taro-swiper-item-core:not(.swiper-slide-duplicate)") || [];
        this.getNeedFixLoop = ()=>{
            const margins = this.parseMargin();
            const hasMargin = margins.filter(Boolean).length > 0;
            return this.circular && hasMargin;
        };
        this.parseMargin = ()=>{
            const [, previousMargin] = /^(\d+)px/.exec(this.previousMargin) || [];
            const [, nextMargin] = /^(\d+)px/.exec(this.nextMargin) || [];
            return [
                parseInt(previousMargin) || 0,
                parseInt(nextMargin) || 0
            ];
        };
        this.swiperWrapper = void 0;
        this.swiper = void 0;
        this.isWillLoadCalled = false;
        this.indicatorDots = false;
        this.indicatorColor = "rgba(0, 0, 0, .3)";
        this.indicatorActiveColor = "#000000";
        this.autoplay = false;
        this.current = 0;
        this.currentItemId = "";
        this.interval = 5e3;
        this.duration = 500;
        this.circular = false;
        this.vertical = false;
        this.previousMargin = "0px";
        this.nextMargin = "0px";
        this.displayMultipleItems = 1;
        this.full = false;
        this.zoom = false;
        this.effectsProps = {};
        this.observer = void 0;
    }
}, [
    4,
    "taro-swiper-core",
    {
        "indicatorDots": [
            4,
            "indicator-dots"
        ],
        "indicatorColor": [
            1,
            "indicator-color"
        ],
        "indicatorActiveColor": [
            1,
            "indicator-active-color"
        ],
        "autoplay": [
            4
        ],
        "current": [
            2
        ],
        "currentItemId": [
            1,
            "current-item-id"
        ],
        "interval": [
            2
        ],
        "duration": [
            2
        ],
        "circular": [
            4
        ],
        "vertical": [
            4
        ],
        "previousMargin": [
            1,
            "previous-margin"
        ],
        "nextMargin": [
            1,
            "next-margin"
        ],
        "displayMultipleItems": [
            2,
            "display-multiple-items"
        ],
        "full": [
            4
        ],
        "zoom": [
            4
        ],
        "effectsProps": [
            16
        ],
        "swiperWrapper": [
            32
        ],
        "swiper": [
            32
        ],
        "isWillLoadCalled": [
            32
        ],
        "observer": [
            32
        ]
    }
]);
_Swiper_id = /* @__PURE__ */ new WeakMap(), _Swiper_source = /* @__PURE__ */ new WeakMap(), _Swiper_swiperResetting = /* @__PURE__ */ new WeakMap(), _Swiper_domChangeByOutSide = /* @__PURE__ */ new WeakMap(), _Swiper_lastSwiperActiveIndex = /* @__PURE__ */ new WeakMap();
function defineCustomElement$182() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-swiper-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-swiper-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Swiper2);
                }
                break;
        }
    });
}
var defineCustomElement = defineCustomElement$182;
// node_modules/@tarojs/components/dist/components/taro-swiper-item-core.js
var SwiperItem = proxyCustomElement(class extends H {
    //Note:  swiper.js  class  swiper-slide connectedCallback  swiper-slide 
    connectedCallback() {
        this.el.className = classnames(this.el.className, "swiper-slide");
    }
    componentDidRender() {
        handleStencilNodes(this.el);
    }
    render() {
        return h(Host, {
            "item-id": this.itemId
        }, h("slot", null));
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.itemId = void 0;
    }
}, [
    4,
    "taro-swiper-item-core",
    {
        "itemId": [
            1,
            "item-id"
        ]
    }
]);
function defineCustomElement$183() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-swiper-item-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-swiper-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, SwiperItem);
                }
                break;
        }
    });
}
var defineCustomElement2 = defineCustomElement$183;
// node_modules/@tarojs/components/dist/components/taro-switch-core.js
var indexCss18 = '.weui-cell_switch{padding-top:6.5px;padding-bottom:6.5px}.weui-switch{appearance:none}.weui-switch,.weui-switch-cp__box{box-sizing:border-box;background-color:#dfdfdf;border:1px solid #dfdfdf;border-radius:16px;outline:0;width:52px;height:32px;transition:background-color .1s,border .1s;position:relative}.weui-switch:before,.weui-switch-cp__box:before{content:" ";background-color:#fdfdfd;border-radius:15px;width:50px;height:30px;transition:transform .35s cubic-bezier(.45,1,.4,1);position:absolute;top:0;left:0}.weui-switch:after,.weui-switch-cp__box:after{content:" ";background-color:#fff;border-radius:15px;width:30px;height:30px;transition:transform .35s cubic-bezier(.4,.4,.25,1.35);position:absolute;top:0;left:0;box-shadow:0 1px 3px rgba(0,0,0,.4)}.weui-switch:checked,.weui-switch-cp__input:checked~.weui-switch-cp__box{background-color:#04be02;border-color:#04be02}.weui-switch:checked:before,.weui-switch-cp__input:checked~.weui-switch-cp__box:before{transform:scale(0)}.weui-switch:checked:after,.weui-switch-cp__input:checked~.weui-switch-cp__box:after{transform:translate(20px)}.weui-switch-cp__input{position:absolute;left:-9999px}.weui-switch-cp__box{display:block}taro-switch-core{width:52px;height:32px;display:inline-block}taro-switch-core .weui-switch{width:100%;height:100%;display:block}';
var Switch = proxyCustomElement(class extends H {
    function(newValue) {
        if (!this.isWillLoadCalled) return;
        if (this.inputRef.checked !== newValue) {
            this.inputRef.checked = newValue;
        }
    }
    componentWillLoad() {
        this.isWillLoadCalled = true;
    }
    componentDidLoad() {
        Object.defineProperty(this.el, "value", {
            get: ()=>this.checked,
            configurable: true
        });
    }
    render() {
        const { type, color, checked, name, disabled, nativeProps } = this;
        const style = checked ? {
            borderColor: color || "04BE02",
            backgroundColor: color || "04BE02"
        } : {};
        return h("input", Object.assign({
            ref: (input)=>{
                this.inputRef = input;
            },
            type: "checkbox",
            class: `weui-${type}`,
            style,
            checked,
            name,
            disabled,
            onChange: this.switchChange
        }, nativeProps));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "checked": [
                "function"
            ]
        };
    }
    static get style() {
        return indexCss18;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onChange = createEvent(this, "change", 7);
        this.switchChange = (e)=>{
            e.stopPropagation();
            const value = e.target.checked;
            this.checked = value;
            this.onChange.emit({
                value
            });
        };
        this.type = "switch";
        this.checked = false;
        this.color = "#04BE02";
        this.name = void 0;
        this.disabled = false;
        this.nativeProps = {};
        this.isWillLoadCalled = false;
    }
}, [
    0,
    "taro-switch-core",
    {
        "type": [
            1
        ],
        "checked": [
            1028
        ],
        "color": [
            1
        ],
        "name": [
            1
        ],
        "disabled": [
            4
        ],
        "nativeProps": [
            16
        ],
        "isWillLoadCalled": [
            32
        ]
    }
]);
function defineCustomElement$184() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-switch-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-switch-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Switch);
                }
                break;
        }
    });
}
var defineCustomElement86 = defineCustomElement$184;
// node_modules/@tarojs/components/dist/components/taro-tab-item-core.js
var TabItem = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("TabItem", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-tab-item-core"
]);
function defineCustomElement$185() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-tab-item-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-tab-item-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, TabItem);
                }
                break;
        }
    });
}
var defineCustomElement87 = defineCustomElement$185;
// node_modules/resolve-pathname/esm/resolve-pathname.js
function isAbsolute(pathname) {
    return pathname.charAt(0) === "/";
}
function spliceOne(list2, index) {
    for(var i2 = index, k = i2 + 1, n = list2.length; k < n; i2 += 1, k += 1){
        list2[i2] = list2[k];
    }
    list2.pop();
}
function resolvePathname(to, from) {
    if (from === void 0) from = "";
    var toParts = to && to.split("/") || [];
    var fromParts = from && from.split("/") || [];
    var isToAbs = to && isAbsolute(to);
    var isFromAbs = from && isAbsolute(from);
    var mustEndAbs = isToAbs || isFromAbs;
    if (to && isAbsolute(to)) {
        fromParts = toParts;
    } else if (toParts.length) {
        fromParts.pop();
        fromParts = fromParts.concat(toParts);
    }
    if (!fromParts.length) return "/";
    var hasTrailingSlash;
    if (fromParts.length) {
        var last = fromParts[fromParts.length - 1];
        hasTrailingSlash = last === "." || last === ".." || last === "";
    } else {
        hasTrailingSlash = false;
    }
    var up = 0;
    for(var i2 = fromParts.length; i2 >= 0; i2--){
        var part = fromParts[i2];
        if (part === ".") {
            spliceOne(fromParts, i2);
        } else if (part === "..") {
            spliceOne(fromParts, i2);
            up++;
        } else if (up) {
            spliceOne(fromParts, i2);
            up--;
        }
    }
    if (!mustEndAbs) for(; up--; up)fromParts.unshift("..");
    if (mustEndAbs && fromParts[0] !== "" && (!fromParts[0] || !isAbsolute(fromParts[0]))) fromParts.unshift("");
    var result = fromParts.join("/");
    if (hasTrailingSlash && result.substr(-1) !== "/") result += "/";
    return result;
}
var resolve_pathname_default = resolvePathname;
// node_modules/@tarojs/components/dist/components/taro-tabbar.js
var splitUrl = (_url)=>{
    let url = _url || "";
    let pos;
    const res = {
        path: null,
        query: null,
        fragment: null
    };
    pos = url.indexOf("#");
    if (pos > -1) {
        res.fragment = url.substring(pos + 1);
        url = url.substring(0, pos);
    }
    pos = url.indexOf("?");
    if (pos > -1) {
        res.query = url.substring(pos + 1);
        url = url.substring(0, pos);
    }
    res.path = url;
    return res;
};
var TabbarItem = ({ index, isSelected = false, textColor, iconPath, badgeText, showRedDot = false, pagePath, text, onSelect })=>{
    const className = classnames("weui-tabbar__item", {
        "weui-bar__item_on": isSelected
    });
    const badgeStyle = {
        position: "absolute",
        top: "-2px",
        right: "-13px"
    };
    const dotStyle = {
        position: "absolute",
        top: "0",
        right: "-6px"
    };
    function onClick2() {
        const page = taro.getCurrentPages().shift();
        if (typeof (page === null || page === void 0 ? void 0 : page.onTabItemTap) === "function" && isVisible(this)) {
            page.onTabItemTap({
                index,
                pagePath,
                text
            });
        }
        onSelect(index);
    }
    return h("a", {
        key: index,
        href: "javascript:;",
        class: className,
        onClick: onClick2
    }, h("span", {
        style: {
            display: "inline-block",
            position: "relative"
        }
    }, h("img", {
        src: iconPath,
        alt: "",
        class: "weui-tabbar__icon"
    }), !!badgeText && h("span", {
        class: "weui-badge taro-tabbar-badge",
        style: badgeStyle
    }, badgeText), showRedDot && h("span", {
        class: "weui-badge weui-badge_dot",
        style: dotStyle
    })), h("p", {
        class: "weui-tabbar__label",
        style: {
            color: textColor
        }
    }, text));
};
var indexCss19 = '.weui-tabbar{z-index:500;background-color:#f7f7fa;align-items:center;width:100%;display:flex;position:absolute;bottom:0}.weui-tabbar:before{content:" ";color:#c0bfc4;transform-origin:0 0;border-top:1px solid #c0bfc4;height:1px;position:absolute;top:0;left:0;right:0;transform:scaleY(.5)}.weui-tabbar__item{padding:5px 0;padding-bottom:constant(safe-area-inset-bottom);padding-bottom:env(safe-area-inset-bottom);color:#999;text-align:center;-webkit-tap-highlight-color:transparent;flex:1;font-size:0;display:block}.weui-tabbar__item.weui-bar__item_on .weui-tabbar__icon,.weui-tabbar__item.weui-bar__item_on .weui-tabbar__icon>i,.weui-tabbar__item.weui-bar__item_on .weui-tabbar__label{color:#09bb07}.weui-tabbar__icon{width:27px;height:27px;display:inline-block}.weui-tabbar__icon img{width:100%;height:100%}i.weui-tabbar__icon,.weui-tabbar__icon>i{color:#999;font-size:24px}.weui-tabbar__label{text-align:center;color:#999;font-size:10px;line-height:1.8}.weui-badge{color:#fff;text-align:center;vertical-align:middle;background-color:#f43530;border-radius:18px;min-width:8px;padding:.15em .4em;font-size:12px;line-height:1.2;display:inline-block}.weui-badge_dot{min-width:0;padding:.4em}:root{--taro-tabbar-height:50px}#app{height:100%}.taro-tabbar__border-white:before{border-top-color:#fff!important}.taro-tabbar__container{flex-direction:column;height:100%;display:flex;overflow:hidden}.taro-tabbar__panel{-webkit-overflow-scrolling:auto;flex:1;position:relative;overflow:auto}.taro-tabbar__tabbar{width:100%;height:var(--taro-tabbar-height);transition:bottom .2s,top .2s;position:relative}.taro-tabbar__tabbar-top{top:0}.taro-tabbar__tabbar-bottom{margin-bottom:constant(safe-area-inset-bottom);margin-bottom:env(safe-area-inset-bottom);bottom:0}.taro-tabbar__tabbar-hide{display:none}.taro-tabbar__tabbar-slideout{flex:0 0;top:-52px}.taro-tabbar__panel+.taro-tabbar__tabbar-slideout{top:auto;bottom:-52px}';
var STATUS_SHOW = 0;
var STATUS_HIDE = 1;
var STATUS_SLIDEOUT = 2;
var basicTabBarClassName = "taro-tabbar__tabbar";
var hideTabBarClassName = "taro-tabbar__tabbar-hide";
var hideTabBarWithAnimationClassName = "taro-tabbar__tabbar-slideout";
var Tabbar = proxyCustomElement(class extends H {
    componentWillLoad() {
        var _a, _b;
        const list2 = ((_a = this.conf) === null || _a === void 0 ? void 0 : _a.list) || [];
        const customRoutes = ((_b = this.conf) === null || _b === void 0 ? void 0 : _b.customRoutes) || {};
        if (Object.prototype.toString.call(list2) !== "[object Array]" || list2.length < 2 || list2.length > 5) {
            throw new Error("tabBar \u914D\u7F6E\u9519\u8BEF");
        }
        this.homePage = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(this.conf.homePage);
        for(let key in customRoutes){
            const path = customRoutes[key];
            key = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(key);
            if (typeof path === "string") {
                this.customRoutes.push([
                    key,
                    (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(path)
                ]);
            } else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.customRoutes.push(...path.map((p)=>[
                        key,
                        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(p)
                    ]));
            }
        }
        list2.forEach((item)=>{
            if (item.pagePath.indexOf("/") !== 0) {
                item.pagePath = "/" + item.pagePath;
            }
        });
        this.list = list2;
        this.borderStyle = this.conf.borderStyle;
        this.backgroundColor = this.conf.backgroundColor;
        this.color = this.conf.color;
        this.selectedColor = this.conf.selectedColor;
    }
    getCurrentUrl() {
        const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getCurrentPage)(this.conf.mode, this.conf.basename);
        return decodeURI(routePath === "/" ? this.homePage : routePath);
    }
    bindEvent() {
        taro.eventCenter.on("__taroRouterChange", this.routerChangeHandler);
        taro.eventCenter.on("__taroSwitchTab", this.switchTabHandler);
        taro.eventCenter.on("__taroSetTabBarBadge", this.setTabBarBadgeHandler);
        taro.eventCenter.on("__taroRemoveTabBarBadge", this.removeTabBarBadgeHandler);
        taro.eventCenter.on("__taroShowTabBarRedDotHandler", this.showTabBarRedDotHandler);
        taro.eventCenter.on("__taroHideTabBarRedDotHandler", this.hideTabBarRedDotHandler);
        taro.eventCenter.on("__taroShowTabBar", this.showTabBarHandler);
        taro.eventCenter.on("__taroHideTabBar", this.hideTabBarHandler);
        taro.eventCenter.on("__taroSetTabBarStyle", this.setTabBarStyleHandler);
        taro.eventCenter.on("__taroSetTabBarItem", this.setTabBarItemHandler);
    }
    removeEvent() {
        taro.eventCenter.off("__taroRouterChange", this.routerChangeHandler);
        taro.eventCenter.off("__taroSwitchTab", this.switchTabHandler);
        taro.eventCenter.off("__taroSetTabBarBadge", this.setTabBarBadgeHandler);
        taro.eventCenter.off("__taroRemoveTabBarBadge", this.removeTabBarBadgeHandler);
        taro.eventCenter.off("__taroShowTabBarRedDotHandler", this.showTabBarRedDotHandler);
        taro.eventCenter.off("__taroHideTabBarRedDotHandler", this.hideTabBarRedDotHandler);
        taro.eventCenter.off("__taroShowTabBar", this.showTabBarHandler);
        taro.eventCenter.off("__taroHideTabBar", this.hideTabBarHandler);
        taro.eventCenter.off("__taroSetTabBarStyle", this.setTabBarStyleHandler);
        taro.eventCenter.off("__taroSetTabBarItem", this.setTabBarItemHandler);
    }
    componentDidLoad() {
        this.tabbarPos = this.tabbar.nextElementSibling ? "top" : "bottom";
        this.bindEvent();
        this.routerChangeHandler();
    }
    disconnectedCallback() {
        this.removeEvent();
    }
    render() {
        const { tabbarPos = "bottom" } = this;
        const status2 = this.status;
        const containerCls = classnames("weui-tabbar", {
            [`taro-tabbar__border-${this.borderStyle || "black"}`]: true
        });
        const shouldHideTabBar = this.selectedIndex === -1 || status2 === STATUS_HIDE;
        const shouldSlideout = status2 === STATUS_SLIDEOUT;
        return h(Host, {
            class: classnames(basicTabBarClassName, `${basicTabBarClassName}-${tabbarPos}`, {
                [hideTabBarClassName]: shouldHideTabBar,
                [hideTabBarWithAnimationClassName]: shouldSlideout
            })
        }, h("div", {
            class: containerCls,
            style: {
                backgroundColor: this.backgroundColor || "",
                height: "inherit"
            }
        }, this.list.map((item, index)=>{
            const isSelected = this.selectedIndex === index;
            let textColor;
            let iconPath;
            if (isSelected) {
                textColor = this.selectedColor || "";
                iconPath = item.selectedIconPath;
            } else {
                textColor = this.color || "";
                iconPath = item.iconPath;
            }
            return h(TabbarItem, {
                index,
                onSelect: this.switchTab.bind(this),
                isSelected,
                textColor,
                iconPath,
                pagePath: item.pagePath,
                text: item.text,
                badgeText: item.badgeText,
                showRedDot: item.showRedDot
            });
        })));
    }
    get tabbar() {
        return this;
    }
    static get style() {
        return indexCss19;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.homePage = "";
        this.customRoutes = [];
        this.tabbarPos = "bottom";
        this.getOriginUrl = (url)=>{
            const customRoute = this.customRoutes.filter(([, customUrl])=>{
                const pathA = splitUrl(customUrl).path;
                const pathB = splitUrl(url).path;
                return pathA === pathB;
            });
            return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripSuffix)(customRoute.length ? customRoute[0][0] : url, ".html");
        };
        this.getSelectedIndex = (url)=>{
            let foundIndex = -1;
            this.list.forEach(({ pagePath }, idx)=>{
                const pathA = splitUrl(url).path;
                const pathB = splitUrl(pagePath).path;
                if (pathA === pathB) {
                    foundIndex = idx;
                }
            });
            return foundIndex;
        };
        this.switchTab = (index)=>{
            this.selectedIndex = index;
            taro.switchTab({
                url: this.list[index].pagePath
            });
        };
        this.switchTabHandler = ({ url, successHandler, errorHandler })=>{
            const currentUrl = this.getOriginUrl(this.getCurrentUrl() || this.homePage);
            const nextTab = resolve_pathname_default(url, currentUrl);
            const foundIndex = this.getSelectedIndex(nextTab);
            if (foundIndex > -1) {
                this.switchTab(foundIndex);
                successHandler({
                    errMsg: "switchTab:ok"
                });
            } else {
                errorHandler({
                    errMsg: `switchTab:fail page "${nextTab}" is not found`
                });
            }
        };
        this.routerChangeHandler = (options3)=>{
            var _a;
            const to = (_a = options3 === null || options3 === void 0 ? void 0 : options3.toLocation) === null || _a === void 0 ? void 0 : _a.path;
            let currentPage;
            if (typeof to === "string") {
                const routerBasename = this.conf.basename || "/";
                currentPage = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(to || this.homePage), routerBasename) || "/";
            } else {
                currentPage = this.getCurrentUrl();
            }
            this.selectedIndex = this.getSelectedIndex(this.getOriginUrl(currentPage));
        };
        this.setTabBarBadgeHandler = ({ index, text, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index in list2) {
                list2[index].showRedDot = false;
                list2[index].badgeText = text;
                successHandler({
                    errMsg: "setTabBarBadge:ok"
                });
            } else {
                errorHandler({
                    errMsg: "setTabBarBadge:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.removeTabBarBadgeHandler = ({ index, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index in list2) {
                list2[index].badgeText = null;
                list2[index].badgeText = null;
                successHandler({
                    errMsg: "removeTabBarBadge:ok"
                });
            } else {
                errorHandler({
                    errMsg: "removeTabBarBadge:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.showTabBarRedDotHandler = ({ index, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index in list2) {
                list2[index].badgeText = null;
                list2[index].showRedDot = true;
                successHandler({
                    errMsg: "showTabBarRedDot:ok"
                });
            } else {
                errorHandler({
                    errMsg: "showTabBarRedDot:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.hideTabBarRedDotHandler = ({ index, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index in list2) {
                list2[index].showRedDot = false;
                successHandler({
                    errMsg: "hideTabBarRedDot:ok"
                });
            } else {
                errorHandler({
                    errMsg: "hideTabBarRedDot:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.showTabBarHandler = ({ successHandler })=>{
            this.status = STATUS_SHOW;
            successHandler({
                errMsg: "showTabBar:ok"
            });
        };
        this.hideTabBarHandler = ({ animation, successHandler })=>{
            this.status = animation ? STATUS_SLIDEOUT : STATUS_HIDE;
            successHandler({
                errMsg: "hideTabBar:ok"
            });
        };
        this.setTabBarStyleHandler = ({ color, selectedColor, backgroundColor, borderStyle, successHandler })=>{
            if (backgroundColor) this.backgroundColor = backgroundColor;
            if (borderStyle) this.borderStyle = borderStyle;
            if (color) this.color = color;
            if (selectedColor) this.selectedColor = selectedColor;
            successHandler({
                errMsg: "setTabBarStyle:ok"
            });
        };
        this.setTabBarItemHandler = ({ index, iconPath, selectedIconPath, text, successHandler, errorHandler })=>{
            const list2 = [
                ...this.list
            ];
            if (index in list2) {
                if (iconPath) list2[index].iconPath = iconPath;
                if (selectedIconPath) list2[index].selectedIconPath = selectedIconPath;
                if (text) list2[index].text = text;
                successHandler({
                    errMsg: "setTabBarItem:ok"
                });
            } else {
                errorHandler({
                    errMsg: "setTabBarItem:fail tabbar item not found"
                });
            }
            this.list = list2;
        };
        this.conf = void 0;
        this.list = void 0;
        this.borderStyle = void 0;
        this.backgroundColor = void 0;
        this.color = void 0;
        this.selectedColor = void 0;
        this.selectedIndex = -1;
        this.status = STATUS_SHOW;
    }
}, [
    0,
    "taro-tabbar",
    {
        "conf": [
            16
        ],
        "list": [
            32
        ],
        "borderStyle": [
            32
        ],
        "backgroundColor": [
            32
        ],
        "color": [
            32
        ],
        "selectedColor": [
            32
        ],
        "selectedIndex": [
            32
        ],
        "status": [
            32
        ]
    }
]);
function defineCustomElement$186() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-tabbar"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-tabbar":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Tabbar);
                }
                break;
        }
    });
}
var defineCustomElement88 = defineCustomElement$186;
// node_modules/@tarojs/components/dist/components/taro-tabs-core.js
var Tabs = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("Tabs", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-tabs-core"
]);
function defineCustomElement$187() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-tabs-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-tabs-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Tabs);
                }
                break;
        }
    });
}
var defineCustomElement89 = defineCustomElement$187;
// node_modules/@tarojs/components/dist/components/taro-tap-gesture-handler-core.js
var TapGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("TapGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-tap-gesture-handler-core"
]);
function defineCustomElement$188() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-tap-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-tap-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, TapGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement90 = defineCustomElement$188;
// node_modules/@tarojs/components/dist/components/taro-text-core.js
var indexCss20 = "taro-text-core{user-select:none;display:inline}taro-text-core[selectable=true],taro-text-core[user-select=true]{user-select:text;display:inline-block}taro-text-core[space]{white-space:pre-wrap}taro-text-core[space=ensp]{word-spacing:.5em}taro-text-core[space=nbsp]{word-spacing:1em}taro-text-core[number-of-lines]{--line-clamp:2;word-wrap:break-word;text-overflow:ellipsis;-webkit-line-clamp:var(--line-clamp);-webkit-box-orient:vertical;display:-webkit-box;overflow:hidden}";
var Text = proxyCustomElement(class extends H {
    render() {
        const style = {};
        if (typeof this.numberOfLines === "number") {
            style["--line-clamp"] = this.numberOfLines;
        }
        return h(Host, {
            style
        }, h("slot", null));
    }
    static get style() {
        return indexCss20;
    }
    constructor(){
        super();
        this.__registerHost();
        this.selectable = false;
        this.userSelect = false;
        this.space = void 0;
        this.numberOfLines = void 0;
    }
}, [
    4,
    "taro-text-core",
    {
        "selectable": [
            1028
        ],
        "userSelect": [
            1028,
            "user-select"
        ],
        "space": [
            1025
        ],
        "numberOfLines": [
            2,
            "number-of-lines"
        ]
    }
]);
function defineCustomElement$189() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-text-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-text-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Text);
                }
                break;
        }
    });
}
var defineCustomElement91 = defineCustomElement$189;
// node_modules/@tarojs/components/dist/components/taro-textarea-core.js
var indexCss21 = "taro-textarea-core{width:300px;display:block}taro-textarea-core .auto-height{height:auto}.taro-textarea{width:100%;height:inherit;appearance:none;cursor:auto;border:0;line-height:1.5;display:block;position:relative}.taro-textarea:focus{outline:none}";
function fixControlledValue2(value) {
    return value !== null && value !== void 0 ? value : "";
}
var Textarea = proxyCustomElement(class extends H {
    watchAutoFocus(newValue, oldValue) {
        var _a;
        if (!oldValue && newValue) {
            (_a = this.textareaRef) === null || _a === void 0 ? void 0 : _a.focus();
        }
    }
    watchValue(newValue) {
        if (this.isComposing) return;
        const value = fixControlledValue2(newValue);
        if (this.textareaRef.value !== value) {
            const isActive = typeof document !== "undefined" && document.activeElement === this.textareaRef;
            const selection = isActive ? this.lastSelectionRange || this.getSelectionSnapshot(this.textareaRef) : null;
            this.textareaRef.value = value;
            if (selection) {
                this.restoreSelection(this.textareaRef, selection);
            }
        }
    }
    focus() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.textareaRef.focus();
        })();
    }
    componentDidLoad() {
        var _a, _b;
        (_a = this.textareaRef) === null || _a === void 0 ? void 0 : _a.addEventListener("compositionstart", this.handleComposition);
        (_b = this.textareaRef) === null || _b === void 0 ? void 0 : _b.addEventListener("compositionend", this.handleComposition);
    }
    disconnectedCallback() {
        var _a, _b;
        (_a = this.textareaRef) === null || _a === void 0 ? void 0 : _a.removeEventListener("compositionstart", this.handleComposition);
        (_b = this.textareaRef) === null || _b === void 0 ? void 0 : _b.removeEventListener("compositionend", this.handleComposition);
    }
    getSelectionSnapshot(target) {
        if (!target) return null;
        const { selectionStart, selectionEnd } = target;
        if (selectionStart === null || selectionEnd === null) return null;
        this.lastSelectionRange = {
            selectionStart,
            selectionEnd
        };
        return {
            selectionStart,
            selectionEnd
        };
    }
    getCursorFromTarget(target, fallback2) {
        var _a;
        if (!target) return fallback2;
        const { selectionEnd } = target;
        if (typeof selectionEnd === "number") {
            const selectionStart = (_a = target.selectionStart) !== null && _a !== void 0 ? _a : selectionEnd;
            this.lastSelectionRange = {
                selectionStart,
                selectionEnd
            };
            return selectionEnd;
        }
        return fallback2;
    }
    restoreSelection(target, selection) {
        if (!target) return;
        const range = selection || this.lastSelectionRange || null;
        if (!range) return;
        const max = target.value.length;
        const start = Math.min(range.selectionStart, max);
        const end = Math.min(range.selectionEnd, max);
        if (typeof target.setSelectionRange === "function") {
            target.setSelectionRange(start, end);
        }
    }
    render() {
        const { value, placeholder, disabled, maxlength, autoFocus, autoHeight, name, nativeProps, handleInput, handleFocus, handleBlur, handleChange, compositionValue } = this;
        const otherProps = {};
        if (autoHeight) {
            otherProps.rows = this.line;
        }
        return h("textarea", Object.assign({
            ref: (input)=>{
                if (input) {
                    this.textareaRef = input;
                    if (autoFocus && input) input.focus();
                }
            },
            class: `taro-textarea ${autoHeight ? "auto-height" : ""}`,
            value: compositionValue !== void 0 ? compositionValue : fixControlledValue2(value),
            placeholder,
            name,
            disabled,
            maxLength: maxlength,
            autoFocus,
            onInput: handleInput,
            onFocus: handleFocus,
            onBlur: handleBlur,
            onChange: handleChange,
            onKeyDown: this.handleKeyDown
        }, nativeProps, otherProps));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "autoFocus": [
                "watchAutoFocus"
            ],
            "value": [
                "watchValue"
            ]
        };
    }
    static get style() {
        return indexCss21;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onInput = createEvent(this, "input", 7);
        this.onFocus = createEvent(this, "focus", 7);
        this.onBlur = createEvent(this, "blur", 7);
        this.onConfirm = createEvent(this, "confirm", 7);
        this.onChange = createEvent(this, "change", 7);
        this.onLineChange = createEvent(this, "linechange", 7);
        this.onKeyDown = createEvent(this, "keydown", 7);
        this.isComposing = false;
        this.onInputExecuted = false;
        this.handleInput = (e)=>{
            e.stopPropagation();
            this.handleLineChange();
            if (this.onInputExecuted) {
                this.onInputExecuted = false;
                return;
            }
            const value = e.target.value || "";
            const cursor = this.getCursorFromTarget(e.target, value.length);
            if (this.isComposing) {
                this.compositionValue = value;
                return;
            }
            this.onInputExecuted = true;
            if (this.compositionValue !== void 0) {
                this.compositionValue = void 0;
            }
            this.value = value;
            this.onInput.emit({
                value,
                cursor
            });
            this.onInputExecuted = false;
        };
        this.handleComposition = (e)=>{
            e.stopPropagation();
            if (!(e.target instanceof HTMLTextAreaElement)) return;
            if (e.type === "compositionend") {
                this.isComposing = false;
                const value = e.target.value || "";
                const cursor = this.getCursorFromTarget(e.target, value.length);
                this.compositionValue = void 0;
                this.handleLineChange();
                this.value = value;
                this.onInput.emit({
                    value,
                    cursor
                });
            } else {
                this.isComposing = true;
            }
        };
        this.handleFocus = (e)=>{
            e.stopPropagation();
            this.onFocus.emit({
                value: e.target.value
            });
        };
        this.handleBlur = (e)=>{
            e.stopPropagation();
            this.onBlur.emit({
                value: e.target.value
            });
            this.lastSelectionRange = void 0;
        };
        this.handleChange = (e)=>{
            e.stopPropagation();
            this.onChange.emit({
                value: e.target.value
            });
        };
        this.handleLineChange = ()=>{
            const line = this.getNumberOfLines();
            if (line !== this.line) {
                this.line = line;
                this.onLineChange.emit({
                    height: this.textareaRef.clientHeight,
                    lineCount: this.line
                });
            }
        };
        this.handleKeyDown = (e)=>{
            e.stopPropagation();
            const { value } = e.target;
            const cursor = this.getCursorFromTarget(e.target, value.length);
            const keyCode = e.keyCode || e.code;
            this.onKeyDown.emit({
                value,
                cursor,
                keyCode
            });
            keyCode === 13 && this.onConfirm.emit({
                value
            });
        };
        this.calculateContentHeight = (ta, scanAmount)=>{
            const origHeight = ta.style.height;
            let height = ta.offsetHeight;
            const scrollHeight = ta.scrollHeight;
            const overflow = ta.style.overflow;
            const originMinHeight = ta.style.minHeight || null;
            if (height >= scrollHeight) {
                ta.style.minHeight = 0;
                ta.style.height = height + scanAmount + "px";
                ta.style.overflow = "hidden";
                if (scrollHeight < ta.scrollHeight) {
                    while(ta.offsetHeight >= ta.scrollHeight){
                        ta.style.height = (height -= scanAmount) + "px";
                    }
                    while(ta.offsetHeight < ta.scrollHeight){
                        ta.style.height = height++ + "px";
                    }
                    ta.style.height = origHeight;
                    ta.style.overflow = overflow;
                    ta.style.minHeight = originMinHeight;
                    return height;
                }
            } else {
                return scrollHeight;
            }
        };
        this.getNumberOfLines = ()=>{
            const ta = this.textareaRef;
            const style = window.getComputedStyle ? window.getComputedStyle(ta) : ta.style;
            const taLineHeight = parseInt(style.lineHeight, 10);
            const taHeight = this.calculateContentHeight(ta, taLineHeight);
            const numberOfLines = Math.floor(taHeight / taLineHeight);
            return numberOfLines;
        };
        this.value = "";
        this.placeholder = void 0;
        this.disabled = false;
        this.maxlength = 140;
        this.autoFocus = false;
        this.autoHeight = false;
        this.name = void 0;
        this.nativeProps = {};
        this.line = 1;
        this.compositionValue = void 0;
    }
}, [
    0,
    "taro-textarea-core",
    {
        "value": [
            1025
        ],
        "placeholder": [
            1
        ],
        "disabled": [
            4
        ],
        "maxlength": [
            2
        ],
        "autoFocus": [
            4,
            "focus"
        ],
        "autoHeight": [
            4,
            "auto-height"
        ],
        "name": [
            1
        ],
        "nativeProps": [
            16
        ],
        "line": [
            32
        ],
        "compositionValue": [
            32
        ],
        "focus": [
            64
        ]
    }
]);
function defineCustomElement$190() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-textarea-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-textarea-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Textarea);
                }
                break;
        }
    });
}
var defineCustomElement92 = defineCustomElement$190;
// node_modules/@tarojs/components/dist/components/taro-vertical-drag-gesture-handler-core.js
var VerticalDragGestureHandler = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("VerticalDragGestureHandler", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-vertical-drag-gesture-handler-core"
]);
function defineCustomElement$191() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-vertical-drag-gesture-handler-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-vertical-drag-gesture-handler-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VerticalDragGestureHandler);
                }
                break;
        }
    });
}
var defineCustomElement93 = defineCustomElement$191;
// node_modules/@tarojs/components/dist/components/video-control.js
var formatTime = (time)=>{
    if (!time) return "";
    const sec = Math.round(time % 60);
    const min = Math.round((time - sec) / 60);
    return `${min < 10 ? `0${min}` : min}:${sec < 10 ? `0${sec}` : sec}`;
};
var calcDist = (x, y)=>{
    return Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));
};
var normalizeNumber = (number2)=>{
    return Math.max(-1, Math.min(number2, 1));
};
var scene = "default";
var screenFn = function() {
    let val;
    const fnMap = [
        [
            "requestFullscreen",
            "exitFullscreen",
            "fullscreenElement",
            "fullscreenEnabled",
            "fullscreenchange",
            "fullscreenerror"
        ],
        // New WebKit
        [
            "webkitRequestFullscreen",
            "webkitExitFullscreen",
            "webkitFullscreenElement",
            "webkitFullscreenEnabled",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
        ],
        // Old WebKit
        [
            "webkitRequestFullScreen",
            "webkitCancelFullScreen",
            "webkitCurrentFullScreenElement",
            "webkitCancelFullScreen",
            "webkitfullscreenchange",
            "webkitfullscreenerror"
        ],
        [
            "mozRequestFullScreen",
            "mozCancelFullScreen",
            "mozFullScreenElement",
            "mozFullScreenEnabled",
            "mozfullscreenchange",
            "mozfullscreenerror"
        ],
        [
            "msRequestFullscreen",
            "msExitFullscreen",
            "msFullscreenElement",
            "msFullscreenEnabled",
            "MSFullscreenChange",
            "MSFullscreenError"
        ]
    ];
    var defaultIOSMap = [
        "webkitEnterFullscreen",
        "webkitExitFullscreen",
        "webkitCurrentFullScreenElement",
        "webkitSupportsFullscreen",
        "fullscreenchange",
        "fullscreenerror"
    ];
    let i2 = 0;
    const l = fnMap.length;
    const ret = {};
    for(; i2 < l; i2++){
        val = fnMap[i2];
        if (val && val[1] in document) {
            for(i2 = 0; i2 < val.length; i2++){
                ret[fnMap[0][i2]] = val[i2];
            }
            return ret;
        }
    }
    if (!ret[fnMap[0][0]]) {
        scene = "iOS";
        for(i2 = 0; i2 < defaultIOSMap.length; i2++){
            ret[fnMap[0][i2]] = defaultIOSMap[i2];
        }
    }
    return ret;
}();
var isHls = (url)=>/\.(m3u8)($|\?)/i.test(url);
var VideoControl = proxyCustomElement(class extends H {
    onDocumentTouchMove(e) {
        if (!this.isDraggingProgressBall) return;
        const touchX = e.touches[0].pageX;
        this.percentage = this.calcPercentage(touchX);
        this.setProgressBall(this.percentage);
        this.setCurrentTime(this.percentage * this.duration);
    }
    onDocumentTouchEnd() {
        if (!this.isDraggingProgressBall) return;
        this.isDraggingProgressBall = false;
        this.seekFunc(this.percentage * this.duration);
        this.toggleVisibility(true);
    }
    setProgressBall(percentage) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this.progressBallRef) {
                _this.progressBallRef.style.left = `${percentage * 100}%`;
            }
        })();
    }
    toggleVisibility(nextVisible) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this.controls) {
                _this.visible = false;
                return;
            }
            const visible = nextVisible === void 0 ? !_this.visible : nextVisible;
            if (visible) {
                _this.hideControlsTimer && clearTimeout(_this.hideControlsTimer);
                if (_this.isPlaying) {
                    _this.hideControlsTimer = setTimeout(()=>{
                        _this.toggleVisibility(false);
                    }, 2e3);
                }
                _this.el.style.visibility = "visible";
            } else {
                _this.el.style.visibility = "hidden";
            }
            _this.visible = !!visible;
        })();
    }
    getIsDraggingProgressBall() {
        var _this = this;
        return _async_to_generator(function*() {
            return _this.isDraggingProgressBall;
        })();
    }
    setCurrentTime(time) {
        var _this = this;
        return _async_to_generator(function*() {
            if (!_this.currentTimeRef) return;
            _this.currentTimeRef.innerHTML = formatTime(time);
        })();
    }
    render() {
        const { controls, currentTime, duration, isPlaying, pauseFunc, playFunc, showPlayBtn, showProgress } = this;
        if (!controls) {
            return h(Host, {
                class: "taro-video-bar taro-video-bar-full",
                style: {
                    display: "none"
                }
            }, h("slot", null));
        }
        const formattedDuration = formatTime(duration);
        let playBtn;
        if (!showPlayBtn) {
            playBtn = null;
        } else if (isPlaying) {
            playBtn = h("div", {
                class: "taro-video-control-button taro-video-control-button-pause",
                onClick: pauseFunc
            });
        } else {
            playBtn = h("div", {
                class: "taro-video-control-button taro-video-control-button-play",
                onClick: playFunc
            });
        }
        return h(Host, {
            class: "taro-video-bar taro-video-bar-full"
        }, h("div", {
            class: "taro-video-controls"
        }, playBtn, showProgress && h("div", {
            class: "taro-video-current-time",
            ref: (dom)=>this.currentTimeRef = dom
        }, formatTime(currentTime)), showProgress && h("div", {
            class: "taro-video-progress-container",
            onClick: this.onClickProgress
        }, h("div", {
            class: "taro-video-progress",
            ref: (ref)=>{
                if (!ref) return;
                const rect = ref.getBoundingClientRect();
                this.progressDimensions.left = rect.left;
                this.progressDimensions.width = rect.width;
            }
        }, h("div", {
            class: "taro-video-progress-buffered",
            style: {
                width: "100%"
            }
        }), h("div", {
            class: "taro-video-ball",
            ref: (dom)=>this.progressBallRef = dom,
            onTouchStart: this.onDragProgressBallStart,
            style: {
                left: `${formattedDuration ? this.currentTime / duration * 100 : 0}%`
            }
        }, h("div", {
            class: "taro-video-inner"
        })))), showProgress && h("div", {
            class: "taro-video-duration"
        }, formattedDuration)), h("slot", null));
    }
    get el() {
        return this;
    }
    constructor(){
        super();
        this.__registerHost();
        this.visible = false;
        this.isDraggingProgressBall = false;
        this.percentage = 0;
        this.progressDimensions = {
            left: 0,
            width: 0
        };
        this.calcPercentage = (pageX)=>{
            let pos = pageX - this.progressDimensions.left;
            pos = Math.max(pos, 0);
            pos = Math.min(pos, this.progressDimensions.width);
            return pos / this.progressDimensions.width;
        };
        this.onDragProgressBallStart = ()=>{
            this.isDraggingProgressBall = true;
            this.hideControlsTimer && clearTimeout(this.hideControlsTimer);
        };
        this.onClickProgress = (e)=>{
            e.stopPropagation();
            const percentage = this.calcPercentage(e.pageX);
            this.seekFunc(percentage * this.duration);
            this.toggleVisibility(true);
        };
        this.controls = void 0;
        this.currentTime = void 0;
        this.duration = void 0;
        this.isPlaying = void 0;
        this.pauseFunc = void 0;
        this.playFunc = void 0;
        this.seekFunc = void 0;
        this.showPlayBtn = void 0;
        this.showProgress = void 0;
    }
}, [
    4,
    "taro-video-control",
    {
        "controls": [
            4
        ],
        "currentTime": [
            2,
            "current-time"
        ],
        "duration": [
            2
        ],
        "isPlaying": [
            4,
            "is-playing"
        ],
        "pauseFunc": [
            16
        ],
        "playFunc": [
            16
        ],
        "seekFunc": [
            16
        ],
        "showPlayBtn": [
            4,
            "show-play-btn"
        ],
        "showProgress": [
            4,
            "show-progress"
        ],
        "setProgressBall": [
            64
        ],
        "toggleVisibility": [
            64
        ],
        "getIsDraggingProgressBall": [
            64
        ],
        "setCurrentTime": [
            64
        ]
    },
    [
        [
            5,
            "touchmove",
            "onDocumentTouchMove"
        ],
        [
            5,
            "touchend",
            "onDocumentTouchEnd"
        ],
        [
            5,
            "touchcancel",
            "onDocumentTouchEnd"
        ]
    ]
]);
function defineCustomElement94() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-video-control"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-control":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VideoControl);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-video-control.js
var defineCustomElement95 = defineCustomElement94;
// node_modules/@tarojs/components/dist/components/video-danmu.js
var VideoDanmu = proxyCustomElement(class extends H {
    ensureProperties(danmu) {
        const clonedDanmu = Object.assign({}, danmu);
        if (!("time" in danmu)) {
            clonedDanmu.time = this.currentTime;
        }
        clonedDanmu.key = Math.random();
        clonedDanmu.bottom = `${Math.random() * 90 + 5}%`;
        return clonedDanmu;
    }
    sendDanmu(danmuList = []) {
        var _this = this;
        return _async_to_generator(function*() {
            if (Array.isArray(danmuList)) {
                _this.list = [
                    ..._this.list,
                    ...danmuList.map((danmu)=>_this.ensureProperties(danmu))
                ];
            } else {
                const danmu = danmuList;
                _this.list = [
                    ..._this.list,
                    Object.assign({}, _this.ensureProperties(danmu))
                ];
            }
        })();
    }
    tick(currentTime) {
        var _this = this;
        return _async_to_generator(function*() {
            _this.currentTime = currentTime;
            if (!_this.enable) return;
            const danmuList = _this.list;
            const newDanmuList = danmuList.filter(({ time })=>{
                return currentTime - time < 4 && currentTime > time;
            });
            let shouldUpdate = false;
            const oldDanmuList = _this.danmuList;
            if (newDanmuList.length !== oldDanmuList.length) {
                shouldUpdate = true;
            } else {
                shouldUpdate = newDanmuList.some(({ key })=>{
                    return oldDanmuList.every((danmu)=>{
                        return key !== danmu.key;
                    });
                });
            }
            if (shouldUpdate) {
                _this.danmuList = newDanmuList;
            }
        })();
    }
    componentDidUpdate() {
        requestAnimationFrame(()=>{
            setTimeout(()=>{
                const danmuElList = this.danmuElList.splice(0);
                danmuElList.forEach((danmu)=>{
                    danmu.style.left = "0";
                    danmu.style.webkitTransform = "translateX(-100%)";
                    danmu.style.transform = "translateX(-100%)";
                });
            });
        });
    }
    render() {
        if (!this.enable) return "";
        return h(Host, {
            class: "taro-video-danmu"
        }, this.danmuList.map(({ text, color, bottom, key })=>h("p", {
                class: "taro-video-danmu-item",
                key,
                style: {
                    color,
                    bottom
                },
                ref: (ref)=>{
                    if (ref) {
                        this.danmuElList.push(ref);
                    }
                }
            }, text)));
    }
    constructor(){
        super();
        this.__registerHost();
        this.list = [];
        this.danmuElList = [];
        this.currentTime = 0;
        this.enable = false;
        this.danmuList = [];
    }
}, [
    0,
    "taro-video-danmu",
    {
        "enable": [
            4
        ],
        "danmuList": [
            32
        ],
        "sendDanmu": [
            64
        ],
        "tick": [
            64
        ]
    }
]);
function defineCustomElement96() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-video-danmu"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-danmu":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VideoDanmu);
                }
                break;
        }
    });
}
// node_modules/@tarojs/components/dist/components/taro-video-core.js
var indexCss22 = '.taro-video{width:100%;height:225px;line-height:0;display:inline-block;position:relative;overflow:hidden}.taro-video[hidden]{display:none}.taro-video-container{object-position:inherit;background-color:#000;width:100%;height:100%;display:inline-block;position:absolute;top:0;left:0}.taro-video-container.taro-video-type-fullscreen{z-index:999;position:fixed;inset:0}.taro-video-container.taro-video-type-fullscreen.taro-video-type-rotate-left{transform:translate(-50%,-50%)rotate(-90deg)}.taro-video-container.taro-video-type-fullscreen.taro-video-type-rotate-right{transform:translate(-50%,-50%)rotate(90deg)}.taro-video-video{object-position:inherit;width:100%;height:100%;display:block}.taro-video-cover{z-index:1;background-color:rgba(1,1,1,.5);-webkit-box-orient:vertical;-webkit-box-direction:normal;flex-direction:column;-webkit-box-align:center;-webkit-box-pack:center;justify-content:center;align-items:center;width:100%;display:flex;position:absolute;top:0;bottom:0;left:0}.taro-video-cover-play-button{background-position:50%;background-repeat:no-repeat;background-size:50%;width:40px;height:40px}.taro-video-cover-duration{color:#fff;margin-top:10px;font-size:16px;line-height:1}.taro-video-bar{visibility:hidden;z-index:1;background-color:rgba(0,0,0,.5);-webkit-box-align:center;align-items:center;height:44px;padding:0 10px;display:flex;position:absolute;bottom:0;right:0;overflow:hidden}.taro-video-bar.taro-video-bar-full{left:0}.taro-video-controls{-webkit-box-flex:1;flex-grow:1;margin:0 8.5px;display:flex}.taro-video-control-button{box-sizing:content-box;width:13px;height:15px;margin-left:-8.5px;padding:14.5px 12.5px}.taro-video-control-button:after{content:"";background-position:50%;background-repeat:no-repeat;background-size:100%;width:100%;height:100%;display:block}.taro-video-control-button.taro-video-control-button-play:after,.taro-video-cover-play-button{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABoAAAAeCAYAAAAy2w7YAAAAAXNSR0IArs4c6QAAAWhJREFUSA1j+P///0cgBoHjQGzCQCsAtgJB/AMy5wCxGNXtQ9iBwvoA5BUCMQvVLEQxHpNzDSjkRhXLMM3GKrIeKKpEkYVYjcUu+AMo3ALE3GRZiN1MvKKPgbIRJFuG10j8koeA0gZEW4jfLIKyf4EqpgOxMEELCRpFnIJ3QGU5QMyM00LizCFa1SWgSkeslhFtBGkKVwGVy6FYSJp+klR/A6quB2JOkIWMIK0oNlOf8xBoZDE9LAI7nYn6HsBq4l96WHQEaLUpAyiOaASeAM2NgvuPBpaACt82IEYtfKls0UagecpwXyAzqGTRdaA57sjmYrAptAjUsCkGYlYMg9EFyLQI1IiZB8Ti6Obh5JNh0QmgHlOcBuKSIMGi50C18UDMiMssvOJEWPQLqKYbiHnxGkRIkoBF24DyaoTMIEoeh0W3geI+RBlArCI0iz4D+RVAzEasfqLVAQ19AcSg5LoYiKWI1kiiQgCMBLnEEcfDSgAAAABJRU5ErkJggg==)}.taro-video-control-button.taro-video-control-button-pause:after{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABIAAAAgCAYAAAAffCjxAAAAAXNSR0IArs4c6QAAAFlJREFUSA3tksEKACAIQ7X//5zq98wOgQayum8QaGweHhMzG/6OujzKAymn+0LMqivu1XznWmX8/echTIyMyAgTwA72iIwwAexgj8gIE8CO3aMRbDPMaEy5BRGaKcZv8YxRAAAAAElFTkSuQmCC)}.taro-video-current-time,.taro-video-duration{color:#cbcbcb;height:14.5px;margin-top:15px;margin-bottom:14.5px;font-size:12px;line-height:14.5px}.taro-video-progress-container{-webkit-box-flex:2;flex-grow:2;position:relative}.taro-video-progress{background-color:rgba(255,255,255,.4);height:2px;margin:21px 12px;position:relative}.taro-video-progress-buffered{background-color:rgba(255,255,255,.8);width:0;height:100%;transition:width .1s;position:absolute;top:0;left:0}.taro-video-ball{box-sizing:content-box;width:16px;height:16px;margin-left:-22px;padding:14px;position:absolute;top:-21px;left:0}.taro-video-inner{background-color:#fff;border-radius:50%;width:100%;height:100%}.taro-video-danmu-button{color:#fff;white-space:nowrap;border:1px solid #fff;border-radius:5px;margin:0 8.5px;padding:2px 10px;font-size:13px;line-height:1}.taro-video-danmu-button.taro-video-danmu-button-active{color:#48c23d;border-color:#48c23d}.taro-video-fullscreen,.taro-video-mute{box-sizing:content-box;background-position:50%;background-repeat:no-repeat;background-size:50%;width:17px;height:17px;padding:8.5px}.taro-video-fullscreen{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAhUlEQVRYR+2WSwrAMAhEnZO3PfmULLooGEFTiIXJ2s/kRY2wzQeb85sE9CRA8jSzY1YfAFzhJBnU1AVgxH2dSiArCnD9QgGzRNnOech48SRABHoSyFb5in3PSbhyo6yvCPQkEM3u7BsPe/0FIvBfAh/vhKmVbO9SWun1qk/PSVi9TcVPBG6R1YIhgWwNpQAAAABJRU5ErkJggg==)}.taro-video-fullscreen.taro-video-type-fullscreen{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABPUlEQVRYR+2Xu0pDURBF1/ZLxNcHKNiIlfhA7C0UBSEE8RNEBNFPUEQEEbGxFiSSSrCwEHsf5E/ccsSUuWfUhKQ40947+y42Z8+ZK/pcinzf9hhwD1xJ2q/qsb0JHAOzkl5y+lGAGnCWICQtZgAS6DxQk3TeLYA6cAo0JSXxjmW7CcwBdUkJurKiDhSA4kBvHbA9CqwBQx2O7BSw8ssU3ALPFRF4knT3nQLbr8B4LjLBOdAAFgJaLUkjbYC9n+zm+i4kXWbmwCqwnRMCHiXthuZAQOzPrxSA4kBxYDAcsH0EzATCfCLpJjOINoCtgFZabg7bk7AFDAeaGpKWgitZTu5N0kQbYBmYrujo9mX0CVxL+gidAdu9vY5zXhWA4sAgOND3X7NJ4AHYCaxkB8B62gslvecSFpoDOZH/PP8Cnt7hIaM5xCEAAAAASUVORK5CYII=)}.taro-video-mute{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDQtMTFUMTA6MTg6MjArMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjk3YmE4Yjg0LTFhNTYtNGM1MS04NDVkLTNiZmYyMGI0ZDc0ZiIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjg1NGQ3MjlkLWUwNjctZjU0OC1hMTlhLTBlZjQ4OGRkYjJiOSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjA1ODY3ZDFlLWQ3NGEtNDgyNC04MDU3LTYzYmRmMTdjODk5ZSI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDU4NjdkMWUtZDc0YS00ODI0LTgwNTctNjNiZGYxN2M4OTllIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjE4OjIwKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6OTdiYThiODQtMWE1Ni00YzUxLTg0NWQtM2JmZjIwYjRkNzRmIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjIyOjIyKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz459+FoAAABqElEQVRYhc2XPWsVQRSGnxPjF4oGRfxoRQKGWCU2Ft7CykrQWosEyf/If0hhIPgHDEmbNJZqCFxiQEgTUGxsBUVEHgvnyrjZZJO92V1fGIaZnTPvszPszNlQ6VIjnbr/DwCoDLMNak/dUVfUK0f2rQugnlcX/FevWgFQH6gf3autRgHUC+piiXHzAOmtPx9gXgug8itQx9SXwDpw47AGKXZWvXvQmNFCwE3gCXA2dY0Az4GrRzHONA9cU/vAbERsllEOyh31e8USV2mrMPdG9uyn+rDom2/BHHCm5puWKiKmgdtAnz+rvaxO5mNygEvHaZ5BfADuARvAaWBpP4DGFBHfgBngFzClTrUKkCDeA+9S837rAEnbqb7VFcCpVJ/oCmCw959aB1AfAROpudYqgDoOLKRmPyLelAF8bcD4pPoMeAtcB34AT4uDBqXXwFG8XXUU/72MIuK1OgE8Bs6l7mEvo8up7lN1Ge0n9aK6VHMFZvJTr9S3CiALaCQhqZOSvegMIAvu2UVSWpigLC1fbQ0gm6in7qpfLCQbhwGIYcyPQ53/G3YO8BtUtd35bvKcVwAAAABJRU5ErkJggg==)}.taro-video-mute.taro-video-type-mute{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAgCAYAAAB3j6rJAAAACXBIWXMAAAsTAAALEwEAmpwYAAAGAGlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNS42LWMxNDAgNzkuMTYwNDUxLCAyMDE3LzA1LzA2LTAxOjA4OjIxICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMTktMDQtMTFUMTA6MTk6MDMrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjAzYjJmNjE2LTZmZTUtNDJjNC1iNTgwLTczNzZjZjI2NzdmNSIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjYzZjQ2NTYzLWE0ZjktOGQ0Mi1hM2FhLTY3ODJhNDBhYWNjMSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjIyYWNjMWFlLTg4ZmMtNDBlZi1iMWM1LTNmODgwY2QzYWI2MiI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MjJhY2MxYWUtODhmYy00MGVmLWIxYzUtM2Y4ODBjZDNhYjYyIiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjE5OjAzKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MDNiMmY2MTYtNmZlNS00MmM0LWI1ODAtNzM3NmNmMjY3N2Y1IiBzdEV2dDp3aGVuPSIyMDE5LTA0LTExVDEwOjIyOjMzKzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgQ0MgMjAxOCAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5PmxYVAAACLklEQVRYhc2XP2sVQRRHz40hKoqaQgVBCy1EozFlGiVFxMLGh4piYWEh+hkEP4YKAVFEEFTyughaCH6DqIVpAhYWEgIxoJE8cywyi5tNHu/tJmvyg2WZO3dmzt47/zZUtoJ6Nhsg09YDiYhKDzACTAFNYH9lEpUq80TdrT5wpV5n/ZV9KoGoo+pXV2uyKkipOaLuUceAt8DhUvQd1FsCYhR4ChzaSIBMHSOi7lOfsByFWiCgEBH1GHAF2JlMPcBt4GC3HUYEaj9wF3gVEVPtfNVTwAXgWX7CDKq/1piAZTSZBmim8qJ6sQ3EgDqb/L7kU3MH2NHtl3dQX3r3Ak21UYAYAj4A/cl0JB+RF+uMRj4iQ+p8zt7KYFLdXKHuRi0gacBhV6a6pd5bA6KRNagFJPU9qv5u47toLmW1HnoR8Q5oAK1CVQu4FBHj/wUkaXsb+4pzpVaQFPqXrN7Be4Fx9VztIOr1BLEtmX4A94E/qdwHTKjDWYM6lu81dSlnn3V570BtuLxaMs2rZ/IgYxsBovaoPwsQA4VoFWEm8ql5DiysNyURsQTMpOIMcDYiPhd8xoGr/FtNC2G6FKXD6ihwGdiVHMoeeh8jYlA9ANwE3kTEp3bO6vE03qOONzR1r/q4RGrquaFFxFxE3ALOA9+6jExpdb180y55AhirhaRTatq0GXEzL8+ZIuI9cBJ4WKiartJf9nWV/mty7UfUafW7erpqRGI9EBuprffvu9n6C1KOmsqwI5A1AAAAAElFTkSuQmCC)}.taro-video-danmu{width:100%;margin-top:14px;margin-bottom:44px;font-size:14px;line-height:14px;position:absolute;top:0;bottom:0;left:0;overflow:visible}.taro-video-danmu-item{color:#fff;white-space:nowrap;line-height:1;transition-property:left,transform;transition-duration:3s;transition-timing-function:linear;position:absolute;left:100%;transform:translate(0)}.taro-video-toast{visibility:hidden;pointer-events:none;color:#000;background-color:rgba(255,255,255,.8);border-radius:5px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%,-50%)}.taro-video-toast.taro-video-toast-volume{width:100px;height:100px;display:block}.taro-video-toast-volume .taro-video-toast-title{text-align:center;width:100%;margin-top:10px;font-size:12px;line-height:16px;display:block}.taro-video-toast-volume .taro-video-toast-icon{fill:#000;background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAFhklEQVR4Xu2aeaxfQxTHP1VBES0NIQitWtpaaxeCUkQtaYVa0tiClAq1ExIiQTVppaWxt8RWSa2tWkJQRGgtQaSIpUKEpG0ssbbk28yV2+mZO/e9e3vvu/e98897mZnfzPl+75mZs0wvurn06ub46SGgxwLqZaA3sB/wO/A+8G/V6tS5BU4BJgJbO9DvAMOB36okoQ4CNgAeBEYbQK8Bbm4zAdsBc4EdAyA/APZoKwHHAA8DG2UA/AnYrG0ErAVcD1yXA9gfQJ8c40obsqbPgH7AY8CROTVuFQFD3X7fJid4DWsNAWOAGZ0w58YTsDZwKzChA189PbTRBGwKzAYO6iT4srbAMHfTfAksjulS1iG4JzAH2Dy2YKS/qAVcCdzi1vgZOBZ4PWvNGAG6wgYCW0IwctzNmf06BcEXtYABwOeA4otEfgEOdnGGqV6IAAUopwM6zDYuAVjeKYpYwCjgCWOhH513+b2lhE+Avrj89NPyalzyuCIE6EN9BfQ1dHoPOAD40+9LE6D/5aoqSqtLsgiQC60DTiHzfGCFoaSsQAexZdlTgEuyCDgLuK8u5G7dEAHyKN8CBrtxLwDHAX8Z+l4N3GS0L3db4aN0X5opmc+2XZQAfb2LPd2eciG1lUSRJZ9qYHkZONwiYAjwSc3gs24BXWWWfzEVuMjQez13HljX8v7A28lvEgsInaBVcxLaAvr6sgJLtBWeNTrOB+4w2p8DRvoEnAPcXTVaY70QAbrbXwIONX7zBSAL/tvrk1+iviTllnRry2irr/QSEws4D7izCxMg1XQLLAQGGXpeCkw22kOWI49RMUujCJC+uwAfGtfcImAng4AtAMsBeg04pIkESOfbgQsMsNoGnxrtSrfv7rXrSlwXWN6kLZBgEBiB8iWUUZZPIN/AF1nMoiYSICDfAlt5iB4CxhpAzwXuMtqPBuY1lYB5wFEeqFeAwwyguvIUqvuiQO/xphJwP3Cmhyh0EKrOoGDIF7n+M5pKwEwXrqdBCaQSM77Ig7SSIicDs5pKwIvACA+pzFwZIF9OlKm36QyQV7jEqDDJk5VD58uFgGIGX1Se+6yJFqAKsqI6X84GdDb4Mh0Y5zUqjFYFakUTCXja5QLSmBQHbAL8ahAgT1AeYVreSKLLphGwF/CuAfLJQLldGSTFD75c5d4mNCoWyAqG9gYWGED1AOMKo12ZbiWA/idA++deY2DVTZ0Jh5UJPsFQtD/wDaAHGWl5EzgwaUi2gK4UXS11S0cTIjrMFBtYQdAk4DID0BnAAz4B6wNLgTKKG0VIDBHwqitwpOcW+OOB540FdeipNKbUWFrUtn06o5xOij4KyDuqU0IE3Obl/rLA63pTzm9XA8jKACjdniZAaSKFmUpB1yUhAlTsUEpMh913wEkuTe7rKTzPAHqO44vpKPkFhH3cWWBVV6ogJVYZUgz/tXtIYelzI3Ct0fExIGx6j7iKWBUUveyYBehv1RIjIEsfqziq8Xp4pSBJOYTVJFQcVY3wCFeKUjVGyYfQWB00+5bEVBECrNS+qsOKBpVHNCVWHs+LS7H5PV5pOu9v0+OKEOAXR39w1e1C7wM6AkJ1eLmkRcrpRQiQrqobXO5S3vL3/4kBKMsCknV0k+iasVLUMV3UX5SAPGtED8EOT+L9YENnCasUIXNO2goChFWHqAIRyxXN4qI1BCQg9dJESYq8LnbrCBAR8t50Lig6i0krCRBoVWhVlt45wkBrCRBuRZyPuAguxIPe9lXqhpd9DcZMXOvdkPF0Xu/8dohNUmZ/1QQkuitXr+d4fryuFx3jywQYm6suAqSX8vLTXKJDt4QqO6rtLYspXWZ/nQQkOJTAUJZGIav19q9MvKvN1RUIWKMAY5P3EBBjqO393d4C/gMVHwRQlpx21QAAAABJRU5ErkJggg==);background-position:50%;background-repeat:no-repeat;background-size:50%;width:50%;height:50%;margin-left:25%;display:block}.taro-video-toast-volume .taro-video-toast-value{width:80px;height:5px;margin-top:5px;margin-left:10px}.taro-video-toast-volume .taro-video-toast-value>.taro-video-toast-value-content{overflow:hidden}.taro-video-toast-volume-grids{width:80px;height:5px}.taro-video-toast-volume-grids-item{float:left;background-color:#000;width:7.1px;height:5px}.taro-video-toast-volume-grids-item:not(:first-child){margin-left:1px}.taro-video-toast.taro-video-toast-progress{color:#fff;background-color:rgba(0,0,0,.8);padding:6px;font-size:14px;line-height:18px}';
var Video = proxyCustomElement(class extends H {
    componentWillLoad() {
        this._enableDanmu = this.enableDanmu;
        this.isMute = this.muted;
    }
    componentDidLoad() {
        var _a, _b;
        this.init();
        if (this.initialTime) {
            this.videoRef.currentTime = this.initialTime;
        }
        (_b = (_a = this.danmuRef).sendDanmu) === null || _b === void 0 ? void 0 : _b.call(_a, this.danmuList);
        if (document.addEventListener) {
            document.addEventListener(screenFn.fullscreenchange, this.handleFullScreenChange);
        }
        if (this.videoRef && scene === "iOS") {
            this.videoRef.addEventListener("webkitendfullscreen", this.handleFullScreenChange);
        }
    }
    componentDidRender() {}
    disconnectedCallback() {
        if (document.removeEventListener) {
            document.removeEventListener(screenFn.fullscreenchange, this.handleFullScreenChange);
        }
        if (this.videoRef && scene === "iOS") {
            this.videoRef.removeEventListener("webkitendfullscreen", this.handleFullScreenChange);
        }
    }
    watchEnableDanmu(newVal) {
        this._enableDanmu = newVal;
    }
    watchSrc() {
        this.init();
    }
    onDocumentTouchMove(e) {
        var _this = this;
        return _async_to_generator(function*() {
            if (_this.lastTouchScreenX === void 0 || _this.lastTouchScreenY === void 0) return;
            if (yield _this.controlsRef.getIsDraggingProgressBall()) return;
            const gestureObj = _this.analyzeGesture(e);
            if (gestureObj.type === "adjustVolume") {
                _this.toastVolumeRef.style.visibility = "visible";
                const nextVolume = Math.max(Math.min(_this.lastVolume - gestureObj.dataY, 1), 0);
                _this.videoRef.volume = nextVolume;
                _this.toastVolumeBarRef.style.width = `${nextVolume * 100}%`;
            } else if (gestureObj.type === "adjustProgress") {
                _this.isDraggingProgress = true;
                _this.nextPercentage = Math.max(Math.min(_this.lastPercentage + (gestureObj.dataX || 0), 1), 0);
                if (_this.controls && _this.showProgress) {
                    _this.controlsRef.setProgressBall(_this.nextPercentage);
                    _this.controlsRef.toggleVisibility(true);
                }
                const duration = _this.duration || _this._duration;
                _this.toastProgressTitleRef.innerHTML = `${formatTime(_this.nextPercentage * duration)} / ${formatTime(duration)}`;
                _this.toastProgressRef.style.visibility = "visible";
            }
        })();
    }
    onDocumentTouchEnd() {
        var _a;
        if (this.gestureType === "adjustVolume") {
            this.toastVolumeRef.style.visibility = "hidden";
        } else if (this.gestureType === "adjustProgress") {
            this.toastProgressRef.style.visibility = "hidden";
        }
        if (this.isDraggingProgress) {
            this.isDraggingProgress = false;
            this.seek(this.nextPercentage * ((_a = this.duration) !== null && _a !== void 0 ? _a : this._duration));
        }
        this.gestureType = "none";
        this.lastTouchScreenX = void 0;
        this.lastTouchScreenY = void 0;
    }
    getHlsObject() {
        var _this = this;
        return _async_to_generator(function*() {
            return _this.hls;
        })();
    }
    /**  */ play() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._play();
        })();
    }
    /**  */ pause() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._pause();
        })();
    }
    /**  */ stop() {
        var _this = this;
        return _async_to_generator(function*() {
            _this._stop();
        })();
    }
    /**  */ seek(position) {
        var _this = this;
        return _async_to_generator(function*() {
            _this._seek(position);
        })();
    }
    /**  video  */ requestFullScreen() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.toggleFullScreen(true);
        })();
    }
    /**  */ exitFullScreen() {
        var _this = this;
        return _async_to_generator(function*() {
            _this.toggleFullScreen(false);
        })();
    }
    render() {
        const { controls, autoplay, loop: loop2, muted, poster, objectFit, isFirst, isMute, isFullScreen, showCenterPlayBtn, isPlaying, _enableDanmu, showMuteBtn, danmuBtn, showFullscreenBtn, nativeProps } = this;
        const duration = this.duration || this._duration;
        const durationTime = formatTime(duration);
        return h(Host, {
            class: classnames("taro-video-container", {
                "taro-video-type-fullscreen": isFullScreen
            }),
            onTouchStart: this.onTouchStartContainer,
            onClick: this.onClickContainer
        }, h("video", Object.assign({
            class: "taro-video-video",
            style: {
                "object-fit": objectFit
            },
            ref: (dom)=>{
                if (dom) {
                    this.videoRef = dom;
                }
            },
            autoplay,
            loop: loop2,
            muted,
            poster: controls ? poster : void 0,
            playsinline: true,
            "webkit-playsinline": true,
            onPlay: this.handlePlay,
            onPause: this.handlePause,
            onEnded: this.handleEnded,
            onTimeUpdate: this.handleTimeUpdate,
            onError: this.handleError,
            onDurationChange: this.handleDurationChange,
            onProgress: this.handleProgress,
            onLoadedMetaData: this.handleLoadedMetaData
        }, nativeProps), "\u6682\u65F6\u4E0D\u652F\u6301\u64AD\u653E\u8BE5\u89C6\u9891"), h("taro-video-danmu", {
            ref: (dom)=>{
                if (dom) {
                    this.danmuRef = dom;
                }
            },
            enable: _enableDanmu
        }), isFirst && showCenterPlayBtn && !isPlaying && h("div", {
            class: "taro-video-cover"
        }, h("div", {
            class: "taro-video-cover-play-button",
            onClick: ()=>this.play()
        }), h("p", {
            class: "taro-video-cover-duration"
        }, durationTime)), h("taro-video-control", {
            ref: (dom)=>{
                if (dom) {
                    this.controlsRef = dom;
                }
            },
            controls,
            currentTime: this.currentTime,
            duration,
            isPlaying: this.isPlaying,
            pauseFunc: this._pause,
            playFunc: this._play,
            seekFunc: this._seek,
            showPlayBtn: this.showPlayBtn,
            showProgress: this.showProgress
        }, showMuteBtn && h("div", {
            class: classnames("taro-video-mute", {
                "taro-video-type-mute": isMute
            }),
            onClick: this.toggleMute
        }), danmuBtn && h("div", {
            class: classnames("taro-video-danmu-button", {
                "taro-video-danmu-button-active": _enableDanmu
            }),
            onClick: this.toggleDanmu
        }, "\u5F39\u5E55"), showFullscreenBtn && h("div", {
            class: classnames("taro-video-fullscreen", {
                "taro-video-type-fullscreen": isFullScreen
            }),
            onClick: this.onClickFullScreenBtn
        })), h("div", {
            class: "taro-video-toast taro-video-toast-volume",
            ref: (dom)=>{
                if (dom) {
                    this.toastVolumeRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-title"
        }, "\u97F3\u91CF"), h("div", {
            class: "taro-video-toast-icon"
        }), h("div", {
            class: "taro-video-toast-value"
        }, h("div", {
            class: "taro-video-toast-value-content",
            ref: (dom)=>{
                if (dom) {
                    this.toastVolumeBarRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-volume-grids"
        }, Array(10).fill(1).map(()=>h("div", {
                class: "taro-video-toast-volume-grids-item"
            })))))), h("div", {
            class: "taro-video-toast taro-video-toast-progress",
            ref: (dom)=>{
                if (dom) {
                    this.toastProgressRef = dom;
                }
            }
        }, h("div", {
            class: "taro-video-toast-title",
            ref: (dom)=>{
                if (dom) {
                    this.toastProgressTitleRef = dom;
                }
            }
        })));
    }
    get el() {
        return this;
    }
    static get watchers() {
        return {
            "enableDanmu": [
                "watchEnableDanmu"
            ],
            "src": [
                "watchSrc"
            ]
        };
    }
    static get style() {
        return indexCss22;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onPlay = createEvent(this, "play", 7);
        this.onPause = createEvent(this, "pause", 7);
        this.onEnded = createEvent(this, "ended", 7);
        this.onTimeUpdate = createEvent(this, "timeupdate", 7);
        this.onError = createEvent(this, "error", 7);
        this.onFullScreenChange = createEvent(this, "fullscreenchange", 7);
        this.onProgress = createEvent(this, "progress", 7);
        this.onLoadedMetaData = createEvent(this, "loadedmetadata", 7);
        this.currentTime = 0;
        this.isDraggingProgress = false;
        this.gestureType = "none";
        this.analyzeGesture = (e)=>{
            var _a;
            const obj = {
                type: "none"
            };
            const nowX = e.touches[0].screenX;
            const nowY = e.touches[0].screenY;
            const distX = nowX - this.lastTouchScreenX;
            const distY = nowY - this.lastTouchScreenY;
            const enableVslideGesture = this.isFullScreen ? this.vslideGestureInFullscreen : this.vslideGesture;
            if (this.gestureType === "none") {
                const dist = calcDist(distX, distY);
                if (dist < 10) return obj;
                if (Math.abs(distY) >= Math.abs(distX)) {
                    if (enableVslideGesture) {
                        this.gestureType = "adjustVolume";
                        this.lastVolume = this.videoRef.volume;
                    } else {
                        return obj;
                    }
                } else if (Math.abs(distY) < Math.abs(distX)) {
                    if (this.enableProgressGesture) {
                        this.gestureType = "adjustProgress";
                        this.lastPercentage = this.currentTime / ((_a = this.duration) !== null && _a !== void 0 ? _a : this._duration);
                    } else {
                        return obj;
                    }
                }
            }
            obj.type = this.gestureType;
            obj.dataX = normalizeNumber(distX / 200);
            obj.dataY = normalizeNumber(distY / 200);
            return obj;
        };
        this.loadNativePlayer = ()=>{
            var _a, _b;
            if (this.videoRef) {
                this.videoRef.src = this.src;
                (_b = (_a = this.videoRef).load) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
        };
        this.init = ()=>{
            const { src, videoRef } = this;
            if (isHls(src)) {
                __webpack_require__.e(/*! import() */ "vendors-node_modules_taro_h5_prebundle_hls-FIDQUEZ7_js").then(__webpack_require__.bind(__webpack_require__, /*! ./hls-FIDQUEZ7.js */ "./node_modules/.taro/h5/prebundle/hls-FIDQUEZ7.js")).then((e)=>{
                    const Hls = e.default;
                    this.HLS = Hls;
                    if (Hls.isSupported()) {
                        if (this.hls) {
                            this.hls.destroy();
                        }
                        this.hls = new Hls();
                        this.hls.loadSource(src);
                        this.hls.attachMedia(videoRef);
                        this.hls.on(Hls.Events.MANIFEST_PARSED, ()=>{
                            this.autoplay && this.play();
                        });
                        this.hls.on(Hls.Events.ERROR, (_, data)=>{
                            this.handleError(data);
                        });
                    } else if (videoRef.canPlayType("application/vnd.apple.mpegurl")) {
                        this.loadNativePlayer();
                    } else {
                        console.error("\u8BE5\u6D4F\u89C8\u5668\u4E0D\u652F\u6301 HLS \u64AD\u653E");
                    }
                });
            } else {
                this.loadNativePlayer();
            }
        };
        this.handlePlay = ()=>{
            this.isPlaying = true;
            this.isFirst = false;
            this.controlsRef.toggleVisibility(true);
            this.onPlay.emit();
        };
        this.handlePause = ()=>{
            this.isPlaying = false;
            this.controlsRef.toggleVisibility(true);
            this.onPause.emit();
        };
        this.handleEnded = ()=>{
            this.isFirst = true;
            this.pause();
            this.controlsRef.toggleVisibility();
            this.onEnded.emit();
        };
        var _this = this;
        this.handleTimeUpdate = throttle2(function() {
            var _ref = _async_to_generator(function*(e) {
                var _a, _b;
                _this.currentTime = _this.videoRef.currentTime;
                const duration = _this.duration || _this._duration;
                const isControlDragging = yield _this.controlsRef.getIsDraggingProgressBall();
                if (_this.controls && _this.showProgress) {
                    if (!isControlDragging && !_this.isDraggingProgress) {
                        _this.controlsRef.setProgressBall(_this.currentTime / duration);
                        _this.controlsRef.setCurrentTime(_this.currentTime);
                    }
                }
                _this.danmuRef.tick(_this.currentTime);
                _this.onTimeUpdate.emit({
                    duration: (_a = e.target) === null || _a === void 0 ? void 0 : _a.duration,
                    currentTime: (_b = e.target) === null || _b === void 0 ? void 0 : _b.currentTime
                });
                if (_this.duration) {
                    if (_this.currentTime >= _this.duration) {
                        _this.seek(0);
                        _this.handleEnded();
                    }
                }
            });
            return function(e) {
                return _ref.apply(this, arguments);
            };
        }(), 250);
        this.handleError = (e)=>{
            var _a, _b;
            if (this.hls) {
                switch(e.type){
                    case this.HLS.ErrorTypes.NETWORK_ERROR:
                        this.onError.emit({
                            errMsg: e.response
                        });
                        this.hls.startLoad();
                        break;
                    case this.HLS.ErrorTypes.MEDIA_ERROR:
                        this.onError.emit({
                            errMsg: e.reason || "\u5A92\u4F53\u9519\u8BEF,\u8BF7\u91CD\u8BD5"
                        });
                        this.hls.recoverMediaError();
                        break;
                }
            } else {
                this.onError.emit({
                    errMsg: (_b = (_a = e.target) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.message
                });
            }
        };
        this.handleDurationChange = ()=>{
            this._duration = this.videoRef.duration;
        };
        this.handleProgress = ()=>{
            this.onProgress.emit();
        };
        this.handleLoadedMetaData = (e)=>{
            const target = e.target;
            this.onLoadedMetaData.emit({
                width: target.videoWidth,
                height: target.videoHeight,
                duration: target.duration
            });
        };
        this._play = ()=>this.videoRef.play();
        this._pause = ()=>this.videoRef.pause();
        this._stop = ()=>{
            this.videoRef.pause();
            this._seek(0);
        };
        this._seek = (position)=>{
            this.videoRef.currentTime = position;
        };
        this.onTouchStartContainer = (e)=>{
            this.lastTouchScreenX = e.touches[0].screenX;
            this.lastTouchScreenY = e.touches[0].screenY;
        };
        this.onClickContainer = ()=>{
            if (this.enablePlayGesture) {
                const now3 = Date.now();
                if (now3 - this.lastClickedTime < 300) {
                    this.isPlaying ? this.pause() : this.play();
                }
                this.lastClickedTime = now3;
            }
            this.controlsRef.toggleVisibility();
        };
        this.onClickFullScreenBtn = (e)=>{
            e.stopPropagation();
            this.toggleFullScreen();
        };
        this.handleFullScreenChange = (e)=>{
            const timestamp2 = /* @__PURE__ */ new Date().getTime();
            if (!e.detail && this.isFullScreen && !document[screenFn.fullscreenElement] && timestamp2 - this.fullScreenTimestamp > 100) {
                this.toggleFullScreen(false, true);
            }
        };
        this.toggleFullScreen = (isFullScreen = !this.isFullScreen, fromBrowser = false)=>{
            this.isFullScreen = isFullScreen;
            this.controlsRef.toggleVisibility(true);
            this.fullScreenTimestamp = /* @__PURE__ */ new Date().getTime();
            this.onFullScreenChange.emit({
                fullScreen: this.isFullScreen,
                direction: "vertical"
            });
            if (this.isFullScreen && !document[screenFn.fullscreenElement]) {
                setTimeout(()=>{
                    this.videoRef[screenFn.requestFullscreen]({
                        navigationUI: "auto"
                    });
                    taro.eventCenter.trigger("__taroEnterFullScreen", {});
                }, 0);
            } else {
                if (!fromBrowser) {
                    document[screenFn.exitFullscreen]();
                }
                taro.eventCenter.trigger("__taroExitFullScreen", {});
            }
        };
        this.toggleMute = (e)=>{
            e.stopPropagation();
            this.videoRef.muted = !this.isMute;
            this.controlsRef.toggleVisibility(true);
            this.isMute = !this.isMute;
        };
        this.toggleDanmu = (e)=>{
            e.stopPropagation();
            this.controlsRef.toggleVisibility(true);
            this._enableDanmu = !this._enableDanmu;
        };
        this.src = void 0;
        this.duration = void 0;
        this.controls = true;
        this.autoplay = false;
        this.loop = false;
        this.muted = false;
        this.initialTime = 0;
        this.poster = void 0;
        this.objectFit = "contain";
        this.showProgress = true;
        this.showFullscreenBtn = true;
        this.showPlayBtn = true;
        this.showCenterPlayBtn = true;
        this.showMuteBtn = false;
        this.danmuList = void 0;
        this.danmuBtn = false;
        this.enableDanmu = false;
        this.enablePlayGesture = false;
        this.enableProgressGesture = true;
        this.vslideGesture = false;
        this.vslideGestureInFullscreen = true;
        this.nativeProps = {};
        this._duration = void 0;
        this._enableDanmu = false;
        this.isPlaying = false;
        this.isFirst = true;
        this.isFullScreen = false;
        this.fullScreenTimestamp = /* @__PURE__ */ new Date().getTime();
        this.isMute = false;
    }
}, [
    0,
    "taro-video-core",
    {
        "src": [
            1
        ],
        "duration": [
            2
        ],
        "controls": [
            4
        ],
        "autoplay": [
            4
        ],
        "loop": [
            4
        ],
        "muted": [
            4
        ],
        "initialTime": [
            2,
            "initial-time"
        ],
        "poster": [
            1
        ],
        "objectFit": [
            1,
            "object-fit"
        ],
        "showProgress": [
            4,
            "show-progress"
        ],
        "showFullscreenBtn": [
            4,
            "show-fullscreen-btn"
        ],
        "showPlayBtn": [
            4,
            "show-play-btn"
        ],
        "showCenterPlayBtn": [
            4,
            "show-center-play-btn"
        ],
        "showMuteBtn": [
            4,
            "show-mute-btn"
        ],
        "danmuList": [
            16
        ],
        "danmuBtn": [
            4,
            "danmu-btn"
        ],
        "enableDanmu": [
            4,
            "enable-danmu"
        ],
        "enablePlayGesture": [
            4,
            "enable-play-gesture"
        ],
        "enableProgressGesture": [
            4,
            "enable-progress-gesture"
        ],
        "vslideGesture": [
            4,
            "vslide-gesture"
        ],
        "vslideGestureInFullscreen": [
            4,
            "vslide-gesture-in-fullscreen"
        ],
        "nativeProps": [
            16
        ],
        "_duration": [
            32
        ],
        "_enableDanmu": [
            32
        ],
        "isPlaying": [
            32
        ],
        "isFirst": [
            32
        ],
        "isFullScreen": [
            32
        ],
        "fullScreenTimestamp": [
            32
        ],
        "isMute": [
            32
        ],
        "getHlsObject": [
            64
        ],
        "play": [
            64
        ],
        "pause": [
            64
        ],
        "stop": [
            64
        ],
        "seek": [
            64
        ],
        "requestFullScreen": [
            64
        ],
        "exitFullScreen": [
            64
        ]
    },
    [
        [
            5,
            "touchmove",
            "onDocumentTouchMove"
        ],
        [
            5,
            "touchend",
            "onDocumentTouchEnd"
        ],
        [
            5,
            "touchcancel",
            "onDocumentTouchEnd"
        ]
    ]
]);
function defineCustomElement$192() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-video-core",
        "taro-video-control",
        "taro-video-danmu"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-video-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, Video);
                }
                break;
            case "taro-video-control":
                if (!customElements.get(tagName)) {
                    defineCustomElement94();
                }
                break;
            case "taro-video-danmu":
                if (!customElements.get(tagName)) {
                    defineCustomElement96();
                }
                break;
        }
    });
}
var defineCustomElement97 = defineCustomElement$192;
// node_modules/@tarojs/components/dist/components/taro-video-danmu.js
var defineCustomElement98 = defineCustomElement96;
// node_modules/@tarojs/components/dist/components/taro-view-core.js
var indexCss23 = "taro-view-core{display:block}";
var View = proxyCustomElement(class extends H {
    onTouchStart() {
        if (this.hoverClass) {
            this.touch = true;
            setTimeout(()=>{
                if (this.touch) {
                    this.hover = true;
                }
            }, this.hoverStartTime);
        }
        this.timeoutEvent = setTimeout(()=>{
            this.onLongPress.emit();
        }, 350);
        this.startTime = Date.now();
    }
    onTouchMove() {
        clearTimeout(this.timeoutEvent);
    }
    onTouchEnd() {
        const spanTime = Date.now() - this.startTime;
        if (spanTime < 350) {
            clearTimeout(this.timeoutEvent);
        }
        if (this.hoverClass) {
            this.touch = false;
            setTimeout(()=>{
                if (!this.touch) {
                    this.hover = false;
                }
            }, this.hoverStayTime);
        }
    }
    componentDidRender() {
        handleStencilNodes(this.el);
    }
    render() {
        const cls = classnames({
            [`${this.hoverClass}`]: this.hover
        });
        let attr = {};
        if (!!this.animation) {
            attr["animation"] = this.animation;
            attr["data-animation"] = this.animation;
        }
        return h(Host, Object.assign({
            class: cls
        }, attr), h("slot", null));
    }
    get el() {
        return this;
    }
    static get style() {
        return indexCss23;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLongPress = createEvent(this, "longpress", 7);
        this.startTime = 0;
        this.animation = void 0;
        this.hoverClass = void 0;
        this.hoverStartTime = 50;
        this.hoverStayTime = 400;
        this.hover = false;
        this.touch = false;
    }
}, [
    4,
    "taro-view-core",
    {
        "animation": [
            1
        ],
        "hoverClass": [
            1,
            "hover-class"
        ],
        "hoverStartTime": [
            2,
            "hover-start-time"
        ],
        "hoverStayTime": [
            2,
            "hover-stay-time"
        ],
        "hover": [
            32
        ],
        "touch": [
            32
        ]
    },
    [
        [
            1,
            "touchstart",
            "onTouchStart"
        ],
        [
            1,
            "touchmove",
            "onTouchMove"
        ],
        [
            1,
            "touchend",
            "onTouchEnd"
        ]
    ]
]);
function defineCustomElement$193() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, View);
                }
                break;
        }
    });
}
var defineCustomElement99 = defineCustomElement$193;
// node_modules/@tarojs/components/dist/components/taro-voip-room-core.js
var VoipRoom = proxyCustomElement(class extends H {
    componentDidLoad() {
        notSupport("VoipRoom", this);
    }
    render() {
        return h(Host, null);
    }
    constructor(){
        super();
        this.__registerHost();
    }
}, [
    0,
    "taro-voip-room-core"
]);
function defineCustomElement$194() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-voip-room-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-voip-room-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, VoipRoom);
                }
                break;
        }
    });
}
var defineCustomElement100 = defineCustomElement$194;
// node_modules/@tarojs/components/dist/components/taro-web-view-core.js
var indexCss24 = "iframe{border:none}.taro-webview{z-index:999;width:100%;height:100%;position:fixed;top:0;bottom:0}";
var WebView = proxyCustomElement(class extends H {
    render() {
        const { src, onLoad: onLoad2, onError: onError2 } = this;
        return h("iframe", {
            class: "taro-webview",
            onLoad: (e)=>{
                e.stopPropagation();
                onLoad2.emit({
                    src
                });
            },
            onError: (e)=>{
                e.stopPropagation();
                onError2.emit({
                    src
                });
            },
            src
        });
    }
    static get style() {
        return indexCss24;
    }
    constructor(){
        super();
        this.__registerHost();
        this.onLoad = createEvent(this, "load", 7);
        this.onError = createEvent(this, "error", 7);
        this.src = void 0;
    }
}, [
    0,
    "taro-web-view-core",
    {
        "src": [
            1
        ]
    }
]);
function defineCustomElement$195() {
    if (typeof customElements === "undefined") {
        return;
    }
    const components = [
        "taro-web-view-core"
    ];
    components.forEach((tagName)=>{
        switch(tagName){
            case "taro-web-view-core":
                if (!customElements.get(tagName)) {
                    customElements.define(tagName, WebView);
                }
                break;
        }
    });
}
var defineCustomElement101 = defineCustomElement$195;
// node_modules/@tarojs/router/node_modules/query-string/base.js
var base_exports2 = {};
(0,_chunk_KXQ2QJJZ_js__WEBPACK_IMPORTED_MODULE_2__.__export)(base_exports2, {
    exclude: ()=>exclude2,
    extract: ()=>extract2,
    parse: ()=>parse2,
    parseUrl: ()=>parseUrl2,
    pick: ()=>pick2,
    stringify: ()=>stringify3,
    stringifyUrl: ()=>stringifyUrl2
});
// node_modules/@tarojs/router/node_modules/decode-uri-component/index.js
var token2 = "%[a-f0-9]{2}";
var singleMatcher2 = new RegExp("(" + token2 + ")|([^%]+?)", "gi");
var multiMatcher2 = new RegExp("(" + token2 + ")+", "gi");
function decodeComponents2(components, split2) {
    try {
        return [
            decodeURIComponent(components.join(""))
        ];
    } catch (e) {}
    if (components.length === 1) {
        return components;
    }
    split2 = split2 || 1;
    const left = components.slice(0, split2);
    const right = components.slice(split2);
    return Array.prototype.concat.call([], decodeComponents2(left), decodeComponents2(right));
}
function decode4(input) {
    try {
        return decodeURIComponent(input);
    } catch (e) {
        let tokens = input.match(singleMatcher2) || [];
        for(let i2 = 1; i2 < tokens.length; i2++){
            input = decodeComponents2(tokens, i2).join("");
            tokens = input.match(singleMatcher2) || [];
        }
        return input;
    }
}
function customDecodeURIComponent2(input) {
    const replaceMap = {
        "%FE%FF": "\uFFFD\uFFFD",
        "%FF%FE": "\uFFFD\uFFFD"
    };
    let match2 = multiMatcher2.exec(input);
    while(match2){
        try {
            replaceMap[match2[0]] = decodeURIComponent(match2[0]);
        } catch (e) {
            const result = decode4(match2[0]);
            if (result !== match2[0]) {
                replaceMap[match2[0]] = result;
            }
        }
        match2 = multiMatcher2.exec(input);
    }
    replaceMap["%C2"] = "\uFFFD";
    const entries = Object.keys(replaceMap);
    for (const key of entries){
        input = input.replace(new RegExp(key, "g"), replaceMap[key]);
    }
    return input;
}
function decodeUriComponent2(encodedURI) {
    if (typeof encodedURI !== "string") {
        throw new TypeError("Expected `encodedURI` to be of type `string`, got `" + typeof encodedURI + "`");
    }
    try {
        return decodeURIComponent(encodedURI);
    } catch (e) {
        return customDecodeURIComponent2(encodedURI);
    }
}
// node_modules/@tarojs/router/node_modules/query-string/base.js
var isNullOrUndefined2 = (value)=>value === null || value === void 0;
var strictUriEncode2 = (string2)=>encodeURIComponent(string2).replaceAll(/[!'()*]/g, (x)=>`%${x.charCodeAt(0).toString(16).toUpperCase()}`);
var encodeFragmentIdentifier2 = Symbol("encodeFragmentIdentifier");
function encoderForArrayFormat2(options3) {
    switch(options3.arrayFormat){
        case "index":
            {
                return (key)=>(result, value)=>{
                        const index = result.length;
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode2(key, options3),
                                    "[",
                                    index,
                                    "]"
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode2(key, options3),
                                "[",
                                encode2(index, options3),
                                "]=",
                                encode2(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "bracket":
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode2(key, options3),
                                    "[]"
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode2(key, options3),
                                "[]=",
                                encode2(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "colon-list-separator":
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                [
                                    encode2(key, options3),
                                    ":list="
                                ].join("")
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode2(key, options3),
                                ":list=",
                                encode2(value, options3)
                            ].join("")
                        ];
                    };
            }
        case "comma":
        case "separator":
        case "bracket-separator":
            {
                const keyValueSeparator = options3.arrayFormat === "bracket-separator" ? "[]=" : "=";
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        value = value === null ? "" : value;
                        if (result.length === 0) {
                            return [
                                [
                                    encode2(key, options3),
                                    keyValueSeparator,
                                    encode2(value, options3)
                                ].join("")
                            ];
                        }
                        return [
                            [
                                result,
                                encode2(value, options3)
                            ].join(options3.arrayFormatSeparator)
                        ];
                    };
            }
        default:
            {
                return (key)=>(result, value)=>{
                        if (value === void 0 || options3.skipNull && value === null || options3.skipEmptyString && value === "") {
                            return result;
                        }
                        if (value === null) {
                            return [
                                ...result,
                                encode2(key, options3)
                            ];
                        }
                        return [
                            ...result,
                            [
                                encode2(key, options3),
                                "=",
                                encode2(value, options3)
                            ].join("")
                        ];
                    };
            }
    }
}
function parserForArrayFormat2(options3) {
    let result;
    switch(options3.arrayFormat){
        case "index":
            {
                return (key, value, accumulator)=>{
                    result = /\[(\d*)]$/.exec(key);
                    key = key.replace(/\[\d*]$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = {};
                    }
                    accumulator[key][result[1]] = value;
                };
            }
        case "bracket":
            {
                return (key, value, accumulator)=>{
                    result = /(\[])$/.exec(key);
                    key = key.replace(/\[]$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = [
                            value
                        ];
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        value
                    ];
                };
            }
        case "colon-list-separator":
            {
                return (key, value, accumulator)=>{
                    result = /(:list)$/.exec(key);
                    key = key.replace(/:list$/, "");
                    if (!result) {
                        accumulator[key] = value;
                        return;
                    }
                    if (accumulator[key] === void 0) {
                        accumulator[key] = [
                            value
                        ];
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        value
                    ];
                };
            }
        case "comma":
        case "separator":
            {
                return (key, value, accumulator)=>{
                    const isArray2 = typeof value === "string" && value.includes(options3.arrayFormatSeparator);
                    const newValue = isArray2 ? value.split(options3.arrayFormatSeparator).map((item)=>decode5(item, options3)) : value === null ? value : decode5(value, options3);
                    accumulator[key] = newValue;
                };
            }
        case "bracket-separator":
            {
                return (key, value, accumulator)=>{
                    const isArray2 = /(\[])$/.test(key);
                    key = key.replace(/\[]$/, "");
                    if (!isArray2) {
                        accumulator[key] = value ? decode5(value, options3) : value;
                        return;
                    }
                    const arrayValue = value === null ? [] : decode5(value, options3).split(options3.arrayFormatSeparator);
                    if (accumulator[key] === void 0) {
                        accumulator[key] = arrayValue;
                        return;
                    }
                    accumulator[key] = [
                        ...accumulator[key],
                        ...arrayValue
                    ];
                };
            }
        default:
            {
                return (key, value, accumulator)=>{
                    if (accumulator[key] === void 0) {
                        accumulator[key] = value;
                        return;
                    }
                    accumulator[key] = [
                        ...[
                            accumulator[key]
                        ].flat(),
                        value
                    ];
                };
            }
    }
}
function validateArrayFormatSeparator2(value) {
    if (typeof value !== "string" || value.length !== 1) {
        throw new TypeError("arrayFormatSeparator must be single character string");
    }
}
function encode2(value, options3) {
    if (options3.encode) {
        return options3.strict ? strictUriEncode2(value) : encodeURIComponent(value);
    }
    return value;
}
function decode5(value, options3) {
    if (options3.decode) {
        return decodeUriComponent2(value);
    }
    return value;
}
function keysSorter2(input) {
    if (Array.isArray(input)) {
        return input.sort();
    }
    if (typeof input === "object") {
        return keysSorter2(Object.keys(input)).sort((a, b)=>Number(a) - Number(b)).map((key)=>input[key]);
    }
    return input;
}
function removeHash2(input) {
    const hashStart = input.indexOf("#");
    if (hashStart !== -1) {
        input = input.slice(0, hashStart);
    }
    return input;
}
function getHash2(url) {
    let hash = "";
    const hashStart = url.indexOf("#");
    if (hashStart !== -1) {
        hash = url.slice(hashStart);
    }
    return hash;
}
function parseValue2(value, options3, type) {
    if (type === "string" && typeof value === "string") {
        return value;
    }
    if (typeof type === "function" && typeof value === "string") {
        return type(value);
    }
    if (type === "boolean" && value === null) {
        return true;
    }
    if (type === "boolean" && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
    }
    if (type === "boolean" && value !== null && (value.toLowerCase() === "1" || value.toLowerCase() === "0")) {
        return value.toLowerCase() === "1";
    }
    if (type === "string[]" && options3.arrayFormat !== "none" && typeof value === "string") {
        return [
            value
        ];
    }
    if (type === "number[]" && options3.arrayFormat !== "none" && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return [
            Number(value)
        ];
    }
    if (type === "number" && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return Number(value);
    }
    if (options3.parseBooleans && value !== null && (value.toLowerCase() === "true" || value.toLowerCase() === "false")) {
        return value.toLowerCase() === "true";
    }
    if (options3.parseNumbers && !Number.isNaN(Number(value)) && typeof value === "string" && value.trim() !== "") {
        return Number(value);
    }
    return value;
}
function extract2(input) {
    input = removeHash2(input);
    const queryStart = input.indexOf("?");
    if (queryStart === -1) {
        return "";
    }
    return input.slice(queryStart + 1);
}
function parse2(query, options3) {
    options3 = _object_spread({
        decode: true,
        sort: true,
        arrayFormat: "none",
        arrayFormatSeparator: ",",
        parseNumbers: false,
        parseBooleans: false,
        types: /* @__PURE__ */ Object.create(null)
    }, options3);
    validateArrayFormatSeparator2(options3.arrayFormatSeparator);
    const formatter = parserForArrayFormat2(options3);
    const returnValue = /* @__PURE__ */ Object.create(null);
    if (typeof query !== "string") {
        return returnValue;
    }
    query = query.trim().replace(/^[?#&]/, "");
    if (!query) {
        return returnValue;
    }
    for (const parameter of query.split("&")){
        if (parameter === "") {
            continue;
        }
        const parameter_ = options3.decode ? parameter.replaceAll("+", " ") : parameter;
        let [key, value] = splitOnFirst(parameter_, "=");
        if (key === void 0) {
            key = parameter_;
        }
        value = value === void 0 ? null : [
            "comma",
            "separator",
            "bracket-separator"
        ].includes(options3.arrayFormat) ? value : decode5(value, options3);
        formatter(decode5(key, options3), value, returnValue);
    }
    for (const [key, value] of Object.entries(returnValue)){
        if (typeof value === "object" && value !== null && options3.types[key] !== "string") {
            for (const [key2, value2] of Object.entries(value)){
                const typeOption = options3.types[key];
                const type = typeof typeOption === "function" ? typeOption : typeOption ? typeOption.replace("[]", "") : void 0;
                value[key2] = parseValue2(value2, options3, type);
            }
        } else if (typeof value === "object" && value !== null && options3.types[key] === "string") {
            returnValue[key] = Object.values(value).join(options3.arrayFormatSeparator);
        } else {
            returnValue[key] = parseValue2(value, options3, options3.types[key]);
        }
    }
    if (options3.sort === false) {
        return returnValue;
    }
    return (options3.sort === true ? Object.keys(returnValue).sort() : Object.keys(returnValue).sort(options3.sort)).reduce((result, key)=>{
        const value = returnValue[key];
        result[key] = Boolean(value) && typeof value === "object" && !Array.isArray(value) ? keysSorter2(value) : value;
        return result;
    }, /* @__PURE__ */ Object.create(null));
}
function stringify3(object2, options3) {
    if (!object2) {
        return "";
    }
    options3 = _object_spread({
        encode: true,
        strict: true,
        arrayFormat: "none",
        arrayFormatSeparator: ","
    }, options3);
    validateArrayFormatSeparator2(options3.arrayFormatSeparator);
    const shouldFilter = (key)=>options3.skipNull && isNullOrUndefined2(object2[key]) || options3.skipEmptyString && object2[key] === "";
    const formatter = encoderForArrayFormat2(options3);
    const objectCopy = {};
    for (const [key, value] of Object.entries(object2)){
        if (!shouldFilter(key)) {
            objectCopy[key] = value;
        }
    }
    const keys2 = Object.keys(objectCopy);
    if (options3.sort !== false) {
        keys2.sort(options3.sort);
    }
    return keys2.map((key)=>{
        let value = object2[key];
        if (options3.replacer) {
            value = options3.replacer(key, value);
            if (value === void 0) {
                return "";
            }
        }
        if (value === void 0) {
            return "";
        }
        if (value === null) {
            return encode2(key, options3);
        }
        if (Array.isArray(value)) {
            if (value.length === 0 && options3.arrayFormat === "bracket-separator") {
                return encode2(key, options3) + "[]";
            }
            let processedArray = value;
            if (options3.replacer) {
                processedArray = value.map((item, index)=>options3.replacer(`${key}[${index}]`, item)).filter((item)=>item !== void 0);
            }
            return processedArray.reduce(formatter(key), []).join("&");
        }
        return encode2(key, options3) + "=" + encode2(value, options3);
    }).filter((x)=>x.length > 0).join("&");
}
function parseUrl2(url, options3) {
    var _url__split;
    options3 = _object_spread({
        decode: true
    }, options3);
    let [url_, hash] = splitOnFirst(url, "#");
    if (url_ === void 0) {
        url_ = url;
    }
    var _url__split_;
    return _object_spread({
        url: (_url__split_ = url_ === null || url_ === void 0 ? void 0 : (_url__split = url_.split("?")) === null || _url__split === void 0 ? void 0 : _url__split[0]) !== null && _url__split_ !== void 0 ? _url__split_ : "",
        query: parse2(extract2(url), options3)
    }, options3 && options3.parseFragmentIdentifier && hash ? {
        fragmentIdentifier: decode5(hash, options3)
    } : {});
}
function stringifyUrl2(object2, options3) {
    options3 = _object_spread({
        encode: true,
        strict: true,
        [encodeFragmentIdentifier2]: true
    }, options3);
    const url = removeHash2(object2.url).split("?")[0] || "";
    const queryFromUrl = extract2(object2.url);
    const query = _object_spread({}, parse2(queryFromUrl, _object_spread({
        sort: false
    }, options3)), object2.query);
    let queryString = stringify3(query, options3);
    queryString && (queryString = `?${queryString}`);
    let hash = getHash2(object2.url);
    if (typeof object2.fragmentIdentifier === "string") {
        const urlObjectForFragmentEncode = new URL(url);
        urlObjectForFragmentEncode.hash = object2.fragmentIdentifier;
        hash = options3[encodeFragmentIdentifier2] ? urlObjectForFragmentEncode.hash : `#${object2.fragmentIdentifier}`;
    }
    return `${url}${queryString}${hash}`;
}
function pick2(input, filter2, options3) {
    options3 = _object_spread({
        parseFragmentIdentifier: true,
        [encodeFragmentIdentifier2]: false
    }, options3);
    const { url, query, fragmentIdentifier } = parseUrl2(input, options3);
    return stringifyUrl2({
        url,
        query: includeKeys(query, filter2),
        fragmentIdentifier
    }, options3);
}
function exclude2(input, filter2, options3) {
    const exclusionFilter = Array.isArray(filter2) ? (key)=>!filter2.includes(key) : (key, value)=>!filter2(key, value);
    return pick2(input, exclusionFilter, options3);
}
// node_modules/@tarojs/router/node_modules/query-string/index.js
var query_string_default2 = base_exports2;
// node_modules/path-to-regexp/dist.es2015/index.js
function lexer(str) {
    var tokens = [];
    var i2 = 0;
    while(i2 < str.length){
        var char = str[i2];
        if (char === "*" || char === "+" || char === "?") {
            tokens.push({
                type: "MODIFIER",
                index: i2,
                value: str[i2++]
            });
            continue;
        }
        if (char === "\\") {
            tokens.push({
                type: "ESCAPED_CHAR",
                index: i2++,
                value: str[i2++]
            });
            continue;
        }
        if (char === "{") {
            tokens.push({
                type: "OPEN",
                index: i2,
                value: str[i2++]
            });
            continue;
        }
        if (char === "}") {
            tokens.push({
                type: "CLOSE",
                index: i2,
                value: str[i2++]
            });
            continue;
        }
        if (char === ":") {
            var name = "";
            var j = i2 + 1;
            while(j < str.length){
                var code = str.charCodeAt(j);
                if (// `0-9`
                code >= 48 && code <= 57 || // `A-Z`
                code >= 65 && code <= 90 || // `a-z`
                code >= 97 && code <= 122 || // `_`
                code === 95) {
                    name += str[j++];
                    continue;
                }
                break;
            }
            if (!name) throw new TypeError("Missing parameter name at ".concat(i2));
            tokens.push({
                type: "NAME",
                index: i2,
                value: name
            });
            i2 = j;
            continue;
        }
        if (char === "(") {
            var count = 1;
            var pattern = "";
            var j = i2 + 1;
            if (str[j] === "?") {
                throw new TypeError('Pattern cannot start with "?" at '.concat(j));
            }
            while(j < str.length){
                if (str[j] === "\\") {
                    pattern += str[j++] + str[j++];
                    continue;
                }
                if (str[j] === ")") {
                    count--;
                    if (count === 0) {
                        j++;
                        break;
                    }
                } else if (str[j] === "(") {
                    count++;
                    if (str[j + 1] !== "?") {
                        throw new TypeError("Capturing groups are not allowed at ".concat(j));
                    }
                }
                pattern += str[j++];
            }
            if (count) throw new TypeError("Unbalanced pattern at ".concat(i2));
            if (!pattern) throw new TypeError("Missing pattern at ".concat(i2));
            tokens.push({
                type: "PATTERN",
                index: i2,
                value: pattern
            });
            i2 = j;
            continue;
        }
        tokens.push({
            type: "CHAR",
            index: i2,
            value: str[i2++]
        });
    }
    tokens.push({
        type: "END",
        index: i2,
        value: ""
    });
    return tokens;
}
function parse3(str, options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var tokens = lexer(str);
    var _a = options3.prefixes, prefixes2 = _a === void 0 ? "./" : _a, _b = options3.delimiter, delimiter = _b === void 0 ? "/#?" : _b;
    var result = [];
    var key = 0;
    var i2 = 0;
    var path = "";
    var tryConsume = function(type) {
        if (i2 < tokens.length && tokens[i2].type === type) return tokens[i2++].value;
    };
    var mustConsume = function(type) {
        var value2 = tryConsume(type);
        if (value2 !== void 0) return value2;
        var _a2 = tokens[i2], nextType = _a2.type, index = _a2.index;
        throw new TypeError("Unexpected ".concat(nextType, " at ").concat(index, ", expected ").concat(type));
    };
    var consumeText = function() {
        var result2 = "";
        var value2;
        while(value2 = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR")){
            result2 += value2;
        }
        return result2;
    };
    var isSafe = function(value2) {
        for(var _i = 0, delimiter_1 = delimiter; _i < delimiter_1.length; _i++){
            var char2 = delimiter_1[_i];
            if (value2.indexOf(char2) > -1) return true;
        }
        return false;
    };
    var safePattern = function(prefix2) {
        var prev = result[result.length - 1];
        var prevText = prefix2 || (prev && typeof prev === "string" ? prev : "");
        if (prev && !prevText) {
            throw new TypeError('Must have text between two parameters, missing text after "'.concat(prev.name, '"'));
        }
        if (!prevText || isSafe(prevText)) return "[^".concat(escapeString(delimiter), "]+?");
        return "(?:(?!".concat(escapeString(prevText), ")[^").concat(escapeString(delimiter), "])+?");
    };
    while(i2 < tokens.length){
        var char = tryConsume("CHAR");
        var name = tryConsume("NAME");
        var pattern = tryConsume("PATTERN");
        if (name || pattern) {
            var prefix = char || "";
            if (prefixes2.indexOf(prefix) === -1) {
                path += prefix;
                prefix = "";
            }
            if (path) {
                result.push(path);
                path = "";
            }
            result.push({
                name: name || key++,
                prefix,
                suffix: "",
                pattern: pattern || safePattern(prefix),
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        var value = char || tryConsume("ESCAPED_CHAR");
        if (value) {
            path += value;
            continue;
        }
        if (path) {
            result.push(path);
            path = "";
        }
        var open = tryConsume("OPEN");
        if (open) {
            var prefix = consumeText();
            var name_1 = tryConsume("NAME") || "";
            var pattern_1 = tryConsume("PATTERN") || "";
            var suffix = consumeText();
            mustConsume("CLOSE");
            result.push({
                name: name_1 || (pattern_1 ? key++ : ""),
                pattern: name_1 && !pattern_1 ? safePattern(prefix) : pattern_1,
                prefix,
                suffix,
                modifier: tryConsume("MODIFIER") || ""
            });
            continue;
        }
        mustConsume("END");
    }
    return result;
}
function match(str, options3) {
    var keys2 = [];
    var re = pathToRegexp(str, keys2, options3);
    return regexpToFunction(re, keys2, options3);
}
function regexpToFunction(re, keys2, options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _a = options3.decode, decode7 = _a === void 0 ? function(x) {
        return x;
    } : _a;
    return function(pathname) {
        var m = re.exec(pathname);
        if (!m) return false;
        var path = m[0], index = m.index;
        var params = /* @__PURE__ */ Object.create(null);
        var _loop_1 = function(i3) {
            if (m[i3] === void 0) return "continue";
            var key = keys2[i3 - 1];
            if (key.modifier === "*" || key.modifier === "+") {
                params[key.name] = m[i3].split(key.prefix + key.suffix).map(function(value) {
                    return decode7(value, key);
                });
            } else {
                params[key.name] = decode7(m[i3], key);
            }
        };
        for(var i2 = 1; i2 < m.length; i2++){
            _loop_1(i2);
        }
        return {
            path,
            index,
            params
        };
    };
}
function escapeString(str) {
    return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
}
function flags(options3) {
    return options3 && options3.sensitive ? "" : "i";
}
function regexpToRegexp(path, keys2) {
    if (!keys2) return path;
    var groupsRegex = /\((?:\?<(.*?)>)?(?!\?)/g;
    var index = 0;
    var execResult = groupsRegex.exec(path.source);
    while(execResult){
        keys2.push({
            // Use parenthesized substring match if available, index otherwise
            name: execResult[1] || index++,
            prefix: "",
            suffix: "",
            modifier: "",
            pattern: ""
        });
        execResult = groupsRegex.exec(path.source);
    }
    return path;
}
function arrayToRegexp(paths, keys2, options3) {
    var parts = paths.map(function(path) {
        return pathToRegexp(path, keys2, options3).source;
    });
    return new RegExp("(?:".concat(parts.join("|"), ")"), flags(options3));
}
function stringToRegexp(path, keys2, options3) {
    return tokensToRegexp(parse3(path, options3), keys2, options3);
}
function tokensToRegexp(tokens, keys2, options3) {
    if (options3 === void 0) {
        options3 = {};
    }
    var _a = options3.strict, strict = _a === void 0 ? false : _a, _b = options3.start, start = _b === void 0 ? true : _b, _c = options3.end, end = _c === void 0 ? true : _c, _d = options3.encode, encode3 = _d === void 0 ? function(x) {
        return x;
    } : _d, _e = options3.delimiter, delimiter = _e === void 0 ? "/#?" : _e, _f = options3.endsWith, endsWith = _f === void 0 ? "" : _f;
    var endsWithRe = "[".concat(escapeString(endsWith), "]|$");
    var delimiterRe = "[".concat(escapeString(delimiter), "]");
    var route = start ? "^" : "";
    for(var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++){
        var token3 = tokens_1[_i];
        if (typeof token3 === "string") {
            route += escapeString(encode3(token3));
        } else {
            var prefix = escapeString(encode3(token3.prefix));
            var suffix = escapeString(encode3(token3.suffix));
            if (token3.pattern) {
                if (keys2) keys2.push(token3);
                if (prefix || suffix) {
                    if (token3.modifier === "+" || token3.modifier === "*") {
                        var mod = token3.modifier === "*" ? "?" : "";
                        route += "(?:".concat(prefix, "((?:").concat(token3.pattern, ")(?:").concat(suffix).concat(prefix, "(?:").concat(token3.pattern, "))*)").concat(suffix, ")").concat(mod);
                    } else {
                        route += "(?:".concat(prefix, "(").concat(token3.pattern, ")").concat(suffix, ")").concat(token3.modifier);
                    }
                } else {
                    if (token3.modifier === "+" || token3.modifier === "*") {
                        throw new TypeError('Can not repeat "'.concat(token3.name, '" without a prefix and suffix'));
                    }
                    route += "(".concat(token3.pattern, ")").concat(token3.modifier);
                }
            } else {
                route += "(?:".concat(prefix).concat(suffix, ")").concat(token3.modifier);
            }
        }
    }
    if (end) {
        if (!strict) route += "".concat(delimiterRe, "?");
        route += !options3.endsWith ? "$" : "(?=".concat(endsWithRe, ")");
    } else {
        var endToken = tokens[tokens.length - 1];
        var isEndDelimited = typeof endToken === "string" ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1 : endToken === void 0;
        if (!strict) {
            route += "(?:".concat(delimiterRe, "(?=").concat(endsWithRe, "))?");
        }
        if (!isEndDelimited) {
            route += "(?=".concat(delimiterRe, "|").concat(endsWithRe, ")");
        }
    }
    return new RegExp(route, flags(options3));
}
function pathToRegexp(path, keys2, options3) {
    if (path instanceof RegExp) return regexpToRegexp(path, keys2);
    if (Array.isArray(path)) return arrayToRegexp(path, keys2, options3);
    return stringToRegexp(path, keys2, options3);
}
// node_modules/universal-router/module.js
function decode6(val) {
    try {
        return decodeURIComponent(val);
    } catch (err) {
        return val;
    }
}
function matchRoute(route, baseUrl, options3, pathname, parentParams) {
    var matchResult;
    var childMatches;
    var childIndex = 0;
    return {
        next: function next(routeToSkip) {
            if (route === routeToSkip) {
                return {
                    done: true,
                    value: false
                };
            }
            if (!matchResult) {
                var rt = route;
                var end = !rt.children;
                if (!rt.match) {
                    rt.match = match(rt.path || "", Object.assign({
                        end
                    }, options3));
                }
                matchResult = rt.match(pathname);
                if (matchResult) {
                    var _matchResult = matchResult, path = _matchResult.path;
                    matchResult.path = !end && path.charAt(path.length - 1) === "/" ? path.substr(1) : path;
                    matchResult.params = Object.assign({}, parentParams, matchResult.params);
                    return {
                        done: false,
                        value: {
                            route,
                            baseUrl,
                            path: matchResult.path,
                            params: matchResult.params
                        }
                    };
                }
            }
            if (matchResult && route.children) {
                while(childIndex < route.children.length){
                    if (!childMatches) {
                        var childRoute = route.children[childIndex];
                        childRoute.parent = route;
                        childMatches = matchRoute(childRoute, baseUrl + matchResult.path, options3, pathname.substr(matchResult.path.length), matchResult.params);
                    }
                    var childMatch = childMatches.next(routeToSkip);
                    if (!childMatch.done) {
                        return {
                            done: false,
                            value: childMatch.value
                        };
                    }
                    childMatches = null;
                    childIndex++;
                }
            }
            return {
                done: true,
                value: false
            };
        }
    };
}
function resolveRoute(context, params) {
    if (typeof context.route.action === "function") {
        return context.route.action(context, params);
    }
    return void 0;
}
function isChildRoute(parentRoute, childRoute) {
    var route = childRoute;
    while(route){
        route = route.parent;
        if (route === parentRoute) {
            return true;
        }
    }
    return false;
}
var UniversalRouter = function() {
    function UniversalRouter2(routes, options3) {
        if (!routes || typeof routes !== "object") {
            throw new TypeError("Invalid routes");
        }
        this.options = Object.assign({
            decode: decode6
        }, options3);
        this.baseUrl = this.options.baseUrl || "";
        this.root = Array.isArray(routes) ? {
            path: "",
            children: routes,
            parent: null
        } : routes;
        this.root.parent = null;
    }
    var _proto = UniversalRouter2.prototype;
    _proto.resolve = function resolve(pathnameOrContext) {
        var _this = this;
        var context = Object.assign({
            router: this
        }, this.options.context, typeof pathnameOrContext === "string" ? {
            pathname: pathnameOrContext
        } : pathnameOrContext);
        var matchResult = matchRoute(this.root, this.baseUrl, this.options, context.pathname.substr(this.baseUrl.length));
        var resolve2 = this.options.resolveRoute || resolveRoute;
        var matches;
        var nextMatches;
        var currentContext = context;
        function next(resume, parent, prevResult) {
            if (parent === void 0) {
                parent = !matches.done && matches.value.route;
            }
            var routeToSkip = prevResult === null && !matches.done && matches.value.route;
            matches = nextMatches || matchResult.next(routeToSkip);
            nextMatches = null;
            if (!resume) {
                if (matches.done || !isChildRoute(parent, matches.value.route)) {
                    nextMatches = matches;
                    return Promise.resolve(null);
                }
            }
            if (matches.done) {
                var error = new Error("Route not found");
                error.status = 404;
                return Promise.reject(error);
            }
            currentContext = Object.assign({}, context, matches.value);
            return Promise.resolve(resolve2(currentContext, matches.value.params)).then(function(result) {
                if (result !== null && result !== void 0) {
                    return result;
                }
                return next(resume, parent, result);
            });
        }
        context["next"] = next;
        return Promise.resolve().then(function() {
            return next(true, _this.root);
        })["catch"](function(error) {
            if (_this.options.errorHandler) {
                return _this.options.errorHandler(error, currentContext);
            }
            throw error;
        });
    };
    return UniversalRouter2;
}();
var module_default = UniversalRouter;
// node_modules/@tarojs/router/dist/index.esm.js
function loadAnimateStyle(ms = 300) {
    const css = `
body {
  /* \u9632\u6B62 iOS \u9875\u9762\u6EDA\u52A8 */
  overflow: hidden;
}
.taro_router > .taro_page {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  background-color: #fff;
  transform: translate(100%, 0);
  transition: transform ${ms}ms;
  z-index: 0;
}

.taro_router > .taro_page.taro_tabbar_page,
.taro_router > .taro_page.taro_page_show.taro_page_stationed {
  transform: none;
  transition: none;
}

.taro_router > .taro_page.taro_page_show {
  transform: translate(0, 0);
}
`;
    addStyle2(css);
}
function loadRouterStyle(enableTabBar, enableWindowScroll, enhanceAnimation) {
    const css = `
  .taro_router {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .taro_page {
    width: 100%;
    height: 100%;
${enableWindowScroll ? "" : `
    overflow-x: hidden;
    overflow-y: scroll;
    max-height: 100vh;
`}
  }
${enableTabBar ? `
  .taro-tabbar__container {
      height:100%;
  }
  .taro-tabbar__panel {
      height: 100%;
  }
  .taro-tabbar__container > .taro-tabbar__panel {
    overflow: hidden;
  }

  .taro-tabbar__container > .taro-tabbar__panel > .taro_page.taro_tabbar_page {
    max-height: calc(100vh - var(--taro-tabbar-height) - constant(safe-area-inset-bottom));
    max-height: calc(100vh - var(--taro-tabbar-height) - env(safe-area-inset-bottom));
  }

` : ""}
${enhanceAnimation ? `.taro_page_shade:has(+.taro_page_stationed),
  .taro_page_shade.taro_tabbar_page,
  .taro_router > .taro_page.taro_page_show.taro_page_stationed:not(.taro_page_shade):not(.taro_tabbar_page):not(:last-child):has(+.taro_page_stationed) {
    display: none;
  }` : ` .taro_page_shade,
  .taro_router > .taro_page.taro_page_show.taro_page_stationed:not(.taro_page_shade):not(.taro_tabbar_page):not(:last-child) {
    display: none;
  }`}
`;
    addStyle2(css);
}
function loadNavigationBarStyle() {
    const css = `
  .taro-navigation-bar-show {
    display: flex;
    background: white;
    position: sticky;
    z-index: 500;
    top: 0;
    padding-bottom: 8px;
    padding-top: calc(env(safe-area-inset-top) + 8px);
    justify-content: center;
    align-items: center;
  }

  .taro-navigation-bar-hide {
    display: none;
  }

  .taro-navigation-bar-title-wrap {
    display: flex;
    height: 24px;
  }

  .taro-navigation-bar-title-wrap > .taro-navigation-bar-loading {
    display: none;
    animation: loading 2s linear infinite;
  }

  .taro-navigation-bar-title-wrap .taro-navigation-bar-loading.taro-navigation-bar-loading-show {
    display: flex;
  }

  .taro-navigation-bar-title-wrap > .taro-navigation-bar-title {
    font-size: 24px;
    height: 24px;
    line-height: 24px;
    max-width: 100px;
    white-space: nowrap;
    overflow: hidden;
    line-height: 24px;
    text-overflow: ellipsis;
  }

  @keyframes loading {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  @keyframes loading {
    from {
      transform: rotate(0deg);
    }
    to {
      transform: rotate(360deg);
    }
  }

  .taro-navigation-bar-no-icon > .taro-navigation-bar-home {
    display: none;
  }

  .taro-navigation-bar-no-icon > .taro-navigation-bar-back {
    display: none;
  }

  .taro-navigation-bar-home-icon > .taro-navigation-bar-home {
    display: flex;
    left: 8px;
    position: absolute;
    width: 24px;
    height: 24px;
  }

  .taro-navigation-bar-back-icon > .taro-navigation-bar-back {
    display: flex;
    left: 8px;
    position: absolute;
    width: 24px;
    height: 24px;
  }
`;
    addStyle2(css);
}
function addStyle2(css) {
    if (!css) return;
    const style = document.createElement("style");
    style.innerHTML = css;
    document.getElementsByTagName("head")[0].appendChild(style);
}
var home_svg_str = `
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M23.8899 12.2737C23.8232 12.3584 23.7237 12.3997 23.6198 12.3974H20.7994V23.5996C20.7994 23.8194 20.6213 24 20.4001 24H14.7994C14.5791 24 14.4002 23.8194 14.4002 23.5996V15.6H9.59963V23.5996C9.59963 23.8194 9.42075 24 9.20033 24H3.59968C3.48981 24 3.38964 23.954 3.31764 23.8811C3.24495 23.8091 3.2004 23.7087 3.2004 23.5996V12.3975H0.398546V12.3967C0.296893 12.396 0.194446 12.3544 0.11579 12.2738C-0.0371146 12.114 -0.0400714 11.864 0.11579 11.7076L11.7201 0.117284C11.8767 -0.0390948 12.1298 -0.0390948 12.2863 0.117284L23.8899 11.7076C24.0465 11.864 24.0265 12.0995 23.8899 12.2737ZM12.0029 0.964625L1.37086 11.5854L3.59968 11.5839V11.5999C3.65537 11.5999 3.70804 11.611 3.75557 11.6307C3.89952 11.692 4.00046 11.8339 4.00046 11.9996V23.1991H8.79955V15.2003C8.79955 14.9789 8.97917 14.8002 9.20033 14.8002H14.7995C15.0207 14.8002 15.2003 14.9789 15.2003 15.2003V23.1991H20.0001V11.9996C20.0001 11.8339 20.1003 11.692 20.2443 11.6307C20.2918 11.611 20.3453 11.5999 20.4001 11.5999V11.5713L22.6193 11.5691L12.0029 0.964625Z" fill="currentColor"/>
</svg>
`;
var back_svg_str = `
<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M17.8206 22.9016L7.45515 11.8756L17.8206 1.09845C18.0598 0.849741 18.0598 0.435233 17.8206 0.186528C17.5814 -0.0621762 17.1827 -0.0621762 16.9435 0.186528L6.1794 11.4611C5.9402 11.7098 5.9402 12.1244 6.1794 12.3731L16.9435 23.8135C17.1827 24.0622 17.5814 24.0622 17.8206 23.8135C18.0598 23.5648 18.0598 23.1503 17.8206 22.9016Z" fill="currentColor"/>
</svg>
`;
var loading_svg_str = `
<svg t="1709608074670" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4741" width="24" height="24"><path d="M256 529.066667H85.333333a17.066667 17.066667 0 1 1 0-34.133334h170.666667a17.066667 17.066667 0 0 1 0 34.133334z" opacity=".278" p-id="4742"></path><path d="M99.84 640a17.066667 17.066667 0 0 1-4.437333-33.553067l164.693333-44.373333a17.066667 17.066667 0 1 1 8.891733 32.9728l-164.693333 44.373333a17.544533 17.544533 0 0 1-4.4544 0.580267z" opacity=".322" p-id="4743"></path><path d="M264.533333 462.523733a16.896 16.896 0 0 1-4.369066-0.580266l-164.693334-43.52a17.0496 17.0496 0 1 1 8.721067-32.989867l164.693333 43.52a17.066667 17.066667 0 1 1-4.352 33.570133z" opacity=".239" p-id="4744"></path><path d="M384.017067 307.2a17.032533 17.032533 0 0 1-14.7968-8.533333l-85.333334-147.626667a17.066667 17.066667 0 0 1 29.559467-17.083733l85.333333 147.626666A17.066667 17.066667 0 0 1 384.017067 307.2z" opacity=".122" p-id="4745"></path><path d="M639.982933 307.2a17.0496 17.0496 0 0 1-14.762666-25.6l85.333333-147.626667a17.066667 17.066667 0 1 1 29.559467 17.066667l-85.333334 147.626667a17.032533 17.032533 0 0 1-14.7968 8.533333z" opacity=".922" p-id="4746"></path><path d="M692.906667 347.306667a17.066667 17.066667 0 0 1-12.117334-29.098667l120.337067-121.173333a17.066667 17.066667 0 1 1 24.234667 24.046933l-120.337067 121.173333a17.1008 17.1008 0 0 1-12.117333 5.051734z" opacity=".878" p-id="4747"></path><path d="M733.883733 401.066667a17.066667 17.066667 0 0 1-8.5504-31.8464l147.626667-85.333334a17.0496 17.0496 0 1 1 17.066667 29.5424l-147.626667 85.333334a16.776533 16.776533 0 0 1-8.516267 2.304z" opacity=".839" p-id="4748"></path><path d="M512 273.066667a17.066667 17.066667 0 0 1-17.066667-17.066667V85.333333a17.066667 17.066667 0 0 1 34.133334 0v170.666667a17.066667 17.066667 0 0 1-17.066667 17.066667z" p-id="4749"></path><path d="M578.577067 281.6a17.066667 17.066667 0 0 1-16.520534-21.418667l43.52-164.693333a17.066667 17.066667 0 0 1 33.006934 8.721067l-43.52 164.693333a17.066667 17.066667 0 0 1-16.4864 12.6976z" opacity=".961" p-id="4750"></path><path d="M445.44 282.453333a17.066667 17.066667 0 0 1-16.469333-12.629333l-44.373334-164.693333a17.066667 17.066667 0 0 1 32.955734-8.891734l44.373333 164.693334a17.066667 17.066667 0 0 1-16.4864 21.521066z" opacity=".078" p-id="4751"></path><path d="M924.177067 640c-1.4848 0-2.9696-0.187733-4.4544-0.580267l-164.693334-44.373333a17.066667 17.066667 0 0 1 8.874667-32.9728l164.693333 44.373333a17.066667 17.066667 0 0 1-4.420266 33.553067z" opacity=".722" p-id="4752"></path><path d="M881.476267 742.4a17.015467 17.015467 0 0 1-8.482134-2.269867l-148.48-85.333333a17.0496 17.0496 0 1 1 16.9984-29.5936l148.48 85.333333a17.0496 17.0496 0 0 1-8.516266 31.863467z" opacity=".678" p-id="4753"></path><path d="M813.226667 830.293333a17.015467 17.015467 0 0 1-12.066134-5.000533l-120.337066-120.337067a17.0496 17.0496 0 1 1 24.132266-24.132266l120.337067 120.337066a17.0496 17.0496 0 0 1-12.066133 29.1328z" opacity=".639" p-id="4754"></path><path d="M938.666667 529.066667H768a17.066667 17.066667 0 1 1 0-34.133334h170.666667a17.066667 17.066667 0 1 1 0 34.133334z" opacity=".761" p-id="4755"></path><path d="M401.066667 941.226667a17.066667 17.066667 0 0 1-16.4864-21.504l44.373333-164.693334a17.066667 17.066667 0 1 1 32.955733 8.874667l-44.373333 164.693333a17.066667 17.066667 0 0 1-16.469333 12.629334z" opacity=".478" p-id="4756"></path><path d="M298.6496 898.56a17.066667 17.066667 0 0 1-14.779733-25.565867l85.333333-148.48a17.083733 17.083733 0 0 1 29.5936 16.9984l-85.333333 148.48a17.032533 17.032533 0 0 1-14.813867 8.567467z" opacity=".439" p-id="4757"></path><path d="M512 955.733333a17.066667 17.066667 0 0 1-17.066667-17.066666V768a17.066667 17.066667 0 1 1 34.133334 0v170.666667a17.066667 17.066667 0 0 1-17.066667 17.066666z" opacity=".522" p-id="4758"></path><path d="M725.3504 898.56a17.032533 17.032533 0 0 1-14.7968-8.533333l-85.333333-147.626667a17.066667 17.066667 0 0 1 29.559466-17.066667l85.333334 147.626667a17.066667 17.066667 0 0 1-14.762667 25.6z" opacity=".6" p-id="4759"></path><path d="M622.062933 942.08c-7.509333 0-14.421333-5.0176-16.469333-12.629333l-44.3904-164.693334a17.066667 17.066667 0 1 1 32.9728-8.874666l44.3904 164.693333a17.066667 17.066667 0 0 1-16.503467 21.504z" opacity=".561" p-id="4760"></path><path d="M759.4496 463.36a17.083733 17.083733 0 0 1-4.420267-33.553067l164.693334-44.373333a17.066667 17.066667 0 0 1 8.874666 32.955733l-164.693333 44.373334a16.657067 16.657067 0 0 1-4.4544 0.597333z" opacity=".702" p-id="4761"></path><path d="M330.24 347.306667a17.015467 17.015467 0 0 1-12.066133-5.000534l-120.32-120.32a17.0496 17.0496 0 1 1 24.132266-24.132266l120.32 120.32a17.0496 17.0496 0 0 1-12.066133 29.1328z" opacity=".161" p-id="4762"></path><path d="M290.116267 401.066667a17.032533 17.032533 0 0 1-8.533334-2.286934l-147.626666-85.333333a17.066667 17.066667 0 1 1 17.083733-29.5424l147.626667 85.333333a17.066667 17.066667 0 0 1-8.5504 31.829334z" opacity=".2" p-id="4763"></path><path d="M142.523733 742.4a17.066667 17.066667 0 0 1-8.567466-31.8464l147.626666-85.333333a17.066667 17.066667 0 1 1 17.083734 29.559466l-147.626667 85.333334a16.930133 16.930133 0 0 1-8.516267 2.286933z" opacity=".361" p-id="4764"></path><path d="M209.92 830.293333a17.066667 17.066667 0 0 1-12.117333-29.098666l120.32-121.173334a17.066667 17.066667 0 0 1 24.2176 24.029867l-120.32 121.1904a16.896 16.896 0 0 1-12.100267 5.051733z" opacity=".4" p-id="4765"></path></svg>
`;
function initNavigationBar(config, container2) {
    if (config.router.mode === "multi") return;
    const navigationBar = document.createElement("div");
    navigationBar.classList.add("taro-navigation-bar-no-icon");
    const navigationBarBackBtn = document.createElement("div");
    navigationBarBackBtn.classList.add("taro-navigation-bar-back");
    const navigationBarHomeBtn = document.createElement("div");
    navigationBarHomeBtn.classList.add("taro-navigation-bar-home");
    navigationBarBackBtn.innerHTML = back_svg_str;
    navigationBarHomeBtn.innerHTML = home_svg_str;
    const navigationBarTitleWrap = document.createElement("div");
    navigationBarTitleWrap.classList.add("taro-navigation-bar-title-wrap");
    const navigationBarLoading = document.createElement("div");
    navigationBarLoading.classList.add("taro-navigation-bar-loading");
    navigationBarLoading.innerHTML = loading_svg_str;
    const navigationBarTitle = document.createElement("div");
    navigationBarTitle.classList.add("taro-navigation-bar-title");
    navigationBarTitleWrap.appendChild(navigationBarLoading);
    navigationBarTitleWrap.appendChild(navigationBarTitle);
    navigationBar.appendChild(navigationBarHomeBtn);
    navigationBar.appendChild(navigationBarBackBtn);
    navigationBar.appendChild(navigationBarTitleWrap);
    navigationBar.id = "taro-navigation-bar";
    container2.insertBefore(navigationBar, container2.firstChild);
    loadNavigationBarStyle();
}
function initTabbar(config, history2) {
    if (config.tabBar == null || config.tabBar.custom) {
        return;
    }
    defineCustomElement88();
    const tabbar = document.createElement("taro-tabbar");
    const homePage = config.entryPagePath || (config.pages ? config.pages[0] : "");
    tabbar.conf = config.tabBar;
    tabbar.conf.homePage = history2.location.pathname === "/" ? homePage : history2.location.pathname;
    const routerConfig = config.router;
    tabbar.conf.mode = routerConfig && routerConfig.mode ? routerConfig.mode : "hash";
    if (routerConfig.customRoutes) {
        tabbar.conf.custom = true;
        tabbar.conf.customRoutes = routerConfig.customRoutes;
    } else {
        tabbar.conf.custom = false;
        tabbar.conf.customRoutes = {};
    }
    if (typeof routerConfig.basename !== "undefined") {
        tabbar.conf.basename = routerConfig.basename;
    }
    const container2 = document.getElementById("container");
    container2 === null || container2 === void 0 ? void 0 : container2.appendChild(tabbar);
    initTabBarApis(config);
}
var RouterConfig = class {
    static set config(e) {
        this.__config = e;
    }
    static get config() {
        return this.__config;
    }
    static get pages() {
        return this.config.pages || [];
    }
    static get router() {
        return this.config.router || {};
    }
    static get mode() {
        return this.router.mode || "hash";
    }
    static get customRoutes() {
        return this.router.customRoutes || {};
    }
    //  basename  customRoutes url  pages 
    static isPage(url = "") {
        return this.pages.findIndex((e)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(e) === url) !== -1;
    }
};
var history;
var basename = "/";
var MpaHistory = class {
    get location() {
        return {
            pathname: window.location.pathname,
            search: window.location.search,
            hash: window.location.hash,
            key: `${window.history.length}`,
            state: window.history.state
        };
    }
    createHref(_to) {
        throw new Error("Method not implemented.");
    }
    parseUrl(to) {
        let url = to.pathname || "";
        if (RouterConfig.isPage((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(url))) {
            url += ".html";
        }
        if (to.search) {
            url += `?${to.search}`;
        }
        if (to.hash) {
            url += to.hash.startsWith("#") ? to.hash : `#${to.hash}`;
        }
        return url;
    }
    push(to, _state = {}) {
        window.location.assign(this.parseUrl(to));
    }
    replace(to, _state = {}) {
        window.location.replace(this.parseUrl(to));
    }
    go(delta) {
        window.history.go(delta);
    }
    listen(listener) {
        function callback(e) {
            if (e.action === "pushState") {
                listener({
                    action: Action.Push,
                    location: this.location
                });
            } else if (e.action === "replaceState") {
                listener({
                    action: Action.Replace,
                    location: this.location
                });
            } else {
                listener({
                    action: Action.Pop,
                    location: this.location
                });
            }
        }
        window.addEventListener("popstate", callback);
        return ()=>{
            window.removeEventListener("popstate", callback);
        };
    }
    block(_blocker) {
        throw new Error("Method not implemented.");
    }
    eventState(action) {
        return (data, unused, url)=>{
            const wrapper = window.history[action](data, unused, url);
            const evt = new Event(action);
            evt.action = action;
            evt.state = data;
            evt.unused = unused;
            evt.url = url;
            window.dispatchEvent(evt);
            return wrapper;
        };
    }
    constructor(){
        this.back = window.history.back;
        this.forward = window.history.forward;
        this.pushState = this.eventState("pushState");
        this.replaceState = this.eventState("replaceState");
    }
};
function setHistory(h2, base = "/") {
    history = h2;
    basename = base;
}
function createMpaHistory(_) {
    return new MpaHistory();
}
function setHistoryMode(mode, base = "/") {
    const options3 = {
        window
    };
    basename = base;
    if (mode === "browser") {
        history = createBrowserHistory(options3);
    } else if (mode === "multi") {
        history = createMpaHistory();
    } else {
        history = createHashHistory(options3);
    }
}
function prependBasename(url = "") {
    return basename.replace(/\/$/, "") + "/" + url.replace(/^\//, "");
}
var Stacks = class {
    set delta(delta) {
        if (delta > 0) {
            this.backDelta = delta;
        } else if (this.backDelta > 0) {
            --this.backDelta;
        } else {
            this.backDelta = 0;
        }
    }
    get delta() {
        return this.backDelta;
    }
    set method(methodName) {
        this.methodName = methodName;
    }
    get method() {
        return this.methodName;
    }
    get length() {
        return this.stacks.length;
    }
    get last() {
        return this.stacks[this.length - 1];
    }
    get() {
        return this.stacks;
    }
    getItem(index) {
        return this.stacks[index];
    }
    getLastIndex(pathname, stateWith = 1) {
        const list2 = [
            ...this.stacks
        ].reverse();
        return list2.findIndex((page, i2)=>{
            var _a;
            return i2 >= stateWith && ((_a = page.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) === pathname;
        });
    }
    getDelta(pathname) {
        if (this.backDelta >= 1) {
            return this.backDelta;
        }
        const index = this.getLastIndex(pathname);
        return index > 0 ? index : 1;
    }
    getPrevIndex(pathname, stateWith = 1) {
        const lastIndex = this.getLastIndex(pathname, stateWith);
        if (lastIndex < 0) {
            return -1;
        }
        return this.length - 1 - lastIndex;
    }
    pop() {
        return this.stacks.pop();
    }
    push(page) {
        return this.stacks.push(page);
    }
    getTabs() {
        return this.tabs;
    }
    pushTab(path) {
        this.tabs[path] = this.last;
        this.pop();
    }
    popTab(path) {
        this.push(this.tabs[path]);
        delete this.tabs[path];
    }
    removeTab(path) {
        delete this.tabs[path];
    }
    constructor(){
        this.stacks = [];
        this.backDelta = 0;
        this.tabs = {};
        this.methodName = "";
    }
};
var stacks = new Stacks();
var isWeixin = ()=>!!navigator.userAgent.match(/\bMicroMessenger\b/ig);
var isDingTalk = ()=>!!navigator.userAgent.match(/\bDingTalk\b/ig);
var preTitle = document.title;
function setMpaTitle(title) {
    if (preTitle === title) return;
    document.title = title;
    preTitle = title;
    if (false) // removed by dead control flow
{}
}
function setTitle(title) {
    _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroH5SetNavigationBarTitle", title);
}
function setNavigationBarStyle(option) {
    _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroH5setNavigationBarColor", option);
}
function setNavigationBarLoading(loading) {
    _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroH5setNavigationBarLoading", loading);
}
var RoutesAlias = class {
    set(customRoutes = {}) {
        for(let key in customRoutes){
            const path = customRoutes[key];
            key = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(key);
            if (typeof path === "string") {
                this.conf.push([
                    key,
                    (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(path)
                ]);
            } else if ((path === null || path === void 0 ? void 0 : path.length) > 0) {
                this.conf.push(...path.map((p)=>[
                        key,
                        (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(p)
                    ]));
            }
        }
    }
    constructor(){
        this.conf = [];
        this.getConfig = (url = "")=>{
            const customRoute = this.conf.filter((arr)=>{
                return arr.includes(url);
            });
            return customRoute[0];
        };
        this.getOrigin = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[0]) || url;
        };
        this.getAlias = (url = "")=>{
            var _a;
            return ((_a = this.getConfig(url)) === null || _a === void 0 ? void 0 : _a[1]) || url;
        };
        this.getAll = (url = "")=>{
            return this.conf.filter((arr)=>arr.includes(url)).reduceRight((p, a)=>{
                p.unshift(a[1]);
                return p;
            }, []);
        };
    }
};
var routesAlias = new RoutesAlias();
var routeEvtChannel = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.EventChannel.routeChannel;
function processNavigateUrl(option) {
    var _a;
    const pathPieces = parsePath(option.url);
    if ((_a = pathPieces.pathname) === null || _a === void 0 ? void 0 : _a.includes("./")) {
        const parts = routesAlias.getOrigin(history.location.pathname).split("/");
        parts.pop();
        pathPieces.pathname.split("/").forEach((item)=>{
            if (item === ".") return;
            item === ".." ? parts.pop() : parts.push(item);
        });
        pathPieces.pathname = parts.join("/");
    }
    pathPieces.pathname = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(pathPieces.pathname);
    pathPieces.pathname = routesAlias.getAlias((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(pathPieces.pathname));
    pathPieces.pathname = prependBasename(pathPieces.pathname);
    if (!pathPieces.search) pathPieces.search = "";
    return pathPieces;
}
function navigate(option, method) {
    return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
        return new Promise((resolve, reject)=>{
            stacks.method = method;
            const { success, complete, fail } = option;
            const unListen = history.listen(()=>{
                const res = {
                    errMsg: `${method}:ok`
                };
                if (method === "navigateTo") {
                    res.eventChannel = routeEvtChannel;
                    routeEvtChannel.addEvents(option.events);
                }
                success === null || success === void 0 ? void 0 : success(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                resolve(res);
                unListen();
            });
            try {
                if ("url" in option) {
                    const pathPieces = processNavigateUrl(option);
                    const state = {
                        timestamp: Date.now()
                    };
                    if (method === "navigateTo") {
                        history.push(pathPieces, state);
                    } else if (method === "redirectTo" || method === "switchTab") {
                        history.replace(pathPieces, state);
                    } else if (method === "reLaunch") {
                        stacks.delta = stacks.length;
                        history.replace(pathPieces, state);
                    }
                } else if (method === "navigateBack") {
                    stacks.delta = option.delta;
                    if (stacks.length > option.delta) {
                        history.go(-option.delta);
                    } else {
                        history.go(1 - stacks.length);
                    }
                }
            } catch (error) {
                const res = {
                    errMsg: `${method}:fail ${error.message || error}`
                };
                fail === null || fail === void 0 ? void 0 : fail(res);
                complete === null || complete === void 0 ? void 0 : complete(res);
                if (fail || complete) {
                    return resolve(res);
                } else {
                    return reject(res);
                }
            }
        });
    });
}
function navigateTo(option) {
    return navigate(option, "navigateTo");
}
function redirectTo(option) {
    return navigate(option, "redirectTo");
}
function navigateBack(option = {
    delta: 1
}) {
    if (!option.delta || option.delta < 1) {
        option.delta = 1;
    }
    return navigate(option, "navigateBack");
}
function switchTab(option) {
    return navigate(option, "switchTab");
}
function reLaunch(option) {
    return navigate(option, "reLaunch");
}
function getCurrentPages() {
    if (RouterConfig.mode === "multi") {
        console.warn("\u591A\u9875\u9762\u8DEF\u7531\u6A21\u5F0F\u4E0D\u652F\u6301\u4F7F\u7528 getCurrentPages \u65B9\u6CD5\uFF01");
    }
    const pages = stacks.get();
    return pages.map((e)=>{
        var _a;
        return Object.assign(Object.assign({}, e), {
            route: ((_a = e.path) === null || _a === void 0 ? void 0 : _a.replace(/\?.*/g, "")) || ""
        });
    });
}
var pageResizeFn;
function bindPageResize(page) {
    pageResizeFn && window.removeEventListener("resize", pageResizeFn);
    pageResizeFn = function() {
        if (page.onResize) {
            const mediaQuery = window.matchMedia("(orientation: portrait)");
            page.onResize({
                deviceOrientation: mediaQuery.matches ? "portrait" : "landscape",
                size: {
                    windowHeight: window.innerHeight,
                    windowWidth: window.innerWidth,
                    screenHeight: window.screen.height,
                    screenWidth: window.screen.width
                }
            });
        }
    };
    window.addEventListener("resize", pageResizeFn, false);
}
var pageScrollFn = {};
var pageDOM = window;
function bindPageScroll(page, scrollEl, distance = 50) {
    var _a;
    const pagePath = page ? page === null || page === void 0 ? void 0 : page.path : (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.router) === null || _a === void 0 ? void 0 : _a.path;
    pageScrollFn[pagePath] && scrollEl.removeEventListener("scroll", pageScrollFn[pagePath]);
    pageDOM = scrollEl;
    let isReachBottom = false;
    pageScrollFn[pagePath] = function() {
        var _a2;
        (_a2 = page.onPageScroll) === null || _a2 === void 0 ? void 0 : _a2.call(page, {
            scrollTop: pageDOM instanceof Window ? window.scrollY : pageDOM.scrollTop
        });
        if (isReachBottom && getOffset() > distance) {
            isReachBottom = false;
        }
        if (page.onReachBottom && !isReachBottom && getOffset() < distance) {
            isReachBottom = true;
            page.onReachBottom();
        }
    };
    pageDOM.addEventListener("scroll", pageScrollFn[pagePath], false);
}
function getOffset() {
    if (pageDOM instanceof Window) {
        return document.documentElement.scrollHeight - window.scrollY - window.innerHeight;
    } else {
        return pageDOM.scrollHeight - pageDOM.scrollTop - pageDOM.clientHeight;
    }
}
var MultiPageHandler = class {
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        return this.config.route;
    }
    get isTabBar() {
        var _a;
        const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(this.pathname, this.basename));
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>t.pagePath === pagePath);
    }
    get search() {
        return location.search.substr(1);
    }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = true;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === "boolean") {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win3 = window;
        win3.__taroAppConfig || (win3.__taroAppConfig = {});
        win3.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? query_string_default2.parse(search) : {};
        return Object.assign(Object.assign({}, query), options3);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === "string") {
            style = this.pageConfig.navigationStyle;
        }
        return style !== "custom";
    }
    mount() {
        setHistory(this.history, this.basename);
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll);
    }
    onReady(page, onLoad2 = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el["componentOnReady"];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(()=>{
                    requestAnimationFrame(()=>{
                        var _a2;
                        (_a2 = page.onReady) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                        pageEl["__isReady"] = true;
                    });
                });
            } else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl["__isReady"] = true;
            }
            onLoad2 && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}) {
        var _a;
        if (!page) return;
        (_a = page.onLoad) === null || _a === void 0 ? void 0 : _a.call(page, this.getQuery("", page.options), ()=>{
            var _a2;
            const pageEl = this.getPageContainer(page);
            if (this.isTabBar) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page");
            }
            if (this.isDefaultNavigationStyle()) {
                pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_navigation_page");
            }
            this.onReady(page, true);
            (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        });
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll) return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
    triggerRouterChange() {
        setTimeout(()=>{
            _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__afterTaroRouterChange", {
                toLocation: {
                    path: this.pathname
                }
            });
        }, 0);
    }
    constructor(config, history2){
        this.history = history2;
        this.config = config;
        this.mount();
    }
};
var createStampId$1 = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.incrementId)();
var launchStampId$1 = createStampId$1();
function createMultiRouter(history2, app, config, framework) {
    return (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function*() {
        var _a, _b, _c, _d, _e, _f;
        if (typeof app.onUnhandledRejection === "function") {
            window.addEventListener("unhandledrejection", app.onUnhandledRejection);
        }
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.on("__taroH5SetNavigationBarTitle", setMpaTitle);
        RouterConfig.config = config;
        const handler = new MultiPageHandler(config, history2);
        const launchParam = {
            path: config.pageName,
            // 
            query: handler.getQuery(launchStampId$1),
            scene: 0,
            shareTicket: "",
            referrerInfo: {}
        };
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroRouterLaunch", launchParam);
        (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
        app.onError && window.addEventListener("error", (e)=>{
            var _a2;
            return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
        });
        const pathName = config.pageName;
        const pageConfig = handler.pageConfig;
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroRouterChange", {
            toLocation: {
                path: pathName
            }
        });
        let element;
        try {
            element = yield (_b = pageConfig.load) === null || _b === void 0 ? void 0 : _b.call(pageConfig);
            if (element instanceof Array) {
                element = element[0];
            }
        } catch (error) {
            throw new Error(error);
        }
        if (!element) return;
        let enablePullDownRefresh = ((_c = config === null || config === void 0 ? void 0 : config.window) === null || _c === void 0 ? void 0 : _c.enablePullDownRefresh) || false;
        if (pageConfig) {
            setMpaTitle((_d = pageConfig.navigationBarTitleText) !== null && _d !== void 0 ? _d : document.title);
            if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                enablePullDownRefresh = pageConfig.enablePullDownRefresh;
            }
        }
        const el = (_e = element.default) !== null && _e !== void 0 ? _e : element;
        const loadConfig = Object.assign({}, pageConfig);
        delete loadConfig["path"];
        delete loadConfig["load"];
        const page = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.createPageConfig)(enablePullDownRefresh ? _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.hooks.call("createPullDownComponent", el, pathName, framework, handler.PullDownRefresh) : el, pathName + (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(launchParam), {}, loadConfig);
        handler.load(page, pageConfig);
        (_f = app.onShow) === null || _f === void 0 ? void 0 : _f.call(app, launchParam);
        window.addEventListener("visibilitychange", ()=>{
            var _a2, _b2, _c2;
            const currentPath = ((_a2 = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a2 === void 0 ? void 0 : _a2.path) || "";
            const path = currentPath.substring(0, currentPath.indexOf("?"));
            const param = {};
            Object.assign(param, launchParam, {
                path
            });
            if (document.visibilityState === "visible") {
                (_b2 = app.onShow) === null || _b2 === void 0 ? void 0 : _b2.call(app, param);
            } else {
                (_c2 = app.onHide) === null || _c2 === void 0 ? void 0 : _c2.call(app, param);
            }
        });
    });
}
var NavigationBarHandler = class {
    toHomeFn() {
        reLaunch({
            url: this.pageContext.originHomePage
        });
    }
    backFn() {
        navigateBack();
    }
    get homeBtnElement() {
        var _a;
        if (!this.navigationBarElement) return null;
        return (_a = this.navigationBarElement.getElementsByClassName("taro-navigation-bar-home")) === null || _a === void 0 ? void 0 : _a[0];
    }
    get backBtnElement() {
        var _a;
        if (!this.navigationBarElement) return null;
        return (_a = this.navigationBarElement.getElementsByClassName("taro-navigation-bar-back")) === null || _a === void 0 ? void 0 : _a[0];
    }
    get titleElement() {
        var _a;
        if (!this.navigationBarElement) return null;
        return (_a = this.navigationBarElement.getElementsByClassName("taro-navigation-bar-title")) === null || _a === void 0 ? void 0 : _a[0];
    }
    get loadingElement() {
        if (!this.navigationBarElement) return null;
        return this.navigationBarElement.getElementsByClassName("taro-navigation-bar-loading")[0];
    }
    init() {
        var _a, _b;
        this.setNavigationBarElement();
        if (!this.navigationBarElement) return;
        (_a = this.homeBtnElement) === null || _a === void 0 ? void 0 : _a.addEventListener("click", this.toHomeFn.bind(this));
        (_b = this.backBtnElement) === null || _b === void 0 ? void 0 : _b.addEventListener("click", this.backFn.bind(this));
    }
    setNavigationBarElement() {
        this.navigationBarElement = document.getElementById("taro-navigation-bar");
    }
    load() {
        this.setCacheValue();
        this.setTitle();
        this.setNavigationBarVisible();
        this.setFnBtnState();
        this.setNavigationBarBackground();
        this.setNavigationBarTextStyle();
        this.setNavigationLoading();
    }
    setCacheValue() {
        const currentPage = this.pageContext.originPathname;
        if (typeof this.cache[currentPage] !== "object") {
            this.cache[currentPage] = {};
        }
    }
    setFnBtnState() {
        const currentRouter = this.pageContext.currentPage;
        if (this.pageContext.isTabBar(currentRouter) || this.pageContext.homePage === currentRouter) {
            this.fnBtnToggleToNone();
        } else if (stacks.length > 1) {
            this.fnBtnToggleToBack();
        } else {
            this.fnBtnToggleToHome();
        }
    }
    shiftLoadingState(show) {
        if (!this.loadingElement) return;
        if (show) {
            this.loadingElement.classList.add("taro-navigation-bar-loading-show");
        } else {
            this.loadingElement.classList.remove("taro-navigation-bar-loading-show");
        }
    }
    setNavigationLoading(show) {
        var _a;
        if (!this.navigationBarElement) return;
        const currentPage = this.pageContext.originPathname;
        let isShow;
        if (typeof show === "boolean") {
            isShow = show;
            this.cache[currentPage] && (this.cache[currentPage].loading = isShow);
        } else {
            const cacheValue = (_a = this.cache[currentPage]) === null || _a === void 0 ? void 0 : _a.loading;
            if (typeof cacheValue === "boolean") {
                isShow = cacheValue;
            } else {
                isShow = false;
                this.cache[currentPage] && (this.cache[currentPage].loading = isShow);
            }
        }
        this.shiftLoadingState(isShow);
    }
    setNavigationBarBackground(backgroundColor) {
        var _a, _b, _c;
        if (!this.navigationBarElement) return;
        const currentPage = this.pageContext.originPathname;
        let color;
        if (typeof backgroundColor === "string") {
            color = backgroundColor;
            this.cache[currentPage] && (this.cache[currentPage].backgroundColor = color);
        } else {
            const cacheValue = (_a = this.cache[currentPage]) === null || _a === void 0 ? void 0 : _a.backgroundColor;
            if (typeof cacheValue === "string") {
                color = cacheValue;
            } else {
                color = ((_c = (_b = this.pageContext.config) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.navigationBarBackgroundColor) || "#000000";
                this.cache[currentPage] && (this.cache[currentPage].backgroundColor = color);
            }
        }
        this.navigationBarElement.style.background = color;
    }
    setNavigationBarTextStyle(fontColor) {
        var _a, _b, _c;
        if (!this.navigationBarElement) return;
        const currentPage = this.pageContext.originPathname;
        let color;
        if (typeof fontColor === "string") {
            color = fontColor;
            this.cache[currentPage] && (this.cache[currentPage].fontColor = color);
        } else {
            const cacheValue = (_a = this.cache[currentPage]) === null || _a === void 0 ? void 0 : _a.fontColor;
            if (typeof cacheValue === "string") {
                color = cacheValue;
            } else {
                color = ((_c = (_b = this.pageContext.config) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.navigationBarTextStyle) || "white";
                this.cache[currentPage] && (this.cache[currentPage].fontColor = color);
            }
        }
        this.navigationBarElement.style.color = color;
    }
    setTitle(title) {
        var _a, _b, _c;
        const currentPage = this.pageContext.originPathname;
        let proceedTitle;
        if (typeof title === "string") {
            proceedTitle = title;
            this.cache[currentPage] && (this.cache[currentPage].title = proceedTitle);
        } else {
            const cacheValue = (_a = this.cache[currentPage]) === null || _a === void 0 ? void 0 : _a.title;
            if (typeof cacheValue === "string") {
                proceedTitle = cacheValue;
            } else {
                proceedTitle = (_c = (_b = this.pageContext.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationBarTitleText) !== null && _c !== void 0 ? _c : document.title;
                this.cache[currentPage] && (this.cache[currentPage].title = proceedTitle);
            }
        }
        if (false) // removed by dead control flow
{}
        document.title = proceedTitle;
        if (!this.titleElement) return;
        this.titleElement.innerHTML = proceedTitle;
    }
    fnBtnToggleToHome() {
        if (!this.navigationBarElement) return;
        this.navigationBarElement.classList.add("taro-navigation-bar-home-icon");
        this.navigationBarElement.classList.remove("taro-navigation-bar-back-icon");
    }
    fnBtnToggleToBack() {
        if (!this.navigationBarElement) return;
        this.navigationBarElement.classList.remove("taro-navigation-bar-home-icon");
        this.navigationBarElement.classList.add("taro-navigation-bar-back-icon");
    }
    fnBtnToggleToNone() {
        if (!this.navigationBarElement) return;
        this.navigationBarElement.classList.remove("taro-navigation-bar-home-icon");
        this.navigationBarElement.classList.remove("taro-navigation-bar-back-icon");
    }
    setNavigationBarVisible(show) {
        var _a, _b;
        if (!this.navigationBarElement) return;
        let shouldShow;
        if (typeof show === "boolean") {
            shouldShow = show;
        } else {
            shouldShow = (_a = this.pageContext.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
            if (typeof ((_b = this.pageContext.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === "string") {
                shouldShow = this.pageContext.pageConfig.navigationStyle;
            }
        }
        if (shouldShow === "default") {
            this.navigationBarElement.classList.add("taro-navigation-bar-show");
            this.navigationBarElement.classList.remove("taro-navigation-bar-hide");
        } else {
            this.navigationBarElement.classList.add("taro-navigation-bar-hide");
            this.navigationBarElement.classList.remove("taro-navigation-bar-show");
        }
    }
    constructor(pageContext){
        this.isLoadDdEntry = false;
        this.cache = {};
        this.pageContext = pageContext;
        this.init();
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.on("__taroH5SetNavigationBarTitle", (title)=>{
            this.setTitle(title);
        });
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.on("__taroH5setNavigationBarLoading", (loading)=>{
            this.setNavigationLoading(loading);
        });
        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.on("__taroH5setNavigationBarColor", ({ backgroundColor, frontColor })=>{
            if (typeof backgroundColor === "string") this.setNavigationBarBackground(backgroundColor);
            if (typeof frontColor === "string") this.setNavigationBarTextStyle(frontColor);
        });
    }
};
var PageHandler = class {
    get currentPage() {
        const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getCurrentPage)(this.routerMode, this.basename);
        return routePath === "/" ? this.homePage : routePath;
    }
    get appId() {
        return this.config.appId || "app";
    }
    get router() {
        return this.config.router || {};
    }
    get routerMode() {
        return this.router.mode || "hash";
    }
    get customRoutes() {
        return this.router.customRoutes || {};
    }
    get routes() {
        return this.config.routes || [];
    }
    get tabBarList() {
        var _a;
        return ((_a = this.config.tabBar) === null || _a === void 0 ? void 0 : _a.list) || [];
    }
    get PullDownRefresh() {
        return this.config.PullDownRefresh;
    }
    get animation() {
        var _a, _b;
        return (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.animation) !== null && _b !== void 0 ? _b : this.defaultAnimation;
    }
    get animationDelay() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.delay : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.delay : 0) || 0;
    }
    get animationDuration() {
        var _a;
        return (typeof this.animation === "object" ? this.animation.duration : this.animation ? (_a = this.defaultAnimation) === null || _a === void 0 ? void 0 : _a.duration : 0) || 0;
    }
    set pathname(p) {
        this.router.pathname = p;
    }
    get pathname() {
        return this.router.pathname;
    }
    // Note:  pathname  customRoutes  basename
    get originPathname() {
        return routesAlias.getOrigin((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(this.pathname, this.basename)));
    }
    get basename() {
        return this.router.basename || "";
    }
    get pageConfig() {
        const homePage = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(this.homePage);
        return this.routes.find((r)=>{
            const pagePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(r.path);
            return [
                pagePath,
                homePage
            ].includes(this.originPathname);
        });
    }
    isTabBar(pathname) {
        var _a;
        const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(pathname, this.basename)).split("?")[0];
        const pagePath = ((_a = Object.entries(this.customRoutes).find(([, target])=>{
            if (typeof target === "string") {
                return target === routePath;
            } else if ((target === null || target === void 0 ? void 0 : target.length) > 0) {
                return target.includes(routePath);
            }
            return false;
        })) === null || _a === void 0 ? void 0 : _a[0]) || routePath;
        return !!pagePath && this.tabBarList.some((t)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripTrailing)(t.pagePath)) === pagePath);
    }
    isDefaultNavigationStyle() {
        var _a, _b;
        let style = (_a = this.config.window) === null || _a === void 0 ? void 0 : _a.navigationStyle;
        if (typeof ((_b = this.pageConfig) === null || _b === void 0 ? void 0 : _b.navigationStyle) === "string") {
            style = this.pageConfig.navigationStyle;
        }
        return style !== "custom";
    }
    isSamePage(page) {
        const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(this.pathname, this.basename);
        const pagePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(page === null || page === void 0 ? void 0 : page.path, this.basename);
        return pagePath.startsWith(routePath + "?");
    }
    get search() {
        let search = "?";
        if (this.routerMode === "hash") {
            const idx = location.hash.indexOf("?");
            if (idx > -1) {
                search = location.hash.slice(idx);
            }
        } else {
            search = location.search;
        }
        return search.substring(1);
    }
    get usingWindowScroll() {
        var _a;
        let usingWindowScroll = false;
        if (typeof ((_a = this.pageConfig) === null || _a === void 0 ? void 0 : _a.usingWindowScroll) === "boolean") {
            usingWindowScroll = this.pageConfig.usingWindowScroll;
        }
        const win3 = window;
        win3.__taroAppConfig || (win3.__taroAppConfig = {});
        win3.__taroAppConfig.usingWindowScroll = usingWindowScroll;
        return usingWindowScroll;
    }
    getQuery(stamp = "", search = "", options3 = {}) {
        search = search ? `${search}&${this.search}` : this.search;
        const query = search ? query_string_default2.parse(search, {
            decode: false
        }) : {};
        query.stamp = stamp;
        return Object.assign(Object.assign({}, query), options3);
    }
    mount() {
        setHistory(this.history, this.basename);
        this.pathname = history.location.pathname;
        this.animation && loadAnimateStyle(this.animationDuration);
        loadRouterStyle(this.tabBarList.length > 1, this.usingWindowScroll, this.router.enhanceAnimation);
    }
    onReady(page, onLoad2 = true) {
        var _a;
        const pageEl = this.getPageContainer(page);
        if (pageEl && !(pageEl === null || pageEl === void 0 ? void 0 : pageEl["__isReady"])) {
            const el = pageEl.firstElementChild;
            const componentOnReady = el === null || el === void 0 ? void 0 : el["componentOnReady"];
            if (componentOnReady) {
                componentOnReady === null || componentOnReady === void 0 ? void 0 : componentOnReady().then(()=>{
                    (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__._raf)(()=>{
                        var _a2;
                        (_a2 = page.onReady) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                        pageEl["__isReady"] = true;
                    });
                });
            } else {
                (_a = page.onReady) === null || _a === void 0 ? void 0 : _a.call(page);
                pageEl["__isReady"] = true;
            }
            onLoad2 && (pageEl["__page"] = page);
        }
    }
    load(page, pageConfig = {}, stampId, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        stacks.push(page);
        const param = this.getQuery(stampId, "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove("taro_page_shade");
            this.isTabBar(this.pathname) && pageEl.classList.add("taro_tabbar_page");
            this.isDefaultNavigationStyle() && pageEl.classList.add("taro_navigation_page");
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.navigationBarHandler.load();
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.isTabBar(this.pathname) && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_tabbar_page"));
                this.isDefaultNavigationStyle() && (pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.add("taro_navigation_page"));
                this.addAnimation(pageEl, pageNo === 0);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.navigationBarHandler.load();
                this.onReady(page, true);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    unload(page, delta = 1, top = false) {
        var _a, _b, _c;
        if (!page) return;
        stacks.delta = --delta;
        stacks.pop();
        if (this.animation && top) {
            if (this.unloadTimer) {
                clearTimeout(this.unloadTimer);
                (_b = (_a = this.lastUnloadPage) === null || _a === void 0 ? void 0 : _a.onUnload) === null || _b === void 0 ? void 0 : _b.call(_a);
                this.unloadTimer = null;
            }
            this.lastUnloadPage = page;
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            if (pageEl) {
                pageEl.style.zIndex = "1";
            }
            this.unloadTimer = setTimeout(()=>{
                var _a2, _b2;
                this.unloadTimer = null;
                (_b2 = (_a2 = this.lastUnloadPage) === null || _a2 === void 0 ? void 0 : _a2.onUnload) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
                _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroPageOnShowAfterDestroyed");
            }, this.animationDuration);
        } else {
            const pageEl = this.getPageContainer(page);
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_stationed");
            pageEl === null || pageEl === void 0 ? void 0 : pageEl.classList.remove("taro_page_show");
            (_c = page === null || page === void 0 ? void 0 : page.onUnload) === null || _c === void 0 ? void 0 : _c.call(page);
            setTimeout(()=>{
                _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroPageOnShowAfterDestroyed");
            }, 0);
        }
        if (delta >= 1) this.unload(stacks.last, delta);
    }
    show(page, pageConfig = {}, pageNo = 0) {
        var _a, _b;
        if (!page) return;
        const param = this.getQuery(page["$taroParams"]["stamp"], "", page.options);
        let pageEl = this.getPageContainer(page);
        if (pageEl) {
            pageEl.classList.remove("taro_page_shade");
            this.addAnimation(pageEl, pageNo === 0);
            (_a = page.onShow) === null || _a === void 0 ? void 0 : _a.call(page);
            this.navigationBarHandler.load();
            this.bindPageEvents(page, pageConfig);
            this.triggerRouterChange();
        } else {
            (_b = page.onLoad) === null || _b === void 0 ? void 0 : _b.call(page, param, ()=>{
                var _a2;
                pageEl = this.getPageContainer(page);
                this.addAnimation(pageEl, pageNo === 0);
                (_a2 = page.onShow) === null || _a2 === void 0 ? void 0 : _a2.call(page);
                this.navigationBarHandler.load();
                this.onReady(page, false);
                this.bindPageEvents(page, pageConfig);
                this.triggerRouterChange();
            });
        }
    }
    hide(page, animation = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!page) return;
        const pageEl = this.getPageContainer(page);
        if (pageEl) {
            if (animation) {
                if (this.hideTimer) {
                    clearTimeout(this.hideTimer);
                    this.hideTimer = null;
                    (_c = (_b = (_a = this.lastHidePage) === null || _a === void 0 ? void 0 : _a.classList) === null || _b === void 0 ? void 0 : _b.add) === null || _c === void 0 ? void 0 : _c.call(_b, "taro_page_shade");
                }
                this.lastHidePage = pageEl;
                this.hideTimer = setTimeout(()=>{
                    this.hideTimer = null;
                    pageEl.classList.add("taro_page_shade");
                }, this.animationDuration + this.animationDelay);
                (_d = page.onHide) === null || _d === void 0 ? void 0 : _d.call(page);
            } else {
                if (this.hideTimer) {
                    clearTimeout(this.hideTimer);
                    this.hideTimer = null;
                    (_g = (_f = (_e = this.lastHidePage) === null || _e === void 0 ? void 0 : _e.classList) === null || _f === void 0 ? void 0 : _f.add) === null || _g === void 0 ? void 0 : _g.call(_f, "taro_page_shade");
                }
                (_h = page.onHide) === null || _h === void 0 ? void 0 : _h.call(page);
                pageEl.classList.add("taro_page_shade");
                this.lastHidePage = pageEl;
            }
        } else {
            setTimeout(()=>this.hide(page), 0);
        }
    }
    addAnimation(pageEl, first = false) {
        if (!pageEl) return;
        if (this.animation && !first) {
            setTimeout(()=>{
                pageEl.classList.add("taro_page_show");
                setTimeout(()=>{
                    pageEl.classList.add("taro_page_stationed");
                }, this.animationDuration);
            }, this.animationDelay);
        } else {
            pageEl.classList.add("taro_page_show");
            pageEl.classList.add("taro_page_stationed");
        }
    }
    getPageContainer(page) {
        var _a;
        const path = page ? page === null || page === void 0 ? void 0 : page.path : (_a = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a === void 0 ? void 0 : _a.path;
        const id = path === null || path === void 0 ? void 0 : path.replace(/([^a-z0-9\u00a0-\uffff_-])/ig, "\\$1");
        if (page) {
            return document.querySelector(`.taro_page#${id}`);
        }
        const el = id ? document.querySelector(`.taro_page#${id}`) : document.querySelector(".taro_page") || document.querySelector(".taro_router");
        return el;
    }
    getScrollingElement(page) {
        if (this.usingWindowScroll) return window;
        return this.getPageContainer(page) || window;
    }
    bindPageEvents(page, config = {}) {
        var _a;
        const scrollEl = this.getScrollingElement(page);
        const distance = config.onReachBottomDistance || ((_a = this.config.window) === null || _a === void 0 ? void 0 : _a.onReachBottomDistance) || 50;
        bindPageScroll(page, scrollEl, distance);
        bindPageResize(page);
    }
    triggerRouterChange() {
        setTimeout(()=>{
            _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__afterTaroRouterChange", {
                toLocation: {
                    path: this.pathname
                }
            });
        }, 0);
    }
    constructor(config, history2){
        this.history = history2;
        this.defaultAnimation = {
            duration: 300,
            delay: 50
        };
        this.config = config;
        this.homePage = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.getHomePage)(this.routes[0].path, this.basename, this.customRoutes, this.config.entryPagePath);
        this.originHomePage = this.config.entryPagePath || this.routes[0].path || this.basename;
        this.mount();
        this.navigationBarHandler = new NavigationBarHandler(this);
    }
};
var createStampId = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.incrementId)();
var launchStampId = createStampId();
function createRouter(history2, app, config, framework) {
    var _a, _b;
    if (typeof app.onUnhandledRejection === "function") {
        window.addEventListener("unhandledrejection", app.onUnhandledRejection);
    }
    RouterConfig.config = config;
    const handler = new PageHandler(config, history2);
    const pageLock = {};
    routesAlias.set(handler.router.customRoutes);
    const basename2 = handler.router.basename;
    const routes = handler.routes.map((route)=>{
        const routePath2 = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)(route.path);
        const paths = routesAlias.getAll(routePath2);
        return {
            path: paths.length < 1 ? routePath2 : paths,
            action: route.load
        };
    });
    const router2 = new module_default(routes, {
        baseUrl: basename2 || ""
    });
    const launchParam = {
        path: handler.currentPage,
        query: handler.getQuery(launchStampId),
        scene: 0,
        shareTicket: "",
        referrerInfo: {}
    };
    _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroRouterLaunch", launchParam);
    (_a = app.onLaunch) === null || _a === void 0 ? void 0 : _a.call(app, launchParam);
    app.onError && window.addEventListener("error", (e)=>{
        var _a2;
        return (_a2 = app.onError) === null || _a2 === void 0 ? void 0 : _a2.call(app, e.message);
    });
    const render = (_c)=>(0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, [
            _c
        ], void 0, function*({ location: location2, action }) {
            var _d, _e, _f, _g, _h, _j, _k, _l;
            const currentPathname = decodeURI(location2.pathname);
            if ((_d = window.__taroAppConfig) === null || _d === void 0 ? void 0 : _d.usingWindowScroll) window.scrollTo(0, 0);
            _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroRouterChange", {
                toLocation: {
                    path: currentPathname
                }
            });
            let element, context, params;
            const routerPath = handler.router.forcePath || currentPathname;
            pageLock[routerPath] = typeof pageLock[routerPath] === "number" ? pageLock[routerPath] + 1 : 1;
            const currentLock = pageLock[routerPath];
            let postLock;
            try {
                const result = yield router2.resolve(routerPath);
                [element, context, params] = yield Promise.all(result);
                postLock = pageLock[routerPath];
            } catch (error) {
                if (error.status === 404) {
                    const notFoundEvent = {
                        isEntryPage: stacks.length === 0,
                        path: currentPathname,
                        query: handler.getQuery(createStampId())
                    };
                    (_e = app.onPageNotFound) === null || _e === void 0 ? void 0 : _e.call(app, notFoundEvent);
                    _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroRouterNotFound", notFoundEvent);
                } else if (/Loading hot update .* failed./.test(error.message)) {
                    window.location.reload();
                } else {
                    throw error;
                }
            }
            if (!element || currentLock !== postLock) return;
            handler.pathname = context.pathname;
            const { pathname, pageConfig } = handler;
            let enablePullDownRefresh = ((_f = config === null || config === void 0 ? void 0 : config.window) === null || _f === void 0 ? void 0 : _f.enablePullDownRefresh) || false;
            let navigationStyle = ((_g = config === null || config === void 0 ? void 0 : config.window) === null || _g === void 0 ? void 0 : _g.navigationStyle) || "default";
            let navigationBarTextStyle = ((_h = config === null || config === void 0 ? void 0 : config.window) === null || _h === void 0 ? void 0 : _h.navigationBarTextStyle) || "white";
            let navigationBarBackgroundColor = ((_j = config === null || config === void 0 ? void 0 : config.window) === null || _j === void 0 ? void 0 : _j.navigationBarBackgroundColor) || "#000000";
            if (pageConfig) {
                if (typeof pageConfig.enablePullDownRefresh === "boolean") {
                    enablePullDownRefresh = pageConfig.enablePullDownRefresh;
                }
                if (typeof pageConfig.navigationStyle === "string") {
                    navigationStyle = pageConfig.navigationStyle;
                }
                if (typeof pageConfig.navigationBarTextStyle === "string") {
                    navigationBarTextStyle = pageConfig.navigationBarTextStyle;
                }
                if (typeof pageConfig.navigationBarBackgroundColor === "string") {
                    navigationBarBackgroundColor = pageConfig.navigationBarBackgroundColor;
                }
            }
            _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.trigger("__taroSetNavigationStyle", navigationStyle, navigationBarTextStyle, navigationBarBackgroundColor);
            const currentPage = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page;
            const methodName = (_k = stacks.method) !== null && _k !== void 0 ? _k : "";
            const cacheTabs = stacks.getTabs();
            let shouldLoad = false;
            stacks.method = "";
            if (methodName === "reLaunch") {
                handler.unload(currentPage, stacks.length);
                for(const key in cacheTabs){
                    if (cacheTabs[key]) {
                        handler.unload(cacheTabs[key]);
                        stacks.removeTab(key);
                    }
                }
                shouldLoad = true;
            } else if (currentPage && handler.isTabBar(pathname)) {
                if (handler.isSamePage(currentPage)) return;
                if (handler.isTabBar(currentPage.path)) {
                    handler.hide(currentPage);
                    stacks.pushTab(currentPage.path.split("?")[0]);
                } else if (stacks.length > 0) {
                    const firstIns = stacks.getItem(0);
                    if (handler.isTabBar(firstIns.path)) {
                        handler.unload(currentPage, stacks.length - 1, true);
                        stacks.pushTab(firstIns.path.split("?")[0]);
                    } else {
                        handler.unload(currentPage, stacks.length, true);
                    }
                }
                if (cacheTabs[pathname]) {
                    stacks.popTab(pathname);
                    return handler.show(stacks.getItem(0), pageConfig, 0);
                }
                shouldLoad = true;
            } else if (action === "POP") {
                const prevIndex = stacks.getPrevIndex(pathname);
                const delta = stacks.getDelta(pathname);
                if (currentPage !== stacks.getItem(prevIndex)) {
                    handler.unload(currentPage, delta, prevIndex > -1);
                    if (prevIndex > -1) {
                        _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.eventCenter.once("__taroPageOnShowAfterDestroyed", ()=>{
                            handler.show(stacks.getItem(prevIndex), pageConfig, prevIndex);
                        });
                    } else {
                        shouldLoad = true;
                    }
                }
            } else if (action === "REPLACE") {
                const delta = stacks.getDelta(pathname);
                handler.unload(currentPage, delta);
                shouldLoad = true;
            } else if (action === "PUSH") {
                handler.hide(currentPage, true);
                shouldLoad = true;
            }
            if (shouldLoad || stacks.length < 1) {
                const el = (_l = element.default) !== null && _l !== void 0 ? _l : element;
                const loadConfig = Object.assign({}, pageConfig);
                const stacksIndex = stacks.length;
                delete loadConfig["path"];
                delete loadConfig["load"];
                let pageStampId = "";
                if (launchStampId) {
                    pageStampId = launchStampId;
                    launchStampId = "";
                } else {
                    pageStampId = createStampId();
                }
                const page = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.createPageConfig)(enablePullDownRefresh ? _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.hooks.call("createPullDownComponent", el, pathname, framework, handler.PullDownRefresh, pageStampId) : el, pathname + (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stringify)(handler.getQuery(pageStampId)), {}, loadConfig);
                if (params) page.options = params;
                handler.load(page, pageConfig, pageStampId, stacksIndex);
            }
        });
    const routePath = (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.addLeadingSlash)((0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.stripBasename)(history2.location.pathname, handler.basename));
    if (routePath === "/") {
        history2.replace(prependBasename(handler.homePage + history2.location.search));
    }
    render({
        location: history2.location,
        action: Action.Push
    });
    (_b = app.onShow) === null || _b === void 0 ? void 0 : _b.call(app, launchParam);
    window.addEventListener("visibilitychange", ()=>{
        var _a2, _b2, _c, _d, _e, _f, _g;
        const currentPath = ((_a2 = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _a2 === void 0 ? void 0 : _a2.path) || "";
        const path = currentPath.substring(0, currentPath.indexOf("?"));
        const param = {};
        Object.assign(param, launchParam, {
            path
        });
        if (document.visibilityState === "visible") {
            (_b2 = app.onShow) === null || _b2 === void 0 ? void 0 : _b2.call(app, param);
            (_d = (_c = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _c === void 0 ? void 0 : _c.onShow) === null || _d === void 0 ? void 0 : _d.call(_c);
        } else {
            if ((_e = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _e === void 0 ? void 0 : _e.path) {
                (0,_chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.safeExecute)((_f = _chunk_F3ILHP3R_js__WEBPACK_IMPORTED_MODULE_1__.Current.page) === null || _f === void 0 ? void 0 : _f.path, "onHide");
            }
            (_g = app.onHide) === null || _g === void 0 ? void 0 : _g.call(app, param);
        }
    });
    return history2.listen(render);
}
function handleAppMount(config, _, appId = config.appId || "app") {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement("div");
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add("taro_router");
    if (!isPosition) appWrapper.appendChild(app);
    initNavigationBar(config, appWrapper);
}
function handleAppMountWithTabbar(config, history2, appId = config.appId || "app") {
    let app = document.getElementById(appId);
    let isPosition = true;
    if (!app) {
        app = document.createElement("div");
        app.id = appId;
        isPosition = false;
    }
    const appWrapper = (app === null || app === void 0 ? void 0 : app.parentNode) || (app === null || app === void 0 ? void 0 : app.parentElement) || document.body;
    app.classList.add("taro_router");
    const container2 = document.createElement("div");
    container2.classList.add("taro-tabbar__container");
    container2.id = "container";
    const panel = document.createElement("div");
    panel.classList.add("taro-tabbar__panel");
    panel.appendChild(app.cloneNode(true));
    container2.appendChild(panel);
    if (!isPosition) {
        appWrapper.appendChild(container2);
    } else {
        appWrapper.replaceChild(container2, app);
    }
    initTabbar(config, history2);
    initNavigationBar(config, container2);
}
 /*! Bundled license information:

platform/platform.js:
  (*!
   * Platform.js v1.3.6
   * Copyright 2014-2020 Benjamin Tan
   * Copyright 2011-2013 John-David Dalton
   * Available under MIT license
   *)

hammerjs/hammer.js:
  (*! Hammer.JS - v2.0.7 - 2016-04-22
   * http://hammerjs.github.io/
   *
   * Copyright (c) 2016 Jorik Tangelder;
   * Licensed under the MIT license *)

@stencil/core/internal/client/index.js:
  (*!__STENCIL_STATIC_IMPORT_SWITCH__*)

jsonp-retry/dist/jsonp.esm.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

@tarojs/components/dist/components/index2.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

universal-router/module.js:
  (*! Universal Router | MIT License | https://www.kriasoft.com/universal-router/ *)
*/ 


/***/ }),

/***/ "./node_modules/.taro/h5/prebundle/definition-a6aeff58.json":
/*!******************************************************************!*\
  !*** ./node_modules/.taro/h5/prebundle/definition-a6aeff58.json ***!
  \******************************************************************/
/***/ (function(module) {

module.exports = /*#__PURE__*/JSON.parse('{"apis":{"Behavior":"*","getEnv":"*","ENV_TYPE":"*","Link":"*","interceptors":"*","interceptorify":"*","Current":"*","options":"*","eventCenter":"*","Events":"*","preload":"*","taro":{},"requirePlugin":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"initPxTransform":{"object":"{ designWidth?: number; deviceRatio?: TDeviceRatio; baseFontSize?: number; unitPrecision?: number; targetUnit?: string; }","success":"void"},"pxTransform":{"object":"number","success":"void","return":"*"},"canIUseWebp":{"object":"void","success":"void","return":"boolean"},"getAppInfo":{"object":"void","success":"void","return":"{ platform: string; taroVersion: string; designWidth: any; }"},"createRewardedVideoAd":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createInterstitialAd":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopFaceDetect":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"initFaceDetect":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"faceDetect":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getInferenceEnvInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createInferenceSession":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"isVKSupport":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createVKSession":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getOpenUserInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"tradePay":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getUserCryptoManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setEnableDebug":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getRealtimeLogManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getLogManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"reportPerformance":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getPerformance":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"preloadWebview":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"preloadSkylineView":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"preloadAssets":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openSystemBluetoothSetting":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openAppAuthorizeSetting":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getWindowInfo":{"object":"void","success":"void","return":"Result"},"getSystemSetting":{"object":"void","success":"void","return":"Result"},"getDeviceInfo":{"object":"void","success":"void","return":"Result"},"getAppBaseInfo":{"object":"void","success":"void","return":"Result"},"getAppAuthorizeSetting":{"object":"void","success":"void","return":"Result"},"getSystemInfoSync":{"object":"void","success":"void","return":"Result"},"getSystemInfoAsync":{"object":"Option","success":"void","return":"Promise<Result>"},"getSystemInfo":{"object":"Option","success":"void","return":"Promise<Result>"},"getSkylineInfoSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSkylineInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getRendererUserAgent":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"updateWeChatApp":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getUpdateManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onUnhandledRejection":{"callback":"Result<T>"},"onThemeChange":{"callback":"Result"},"onPageNotFound":{"callback":"Result"},"onLazyLoadError":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onError":{"callback":"string | ErrorEvent | Error"},"onAudioInterruptionEnd":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onAudioInterruptionBegin":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onAppShow":{"callback":"CallbackResult"},"onAppHide":{"callback":"CallbackResult"},"offUnhandledRejection":{"callback":"Result<T>"},"offThemeChange":{"callback":"Result"},"offPageNotFound":{"callback":"Result"},"offLazyLoadError":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offError":{"callback":"string | ErrorEvent | Error"},"offAudioInterruptionEnd":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offAudioInterruptionBegin":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offAppShow":{"callback":"CallbackResult"},"offAppHide":{"callback":"CallbackResult"},"getLaunchOptionsSync":{"object":"void","success":"void","return":"LaunchOptions"},"getEnterOptionsSync":{"object":"void","success":"void","return":"EnterOptions"},"env":{},"arrayBufferToBase64":"*","base64ToArrayBuffer":"*","createCanvasContext":{"object":"string","success":"void","return":"CanvasContext"},"canvasToTempFilePath":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"canvasPutImageData":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"canvasGetImageData":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"createOffscreenCanvas":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"reportMonitor":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"reportAnalytics":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"reportEvent":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getExptInfoSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopAccelerometer":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"startAccelerometer":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"onAccelerometerChange":{"callback":"Result"},"offAccelerometerChange":{"callback":"Result"},"checkIsOpenAccessibility":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBatteryInfoSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBatteryInfo":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"stopBluetoothDevicesDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startBluetoothDevicesDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openBluetoothAdapter":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBluetoothDeviceFound":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBluetoothAdapterStateChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBluetoothDeviceFound":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBluetoothAdapterStateChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"makeBluetoothPair":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"isBluetoothDevicePaired":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getConnectedBluetoothDevices":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBluetoothDevices":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBluetoothAdapterState":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"closeBluetoothAdapter":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"writeBLECharacteristicValue":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setBLEMTU":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"readBLECharacteristicValue":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBLEMTUChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBLEConnectionStateChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBLECharacteristicValueChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBLEMTUChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBLEConnectionStateChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBLECharacteristicValueChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"notifyBLECharacteristicValueChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBLEMTU":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBLEDeviceServices":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBLEDeviceRSSI":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBLEDeviceCharacteristics":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createBLEConnection":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"closeBLEConnection":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBLEPeripheralConnectionStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBLEPeripheralConnectionStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createBLEPeripheralServer":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addPhoneRepeatCalendar":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"addPhoneCalendar":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setClipboardData":{"object":"Option","success":"void","return":"Promise<Promised>"},"getClipboardData":{"object":"Option","success":"void","return":"Promise<Promised>"},"stopCompass":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"startCompass":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"onCompassChange":{"callback":"OnCompassChangeCallbackResult"},"offCompassChange":{"callback":"OnCompassChangeCallbackResult"},"chooseContact":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addPhoneContact":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getRandomValues":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopGyroscope":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startGyroscope":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onGyroscopeChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offGyroscopeChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopBeaconDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startBeaconDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBeaconUpdate":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBeaconServiceChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBeaconUpdate":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offBeaconServiceChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBeacons":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onKeyboardHeightChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offKeyboardHeightChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"hideKeyboard":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSelectedTextRange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onMemoryWarning":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offMemoryWarning":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopDeviceMotionListening":{"object":"Option","success":"void"},"startDeviceMotionListening":{"object":"Option","success":"void"},"onDeviceMotionChange":{"callback":"CallbackResult"},"offDeviceMotionChange":{"callback":"CallbackResult"},"getNetworkType":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"onNetworkWeakChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onNetworkStatusChange":{"callback":"CallbackResult"},"offNetworkWeakChange":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offNetworkStatusChange":{"callback":"CallbackResult"},"getLocalIPAddress":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopHCE":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startHCE":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"sendHCEMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onHCEMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offHCEMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getNFCAdapter":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getHCEState":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"makePhoneCall":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"scanCode":{"object":"Partial<{ needResult: number; }>","success":"void","return":"Promise<any>"},"setVisualEffectOnCapture":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setScreenBrightness":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setKeepScreenOn":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onUserCaptureScreen":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offUserCaptureScreen":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getScreenBrightness":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onScreenRecordingStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offScreenRecordingStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getScreenRecordingState":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"sendSms":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"vibrateShort":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"vibrateLong":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"stopWifi":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startWifi":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setWifiList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onWifiConnectedWithPartialInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onWifiConnected":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onGetWifiList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offWifiConnectedWithPartialInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offWifiConnected":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offGetWifiList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getWifiList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getConnectedWifi":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"connectWifi":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getExtConfigSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getExtConfig":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"saveFileToDisk":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"saveFile":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"removeSavedFile":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openDocument":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSavedFileList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSavedFileInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getFileSystemManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getFileInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getApp":{"object":"*","success":"void","return":"Instance<T>"},"getCurrentInstance":{"object":"void","success":"void","return":"Current"},"getLocation":{"object":"Partial<Option>","success":"void","return":"Promise<SuccessCallbackResult>"},"css_248z":{},"chooseLocation":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"onLocationChange":"*","offLocationChange":"*","onLocationChangeError":"*","offLocationChangeError":"*","stopLocationUpdate":{"object":"Partial<Option>","success":"void","return":"Promise<CallbackResult>"},"startLocationUpdate":{"object":"Partial<Option>","success":"void","return":"Promise<CallbackResult>"},"startLocationUpdateBackground":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openLocation":{"object":"Partial<{ scale: number; }>","success":"void","return":"Promise<any>"},"choosePoi":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getFuzzyLocation":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopVoice":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setInnerAudioOption":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"playVoice":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"pauseVoice":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getAvailableAudioSources":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createWebAudioContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createMediaAudioPlayer":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createInnerAudioContext":{"object":"Option","success":"void","return":"InnerAudioContext"},"createAudioContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopBackgroundAudio":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"seekBackgroundAudio":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"playBackgroundAudio":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"pauseBackgroundAudio":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBackgroundAudioStop":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBackgroundAudioPlay":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBackgroundAudioPause":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBackgroundAudioPlayerState":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBackgroundAudioManager":{"object":"void","success":"void","return":"BackgroundAudioManager"},"createCameraContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"saveImageToPhotosAlbum":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"getImageInfo":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"previewImage":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"chooseImage":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"previewMedia":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"compressImage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"chooseMessageFile":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"editImage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"cropImage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createLivePusherContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createLivePlayerContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createMapContext":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createMediaRecorder":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"stopRecord":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startRecord":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getRecorderManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"saveVideoToPhotosAlbum":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"getVideoInfo":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"chooseMedia":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"chooseVideo":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"openVideoEditor":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createVideoContext":{"object":"string","success":"void","return":"VideoContext"},"compressVideo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createVideoDecoder":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createMediaContainer":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"updateVoIPChatMuteConfig":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"subscribeVoIPVideoMembers":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setEnable1v1Chat":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onVoIPVideoMembersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onVoIPChatStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onVoIPChatSpeakersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onVoIPChatMembersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onVoIPChatInterrupted":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offVoIPChatSpeakersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offVoIPVideoMembersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offVoIPChatStateChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offVoIPChatMembersChanged":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offVoIPChatInterrupted":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"joinVoIPChat":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"join1v1Chat":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"exitVoIPChat":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openEmbeddedMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"navigateToMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"navigateBackMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"exitMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openBusinessView":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"downloadFile":{"object":"Option","success":"void","return":"DownloadTaskPromise"},"stopLocalServiceDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startLocalServiceDiscovery":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onLocalServiceResolveFail":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onLocalServiceLost":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onLocalServiceFound":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onLocalServiceDiscoveryStop":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offLocalServiceResolveFail":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offLocalServiceLost":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offLocalServiceFound":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offLocalServiceDiscoveryStop":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"request":{"object":"*","success":"void","return":"RequestTask<T>"},"addInterceptor":"*","cleanInterceptors":"*","createTCPSocket":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createUDPSocket":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"uploadFile":{"object":"Option","success":"void","return":"UploadTaskPromise"},"sendSocketMessage":"*","onSocketOpen":"*","onSocketMessage":"*","onSocketError":"*","onSocketClose":"*","connectSocket":"*","closeSocket":"*","getAccountInfoSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"chooseAddress":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"authorizeForMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"authorize":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openCard":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addCard":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"reserveChannelsLive":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openChannelsUserProfile":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openChannelsLive":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openChannelsEvent":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openChannelsActivity":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getChannelsShareKey":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getChannelsLiveNoticeInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getChannelsLiveInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openCustomerServiceChat":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestDeviceVoIP":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getDeviceVoIPList":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"checkIsSupportFacialRecognition":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startFacialRecognitionVerify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startFacialRecognitionVerifyAndUploadVideo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"faceVerifyForPay":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addVideoToFavorites":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addFileToFavorites":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getGroupEnterInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"chooseInvoiceTitle":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"chooseInvoice":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"chooseLicensePlate":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"pluginLogin":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"login":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"checkSession":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"checkIsAddedToMyMiniProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requirePrivacyAuthorize":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openPrivacyContract":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onNeedPrivacyAuthorization":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getPrivacySetting":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"showRedPackage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openSetting":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSetting":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startSoterAuthentication":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"checkIsSupportSoterAuthentication":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"checkIsSoterEnrolledInDevice":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestSubscribeMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestSubscribeDeviceMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getUserProfile":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getUserInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"shareToWeRun":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getWeRunData":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestPayment":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestPluginPayment":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestOrderPayment":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"openQzonePublish":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getQQRunData":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setOfficialDress":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setCustomDress":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"updateQQApp":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"addRecentColorSign":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getGuildInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"applyAddToMyApps":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"isAddedToMyApps":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"router":{},"updateShareMenu":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"showShareMenu":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"showShareImageMenu":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"shareVideoMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"shareFileMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onCopyUrl":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"offCopyUrl":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"hideShareMenu":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getShareInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"authPrivateMessage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setBackgroundFetchToken":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onBackgroundFetchData":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBackgroundFetchToken":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getBackgroundFetchData":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createCacheManager":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setStorageSync":{"object":"string","success":"void"},"setStorage":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"revokeBufferURL":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"removeStorageSync":{"object":"string","success":"void"},"removeStorage":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"getStorageSync":{"object":"*","success":"void","return":"*"},"getStorageInfoSync":{"object":"void","success":"void","return":"Option"},"getStorageInfo":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"getStorage":{"object":"*","success":"void","return":"Promise<SuccessCallbackResult<T>>"},"createBufferURL":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"clearStorageSync":{"object":"void","success":"void"},"clearStorage":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"batchSetStorageSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"batchSetStorage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"batchGetStorageSync":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"batchGetStorage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setPageInfo":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"ocrIdCard":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"ocrBankCard":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"ocrDrivingLicense":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"ocrVehicleLicense":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"textReview":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"textToAudio":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"imageAudit":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"advancedGeneralIdentify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"objectDetectIdentify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"carClassify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"dishClassify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"logoClassify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"animalClassify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"plantClassify":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getSwanId":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"requestPolymerPayment":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"navigateToSmartGameProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"navigateToSmartProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"navigateBackSmartProgram":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"preloadSubPackage":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createAnimation":{"object":"Option","success":"void","return":"Animation"},"worklet":"*","setBackgroundTextStyle":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"setBackgroundColor":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"nextTick":{"callback":"any[]"},"loadFontFace":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"showToast":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"hideToast":{"object":"Option","success":"void"},"showLoading":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"hideLoading":{"object":"Option","success":"void"},"showModal":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"showActionSheet":{"object":"Option","success":"void","return":"Promise<SuccessCallbackResult>"},"enableAlertBeforeUnload":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"disableAlertBeforeUnload":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"getMenuButtonBoundingClientRect":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"showNavigationBarLoading":"*","setNavigationBarTitle":"*","setNavigationBarColor":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"hideNavigationBarLoading":"*","hideHomeButton":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"startPullDownRefresh":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"stopPullDownRefresh":{"object":"Option","success":"void"},"pageScrollTo":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setTopBarText":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"initTabBarApis":"*","showTabBarRedDot":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"showTabBar":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setTabBarStyle":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setTabBarItem":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setTabBarBadge":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"removeTabBarBadge":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"hideTabBarRedDot":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"hideTabBar":{"object":"Option","success":"void","return":"Promise<CallbackResult>"},"setWindowSize":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"onWindowResize":{"callback":"CallbackResult"},"offWindowResize":{"callback":"CallbackResult"},"checkIsPictureInPictureActive":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createWorker":{"object":"*","success":"void","return":"Promise<Partial<CallbackResult> & Record<string, unknown> & CallbackResult>"},"createSelectorQuery":{"object":"void","success":"void","return":"SelectorQuery"},"createIntersectionObserver":{"object":"*","success":"void","return":"IntersectionObserver"},"createMediaQueryObserver":{"object":"void","success":"void","return":"MediaQueryObserver"}},"components":{"ad":{},"ad-custom":{},"animation-video":{},"animation-view":{},"ar-camera":{},"audio":{"autoplay":"boolean","controls":"boolean","loop":"boolean","muted":"boolean","nativeProps":"*","src":"string"},"aweme-data":{},"block":{},"button":{"disabled":"boolean","formType":"\\"submit\\" | \\"reset\\"","hoverClass":"string","hoverStartTime":"number","hoverStayTime":"number","loading":"boolean","plain":"boolean","size":"string","type":"string"},"camera":{},"canvas":{"canvasId":"string","height":"string","nativeProps":"*","width":"string"},"channel-live":{},"channel-video":{},"checkbox":{"checked":"boolean","color":"string","disabled":"boolean","id":"string","name":"string","nativeProps":"*","value":"string | number"},"checkbox-group":{"name":"*"},"comment-detail":{},"comment-list":{},"contact-button":{},"cover-image":{"nativeProps":"*","src":"string"},"cover-view":{"animation":"string","hoverClass":"string","hoverStartTime":"number","hoverStayTime":"number"},"custom-wrapper":{},"double-tap-gesture-handler":{},"draggable-sheet":{},"editor":{},"follow-swan":{},"force-press-gesture-handler":{},"form":{},"functional-page-navigator":{},"grid-builder":{},"grid-view":{},"horizontal-drag-gesture-handler":{},"icon":{"color":"string","size":"string | number","type":"Type"},"image":{"lazyLoad":"boolean","mode":"Mode","nativeProps":"*","src":"string"},"inline-payment-panel":{},"input":{"autoFocus":"boolean","confirmType":"string","disabled":"boolean","focus":"() => Promise<void>","maxlength":"number","name":"string","nativeProps":"*","password":"boolean","placeholder":"string","readonly":"boolean","type":"string","value":"string"},"keyboard-accessory":{},"label":{"for":"string"},"lifestyle":{},"like":{},"list-builder":{},"list-view":{},"live-player":{},"live-pusher":{},"login":{},"long-press-gesture-handler":{},"lottie":{},"map":{"circles":"MapProps.circle[]","enable3D":"boolean","enableAutoMaxOverlooking":"boolean","enableBuilding":"boolean","enableOverlooking":"boolean","enableRotate":"boolean","enableSatellite":"boolean","enableScroll":"boolean","enableTraffic":"boolean","enableZoom":"boolean","height":"string","latitude":"number","layerStyle":"number","longitude":"number","markers":"MapProps.marker[]","maxScale":"number","minScale":"number","polygons":"MapProps.polygon[]","polyline":"MapProps.polyline[]","rotate":"number","scale":"number","showCompass":"boolean","showScale":"boolean","skew":"number","subkey":"string","width":"string"},"match-media":{},"movable-area":{"scaleArea":"boolean"},"movable-view":{"animation":"boolean","damping":"number","direction":"\\"all\\" | \\"vertical\\" | \\"horizontal\\" | \\"none\\"","disabled":"boolean","endScale":"() => Promise<void>","friction":"number","inertia":"boolean","outOfBounds":"boolean","scale":"boolean","scaleMax":"number","scaleMin":"number","scaleValue":"number","setParent":"({ element, area }: { element: HTMLElement; area: { width: number; height: number; }; }) => Promise<void>","setScale":"(scale: number) => Promise<void>","x":"string | number","y":"string | number"},"native-slot":{},"navigation-bar":{},"navigator":{"delta":"number","hoverClass":"string","isHover":"boolean","openType":"string","url":"string"},"nested-scroll-body":{},"nested-scroll-header":{},"official-account":{},"open-container":{},"open-data":{},"page-container":{},"page-meta":{},"pan-gesture-handler":{},"picker":{"disabled":"boolean","end":"string","fields":"Fields","mode":"Mode","name":"string","range":"any[]","rangeKey":"string","start":"string","textProps":"PickerText","value":"PickerValue"},"picker-view-column":{"col":"string","initialPosition":"string","paddingVertical":"number"},"picker-view":{"indicatorClass":"string","indicatorStyle":"string","maskClass":"string","maskStyle":"string","value":"number[]"},"progress":{"active":"boolean","activeColor":"string","backgroundColor":"string","borderRadius":"string | number","fontSize":"string | number","percent":"number","showInfo":"boolean","strokeWidth":"string | number"},"pull-to-refresh":{"damping":"number","distanceToRefresh":"number","indicator":"{ activate: string; deactivate: string; release: string; finish: string; }","prefixCls":"string"},"radio":{"checked":"boolean","disabled":"boolean","id":"string","name":"string","nativeProps":"*","value":"string"},"radio-group":{"name":"*"},"rich-text":{"nodes":"Nodes","selectable":"boolean","space":"string | number | symbol","userSelect":"boolean"},"root-portal":{},"rtc-room":{},"rtc-room-item":{},"scale-gesture-handler":{},"script":{},"scroll-view":{"animated":"boolean","enhanced":"boolean","lowerThreshold":"string | number","mpScrollIntoView":"string","mpScrollIntoViewAlignment":"\\"center\\" | \\"start\\" | \\"end\\" | \\"nearest\\"","mpScrollIntoViewMethod":"(selector: string) => Promise<void>","mpScrollLeft":"string | number","mpScrollToMethod":"(object: Option) => Promise<void>","mpScrollTop":"string | number","scrollX":"boolean","scrollY":"boolean","showScrollbar":"boolean","upperThreshold":"string | number"},"share-element":{},"slider":{"activeColor":"string","backgroundColor":"string","blockColor":"string","blockSize":"number","disabled":"boolean","max":"number","min":"number","name":"string","showValue":"boolean","step":"number","value":"number"},"slot":{},"snapshot":{},"span":{},"sticky-header":{},"sticky-section":{},"swiper":{"autoplay":"boolean","circular":"boolean","current":"number","currentItemId":"string","displayMultipleItems":"number","duration":"number","effectsProps":"Record<string, any>","full":"boolean","indicatorActiveColor":"string","indicatorColor":"string","indicatorDots":"boolean","interval":"number","nextMargin":"string","previousMargin":"string","vertical":"boolean","zoom":"boolean"},"swiper-item":{"itemId":"string"},"switch":{"checked":"boolean","color":"string","disabled":"boolean","name":"string","nativeProps":"*","type":"string"},"tab-item":{},"tabs":{},"tap-gesture-handler":{},"text":{"numberOfLines":"number","selectable":"boolean","space":"string | number | symbol","userSelect":"boolean"},"textarea":{"autoFocus":"boolean","autoHeight":"boolean","disabled":"boolean","focus":"() => Promise<void>","maxlength":"number","name":"string","nativeProps":"*","placeholder":"string","value":"string"},"vertical-drag-gesture-handler":{},"video":{"autoplay":"boolean","controls":"boolean","danmuBtn":"boolean","danmuList":"[]","duration":"number","enableDanmu":"boolean","enablePlayGesture":"boolean","enableProgressGesture":"boolean","exitFullScreen":"() => Promise<void>","getHlsObject":"() => Promise<HLS>","initialTime":"number","loop":"boolean","muted":"boolean","nativeProps":"*","objectFit":"\\"contain\\" | \\"fill\\" | \\"cover\\"","pause":"() => Promise<void>","play":"() => Promise<void>","poster":"string","requestFullScreen":"() => Promise<void>","seek":"(position: number) => Promise<void>","showCenterPlayBtn":"boolean","showFullscreenBtn":"boolean","showMuteBtn":"boolean","showPlayBtn":"boolean","showProgress":"boolean","src":"string","stop":"() => Promise<void>","vslideGesture":"boolean","vslideGestureInFullscreen":"boolean"},"view":{"animation":"string","hoverClass":"string","hoverStartTime":"number","hoverStayTime":"number"},"voip-room":{},"web-view":{"src":"string"}}}');

/***/ })

}]);