// node_modules/@tarojs/shared/dist/shared.esm.js
var DEFAULT_EMPTY_ARRAY = "[]";
var NO_DEFAULT_VALUE = "";
var DEFAULT_TRUE = "!0";
var DEFAULT_FALSE = "!1";
var touchEvents = {
    bindTouchStart: NO_DEFAULT_VALUE,
    bindTouchMove: NO_DEFAULT_VALUE,
    bindTouchEnd: NO_DEFAULT_VALUE,
    bindTouchCancel: NO_DEFAULT_VALUE,
    bindLongTap: NO_DEFAULT_VALUE
};
var animation = {
    animation: NO_DEFAULT_VALUE,
    bindAnimationStart: NO_DEFAULT_VALUE,
    bindAnimationIteration: NO_DEFAULT_VALUE,
    bindAnimationEnd: NO_DEFAULT_VALUE,
    bindTransitionEnd: NO_DEFAULT_VALUE
};
function singleQuote(s) {
    return `'${s}'`;
}
var View = Object.assign(Object.assign({
    "hover-class": singleQuote("none"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "400"
}, touchEvents), animation);
var Icon = {
    type: NO_DEFAULT_VALUE,
    size: "23",
    color: NO_DEFAULT_VALUE
};
var MapComp = Object.assign({
    longitude: NO_DEFAULT_VALUE,
    latitude: NO_DEFAULT_VALUE,
    scale: "16",
    markers: DEFAULT_EMPTY_ARRAY,
    covers: NO_DEFAULT_VALUE,
    polyline: DEFAULT_EMPTY_ARRAY,
    circles: DEFAULT_EMPTY_ARRAY,
    controls: DEFAULT_EMPTY_ARRAY,
    "include-points": DEFAULT_EMPTY_ARRAY,
    "show-location": NO_DEFAULT_VALUE,
    "layer-style": "1",
    bindMarkerTap: NO_DEFAULT_VALUE,
    bindControlTap: NO_DEFAULT_VALUE,
    bindCalloutTap: NO_DEFAULT_VALUE,
    bindUpdated: NO_DEFAULT_VALUE
}, touchEvents);
var Progress = {
    percent: NO_DEFAULT_VALUE,
    "stroke-width": "6",
    color: singleQuote("#09BB07"),
    activeColor: singleQuote("#09BB07"),
    backgroundColor: singleQuote("#EBEBEB"),
    active: DEFAULT_FALSE,
    "active-mode": singleQuote("backwards"),
    "show-info": DEFAULT_FALSE
};
var RichText = {
    nodes: DEFAULT_EMPTY_ARRAY
};
var Text = Object.assign({
    selectable: DEFAULT_FALSE,
    space: NO_DEFAULT_VALUE,
    decode: DEFAULT_FALSE
}, touchEvents);
var Button = Object.assign({
    size: singleQuote("default"),
    type: NO_DEFAULT_VALUE,
    plain: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    loading: DEFAULT_FALSE,
    "form-type": NO_DEFAULT_VALUE,
    "open-type": NO_DEFAULT_VALUE,
    "hover-class": singleQuote("button-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "20",
    "hover-stay-time": "70",
    name: NO_DEFAULT_VALUE,
    bindagreeprivacyauthorization: NO_DEFAULT_VALUE
}, touchEvents);
var Checkbox = {
    value: NO_DEFAULT_VALUE,
    disabled: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var CheckboxGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Form = {
    "report-submit": DEFAULT_FALSE,
    bindSubmit: NO_DEFAULT_VALUE,
    bindReset: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Input = {
    value: NO_DEFAULT_VALUE,
    type: singleQuote(NO_DEFAULT_VALUE),
    password: DEFAULT_FALSE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("input-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "cursor-spacing": "0",
    focus: DEFAULT_FALSE,
    "confirm-type": singleQuote("done"),
    "confirm-hold": DEFAULT_FALSE,
    cursor: "-1",
    "selection-start": "-1",
    "selection-end": "-1",
    bindInput: NO_DEFAULT_VALUE,
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Label = Object.assign({
    for: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
}, touchEvents);
var Picker = {
    mode: singleQuote("selector"),
    disabled: NO_DEFAULT_VALUE,
    range: NO_DEFAULT_VALUE,
    "range-key": NO_DEFAULT_VALUE,
    value: NO_DEFAULT_VALUE,
    start: NO_DEFAULT_VALUE,
    end: NO_DEFAULT_VALUE,
    fields: singleQuote("day"),
    "custom-item": NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    bindCancel: NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    bindColumnChange: NO_DEFAULT_VALUE
};
var PickerView = {
    value: NO_DEFAULT_VALUE,
    "indicator-style": NO_DEFAULT_VALUE,
    "indicator-class": NO_DEFAULT_VALUE,
    "mask-style": NO_DEFAULT_VALUE,
    "mask-class": NO_DEFAULT_VALUE,
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var PickerViewColumn = {
    name: NO_DEFAULT_VALUE
};
var Radio = {
    value: NO_DEFAULT_VALUE,
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    color: singleQuote("#09BB07"),
    name: NO_DEFAULT_VALUE
};
var RadioGroup = {
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Slider = {
    min: "0",
    max: "100",
    step: "1",
    disabled: NO_DEFAULT_VALUE,
    value: "0",
    activeColor: singleQuote("#1aad19"),
    backgroundColor: singleQuote("#e9e9e9"),
    "block-size": "28",
    "block-color": singleQuote("#ffffff"),
    "show-value": DEFAULT_FALSE,
    bindChange: NO_DEFAULT_VALUE,
    bindChanging: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Switch = {
    checked: DEFAULT_FALSE,
    disabled: NO_DEFAULT_VALUE,
    type: singleQuote("switch"),
    color: singleQuote("#04BE02"),
    bindChange: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var Textarea = {
    value: NO_DEFAULT_VALUE,
    placeholder: NO_DEFAULT_VALUE,
    "placeholder-style": NO_DEFAULT_VALUE,
    "placeholder-class": singleQuote("textarea-placeholder"),
    disabled: NO_DEFAULT_VALUE,
    maxlength: "140",
    "auto-focus": DEFAULT_FALSE,
    focus: DEFAULT_FALSE,
    "auto-height": DEFAULT_FALSE,
    fixed: DEFAULT_FALSE,
    "cursor-spacing": "0",
    cursor: "-1",
    "selection-start": "-1",
    "selection-end": "-1",
    bindFocus: NO_DEFAULT_VALUE,
    bindBlur: NO_DEFAULT_VALUE,
    bindLineChange: NO_DEFAULT_VALUE,
    bindInput: NO_DEFAULT_VALUE,
    bindConfirm: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE
};
var CoverImage = {
    src: NO_DEFAULT_VALUE,
    bindLoad: "eh",
    bindError: "eh"
};
var CoverView = Object.assign({
    "scroll-top": DEFAULT_FALSE
}, touchEvents);
var MovableArea = {
    "scale-area": DEFAULT_FALSE
};
var MovableView = Object.assign(Object.assign({
    direction: "none",
    inertia: DEFAULT_FALSE,
    "out-of-bounds": DEFAULT_FALSE,
    x: NO_DEFAULT_VALUE,
    y: NO_DEFAULT_VALUE,
    damping: "20",
    friction: "2",
    disabled: NO_DEFAULT_VALUE,
    scale: DEFAULT_FALSE,
    "scale-min": "0.5",
    "scale-max": "10",
    "scale-value": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindScale: NO_DEFAULT_VALUE,
    bindHTouchMove: NO_DEFAULT_VALUE,
    bindVTouchMove: NO_DEFAULT_VALUE,
    width: singleQuote("10px"),
    height: singleQuote("10px")
}, touchEvents), animation);
var ScrollView = Object.assign(Object.assign({
    "scroll-x": DEFAULT_FALSE,
    "scroll-y": DEFAULT_FALSE,
    "upper-threshold": "50",
    "lower-threshold": "50",
    "scroll-top": NO_DEFAULT_VALUE,
    "scroll-left": NO_DEFAULT_VALUE,
    "scroll-into-view": NO_DEFAULT_VALUE,
    "scroll-with-animation": DEFAULT_FALSE,
    "enable-back-to-top": DEFAULT_FALSE,
    bindScrollToUpper: NO_DEFAULT_VALUE,
    bindScrollToLower: NO_DEFAULT_VALUE,
    bindScroll: NO_DEFAULT_VALUE
}, touchEvents), animation);
var Swiper = Object.assign({
    "indicator-dots": DEFAULT_FALSE,
    "indicator-color": singleQuote("rgba(0, 0, 0, .3)"),
    "indicator-active-color": singleQuote("#000000"),
    autoplay: DEFAULT_FALSE,
    current: "0",
    interval: "5000",
    duration: "500",
    circular: DEFAULT_FALSE,
    vertical: DEFAULT_FALSE,
    "previous-margin": singleQuote("0px"),
    "next-margin": singleQuote("0px"),
    "display-multiple-items": "1",
    bindChange: NO_DEFAULT_VALUE,
    bindTransition: NO_DEFAULT_VALUE,
    bindAnimationFinish: NO_DEFAULT_VALUE
}, touchEvents);
var SwiperItem = {
    "item-id": NO_DEFAULT_VALUE
};
var Navigator = {
    url: NO_DEFAULT_VALUE,
    "open-type": singleQuote("navigate"),
    delta: "1",
    "hover-class": singleQuote("navigator-hover"),
    "hover-stop-propagation": DEFAULT_FALSE,
    "hover-start-time": "50",
    "hover-stay-time": "600",
    bindSuccess: NO_DEFAULT_VALUE,
    bindFail: NO_DEFAULT_VALUE,
    bindComplete: NO_DEFAULT_VALUE
};
var Audio = {
    id: NO_DEFAULT_VALUE,
    src: NO_DEFAULT_VALUE,
    loop: DEFAULT_FALSE,
    controls: DEFAULT_FALSE,
    poster: NO_DEFAULT_VALUE,
    name: NO_DEFAULT_VALUE,
    author: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE
};
var Camera = {
    "device-position": singleQuote("back"),
    flash: singleQuote("auto"),
    bindStop: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Image = Object.assign({
    src: NO_DEFAULT_VALUE,
    mode: singleQuote("scaleToFill"),
    "lazy-load": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE
}, touchEvents);
var LivePlayer = Object.assign({
    src: NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    orientation: singleQuote("vertical"),
    "object-fit": singleQuote("contain"),
    "background-mute": DEFAULT_FALSE,
    "min-cache": "1",
    "max-cache": "3",
    bindStateChange: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindNetStatus: NO_DEFAULT_VALUE
}, animation);
var Video = Object.assign({
    src: NO_DEFAULT_VALUE,
    duration: NO_DEFAULT_VALUE,
    controls: DEFAULT_TRUE,
    "danmu-list": NO_DEFAULT_VALUE,
    "danmu-btn": NO_DEFAULT_VALUE,
    "enable-danmu": NO_DEFAULT_VALUE,
    autoplay: DEFAULT_FALSE,
    loop: DEFAULT_FALSE,
    muted: DEFAULT_FALSE,
    "initial-time": "0",
    "page-gesture": DEFAULT_FALSE,
    direction: NO_DEFAULT_VALUE,
    "show-progress": DEFAULT_TRUE,
    "show-fullscreen-btn": DEFAULT_TRUE,
    "show-play-btn": DEFAULT_TRUE,
    "show-center-play-btn": DEFAULT_TRUE,
    "enable-progress-gesture": DEFAULT_TRUE,
    "object-fit": singleQuote("contain"),
    poster: NO_DEFAULT_VALUE,
    "show-mute-btn": DEFAULT_FALSE,
    bindPlay: NO_DEFAULT_VALUE,
    bindPause: NO_DEFAULT_VALUE,
    bindEnded: NO_DEFAULT_VALUE,
    bindTimeUpdate: NO_DEFAULT_VALUE,
    bindFullScreenChange: NO_DEFAULT_VALUE,
    bindWaiting: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
}, animation);
var Canvas = Object.assign({
    "canvas-id": NO_DEFAULT_VALUE,
    "disable-scroll": DEFAULT_FALSE,
    bindError: NO_DEFAULT_VALUE
}, touchEvents);
var Ad = {
    "unit-id": NO_DEFAULT_VALUE,
    "ad-intervals": NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE,
    bindClose: NO_DEFAULT_VALUE
};
var WebView = {
    src: NO_DEFAULT_VALUE,
    bindMessage: NO_DEFAULT_VALUE,
    bindLoad: NO_DEFAULT_VALUE,
    bindError: NO_DEFAULT_VALUE
};
var Block = {};
var SlotView = {
    name: NO_DEFAULT_VALUE
};
var Slot = {
    name: NO_DEFAULT_VALUE
};
var NativeSlot = {
    name: NO_DEFAULT_VALUE
};
var Script = {};
var internalComponents = {
    View,
    Icon,
    Progress,
    RichText,
    Text,
    Button,
    Checkbox,
    CheckboxGroup,
    Form,
    Input,
    Label,
    Picker,
    PickerView,
    PickerViewColumn,
    Radio,
    RadioGroup,
    Slider,
    Switch,
    CoverImage,
    Textarea,
    CoverView,
    MovableArea,
    MovableView,
    ScrollView,
    Swiper,
    SwiperItem,
    Navigator,
    Audio,
    Camera,
    Image,
    LivePlayer,
    Video,
    Canvas,
    Ad,
    WebView,
    Block,
    Map: MapComp,
    Slot,
    SlotView,
    NativeSlot,
    Script
};
var PLATFORM_TYPE;
(function(PLATFORM_TYPE2) {
    PLATFORM_TYPE2["MINI"] = "mini";
    PLATFORM_TYPE2["ASCF"] = "ascf";
    PLATFORM_TYPE2["WEB"] = "web";
    PLATFORM_TYPE2["RN"] = "rn";
    PLATFORM_TYPE2["HARMONY"] = "harmony";
    PLATFORM_TYPE2["QUICK"] = "quickapp";
})(PLATFORM_TYPE || (PLATFORM_TYPE = {}));
var PLATFORM_CONFIG_MAP = {
    h5: {
        type: PLATFORM_TYPE.WEB
    },
    harmony: {
        type: PLATFORM_TYPE.HARMONY
    },
    ascf: {
        type: PLATFORM_TYPE.ASCF
    },
    mini: {
        type: PLATFORM_TYPE.MINI
    },
    rn: {
        type: PLATFORM_TYPE.RN
    },
    quickapp: {
        type: PLATFORM_TYPE.QUICK
    }
};
var Events = class _Events {
    on(eventName, callback, context) {
        let event, tail, _eventName;
        if (!callback) {
            return this;
        }
        if (typeof eventName === "symbol") {
            _eventName = [
                eventName
            ];
        } else {
            _eventName = eventName.split(_Events.eventSplitter);
        }
        this.callbacks || (this.callbacks = {});
        const calls = this.callbacks;
        while(event = _eventName.shift()){
            const list = calls[event];
            const node = list ? list.tail : {};
            node.next = tail = {};
            node.context = context;
            node.callback = callback;
            calls[event] = {
                tail,
                next: list ? list.next : node
            };
        }
        return this;
    }
    once(events, callback, context) {
        const wrapper = (...args)=>{
            callback.apply(this, args);
            this.off(events, wrapper, context);
        };
        this.on(events, wrapper, context);
        return this;
    }
    off(events, callback, context) {
        let event, calls, _events;
        if (!(calls = this.callbacks)) {
            return this;
        }
        if (!(events || callback || context)) {
            delete this.callbacks;
            return this;
        }
        if (typeof events === "symbol") {
            _events = [
                events
            ];
        } else {
            _events = events ? events.split(_Events.eventSplitter) : Object.keys(calls);
        }
        while(event = _events.shift()){
            let node = calls[event];
            delete calls[event];
            if (!node || !(callback || context)) {
                continue;
            }
            const tail = node.tail;
            while((node = node.next) !== tail){
                const cb = node.callback;
                const ctx = node.context;
                if (callback && cb !== callback || context && ctx !== context) {
                    this.on(event, cb, ctx);
                }
            }
        }
        return this;
    }
    trigger(events, ...args) {
        let event, node, calls, _events;
        if (!(calls = this.callbacks)) {
            return this;
        }
        if (typeof events === "symbol") {
            _events = [
                events
            ];
        } else {
            _events = events.split(_Events.eventSplitter);
        }
        while(event = _events.shift()){
            if (node = calls[event]) {
                const tail = node.tail;
                while((node = node.next) !== tail){
                    node.callback.apply(node.context || this, args);
                }
            }
        }
        return this;
    }
    constructor(opts){
        var _a1;
        this.callbacks = (_a1 = opts === null || opts === void 0 ? void 0 : opts.callbacks) !== null && _a1 !== void 0 ? _a1 : {};
    }
};
Events.eventSplitter = ",";
var PageEvts = class extends Events {
    on(eventName, callback) {
        super.on(eventName, callback, this);
        this.exeList = this.exeList.reduce((prev, item)=>{
            if (item.eventName === eventName) {
                super.trigger(item.eventName, item.data);
            } else {
                prev.push(item);
            }
            return prev;
        }, []);
        return this;
    }
    emit(events, data) {
        routeChannel.trigger(events, data);
    }
    constructor(){
        super(...arguments);
        this.exeList = [];
    }
};
var pageChannel = new PageEvts();
var RouteEvts = class extends Events {
    emit(events, data) {
        pageChannel.off(events);
        pageChannel.exeList.push({
            eventName: events,
            data
        });
    }
    addEvents(events) {
        if (!events || typeof events !== "object") return;
        Object.keys(events).forEach((key)=>{
            this.off(key);
            this.on(key, events[key], this);
        });
    }
};
var routeChannel = new RouteEvts();
var EventChannel = {
    pageChannel,
    routeChannel
};
function isString(o) {
    return typeof o === "string";
}
function isUndefined(o) {
    return typeof o === "undefined";
}
function isNull(o) {
    return o === null;
}
function isObject(o) {
    return o !== null && typeof o === "object";
}
function isFunction(o) {
    return typeof o === "function";
}
var isArray = Array.isArray;
var HOOK_TYPE;
(function(HOOK_TYPE2) {
    HOOK_TYPE2[HOOK_TYPE2["SINGLE"] = 0] = "SINGLE";
    HOOK_TYPE2[HOOK_TYPE2["MULTI"] = 1] = "MULTI";
    HOOK_TYPE2[HOOK_TYPE2["WATERFALL"] = 2] = "WATERFALL";
})(HOOK_TYPE || (HOOK_TYPE = {}));
var defaultMiniLifecycle = {
    app: [
        "onLaunch",
        "onShow",
        "onHide"
    ],
    page: [
        "onLoad",
        "onUnload",
        "onReady",
        "onShow",
        "onHide",
        [
            "onPullDownRefresh",
            "onReachBottom",
            "onPageScroll",
            "onResize",
            "defer:onTabItemTap",
            // defer: 需要等页面组件挂载后再调用
            "onTitleClick",
            "onOptionMenuClick",
            "events:onKeyboardHeight",
            // events: 支付宝平台需要挂载到 config.events 上
            "onPopMenuClick",
            "onPullIntercept",
            "onAddToFavorites"
        ],
        [
            "onShareAppMessage",
            "onShareTimeline"
        ]
    ],
    component: [
        "attached",
        "detached"
    ]
};
function TaroHook(type, initial) {
    return {
        type,
        initial: initial || null
    };
}
var TaroHooks = class extends Events {
    tapOneOrMany(hookName, callback) {
        const list = isFunction(callback) ? [
            callback
        ] : callback;
        list.forEach((cb)=>this.on(hookName, cb));
    }
    tap(hookName, callback) {
        const hooks2 = this.hooks;
        const { type, initial } = hooks2[hookName];
        if (type === HOOK_TYPE.SINGLE) {
            this.off(hookName);
            this.on(hookName, isFunction(callback) ? callback : callback[callback.length - 1]);
        } else {
            initial && this.off(hookName, initial);
            this.tapOneOrMany(hookName, callback);
        }
    }
    call(hookName, ...rest) {
        var _a1;
        const hook = this.hooks[hookName];
        if (!hook) return;
        const { type } = hook;
        const calls = this.callbacks;
        if (!calls) return;
        const list = calls[hookName];
        if (list) {
            const tail = list.tail;
            let node = list.next;
            let args = rest;
            let res;
            while(node !== tail){
                res = (_a1 = node.callback) === null || _a1 === void 0 ? void 0 : _a1.apply(node.context || this, args);
                if (type === HOOK_TYPE.WATERFALL) {
                    const params = [
                        res
                    ];
                    args = params;
                }
                node = node.next;
            }
            return res;
        }
    }
    isExist(hookName) {
        var _a1;
        return Boolean((_a1 = this.callbacks) === null || _a1 === void 0 ? void 0 : _a1[hookName]);
    }
    constructor(hooks2, opts){
        super(opts);
        this.hooks = hooks2;
        for(const hookName in hooks2){
            const { initial } = hooks2[hookName];
            if (isFunction(initial)) {
                this.on(hookName, initial);
            }
        }
    }
};
var hooks = new TaroHooks({
    getMiniLifecycle: TaroHook(HOOK_TYPE.SINGLE, (defaultConfig)=>defaultConfig),
    getMiniLifecycleImpl: TaroHook(HOOK_TYPE.SINGLE, function() {
        return this.call("getMiniLifecycle", defaultMiniLifecycle);
    }),
    getLifecycle: TaroHook(HOOK_TYPE.SINGLE, (instance, lifecycle)=>instance[lifecycle]),
    modifyRecursiveComponentConfig: TaroHook(HOOK_TYPE.SINGLE, (defaultConfig)=>defaultConfig),
    getPathIndex: TaroHook(HOOK_TYPE.SINGLE, (indexOfNode)=>`[${indexOfNode}]`),
    getEventCenter: TaroHook(HOOK_TYPE.SINGLE, (Events2)=>new Events2()),
    isBubbleEvents: TaroHook(HOOK_TYPE.SINGLE, (eventName)=>{
        const BUBBLE_EVENTS = /* @__PURE__ */ new Set([
            "touchstart",
            "touchmove",
            "touchcancel",
            "touchend",
            "touchforcechange",
            "tap",
            "longpress",
            "longtap",
            "transitionend",
            "animationstart",
            "animationiteration",
            "animationend"
        ]);
        return BUBBLE_EVENTS.has(eventName);
    }),
    getSpecialNodes: TaroHook(HOOK_TYPE.SINGLE, ()=>[
            "view",
            "text",
            "image"
        ]),
    onRemoveAttribute: TaroHook(HOOK_TYPE.SINGLE),
    batchedEventUpdates: TaroHook(HOOK_TYPE.SINGLE),
    mergePageInstance: TaroHook(HOOK_TYPE.SINGLE),
    modifyPageObject: TaroHook(HOOK_TYPE.SINGLE),
    createPullDownComponent: TaroHook(HOOK_TYPE.SINGLE),
    getDOMNode: TaroHook(HOOK_TYPE.SINGLE),
    modifyHydrateData: TaroHook(HOOK_TYPE.SINGLE),
    transferHydrateData: TaroHook(HOOK_TYPE.SINGLE),
    modifySetAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    modifyRmAttrPayload: TaroHook(HOOK_TYPE.SINGLE),
    onAddEvent: TaroHook(HOOK_TYPE.SINGLE),
    proxyToRaw: TaroHook(HOOK_TYPE.SINGLE, function(proxyObj) {
        return proxyObj;
    }),
    modifyMpEvent: TaroHook(HOOK_TYPE.MULTI),
    modifyMpEventImpl: TaroHook(HOOK_TYPE.SINGLE, function(e) {
        try {
            this.call("modifyMpEvent", e);
        } catch (error) {
            console.warn("[Taro modifyMpEvent hook Error]: " + (error === null || error === void 0 ? void 0 : error.message));
        }
    }),
    injectNewStyleProperties: TaroHook(HOOK_TYPE.SINGLE),
    modifyTaroEvent: TaroHook(HOOK_TYPE.MULTI),
    dispatchTaroEvent: TaroHook(HOOK_TYPE.SINGLE, (e, node)=>{
        node.dispatchEvent(e);
    }),
    dispatchTaroEventFinish: TaroHook(HOOK_TYPE.MULTI),
    modifyTaroEventReturn: TaroHook(HOOK_TYPE.SINGLE, ()=>void 0),
    modifyDispatchEvent: TaroHook(HOOK_TYPE.MULTI),
    initNativeApi: TaroHook(HOOK_TYPE.MULTI),
    patchElement: TaroHook(HOOK_TYPE.MULTI),
    modifyAddEventListener: TaroHook(HOOK_TYPE.SINGLE),
    modifyRemoveEventListener: TaroHook(HOOK_TYPE.SINGLE),
    getMemoryLevel: TaroHook(HOOK_TYPE.SINGLE)
});
var EMPTY_OBJ = {};
var noop = (..._)=>{};
function toDashed(s) {
    return s.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
}
function toCamelCase(s) {
    let camel = "";
    let nextCap = false;
    for(let i = 0; i < s.length; i++){
        if (s[i] !== "-") {
            camel += nextCap ? s[i].toUpperCase() : s[i];
            nextCap = false;
        } else {
            nextCap = true;
        }
    }
    return camel;
}
var toKebabCase = function(string) {
    return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
};
function ensure(condition, msg2) {
    if (!condition) {
        if (true) {
            const reportIssue = "\n\u5982\u6709\u7591\u95EE\uFF0C\u8BF7\u63D0\u4EA4 issue \u81F3\uFF1Ahttps://github.com/nervjs/taro/issues";
            throw new Error(msg2 + reportIssue);
        } else {
            throw new Error(msg2);
        }
    }
}
function warn(condition, msg2) {
    if (true) {
        if (condition) {
            console.warn(`[taro warn] ${msg2}`);
        }
    }
}
var _loadTime = /* @__PURE__ */ new Date().getTime().toString();
function getComponentsAlias(origin) {
    const mapping = {};
    const viewAttrs = origin.View;
    const extraList = {
        "#text": {},
        StaticView: viewAttrs,
        StaticImage: origin.Image,
        StaticText: origin.Text,
        PureView: viewAttrs,
        CatchView: viewAttrs,
        ClickView: viewAttrs
    };
    origin = Object.assign(Object.assign({}, origin), extraList);
    Object.keys(origin).sort((a, b)=>{
        const reg = /^(Static|Pure|Catch|Click)*(View|Image|Text)$/;
        const isACommonly = reg.test(a);
        const isBCommonly = reg.test(b);
        if (isACommonly && isBCommonly) {
            return a > b ? 1 : -1;
        } else if (isACommonly) {
            return -1;
        } else if (isBCommonly) {
            return 1;
        } else {
            return a >= b ? 1 : -1;
        }
    }).forEach((key, num)=>{
        const obj = {
            _num: String(num)
        };
        Object.keys(origin[key]).filter((attr)=>!/^bind/.test(attr) && ![
                "focus",
                "blur",
                "$duplicateFromComponent"
            ].includes(attr)).sort().forEach((attr, index)=>{
            obj[toCamelCase(attr)] = "p" + index;
        });
        mapping[toDashed(key)] = obj;
    });
    return mapping;
}
var Shortcuts;
(function(Shortcuts2) {
    Shortcuts2["Container"] = "container";
    Shortcuts2["Childnodes"] = "cn";
    Shortcuts2["Text"] = "v";
    Shortcuts2["NodeType"] = "nt";
    Shortcuts2["NodeName"] = "nn";
    Shortcuts2["Sid"] = "sid";
    Shortcuts2["Style"] = "st";
    Shortcuts2["Class"] = "cl";
    Shortcuts2["Src"] = "src";
})(Shortcuts || (Shortcuts = {}));
// node_modules/tslib/tslib.es6.mjs
function __rest(s, e) {
    var t = {};
    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }
        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }
        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}
function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
// node_modules/@tarojs/runtime/dist/runtime.esm.js
var PROPERTY_THRESHOLD = 2046;
var TARO_RUNTIME = "Taro runtime";
var HOOKS_APP_ID = "taro-app";
var SET_DATA = "\u5C0F\u7A0B\u5E8F setData";
var PAGE_INIT = "\u9875\u9762\u521D\u59CB\u5316";
var ROOT_STR = "root";
var HTML = "html";
var HEAD = "head";
var BODY = "body";
var APP = "app";
var CONTAINER = "container";
var DOCUMENT_ELEMENT_NAME = "#document";
var DOCUMENT_FRAGMENT = "document-fragment";
var ID = "id";
var UID = "uid";
var CLASS = "class";
var STYLE = "style";
var FOCUS = "focus";
var VIEW = "view";
var STATIC_VIEW = "static-view";
var PURE_VIEW = "pure-view";
var CLICK_VIEW = "click-view";
var PROPS = "props";
var DATASET = "dataset";
var OBJECT = "object";
var VALUE = "value";
var INPUT = "input";
var CHANGE = "change";
var CUSTOM_WRAPPER = "custom-wrapper";
var TARGET = "target";
var CURRENT_TARGET = "currentTarget";
var TYPE = "type";
var CONFIRM = "confirm";
var TIME_STAMP = "timeStamp";
var KEY_CODE = "keyCode";
var TOUCHMOVE = "touchmove";
var DATE = "Date";
var SET_TIMEOUT = "setTimeout";
var COMPILE_MODE = "compileMode";
var CATCHMOVE = "catchMove";
var CATCH_VIEW = "catch-view";
var COMMENT = "comment";
var ON_LOAD = "onLoad";
var ON_READY = "onReady";
var ON_SHOW = "onShow";
var ON_HIDE = "onHide";
var OPTIONS = "options";
var EXTERNAL_CLASSES = "externalClasses";
var EVENT_CALLBACK_RESULT = "e_result";
var BEHAVIORS = "behaviors";
var A = "a";
var CONTEXT_ACTIONS;
(function(CONTEXT_ACTIONS2) {
    CONTEXT_ACTIONS2["INIT"] = "0";
    CONTEXT_ACTIONS2["RESTORE"] = "1";
    CONTEXT_ACTIONS2["RECOVER"] = "2";
    CONTEXT_ACTIONS2["DESTROY"] = "3";
})(CONTEXT_ACTIONS || (CONTEXT_ACTIONS = {}));
var observers = [];
var MutationObserverImpl = class {
    /**
   * Configures the MutationObserver
   * to begin receiving notifications
   * through its callback function
   * when DOM changes matching the given options occur.
   *
   * Options matching is to be implemented.
   */ observe(target, options2) {
        this.disconnect();
        this.target = target;
        this.options = options2 || {};
        observers.push(this);
    }
    /**
   * Stop the MutationObserver instance
   * from receiving further notifications
   * until and unless observe() is called again.
   */ disconnect() {
        this.target = null;
        const index = observers.indexOf(this);
        if (index >= 0) {
            observers.splice(index, 1);
        }
    }
    /**
   * Removes all pending notifications
   * from the MutationObserver's notification queue
   * and returns them in a new Array of MutationRecord objects.
   */ takeRecords() {
        return this.records.splice(0, this.records.length);
    }
    constructor(callback){
        this.records = [];
        this.callback = callback;
    }
};
var sidMatches = (observerTarget, target)=>{
    return !!observerTarget && observerTarget.sid === (target === null || target === void 0 ? void 0 : target.sid);
};
var isConcerned = (record, options2)=>{
    const { characterData, characterDataOldValue, attributes, attributeOldValue, childList } = options2;
    switch(record.type){
        case "characterData":
            if (characterData) {
                if (!characterDataOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "attributes":
            if (attributes) {
                if (!attributeOldValue) record.oldValue = null;
                return true;
            }
            return false;
        case "childList":
            if (childList) {
                return true;
            }
            return false;
    }
};
var pendingMuatations = false;
function logMutation(observer, record) {
    observer.records.push(record);
    if (!pendingMuatations) {
        pendingMuatations = true;
        Promise.resolve().then(()=>{
            pendingMuatations = false;
            observers.forEach((observer2)=>{
                return observer2.callback(observer2.takeRecords());
            });
        });
    }
}
function recordMutation(record) {
    observers.forEach((observer)=>{
        const { options: options2 } = observer;
        for(let t = record.target; t; t = t.parentNode){
            if (sidMatches(observer.target, t) && isConcerned(record, options2)) {
                logMutation(observer, record);
                break;
            }
            if (!options2.subtree) break;
        }
    });
}
var MutationObserver$1 = class MutationObserver2 {
    observe(...args) {
        this.core.observe(...args);
    }
    disconnect() {
        this.core.disconnect();
    }
    takeRecords() {
        return this.core.takeRecords();
    }
    static record(record) {
        recordMutation(record);
    }
    constructor(callback){
        if (ENABLE_MUTATION_OBSERVER) {
            this.core = new MutationObserverImpl(callback);
        } else {
            if (true) {
                console.warn("[Taro Warning] \u82E5\u8981\u4F7F\u7528 MutationObserver\uFF0C\u8BF7\u5728 Taro \u7F16\u8BD1\u914D\u7F6E\u4E2D\u8BBE\u7F6E 'mini.runtime.enableMutationObserver: true'");
            }
            this.core = {
                observe: noop,
                disconnect: noop,
                takeRecords: noop
            };
        }
    }
};
function throttle(fn, threshold = 250, scope) {
    let lastTime1 = 0;
    let deferTimer;
    return function(...args) {
        const context = scope || this;
        const now2 = Date.now();
        if (now2 - lastTime1 > threshold) {
            fn.apply(this, args);
            lastTime1 = now2;
        } else {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(()=>{
                lastTime1 = now2;
                fn.apply(context, args);
            }, threshold);
        }
    };
}
function debounce(fn, ms = 250, scope) {
    let timer;
    return function(...args) {
        const context = scope || this;
        clearTimeout(timer);
        timer = setTimeout(function() {
            fn.apply(context, args);
        }, ms);
    };
}
var eventCenter = hooks.call("getEventCenter", Events);
var env = {
    window: true ? window : EMPTY_OBJ,
    document: true ? document : EMPTY_OBJ
};
var taroGetComputedStyleProvider = true ? env.window.getComputedStyle : function(element) {
    return element.style;
};
var RuntimeCache = class {
    has(identifier) {
        return this.cache.has(identifier);
    }
    set(identifier, ctx) {
        if (identifier && ctx) {
            this.cache.set(identifier, ctx);
        }
    }
    get(identifier) {
        if (this.has(identifier)) return this.cache.get(identifier);
    }
    delete(identifier) {
        this.cache.delete(identifier);
    }
    constructor(name){
        this.cache = /* @__PURE__ */ new Map();
        this.name = name;
    }
};
var _TaroHistory_instances;
var _TaroHistory_location;
var _TaroHistory_stack;
var _TaroHistory_cur;
var _TaroHistory_window;
var _TaroHistory_reset;
var cache$1 = new RuntimeCache("history");
_TaroHistory_location = /* @__PURE__ */ new WeakMap(), _TaroHistory_stack = /* @__PURE__ */ new WeakMap(), _TaroHistory_cur = /* @__PURE__ */ new WeakMap(), _TaroHistory_window = /* @__PURE__ */ new WeakMap(), _TaroHistory_instances = /* @__PURE__ */ new WeakSet(), _TaroHistory_reset = function _TaroHistory_reset2(href = "") {
    __classPrivateFieldSet(this, _TaroHistory_stack, [
        {
            state: null,
            title: "",
            url: href || __classPrivateFieldGet(this, _TaroHistory_location, "f").href
        }
    ], "f");
    __classPrivateFieldSet(this, _TaroHistory_cur, 0, "f");
};
var History = true ? env.window.History : TaroHistory;
var Current = {
    app: null,
    router: null,
    page: null
};
var getCurrentInstance = ()=>Current;
var URLSearchParams = true ? env.window.URLSearchParams : (_a = class {
    append(name, value) {
        appendTo(__classPrivateFieldGet(this, _dict, "f"), name, value);
    }
    delete(name) {
        delete __classPrivateFieldGet(this, _dict, "f")[name];
    }
    get(name) {
        const dict = __classPrivateFieldGet(this, _dict, "f");
        return name in dict ? dict[name][0] : null;
    }
    getAll(name) {
        const dict = __classPrivateFieldGet(this, _dict, "f");
        return name in dict ? dict[name].slice(0) : [];
    }
    has(name) {
        return name in __classPrivateFieldGet(this, _dict, "f");
    }
    keys() {
        return Object.keys(__classPrivateFieldGet(this, _dict, "f"));
    }
    set(name, value) {
        __classPrivateFieldGet(this, _dict, "f")[name] = [
            "" + value
        ];
    }
    forEach(callback, thisArg) {
        const dict = __classPrivateFieldGet(this, _dict, "f");
        Object.getOwnPropertyNames(dict).forEach(function(name) {
            dict[name].forEach(function(value) {
                callback.call(thisArg, value, name, this);
            }, this);
        }, this);
    }
    toJSON() {
        return {};
    }
    toString() {
        const dict = __classPrivateFieldGet(this, _dict, "f");
        const query = [];
        for(const key in dict){
            const name = encode(key);
            for(let i = 0, value = dict[key]; i < value.length; i++){
                query.push(name + "=" + encode(value[i]));
            }
        }
        return query.join("&");
    }
    constructor(query){
        _dict.set(this, /* @__PURE__ */ Object.create(null));
        query !== null && query !== void 0 ? query : query = "";
        const dict = __classPrivateFieldGet(this, _dict, "f");
        if (typeof query === "string") {
            if (query.charAt(0) === "?") {
                query = query.slice(1);
            }
            for(let pairs = query.split("&"), i = 0, length = pairs.length; i < length; i++){
                const value = pairs[i];
                const index = value.indexOf("=");
                try {
                    if (index > -1) {
                        appendTo(dict, decode(value.slice(0, index)), decode(value.slice(index + 1)));
                    } else if (value.length) {
                        appendTo(dict, decode(value), "");
                    }
                } catch (err) {
                    if (true) {
                        console.warn(`[Taro warn] URL \u53C2\u6570 ${value} decode \u5F02\u5E38`);
                    }
                }
            }
        } else {
            if (isArray(query)) {
                for(let i = 0, length = query.length; i < length; i++){
                    const value = query[i];
                    appendTo(dict, value[0], value[1]);
                }
            } else if (query.forEach) {
                query.forEach(addEach, dict);
            } else {
                for(const key in query){
                    appendTo(dict, key, query[key]);
                }
            }
        }
    }
}, _dict = /* @__PURE__ */ new WeakMap(), _a);
var _TaroURL_hash;
var _TaroURL_hostname;
var _TaroURL_pathname;
var _TaroURL_port;
var _TaroURL_protocol;
var _TaroURL_search;
_TaroURL_hash = /* @__PURE__ */ new WeakMap(), _TaroURL_hostname = /* @__PURE__ */ new WeakMap(), _TaroURL_pathname = /* @__PURE__ */ new WeakMap(), _TaroURL_port = /* @__PURE__ */ new WeakMap(), _TaroURL_protocol = /* @__PURE__ */ new WeakMap(), _TaroURL_search = /* @__PURE__ */ new WeakMap();
var TaroURLProvider = true ? env.window.URL : TaroURL;
function parseUrl(url = "") {
    const result = {
        href: "",
        origin: "",
        protocol: "",
        hostname: "",
        host: "",
        port: "",
        pathname: "",
        search: "",
        hash: ""
    };
    if (!url || !isString(url)) return result;
    url = url.trim();
    const PATTERN = /^(([^:/?#]+):)?\/\/(([^/?#]+):(.+)@)?([^/?#:]*)(:(\d+))?([^?#]*)(\?([^#]*))?(#(.*))?/;
    const matches = url.match(PATTERN);
    if (!matches) return result;
    result.protocol = matches[1] || "https:";
    result.hostname = matches[6] || "taro.com";
    result.port = matches[8] || "";
    result.pathname = matches[9] || "/";
    result.search = matches[10] || "";
    result.hash = matches[12] || "";
    result.href = url;
    result.origin = result.protocol + "//" + result.hostname + (result.port ? `:${result.port}` : "");
    result.host = result.hostname + (result.port ? `:${result.port}` : "");
    return result;
}
var _TaroLocation_instances;
var _TaroLocation_url;
var _TaroLocation_noCheckUrl;
var _TaroLocation_window;
var _TaroLocation_reset;
var _TaroLocation_getPreValue;
var _TaroLocation_rollBack;
var _TaroLocation_recordHistory;
var _TaroLocation_checkUrlChange;
var INIT_URL = "https://taro.com";
var cache = new RuntimeCache("location");
_TaroLocation_url = /* @__PURE__ */ new WeakMap(), _TaroLocation_noCheckUrl = /* @__PURE__ */ new WeakMap(), _TaroLocation_window = /* @__PURE__ */ new WeakMap(), _TaroLocation_instances = /* @__PURE__ */ new WeakSet(), _TaroLocation_reset = function _TaroLocation_reset2() {
    const Current2 = getCurrentInstance();
    const router = Current2.router;
    if (router) {
        const { path, params } = router;
        const searchArr = Object.keys(params).map((key)=>{
            return `${key}=${params[key]}`;
        });
        const searchStr = searchArr.length > 0 ? "?" + searchArr.join("&") : "";
        const url = `${INIT_URL}${path.startsWith("/") ? path : "/" + path}${searchStr}`;
        __classPrivateFieldSet(this, _TaroLocation_url, new TaroURLProvider(url), "f");
        this.trigger("__reset_history__", this.href);
    }
}, _TaroLocation_getPreValue = function _TaroLocation_getPreValue2() {
    return __classPrivateFieldGet(this, _TaroLocation_url, "f")._toRaw();
}, _TaroLocation_rollBack = function _TaroLocation_rollBack2(href) {
    __classPrivateFieldGet(this, _TaroLocation_url, "f").href = href;
}, _TaroLocation_recordHistory = function _TaroLocation_recordHistory2() {
    this.trigger("__record_history__", this.href);
}, _TaroLocation_checkUrlChange = function _TaroLocation_checkUrlChange2(preValue) {
    if (__classPrivateFieldGet(this, _TaroLocation_noCheckUrl, "f")) {
        return false;
    }
    const { protocol, hostname, port, pathname, search, hash } = __classPrivateFieldGet(this, _TaroLocation_url, "f")._toRaw();
    if (protocol !== preValue.protocol || hostname !== preValue.hostname || port !== preValue.port) {
        __classPrivateFieldGet(this, _TaroLocation_instances, "m", _TaroLocation_rollBack).call(this, preValue.href);
        return false;
    }
    if (pathname !== preValue.pathname) {
        return true;
    }
    if (search !== preValue.search) {
        return true;
    }
    if (hash !== preValue.hash) {
        __classPrivateFieldGet(this, _TaroLocation_window, "f").trigger("hashchange");
        return true;
    }
    __classPrivateFieldGet(this, _TaroLocation_instances, "m", _TaroLocation_rollBack).call(this, preValue.href);
    return false;
};
var Location = true ? env.window.Location : TaroLocation;
var machine = "Macintosh";
var arch = "Intel Mac OS X 10_14_5";
var engine = "AppleWebKit/534.36 (KHTML, like Gecko) NodeJS/v4.1.0 Chrome/76.0.3809.132 Safari/534.36";
var msg = "(" + machine + "; " + arch + ") " + engine;
var nav = true ? env.window.navigator : {
    appCodeName: "Mozilla",
    appName: "Netscape",
    appVersion: "5.0 " + msg,
    cookieEnabled: true,
    mimeTypes: [],
    onLine: true,
    platform: "MacIntel",
    plugins: [],
    product: "Taro",
    productSub: "20030107",
    userAgent: "Mozilla/5.0 " + msg,
    vendor: "Joyent",
    vendorSub: ""
};
var now;
(function() {
    let loadTime;
    if (typeof performance !== "undefined" && performance !== null && performance.now) {
        now = ()=>performance.now();
    } else if (Date.now) {
        loadTime = Date.now();
        now = ()=>Date.now() - loadTime;
    } else {
        loadTime = /* @__PURE__ */ new Date().getTime();
        now = ()=>/* @__PURE__ */ new Date().getTime() - loadTime;
    }
})();
var _raf = true ? requestAnimationFrame : function(callback) {
    const _now = now();
    const nextTime = Math.max(lastTime + 16, _now);
    return setTimeout(function() {
        callback(lastTime = nextTime);
    }, nextTime - _now);
};
var _caf = true ? cancelAnimationFrame : function(seed) {
    clearTimeout(seed);
};
var taroWindowProvider = true ? env.window : env.window = new TaroWindow();
var taroLocationProvider = taroWindowProvider.location;
var taroHistoryProvider = taroWindowProvider.history;
var addLeadingSlash = (url = "")=>url.charAt(0) === "/" ? url : "/" + url;
var hasBasename = (path = "", prefix = "")=>new RegExp("^" + prefix + "(\\/|\\?|#|$)", "i").test(path) || path === prefix;
var stripBasename = (path = "", prefix = "")=>hasBasename(path, prefix) ? path.substring(prefix.length) : path;
var stripTrailing = (str = "")=>str.replace(/[?#][\s\S]*$/, "");
var stripSuffix = (path = "", suffix = "")=>path.includes(suffix) ? path.substring(0, path.length - suffix.length) : path;
var getHomePage = (path = "", basename = "", customRoutes = {}, entryPagePath = "")=>{
    var _a1;
    const routePath = addLeadingSlash(stripBasename(path, basename));
    const alias = ((_a1 = Object.entries(customRoutes).find(([key])=>key === routePath)) === null || _a1 === void 0 ? void 0 : _a1[1]) || routePath;
    return entryPagePath || (typeof alias === "string" ? alias : alias[0]) || basename;
};
var getCurrentPage = (routerMode = "hash", basename = "/")=>{
    const pagePath = routerMode === "hash" ? taroLocationProvider.hash.slice(1).split("?")[0] : taroLocationProvider.pathname;
    return addLeadingSlash(stripBasename(pagePath, basename));
};
var incrementId = ()=>{
    const chatCodes = [];
    for(let i = 65; i <= 90; i++){
        chatCodes.push(i);
    }
    for(let i = 97; i <= 122; i++){
        chatCodes.push(i);
    }
    const chatCodesLen = chatCodes.length - 1;
    const list = [
        0,
        0
    ];
    return ()=>{
        const target = list.map((item)=>chatCodes[item]);
        const res = String.fromCharCode(...target);
        let tailIdx = list.length - 1;
        list[tailIdx]++;
        while(list[tailIdx] > chatCodesLen){
            list[tailIdx] = 0;
            tailIdx = tailIdx - 1;
            if (tailIdx < 0) {
                list.push(0);
                break;
            }
            list[tailIdx]++;
        }
        return res;
    };
};
function isElement(node) {
    return node.nodeType === 1;
}
function isText(node) {
    return node.nodeType === 3;
}
function isComment(node) {
    return node.nodeName === COMMENT;
}
function isHasExtractProp(el) {
    const res = Object.keys(el.props).find((prop)=>{
        return !(/^(class|style|id)$/.test(prop) || prop.startsWith("data-"));
    });
    return Boolean(res);
}
function isParentBound(node, type) {
    var _a1;
    while(node = (node === null || node === void 0 ? void 0 : node.parentElement) || null){
        if (!node || node.nodeName === ROOT_STR || node.nodeName === "root-portal") {
            return false;
        } else if ((_a1 = node.__handlers[type]) === null || _a1 === void 0 ? void 0 : _a1.length) {
            return true;
        }
    }
    return false;
}
function shortcutAttr(key) {
    switch(key){
        case STYLE:
            return "st";
        case ID:
            return UID;
        case CLASS:
            return "cl";
        default:
            return key;
    }
}
var customWrapperCache = /* @__PURE__ */ new Map();
function extend(ctor, methodName, options2) {
    if (isFunction(options2)) {
        options2 = {
            value: options2
        };
    }
    Object.defineProperty(ctor.prototype, methodName, Object.assign({
        configurable: true,
        enumerable: true
    }, options2));
}
var componentsAlias$1;
function getComponentsAlias2() {
    if (!componentsAlias$1) {
        componentsAlias$1 = getComponentsAlias(internalComponents);
    }
    return componentsAlias$1;
}
function convertNumber2PX(value) {
    return value + "px";
}
var ClassList = class {
    get value() {
        return this.toString();
    }
    get length() {
        return this.tokenList.length;
    }
    add() {
        let index = 0;
        let updated = false;
        const tokens = arguments;
        const length = tokens.length;
        const tokenList = this.tokenList;
        do {
            const token = tokens[index];
            if (this.checkTokenIsValid(token) && !~tokenList.indexOf(token)) {
                tokenList.push(token);
                updated = true;
            }
        }while (++index < length)
        if (updated) {
            this._update();
        }
    }
    remove() {
        let i = 0;
        let updated = false;
        const tokens = arguments;
        const length = tokens.length;
        const tokenList = this.tokenList;
        do {
            const token = tokens[i] + "";
            if (!this.checkTokenIsValid(token)) continue;
            const index = tokenList.indexOf(token);
            if (~tokenList.indexOf(token)) {
                tokenList.splice(index, 1);
                updated = true;
            }
        }while (++i < length)
        if (updated) {
            this._update();
        }
    }
    contains(token) {
        if (!this.checkTokenIsValid(token)) return false;
        return !!~this.tokenList.indexOf(token);
    }
    toggle(token, force) {
        const result = this.contains(token);
        const method = result ? force !== true && "remove" : force !== false && "add";
        if (method) {
            this[method](token);
        }
        if (force === true || force === false) {
            return force;
        } else {
            return !result;
        }
    }
    replace(token, replacement_token) {
        if (!this.checkTokenIsValid(token) || !this.checkTokenIsValid(replacement_token)) return;
        const index = this.tokenList.indexOf(token);
        if (~index) {
            this.tokenList.splice(index, 1, replacement_token);
            this._update();
        }
    }
    toString() {
        return this.tokenList.filter((v)=>v !== "").join(" ");
    }
    checkTokenIsValid(token) {
        if (token === "" || /\s/.test(token)) return false;
        return true;
    }
    _update() {
        this.el.className = this.value;
    }
    constructor(className, el){
        this.tokenList = [];
        this.el = el;
        className.trim().split(/\s+/).forEach((token)=>this.tokenList.push(token));
    }
};
var EventSource = class extends Map {
    removeNode(child) {
        const { sid, uid } = child;
        this.delete(sid);
        if (uid !== sid && uid) this.delete(uid);
    }
    removeNodeTree(child) {
        this.removeNode(child);
        const { childNodes } = child;
        childNodes.forEach((node)=>this.removeNodeTree(node));
    }
};
var eventSource = new EventSource();
var SPECIAL_NODES;
var componentsAlias;
function hydrate(node) {
    var _a1;
    componentsAlias || (componentsAlias = getComponentsAlias2());
    SPECIAL_NODES || (SPECIAL_NODES = hooks.call("getSpecialNodes"));
    const nodeName = node.nodeName;
    let compileModeName = null;
    if (isText(node)) {
        return {
            sid: node.sid,
            ["v"]: node.nodeValue,
            ["nn"]: ((_a1 = componentsAlias[nodeName]) === null || _a1 === void 0 ? void 0 : _a1._num) || "8"
        };
    }
    const data = {
        ["nn"]: nodeName,
        sid: node.sid
    };
    if (node.uid !== node.sid) {
        data.uid = node.uid;
    }
    if (SPECIAL_NODES.indexOf(nodeName) > -1) {
        if (!node.isAnyEventBinded()) {
            data["nn"] = `static-${nodeName}`;
            if (nodeName === VIEW && !isHasExtractProp(node)) {
                data["nn"] = PURE_VIEW;
            }
        }
        if (nodeName === VIEW && node.isOnlyClickBinded() && !isHasExtractProp(node)) {
            data["nn"] = CLICK_VIEW;
        }
    }
    const { props } = node;
    for(const prop in props){
        const propInCamelCase = toCamelCase(prop);
        if (!prop.startsWith("data-") && // 在 node.dataset 的数据
        prop !== CLASS && prop !== STYLE && prop !== ID && propInCamelCase !== CATCHMOVE && propInCamelCase !== COMPILE_MODE) {
            data[propInCamelCase] = props[prop];
        }
        if (nodeName === VIEW && propInCamelCase === CATCHMOVE && props[prop] !== false) {
            data["nn"] = CATCH_VIEW;
        }
        if (propInCamelCase === COMPILE_MODE) {
            compileModeName = props[prop];
        }
    }
    data["cn"] = node.childNodes.filter((node2)=>!isComment(node2)).map(hydrate);
    if (node.className !== "") {
        data["cl"] = node.className;
    }
    const cssText = node.cssText;
    if (cssText !== "" && nodeName !== "swiper-item") {
        data["st"] = cssText;
    }
    hooks.call("modifyHydrateData", data, node);
    const nn = data["nn"];
    const componentAlias = componentsAlias[nn];
    if (componentAlias) {
        data["nn"] = componentAlias._num;
        for(const prop in data){
            if (prop in componentAlias) {
                data[componentAlias[prop]] = data[prop];
                delete data[prop];
            }
        }
    }
    if (compileModeName !== null) {
        data["nn"] = compileModeName;
    }
    const resData = hooks.call("transferHydrateData", data, node, componentAlias);
    return resData || data;
}
var TaroEventTarget = class {
    addEventListener(type, handler, options2) {
        type = type.toLowerCase();
        hooks.call("onAddEvent", type, handler, options2, this);
        if (type === "regionchange") {
            this.addEventListener("begin", handler, options2);
            this.addEventListener("end", handler, options2);
            return;
        }
        let isCapture = Boolean(options2);
        let isOnce = false;
        if (isObject(options2)) {
            isCapture = Boolean(options2.capture);
            isOnce = Boolean(options2.once);
        }
        if (isOnce) {
            const wrapper = function() {
                handler.apply(this, arguments);
                this.removeEventListener(type, wrapper);
            };
            this.addEventListener(type, wrapper, Object.assign(Object.assign({}, options2), {
                once: false
            }));
            return;
        }
        warn(isCapture, "Taro \u6682\u672A\u5B9E\u73B0 event \u7684 capture \u7279\u6027\u3002");
        const oldHandler = handler;
        handler = function() {
            return oldHandler.apply(this, arguments);
        };
        handler.oldHandler = oldHandler;
        const handlers = this.__handlers[type];
        if (isArray(handlers)) {
            handlers.push(handler);
        } else {
            this.__handlers[type] = [
                handler
            ];
        }
    }
    removeEventListener(type, handler) {
        type = type.toLowerCase();
        if (type === "regionchange") {
            this.removeEventListener("begin", handler);
            this.removeEventListener("end", handler);
            return;
        }
        if (!handler) {
            return;
        }
        const handlers = this.__handlers[type];
        if (!isArray(handlers)) {
            return;
        }
        const index = handlers.findIndex((item)=>{
            if (item === handler || item.oldHandler === handler) return true;
        });
        warn(index === -1, `\u4E8B\u4EF6: '${type}' \u6CA1\u6709\u6CE8\u518C\u5728 DOM \u4E2D\uFF0C\u56E0\u6B64\u4E0D\u4F1A\u88AB\u79FB\u9664\u3002`);
        handlers.splice(index, 1);
    }
    isAnyEventBinded() {
        const handlers = this.__handlers;
        const isAnyEventBinded = Object.keys(handlers).find((key)=>handlers[key].length);
        return Boolean(isAnyEventBinded);
    }
    isOnlyClickBinded() {
        const handlers = this.__handlers;
        const isOnlyClickBinded = handlers.tap && Object.keys(handlers).length === 1;
        return Boolean(isOnlyClickBinded);
    }
    constructor(){
        this.__handlers = {};
    }
};
var CHILDNODES = "cn";
var nodeId = incrementId();
var TaroNode = class _TaroNode extends TaroEventTarget {
    updateChildNodes(isClean) {
        const cleanChildNodes = ()=>[];
        const rerenderChildNodes = ()=>{
            const childNodes = this.childNodes.filter((node)=>!isComment(node));
            return childNodes.map(hydrate);
        };
        this.enqueueUpdate({
            path: `${this._path}.${CHILDNODES}`,
            value: isClean ? cleanChildNodes : rerenderChildNodes
        });
    }
    updateSingleChild(index) {
        this.childNodes.forEach((child, childIndex)=>{
            if (isComment(child)) return;
            if (index && childIndex < index) return;
            this.enqueueUpdate({
                path: child._path,
                value: this.hydrate(child)
            });
        });
    }
    get _root() {
        var _a1;
        return ((_a1 = this.parentNode) === null || _a1 === void 0 ? void 0 : _a1._root) || null;
    }
    findIndex(refChild) {
        const index = this.childNodes.indexOf(refChild);
        ensure(index !== -1, "The node to be replaced is not a child of this node.");
        return index;
    }
    get _path() {
        const parentNode = this.parentNode;
        if (parentNode) {
            const list = parentNode.childNodes.filter((node)=>!isComment(node));
            const indexOfNode = list.indexOf(this);
            const index = hooks.call("getPathIndex", indexOfNode);
            return `${parentNode._path}.${CHILDNODES}.${index}`;
        }
        return "";
    }
    get nextSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) + 1]) || null;
    }
    get previousSibling() {
        const parentNode = this.parentNode;
        return (parentNode === null || parentNode === void 0 ? void 0 : parentNode.childNodes[parentNode.findIndex(this) - 1]) || null;
    }
    get parentElement() {
        const parentNode = this.parentNode;
        if ((parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 1) {
            return parentNode;
        }
        return null;
    }
    get firstChild() {
        return this.childNodes[0] || null;
    }
    get lastChild() {
        const childNodes = this.childNodes;
        return childNodes[childNodes.length - 1] || null;
    }
    /**
   * @textContent 目前只能置空子元素
   * @TODO 等待完整 innerHTML 实现
   */ // eslint-disable-next-line accessor-pairs
    set textContent(text) {
        const removedNodes = this.childNodes.slice();
        const addedNodes = [];
        while(this.firstChild){
            this.removeChild(this.firstChild, {
                doUpdate: false
            });
        }
        if (text === "") {
            this.updateChildNodes(true);
        } else {
            const newText = env.document.createTextNode(text);
            addedNodes.push(newText);
            this.appendChild(newText);
            this.updateChildNodes();
        }
        MutationObserver$1.record({
            type: "childList",
            target: this,
            removedNodes,
            addedNodes
        });
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore
   * @scenario
   * [A,B,C]
   *   1. insert D before C, D has no parent
   *   2. insert D before C, D has the same parent of C
   *   3. insert D before C, D has the different parent of C
   */ insertBefore(newChild, refChild, isReplace) {
        if (newChild.nodeName === DOCUMENT_FRAGMENT) {
            newChild.childNodes.reduceRight((previousValue, currentValue)=>{
                this.insertBefore(currentValue, previousValue);
                return currentValue;
            }, refChild);
            return newChild;
        }
        newChild.remove({
            cleanRef: false
        });
        let index = 0;
        newChild.parentNode = this;
        if (refChild) {
            index = this.findIndex(refChild);
            this.childNodes.splice(index, 0, newChild);
        } else {
            this.childNodes.push(newChild);
        }
        const childNodesLength = this.childNodes.length;
        if (this._root) {
            if (!refChild) {
                const isOnlyChild = childNodesLength === 1;
                if (isOnlyChild) {
                    this.updateChildNodes();
                } else {
                    this.enqueueUpdate({
                        path: newChild._path,
                        value: this.hydrate(newChild)
                    });
                }
            } else if (isReplace) {
                this.enqueueUpdate({
                    path: newChild._path,
                    value: this.hydrate(newChild)
                });
            } else {
                const mark = childNodesLength * 2 / 3;
                if (mark > index) {
                    this.updateChildNodes();
                } else {
                    this.updateSingleChild(index);
                }
            }
        }
        MutationObserver$1.record({
            type: "childList",
            target: this,
            addedNodes: [
                newChild
            ],
            removedNodes: isReplace ? [
                refChild
            ] : [],
            nextSibling: isReplace ? refChild.nextSibling : refChild || null,
            /** insertBefore & appendChild */ previousSibling: newChild.previousSibling
        });
        return newChild;
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/appendChild
   * @scenario
   * [A,B,C]
   *   1. append C, C has no parent
   *   2. append C, C has the same parent of B
   *   3. append C, C has the different parent of B
   */ appendChild(newChild) {
        return this.insertBefore(newChild);
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/replaceChild
   * @scenario
   * [A,B,C]
   *   1. replace B with C, C has no parent
   *   2. replace B with C, C has no parent, C has the same parent of B
   *   3. replace B with C, C has no parent, C has the different parent of B
   */ replaceChild(newChild, oldChild) {
        if (oldChild.parentNode !== this) return;
        this.insertBefore(newChild, oldChild, true);
        oldChild.remove({
            doUpdate: false
        });
        return oldChild;
    }
    /**
   * @doc https://developer.mozilla.org/zh-CN/docs/Web/API/Node/removeChild
   * @scenario
   * [A,B,C]
   *   1. remove A or B
   *   2. remove C
   */ removeChild(child, options2 = {}) {
        const { cleanRef, doUpdate } = options2;
        if (cleanRef !== false && doUpdate !== false) {
            MutationObserver$1.record({
                type: "childList",
                target: this,
                removedNodes: [
                    child
                ],
                nextSibling: child.nextSibling,
                previousSibling: child.previousSibling
            });
        }
        const index = this.findIndex(child);
        this.childNodes.splice(index, 1);
        child.parentNode = null;
        if (cleanRef !== false) {
            eventSource.removeNodeTree(child);
        }
        if (this._root && doUpdate !== false) {
            this.updateChildNodes();
        }
        return child;
    }
    remove(options2) {
        var _a1;
        (_a1 = this.parentNode) === null || _a1 === void 0 ? void 0 : _a1.removeChild(this, options2);
    }
    hasChildNodes() {
        return this.childNodes.length > 0;
    }
    enqueueUpdate(payload) {
        var _a1;
        (_a1 = this._root) === null || _a1 === void 0 ? void 0 : _a1.enqueueUpdate(payload);
    }
    get ownerDocument() {
        return env.document;
    }
    static extend(methodName, options2) {
        extend(_TaroNode, methodName, options2);
    }
    constructor(){
        super();
        this.parentNode = null;
        this.childNodes = [];
        this.hydrate = (node)=>()=>hydrate(node);
        this.uid = "_" + nodeId();
        this.sid = this.uid;
        eventSource.set(this.sid, this);
    }
};
var WEBKIT = "webkit";
var styleProperties = [
    "all",
    "appearance",
    "backdropFilter",
    "blockOverflow",
    "blockSize",
    "bottom",
    "clear",
    "contain",
    "content",
    "continue",
    "cursor",
    "direction",
    "display",
    "filter",
    "float",
    "gap",
    "height",
    "inset",
    "isolation",
    "left",
    "letterSpacing",
    "lightingColor",
    "markerSide",
    "mixBlendMode",
    "opacity",
    "order",
    "position",
    "quotes",
    "resize",
    "right",
    "rowGap",
    "tabSize",
    "tableLayout",
    "top",
    "userSelect",
    "verticalAlign",
    "visibility",
    "voiceFamily",
    "volume",
    "whiteSpace",
    "widows",
    "width",
    "zIndex",
    "pointerEvents",
    "aspectRatio"
];
function combine(prefix, list, excludeSelf) {
    !excludeSelf && styleProperties.push(prefix);
    list.forEach((item)=>{
        styleProperties.push(prefix + item);
        if (prefix === WEBKIT) {
            styleProperties.push("Webkit" + item);
        }
    });
}
var color = "Color";
var style = "Style";
var width = "Width";
var image = "Image";
var size = "Size";
var color_style_width = [
    color,
    style,
    width
];
var fitlength_fitwidth_image = [
    "FitLength",
    "FitWidth",
    image
];
var fitlength_fitwidth_image_radius = [
    ...fitlength_fitwidth_image,
    "Radius"
];
var color_style_width_fitlength_fitwidth_image = [
    ...color_style_width,
    ...fitlength_fitwidth_image
];
var endRadius_startRadius = [
    "EndRadius",
    "StartRadius"
];
var bottom_left_right_top = [
    "Bottom",
    "Left",
    "Right",
    "Top"
];
var end_start = [
    "End",
    "Start"
];
var content_items_self = [
    "Content",
    "Items",
    "Self"
];
var blockSize_height_inlineSize_width = [
    "BlockSize",
    "Height",
    "InlineSize",
    width
];
var after_before = [
    "After",
    "Before"
];
combine("borderBlock", color_style_width);
combine("borderBlockEnd", color_style_width);
combine("borderBlockStart", color_style_width);
combine("outline", [
    ...color_style_width,
    "Offset"
]);
combine("border", [
    ...color_style_width,
    "Boundary",
    "Break",
    "Collapse",
    "Radius",
    "Spacing"
]);
combine("borderFit", [
    "Length",
    width
]);
combine("borderInline", color_style_width);
combine("borderInlineEnd", color_style_width);
combine("borderInlineStart", color_style_width);
combine("borderLeft", color_style_width_fitlength_fitwidth_image);
combine("borderRight", color_style_width_fitlength_fitwidth_image);
combine("borderTop", color_style_width_fitlength_fitwidth_image);
combine("borderBottom", color_style_width_fitlength_fitwidth_image);
combine("textDecoration", [
    color,
    style,
    "Line"
]);
combine("textEmphasis", [
    color,
    style,
    "Position"
]);
combine("scrollMargin", bottom_left_right_top);
combine("scrollPadding", bottom_left_right_top);
combine("padding", bottom_left_right_top);
combine("margin", [
    ...bottom_left_right_top,
    "Trim"
]);
combine("scrollMarginBlock", end_start);
combine("scrollMarginInline", end_start);
combine("scrollPaddingBlock", end_start);
combine("scrollPaddingInline", end_start);
combine("gridColumn", end_start);
combine("gridRow", end_start);
combine("insetBlock", end_start);
combine("insetInline", end_start);
combine("marginBlock", end_start);
combine("marginInline", end_start);
combine("paddingBlock", end_start);
combine("paddingInline", end_start);
combine("pause", after_before);
combine("cue", after_before);
combine("mask", [
    "Clip",
    "Composite",
    image,
    "Mode",
    "Origin",
    "Position",
    "Repeat",
    size,
    "Type"
]);
combine("borderImage", [
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    "Transform",
    width
]);
combine("maskBorder", [
    "Mode",
    "Outset",
    "Repeat",
    "Slice",
    "Source",
    width
]);
combine("font", [
    "Family",
    "FeatureSettings",
    "Kerning",
    "LanguageOverride",
    "MaxSize",
    "MinSize",
    "OpticalSizing",
    "Palette",
    size,
    "SizeAdjust",
    "Stretch",
    style,
    "Weight",
    "VariationSettings"
]);
combine("transform", [
    "Box",
    "Origin",
    style
]);
combine("background", [
    color,
    image,
    "Attachment",
    "BlendMode",
    "Clip",
    "Origin",
    "Position",
    "Repeat",
    size
]);
combine("listStyle", [
    image,
    "Position",
    "Type"
]);
combine("scrollSnap", [
    "Align",
    "Stop",
    "Type"
]);
combine("grid", [
    "Area",
    "AutoColumns",
    "AutoFlow",
    "AutoRows"
]);
combine("gridTemplate", [
    "Areas",
    "Columns",
    "Rows"
]);
combine("overflow", [
    "Block",
    "Inline",
    "Wrap",
    "X",
    "Y"
]);
combine("transition", [
    "Delay",
    "Duration",
    "Property",
    "TimingFunction"
]);
combine("color", [
    "Adjust",
    "InterpolationFilters",
    "Scheme"
]);
combine("textAlign", [
    "All",
    "Last"
]);
combine("page", [
    "BreakAfter",
    "BreakBefore",
    "BreakInside"
]);
combine("animation", [
    "Delay",
    "Direction",
    "Duration",
    "FillMode",
    "IterationCount",
    "Name",
    "PlayState",
    "TimingFunction"
]);
combine("flex", [
    "Basis",
    "Direction",
    "Flow",
    "Grow",
    "Shrink",
    "Wrap"
]);
combine("offset", [
    ...after_before,
    ...end_start,
    "Anchor",
    "Distance",
    "Path",
    "Position",
    "Rotate"
]);
combine("perspective", [
    "Origin"
]);
combine("clip", [
    "Path",
    "Rule"
]);
combine("flow", [
    "From",
    "Into"
]);
combine("align", [
    "Content",
    "Items",
    "Self"
], true);
combine("alignment", [
    "Adjust",
    "Baseline"
], true);
combine("borderStart", endRadius_startRadius, true);
combine("borderEnd", endRadius_startRadius, true);
combine("borderCorner", [
    "Fit",
    image,
    "ImageTransform"
], true);
combine("borderTopLeft", fitlength_fitwidth_image_radius, true);
combine("borderTopRight", fitlength_fitwidth_image_radius, true);
combine("borderBottomLeft", fitlength_fitwidth_image_radius, true);
combine("borderBottomRight", fitlength_fitwidth_image_radius, true);
combine("column", [
    "s",
    "Count",
    "Fill",
    "Gap",
    "Rule",
    "RuleColor",
    "RuleStyle",
    "RuleWidth",
    "Span",
    width
], true);
combine("break", [
    ...after_before,
    "Inside"
], true);
combine("wrap", [
    ...after_before,
    "Flow",
    "Inside",
    "Through"
], true);
combine("justify", content_items_self, true);
combine("place", content_items_self, true);
combine("max", [
    ...blockSize_height_inlineSize_width,
    "Lines"
], true);
combine("min", blockSize_height_inlineSize_width, true);
combine("line", [
    "Break",
    "Clamp",
    "Grid",
    "Height",
    "Padding",
    "Snap"
], true);
combine("inline", [
    "BoxAlign",
    size,
    "Sizing"
], true);
combine("text", [
    "CombineUpright",
    "GroupAlign",
    "Height",
    "Indent",
    "Justify",
    "Orientation",
    "Overflow",
    "Shadow",
    "SpaceCollapse",
    "SpaceTrim",
    "Spacing",
    "Transform",
    "UnderlinePosition",
    "Wrap"
], true);
combine("shape", [
    "ImageThreshold",
    "Inside",
    "Margin",
    "Outside"
], true);
combine("word", [
    "Break",
    "Spacing",
    "Wrap"
], true);
combine("object", [
    "Fit",
    "Position"
], true);
combine("box", [
    "DecorationBreak",
    "Shadow",
    "Sizing",
    "Snap"
], true);
combine(WEBKIT, [
    "LineClamp",
    "BoxOrient",
    "TextFillColor",
    "TextStroke",
    "TextStrokeColor",
    "TextStrokeWidth"
], true);
function recordCss(obj) {
    MutationObserver$1.record({
        type: "attributes",
        target: obj._element,
        attributeName: "style",
        oldValue: obj.cssText
    });
}
function enqueueUpdate(obj) {
    const element = obj._element;
    if (element._root) {
        element.enqueueUpdate({
            path: `${element._path}.${"st"}`,
            value: obj.cssText
        });
    }
}
function setStyle(newVal, styleKey) {
    warn(isString(newVal) && newVal.length > PROPERTY_THRESHOLD, `Style \u5C5E\u6027 ${styleKey} \u7684\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\uFF0C\u8003\u8651\u4F7F\u7528 CSS \u7C7B\u6216\u5176\u5B83\u65B9\u6848\u66FF\u4EE3\u3002`);
    const old = this[styleKey];
    if (old === newVal) return;
    !this._pending && recordCss(this);
    if (isNull(newVal) || isUndefined(newVal) || newVal === "") {
        this._usedStyleProp.delete(styleKey);
        delete this._value[styleKey];
    } else {
        this._usedStyleProp.add(styleKey);
        this._value[styleKey] = newVal;
    }
    !this._pending && enqueueUpdate(this);
}
function initStyle(ctor, styleProperties2) {
    const properties = {};
    for(let i = 0; i < styleProperties2.length; i++){
        const styleKey = styleProperties2[i];
        if (ctor[styleKey]) return;
        properties[styleKey] = {
            get () {
                const val = this._value[styleKey];
                return isNull(val) || isUndefined(val) ? "" : val;
            },
            set (newVal) {
                setStyle.call(this, newVal, styleKey);
            }
        };
    }
    Object.defineProperties(ctor.prototype, properties);
}
function isCssVariable(propertyName) {
    return /^--/.test(propertyName);
}
var Style = class {
    setCssVariables(styleKey) {
        this.hasOwnProperty(styleKey) || Object.defineProperty(this, styleKey, {
            enumerable: true,
            configurable: true,
            get: ()=>{
                return this._value[styleKey] || "";
            },
            set: (newVal)=>{
                setStyle.call(this, newVal, styleKey);
            }
        });
    }
    get cssText() {
        if (!this._usedStyleProp.size) return "";
        const texts = [];
        this._usedStyleProp.forEach((key)=>{
            const val = this[key];
            if (isNull(val) || isUndefined(val)) return;
            let styleName = isCssVariable(key) ? key : toDashed(key);
            if (styleName.indexOf("webkit") === 0 || styleName.indexOf("Webkit") === 0) {
                styleName = `-${styleName}`;
            }
            texts.push(`${styleName}: ${val};`);
        });
        return texts.join(" ");
    }
    set cssText(str) {
        this._pending = true;
        recordCss(this);
        this._usedStyleProp.forEach((prop)=>{
            this.removeProperty(prop);
        });
        if (str === "" || isUndefined(str) || isNull(str)) {
            this._pending = false;
            enqueueUpdate(this);
            return;
        }
        const rules = str.split(";");
        for(let i = 0; i < rules.length; i++){
            const rule = rules[i].trim();
            if (rule === "") {
                continue;
            }
            const [propName, ...valList] = rule.split(":");
            const val = valList.join(":");
            if (isUndefined(val)) {
                continue;
            }
            this.setProperty(propName.trim(), val.trim());
        }
        this._pending = false;
        enqueueUpdate(this);
    }
    setProperty(propertyName, value) {
        if (propertyName[0] === "-") {
            this.setCssVariables(propertyName);
        } else {
            propertyName = toCamelCase(propertyName);
        }
        if (isNull(value) || isUndefined(value)) {
            this.removeProperty(propertyName);
        } else {
            this[propertyName] = value;
        }
    }
    removeProperty(propertyName) {
        propertyName = toCamelCase(propertyName);
        if (!this._usedStyleProp.has(propertyName)) {
            return "";
        }
        const value = this[propertyName];
        this[propertyName] = void 0;
        return value;
    }
    getPropertyValue(propertyName) {
        propertyName = toCamelCase(propertyName);
        const value = this[propertyName];
        if (!value) {
            return "";
        }
        return value;
    }
    constructor(element){
        this._element = element;
        this._usedStyleProp = /* @__PURE__ */ new Set();
        this._value = {};
    }
};
initStyle(Style, styleProperties);
hooks.tap("injectNewStyleProperties", (newStyleProperties)=>{
    if (isArray(newStyleProperties)) {
        initStyle(Style, newStyleProperties);
    } else {
        if (typeof newStyleProperties !== "string") return;
        initStyle(Style, [
            newStyleProperties
        ]);
    }
});
function returnTrue() {
    return true;
}
function treeToArray(root, predict) {
    const array = [];
    const filter = predict !== null && predict !== void 0 ? predict : returnTrue;
    let object = root;
    while(object){
        if (object.nodeType === 1 && filter(object)) {
            array.push(object);
        }
        object = following(object, root);
    }
    return array;
}
function following(el, root) {
    const firstChild = el.firstChild;
    const isElmentTypeValid = el.nodeType === 1 || el.nodeType === 9;
    if (firstChild && isElmentTypeValid) {
        return firstChild;
    }
    let current = el;
    do {
        if (current === root) {
            return null;
        }
        const nextSibling = current.nextSibling;
        if (nextSibling) {
            return nextSibling;
        }
        current = current.parentElement;
    }while (current)
    return null;
}
var TaroElement = class _TaroElement extends TaroNode {
    _stopPropagation(event) {
        let target = this;
        while(target = target.parentNode){
            const listeners = target.__handlers[event.type];
            if (!isArray(listeners)) {
                continue;
            }
            for(let i = listeners.length; i--;){
                const l = listeners[i];
                l._stop = true;
            }
        }
    }
    get id() {
        return this.getAttribute(ID);
    }
    set id(val) {
        this.setAttribute(ID, val);
    }
    get className() {
        return this.getAttribute(CLASS) || "";
    }
    set className(val) {
        this.setAttribute(CLASS, val);
    }
    get cssText() {
        return this.getAttribute(STYLE) || "";
    }
    get classList() {
        return new ClassList(this.className, this);
    }
    get children() {
        return this.childNodes.filter(isElement);
    }
    get attributes() {
        const props = this.props;
        const propKeys = Object.keys(props);
        const style2 = this.style.cssText;
        const attrs = propKeys.map((key)=>({
                name: key,
                value: props[key]
            }));
        return attrs.concat(style2 ? {
            name: STYLE,
            value: style2
        } : []);
    }
    get textContent() {
        let text = "";
        const childNodes = this.childNodes;
        for(let i = 0; i < childNodes.length; i++){
            text += childNodes[i].textContent;
        }
        return text;
    }
    set textContent(text) {
        super.textContent = text;
    }
    hasAttribute(qualifiedName) {
        return !isUndefined(this.props[qualifiedName]);
    }
    hasAttributes() {
        return this.attributes.length > 0;
    }
    get focus() {
        return function() {
            this.setAttribute(FOCUS, true);
        };
    }
    // 兼容 Vue3，详情请见：https://github.com/NervJS/taro/issues/10579
    set focus(value) {
        this.setAttribute(FOCUS, value);
    }
    blur() {
        this.setAttribute(FOCUS, false);
    }
    setAttribute(qualifiedName, value) {
        warn(isString(value) && value.length > PROPERTY_THRESHOLD, `\u5143\u7D20 ${this.nodeName} \u7684 ${qualifiedName} \u5C5E\u6027\u503C\u6570\u636E\u91CF\u8FC7\u5927\uFF0C\u53EF\u80FD\u4F1A\u5F71\u54CD\u6E32\u67D3\u6027\u80FD\u3002\u8003\u8651\u964D\u4F4E\u56FE\u7247\u8F6C\u4E3A base64 \u7684\u9608\u503C\u6216\u5728 CSS \u4E2D\u4F7F\u7528 base64\u3002`);
        const isPureView = this.nodeName === VIEW && !isHasExtractProp(this) && !this.isAnyEventBinded();
        if (qualifiedName !== STYLE) {
            MutationObserver$1.record({
                target: this,
                type: "attributes",
                attributeName: qualifiedName,
                oldValue: this.getAttribute(qualifiedName)
            });
        }
        switch(qualifiedName){
            case STYLE:
                this.style.cssText = value;
                break;
            case ID:
                if (this.uid !== this.sid) {
                    eventSource.delete(this.uid);
                }
                value = String(value);
                this.props[qualifiedName] = this.uid = value;
                eventSource.set(value, this);
                break;
            default:
                this.props[qualifiedName] = value;
                if (qualifiedName.startsWith("data-")) {
                    if (this.dataset === EMPTY_OBJ) {
                        this.dataset = /* @__PURE__ */ Object.create(null);
                    }
                    this.dataset[toCamelCase(qualifiedName.replace(/^data-/, ""))] = value;
                }
                break;
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const clickViewAlias = componentsAlias2[CLICK_VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const catchViewAlias = componentsAlias2[CATCH_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: isFunction(value) ? ()=>value : value
        };
        hooks.call("modifySetAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: value ? catchViewAlias : this.isOnlyClickBinded() && !isHasExtractProp(this) ? clickViewAlias : this.isAnyEventBinded() ? viewAlias : staticViewAlias
                });
            } else if (isPureView && isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: staticViewAlias
                });
            }
        }
    }
    removeAttribute(qualifiedName) {
        const isStaticView = this.nodeName === VIEW && isHasExtractProp(this) && !this.isAnyEventBinded();
        MutationObserver$1.record({
            target: this,
            type: "attributes",
            attributeName: qualifiedName,
            oldValue: this.getAttribute(qualifiedName)
        });
        if (qualifiedName === STYLE) {
            this.style.cssText = "";
        } else {
            const isInterrupt = hooks.call("onRemoveAttribute", this, qualifiedName);
            if (isInterrupt) {
                return;
            }
            if (!this.props.hasOwnProperty(qualifiedName)) {
                return;
            }
            delete this.props[qualifiedName];
        }
        if (!this._root) return;
        const componentsAlias2 = getComponentsAlias2();
        const _alias = componentsAlias2[this.nodeName];
        const viewAlias = componentsAlias2[VIEW]._num;
        const staticViewAlias = componentsAlias2[STATIC_VIEW]._num;
        const pureViewAlias = componentsAlias2[PURE_VIEW]._num;
        const clickViewAlias = componentsAlias2[CLICK_VIEW]._num;
        const _path = this._path;
        qualifiedName = shortcutAttr(qualifiedName);
        const qualifiedNameInCamelCase = toCamelCase(qualifiedName);
        const payload = {
            path: `${_path}.${qualifiedNameInCamelCase}`,
            value: ""
        };
        hooks.call("modifyRmAttrPayload", this, qualifiedName, payload, componentsAlias2);
        if (_alias) {
            const qualifiedNameAlias = _alias[qualifiedNameInCamelCase] || qualifiedName;
            payload.path = `${_path}.${toCamelCase(qualifiedNameAlias)}`;
        }
        this.enqueueUpdate(payload);
        if (this.nodeName === VIEW) {
            if (qualifiedNameInCamelCase === CATCHMOVE) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: this.isOnlyClickBinded() && !isHasExtractProp(this) ? clickViewAlias : this.isAnyEventBinded() ? viewAlias : isHasExtractProp(this) ? staticViewAlias : pureViewAlias
                });
            } else if (isStaticView && !isHasExtractProp(this)) {
                this.enqueueUpdate({
                    path: `${_path}.${"nn"}`,
                    value: pureViewAlias
                });
            }
        }
    }
    getAttribute(qualifiedName) {
        const attr = qualifiedName === STYLE ? this.style.cssText : this.props[qualifiedName];
        return attr !== null && attr !== void 0 ? attr : "";
    }
    getElementsByTagName(tagName) {
        return treeToArray(this, (el)=>{
            return el.nodeName === tagName || tagName === "*" && this !== el;
        });
    }
    getElementsByClassName(className) {
        const classNames = className.trim().split(/\s+/);
        return treeToArray(this, (el)=>{
            const classList = el.classList;
            return classNames.every((c)=>classList.contains(c));
        });
    }
    dispatchEvent(event) {
        const cancelable = event.cancelable;
        const listeners = this.__handlers[event.type];
        if (!isArray(listeners)) {
            return false;
        }
        for(let i = listeners.length; i--;){
            const listener = listeners[i];
            let result;
            if (listener._stop) {
                listener._stop = false;
            } else {
                hooks.call("modifyDispatchEvent", event, this);
                result = listener.call(this, event);
            }
            if ((result === false || event._end) && cancelable) {
                event.defaultPrevented = true;
            }
            if (!isUndefined(result) && event.mpEvent) {
                const res = hooks.call("modifyTaroEventReturn", this, event, result);
                if (res) {
                    event.mpEvent[EVENT_CALLBACK_RESULT] = result;
                }
            }
            if (event._end && event._stop) {
                break;
            }
        }
        if (event._stop) {
            this._stopPropagation(event);
        }
        return listeners != null;
    }
    addEventListener(type, handler, options2) {
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        let sideEffect = true;
        if (isObject(options2) && options2.sideEffect === false) {
            sideEffect = false;
            delete options2.sideEffect;
        }
        hooks.call("modifyAddEventListener", this, sideEffect, getComponentsAlias2);
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const alias = componentsAlias2[name]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: alias
            });
        }
        super.addEventListener(type, handler, options2);
    }
    removeEventListener(type, handler, sideEffect = true) {
        super.removeEventListener(type, handler);
        const name = this.nodeName;
        const SPECIAL_NODES2 = hooks.call("getSpecialNodes");
        hooks.call("modifyRemoveEventListener", this, sideEffect, getComponentsAlias2);
        if (sideEffect !== false && !this.isAnyEventBinded() && SPECIAL_NODES2.indexOf(name) > -1) {
            const componentsAlias2 = getComponentsAlias2();
            const value = isHasExtractProp(this) ? `static-${name}` : `pure-${name}`;
            const valueAlias = componentsAlias2[value]._num;
            this.enqueueUpdate({
                path: `${this._path}.${"nn"}`,
                value: valueAlias
            });
        }
    }
    static extend(methodName, options2) {
        extend(_TaroElement, methodName, options2);
    }
    constructor(){
        super();
        this.props = {};
        this.dataset = EMPTY_OBJ;
        this.nodeType = 1;
        this.style = new Style(this);
        hooks.call("patchElement", this);
    }
};
var options = {
    prerender: true,
    debug: false
};
function initPosition() {
    return {
        index: 0,
        column: 0,
        line: 0
    };
}
function feedPosition(position, str, len) {
    const start = position.index;
    const end = position.index = start + len;
    for(let i = start; i < end; i++){
        const char = str.charAt(i);
        if (char === "\n") {
            position.line++;
            position.column = 0;
        } else {
            position.column++;
        }
    }
}
function jumpPosition(position, str, end) {
    const len = end - position.index;
    return feedPosition(position, str, len);
}
function copyPosition(position) {
    return {
        index: position.index,
        line: position.line,
        column: position.column
    };
}
var whitespace = /\s/;
function isWhitespaceChar(char) {
    return whitespace.test(char);
}
var equalSign = /=/;
function isEqualSignChar(char) {
    return equalSign.test(char);
}
function shouldBeIgnore(tagName) {
    const name = tagName.toLowerCase();
    if (options.html.skipElements.has(name)) {
        return true;
    }
    return false;
}
var alphanumeric = /[A-Za-z0-9]/;
function findTextEnd(str, index) {
    while(true){
        const textEnd = str.indexOf("<", index);
        if (textEnd === -1) {
            return textEnd;
        }
        const char = str.charAt(textEnd + 1);
        if (char === "/" || char === "!" || alphanumeric.test(char)) {
            return textEnd;
        }
        index = textEnd + 1;
    }
}
function isWordEnd(cursor, wordBegin, html) {
    if (!isWhitespaceChar(html.charAt(cursor))) return false;
    const len = html.length;
    for(let i = cursor - 1; i > wordBegin; i--){
        const char = html.charAt(i);
        if (!isWhitespaceChar(char)) {
            if (isEqualSignChar(char)) return false;
            break;
        }
    }
    for(let i = cursor + 1; i < len; i++){
        const char = html.charAt(i);
        if (!isWhitespaceChar(char)) {
            if (isEqualSignChar(char)) return false;
            return true;
        }
    }
}
var Scanner = class {
    scan() {
        const { html, position } = this;
        const len = html.length;
        while(position.index < len){
            const start = position.index;
            this.scanText();
            if (position.index === start) {
                const isComment2 = html.startsWith("!--", start + 1);
                if (isComment2) {
                    this.scanComment();
                } else {
                    const tagName = this.scanTag();
                    if (shouldBeIgnore(tagName)) {
                        this.scanSkipTag(tagName);
                    }
                }
            }
        }
        return this.tokens;
    }
    scanText() {
        const type = "text";
        const { html, position } = this;
        let textEnd = findTextEnd(html, position.index);
        if (textEnd === position.index) {
            return;
        }
        if (textEnd === -1) {
            textEnd = html.length;
        }
        const start = copyPosition(position);
        const content = html.slice(position.index, textEnd);
        jumpPosition(position, html, textEnd);
        const end = copyPosition(position);
        this.tokens.push({
            type,
            content,
            position: {
                start,
                end
            }
        });
    }
    scanComment() {
        const type = "comment";
        const { html, position } = this;
        const start = copyPosition(position);
        feedPosition(position, html, 4);
        let contentEnd = html.indexOf("-->", position.index);
        let commentEnd = contentEnd + 3;
        if (contentEnd === -1) {
            contentEnd = commentEnd = html.length;
        }
        const content = html.slice(position.index, contentEnd);
        jumpPosition(position, html, commentEnd);
        this.tokens.push({
            type,
            content,
            position: {
                start,
                end: copyPosition(position)
            }
        });
    }
    scanTag() {
        this.scanTagStart();
        const tagName = this.scanTagName();
        this.scanAttrs();
        this.scanTagEnd();
        return tagName;
    }
    scanTagStart() {
        const type = "tag-start";
        const { html, position } = this;
        const secondChar = html.charAt(position.index + 1);
        const close = secondChar === "/";
        const start = copyPosition(position);
        feedPosition(position, html, close ? 2 : 1);
        this.tokens.push({
            type,
            close,
            position: {
                start
            }
        });
    }
    scanTagEnd() {
        const type = "tag-end";
        const { html, position } = this;
        const firstChar = html.charAt(position.index);
        const close = firstChar === "/";
        feedPosition(position, html, close ? 2 : 1);
        const end = copyPosition(position);
        this.tokens.push({
            type,
            close,
            position: {
                end
            }
        });
    }
    scanTagName() {
        const type = "tag";
        const { html, position } = this;
        const len = html.length;
        let start = position.index;
        while(start < len){
            const char = html.charAt(start);
            const isTagChar = !(isWhitespaceChar(char) || char === "/" || char === ">");
            if (isTagChar) break;
            start++;
        }
        let end = start + 1;
        while(end < len){
            const char = html.charAt(end);
            const isTagChar = !(isWhitespaceChar(char) || char === "/" || char === ">");
            if (!isTagChar) break;
            end++;
        }
        jumpPosition(position, html, end);
        const tagName = html.slice(start, end);
        this.tokens.push({
            type,
            content: tagName
        });
        return tagName;
    }
    scanAttrs() {
        const { html, position, tokens } = this;
        let cursor = position.index;
        let quote = null;
        let wordBegin = cursor;
        const words = [];
        const len = html.length;
        while(cursor < len){
            const char = html.charAt(cursor);
            if (quote) {
                const isQuoteEnd = char === quote;
                if (isQuoteEnd) {
                    quote = null;
                }
                cursor++;
                continue;
            }
            const isTagEnd = char === "/" || char === ">";
            if (isTagEnd) {
                if (cursor !== wordBegin) {
                    words.push(html.slice(wordBegin, cursor));
                }
                break;
            }
            if (isWordEnd(cursor, wordBegin, html)) {
                if (cursor !== wordBegin) {
                    words.push(html.slice(wordBegin, cursor));
                }
                wordBegin = cursor + 1;
                cursor++;
                continue;
            }
            const isQuoteStart = char === "'" || char === '"';
            if (isQuoteStart) {
                quote = char;
                cursor++;
                continue;
            }
            cursor++;
        }
        jumpPosition(position, html, cursor);
        const wLen = words.length;
        const type = "attribute";
        for(let i = 0; i < wLen; i++){
            const word = words[i];
            const isNotPair = word.includes("=");
            if (isNotPair) {
                const secondWord = words[i + 1];
                if (secondWord && secondWord.startsWith("=")) {
                    if (secondWord.length > 1) {
                        const newWord = word + secondWord;
                        tokens.push({
                            type,
                            content: newWord
                        });
                        i += 1;
                        continue;
                    }
                    const thirdWord = words[i + 2];
                    i += 1;
                    if (thirdWord) {
                        const newWord = word + "=" + thirdWord;
                        tokens.push({
                            type,
                            content: newWord
                        });
                        i += 1;
                        continue;
                    }
                }
            }
            if (word.endsWith("=")) {
                const secondWord = words[i + 1];
                if (secondWord && !secondWord.includes("=")) {
                    const newWord2 = word + secondWord;
                    tokens.push({
                        type,
                        content: newWord2
                    });
                    i += 1;
                    continue;
                }
                const newWord = word.slice(0, -1);
                tokens.push({
                    type,
                    content: newWord
                });
                continue;
            }
            tokens.push({
                type,
                content: word
            });
        }
    }
    scanSkipTag(tagName) {
        const { html, position } = this;
        const safeTagName = tagName.toLowerCase();
        const len = html.length;
        while(position.index < len){
            const nextTag = html.indexOf("</", position.index);
            if (nextTag === -1) {
                this.scanText();
                break;
            }
            jumpPosition(position, html, nextTag);
            const name = this.scanTag();
            if (safeTagName === name.toLowerCase()) {
                break;
            }
        }
    }
    constructor(html){
        this.tokens = [];
        this.position = initPosition();
        this.html = html;
    }
};
function unquote(str) {
    const car = str.charAt(0);
    const end = str.length - 1;
    const isQuoteStart = car === '"' || car === "'";
    if (isQuoteStart && car === str.charAt(end)) {
        return str.slice(1, end);
    }
    return str;
}
var LEFT_BRACKET = "{";
var RIGHT_BRACKET = "}";
var CLASS_SELECTOR = ".";
var ID_SELECTOR = "#";
var CHILD_COMBINATOR = ">";
var GENERAL_SIBLING_COMBINATOR = "~";
var ADJACENT_SIBLING_COMBINATOR = "+";
var StyleTagParser = class {
    extractStyle(src) {
        const REG_STYLE = /<style\s?[^>]*>((.|\n|\s)+?)<\/style>/g;
        let html = src;
        html = html.replace(REG_STYLE, (_, $1)=>{
            const style2 = $1.trim();
            this.stringToSelector(style2);
            return "";
        });
        return html.trim();
    }
    stringToSelector(style2) {
        let lb = style2.indexOf(LEFT_BRACKET);
        while(lb > -1){
            const rb = style2.indexOf(RIGHT_BRACKET);
            const selectors = style2.slice(0, lb).trim();
            let content = style2.slice(lb + 1, rb);
            content = content.replace(/:(.*);/g, function(_, $1) {
                const t = $1.trim().replace(/ +/g, "+++");
                return `:${t};`;
            });
            content = content.replace(/ /g, "");
            content = content.replace(/\+\+\+/g, " ");
            if (!/;$/.test(content)) {
                content += ";";
            }
            selectors.split(",").forEach((src)=>{
                const selectorList = this.parseSelector(src);
                this.styles.push({
                    content,
                    selectorList
                });
            });
            style2 = style2.slice(rb + 1);
            lb = style2.indexOf(LEFT_BRACKET);
        }
    }
    parseSelector(src) {
        const list = src.trim().replace(/ *([>~+]) */g, " $1").replace(/ +/g, " ").replace(/\[\s*([^[\]=\s]+)\s*=\s*([^[\]=\s]+)\s*\]/g, "[$1=$2]").split(" ");
        const selectors = list.map((item)=>{
            const firstChar = item.charAt(0);
            const selector = {
                isChild: firstChar === CHILD_COMBINATOR,
                isGeneralSibling: firstChar === GENERAL_SIBLING_COMBINATOR,
                isAdjacentSibling: firstChar === ADJACENT_SIBLING_COMBINATOR,
                tag: null,
                id: null,
                class: [],
                attrs: []
            };
            item = item.replace(/^[>~+]/, "");
            item = item.replace(/\[(.+?)\]/g, function(_, $1) {
                const [key, value] = $1.split("=");
                const all = $1.indexOf("=") === -1;
                const attr = {
                    all,
                    key,
                    value: all ? null : value
                };
                selector.attrs.push(attr);
                return "";
            });
            item = item.replace(/([.#][A-Za-z0-9-_]+)/g, function(_, $1) {
                if ($1[0] === ID_SELECTOR) {
                    selector.id = $1.substr(1);
                } else if ($1[0] === CLASS_SELECTOR) {
                    selector.class.push($1.substr(1));
                }
                return "";
            });
            if (item !== "") {
                selector.tag = item;
            }
            return selector;
        });
        return selectors;
    }
    matchStyle(tagName, el, list) {
        const res = sortStyles(this.styles).reduce((str, { content, selectorList }, i)=>{
            let idx = list[i];
            let selector = selectorList[idx];
            const nextSelector = selectorList[idx + 1];
            if ((nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isGeneralSibling) || (nextSelector === null || nextSelector === void 0 ? void 0 : nextSelector.isAdjacentSibling)) {
                selector = nextSelector;
                idx += 1;
                list[i] += 1;
            }
            let isMatch = this.matchCurrent(tagName, el, selector);
            if (isMatch && selector.isGeneralSibling) {
                let prev = getPreviousElement(el);
                while(prev){
                    if (prev.h5tagName && this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1])) {
                        isMatch = true;
                        break;
                    }
                    prev = getPreviousElement(prev);
                    isMatch = false;
                }
            }
            if (isMatch && selector.isAdjacentSibling) {
                const prev = getPreviousElement(el);
                if (!prev || !prev.h5tagName) {
                    isMatch = false;
                } else {
                    const isSiblingMatch = this.matchCurrent(prev.h5tagName, prev, selectorList[idx - 1]);
                    if (!isSiblingMatch) {
                        isMatch = false;
                    }
                }
            }
            if (isMatch) {
                if (idx === selectorList.length - 1) {
                    return str + content;
                } else if (idx < selectorList.length - 1) {
                    list[i] += 1;
                }
            } else {
                if (selector.isChild && idx > 0) {
                    list[i] -= 1;
                    if (this.matchCurrent(tagName, el, selectorList[list[i]])) {
                        list[i] += 1;
                    }
                }
            }
            return str;
        }, "");
        return res;
    }
    matchCurrent(tagName, el, selector) {
        if (selector.tag && selector.tag !== tagName) return false;
        if (selector.id && selector.id !== el.id) return false;
        if (selector.class.length) {
            const classList = el.className.split(" ");
            for(let i = 0; i < selector.class.length; i++){
                const cls = selector.class[i];
                if (classList.indexOf(cls) === -1) {
                    return false;
                }
            }
        }
        if (selector.attrs.length) {
            for(let i = 0; i < selector.attrs.length; i++){
                const { all, key, value } = selector.attrs[i];
                if (all && !el.hasAttribute(key)) {
                    return false;
                } else {
                    const attr = el.getAttribute(key);
                    if (attr !== unquote(value || "")) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    constructor(){
        this.styles = [];
    }
};
function getPreviousElement(el) {
    const parent = el.parentElement;
    if (!parent) return null;
    const prev = el.previousSibling;
    if (!prev) return null;
    if (prev.nodeType === 1) {
        return prev;
    } else {
        return getPreviousElement(prev);
    }
}
function sortStyles(styles) {
    return styles.sort((s1, s2)=>{
        const hundreds1 = getHundredsWeight(s1.selectorList);
        const hundreds2 = getHundredsWeight(s2.selectorList);
        if (hundreds1 !== hundreds2) return hundreds1 - hundreds2;
        const tens1 = getTensWeight(s1.selectorList);
        const tens2 = getTensWeight(s2.selectorList);
        if (tens1 !== tens2) return tens1 - tens2;
        const ones1 = getOnesWeight(s1.selectorList);
        const ones2 = getOnesWeight(s2.selectorList);
        return ones1 - ones2;
    });
}
function getHundredsWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + (cur.id ? 1 : 0), 0);
}
function getTensWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + cur.class.length + cur.attrs.length, 0);
}
function getOnesWeight(selectors) {
    return selectors.reduce((pre, cur)=>pre + (cur.tag ? 1 : 0), 0);
}
function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for(let i = 0; i < list.length; i++){
        map[list[i]] = true;
    }
    return (val)=>!!map[val.toLowerCase()];
}
var specialMiniElements = {
    img: "image",
    iframe: "web-view"
};
var internalCompsList = Object.keys(internalComponents).map((i)=>i.toLowerCase()).join(",");
var isMiniElements = makeMap(internalCompsList);
var isInlineElements = makeMap("a,i,abbr,iframe,select,acronym,slot,small,span,bdi,kbd,strong,big,map,sub,sup,br,mark,mark,meter,template,canvas,textarea,cite,object,time,code,output,u,data,picture,tt,datalist,var,dfn,del,q,em,s,embed,samp,b");
var isBlockElements = makeMap("address,fieldset,li,article,figcaption,main,aside,figure,nav,blockquote,footer,ol,details,form,p,dialog,h1,h2,h3,h4,h5,h6,pre,dd,header,section,div,hgroup,table,dl,hr,ul,dt");
var closingTagAncestorBreakers = {
    li: [
        "ul",
        "ol",
        "menu"
    ],
    dt: [
        "dl"
    ],
    dd: [
        "dl"
    ],
    tbody: [
        "table"
    ],
    thead: [
        "table"
    ],
    tfoot: [
        "table"
    ],
    tr: [
        "table"
    ],
    td: [
        "table"
    ]
};
function hasTerminalParent(tagName, stack) {
    const tagParents = closingTagAncestorBreakers[tagName];
    if (tagParents) {
        let currentIndex = stack.length - 1;
        while(currentIndex >= 0){
            const parentTagName = stack[currentIndex].tagName;
            if (parentTagName === tagName) {
                break;
            }
            if (tagParents && tagParents.includes(parentTagName)) {
                return true;
            }
            currentIndex--;
        }
    }
    return false;
}
function getTagName(tag) {
    if (options.html.renderHTMLTag) {
        return tag;
    }
    if (specialMiniElements[tag]) {
        return specialMiniElements[tag];
    } else if (isMiniElements(tag)) {
        return tag;
    } else if (isBlockElements(tag)) {
        return "view";
    } else if (isInlineElements(tag)) {
        return "text";
    }
    return "view";
}
function splitEqual(str) {
    const sep = "=";
    const idx = str.indexOf(sep);
    if (idx === -1) return [
        str
    ];
    const key = str.slice(0, idx).trim();
    const value = str.slice(idx + sep.length).trim();
    return [
        key,
        value
    ];
}
function format(children, document2, styleOptions, parent) {
    return children.filter((child)=>{
        if (child.type === "comment") {
            return false;
        } else if (child.type === "text") {
            return child.content !== "";
        }
        return true;
    }).map((child)=>{
        if (child.type === "text") {
            let text = document2.createTextNode(child.content);
            if (isFunction(options.html.transformText)) {
                text = options.html.transformText(text, child);
            }
            parent === null || parent === void 0 ? void 0 : parent.appendChild(text);
            return text;
        }
        const el = document2.createElement(getTagName(child.tagName));
        el.h5tagName = child.tagName;
        parent === null || parent === void 0 ? void 0 : parent.appendChild(el);
        if (!options.html.renderHTMLTag) {
            el.className = `h5-${child.tagName}`;
        }
        for(let i = 0; i < child.attributes.length; i++){
            const attr = child.attributes[i];
            const [key, value] = splitEqual(attr);
            if (key === "class") {
                el.className += " " + unquote(value);
            } else if (key[0] === "o" && key[1] === "n") {
                continue;
            } else {
                el.setAttribute(key, value == null ? true : unquote(value));
            }
        }
        const { styleTagParser, descendantList } = styleOptions;
        const list = descendantList.slice();
        const style2 = styleTagParser.matchStyle(child.tagName, el, list);
        el.setAttribute("style", style2 + el.style.cssText);
        format(child.children, document2, {
            styleTagParser,
            descendantList: list
        }, el);
        if (isFunction(options.html.transformElement)) {
            return options.html.transformElement(el, child);
        }
        return el;
    });
}
function parser(html, document2) {
    const styleTagParser = new StyleTagParser();
    html = styleTagParser.extractStyle(html);
    const tokens = new Scanner(html).scan();
    const root = {
        tagName: "",
        children: [],
        type: "element",
        attributes: []
    };
    const state = {
        tokens,
        cursor: 0,
        stack: [
            root
        ]
    };
    parse(state);
    return format(root.children, document2, {
        styleTagParser,
        descendantList: Array(styleTagParser.styles.length).fill(0)
    });
}
function parse(state) {
    const { tokens, stack } = state;
    let { cursor } = state;
    const len = tokens.length;
    let nodes = stack[stack.length - 1].children;
    while(cursor < len){
        const token = tokens[cursor];
        if (token.type !== "tag-start") {
            nodes.push(token);
            cursor++;
            continue;
        }
        const tagToken = tokens[++cursor];
        cursor++;
        const tagName = tagToken.content.toLowerCase();
        if (token.close) {
            let index = stack.length;
            let shouldRewind = false;
            while(--index > -1){
                if (stack[index].tagName === tagName) {
                    shouldRewind = true;
                    break;
                }
            }
            while(cursor < len){
                const endToken = tokens[cursor];
                if (endToken.type !== "tag-end") break;
                cursor++;
            }
            if (shouldRewind) {
                stack.splice(index);
                break;
            } else {
                continue;
            }
        }
        const isClosingTag = options.html.closingElements.has(tagName);
        let shouldRewindToAutoClose = isClosingTag;
        if (shouldRewindToAutoClose) {
            shouldRewindToAutoClose = !hasTerminalParent(tagName, stack);
        }
        if (shouldRewindToAutoClose) {
            let currentIndex = stack.length - 1;
            while(currentIndex > 0){
                if (tagName === stack[currentIndex].tagName) {
                    stack.splice(currentIndex);
                    const previousIndex = currentIndex - 1;
                    nodes = stack[previousIndex].children;
                    break;
                }
                currentIndex = currentIndex - 1;
            }
        }
        const attributes = [];
        let attrToken;
        while(cursor < len){
            attrToken = tokens[cursor];
            if (attrToken.type === "tag-end") break;
            attributes.push(attrToken.content);
            cursor++;
        }
        cursor++;
        const children = [];
        const element = {
            type: "element",
            tagName: tagToken.content,
            attributes,
            children
        };
        nodes.push(element);
        const hasChildren = !(attrToken.close || options.html.voidElements.has(tagName));
        if (hasChildren) {
            stack.push({
                tagName,
                children
            });
            const innerState = {
                tokens,
                cursor,
                stack
            };
            parse(innerState);
            cursor = innerState.cursor;
        }
    }
    state.cursor = cursor;
}
options.html = {
    skipElements: /* @__PURE__ */ new Set([
        "style",
        "script"
    ]),
    voidElements: /* @__PURE__ */ new Set([
        "!doctype",
        "area",
        "base",
        "br",
        "col",
        "command",
        "embed",
        "hr",
        "img",
        "input",
        "keygen",
        "link",
        "meta",
        "param",
        "source",
        "track",
        "wbr"
    ]),
    closingElements: /* @__PURE__ */ new Set([
        "html",
        "head",
        "body",
        "p",
        "dt",
        "dd",
        "li",
        "option",
        "thead",
        "th",
        "tbody",
        "tr",
        "td",
        "tfoot",
        "colgroup"
    ]),
    renderHTMLTag: false
};
function setInnerHTML(element, html) {
    while(element.firstChild){
        element.removeChild(element.firstChild);
    }
    const children = parser(html, element.ownerDocument);
    for(let i = 0; i < children.length; i++){
        element.appendChild(children[i]);
    }
}
function getBoundingClientRectImpl() {
    if (!options.miniGlobal) return Promise.resolve(null);
    return new Promise((resolve)=>{
        const query = options.miniGlobal.createSelectorQuery();
        if (false) {
            query.select(`#${this.uid}`).boundingClientRect().exec((res)=>{
                resolve(res);
            });
            return;
        }
        query.select(`#${this.uid}`).boundingClientRect((res)=>{
            resolve(res);
        }).exec();
    });
}
function getTemplateContent(ctx) {
    if (ctx.nodeName === "template") {
        const document2 = ctx.ownerDocument;
        const content = document2.createElement(DOCUMENT_FRAGMENT);
        content.childNodes = ctx.childNodes;
        ctx.childNodes = [
            content
        ];
        content.parentNode = ctx;
        content.childNodes.forEach((nodes)=>{
            nodes.parentNode = content;
        });
        return content;
    }
}
function insertAdjacentHTML(position, html) {
    var _a1, _b;
    const parsedNodes = parser(html, this.ownerDocument);
    for(let i = 0; i < parsedNodes.length; i++){
        const n = parsedNodes[i];
        switch(position){
            case "beforebegin":
                (_a1 = this.parentNode) === null || _a1 === void 0 ? void 0 : _a1.insertBefore(n, this);
                break;
            case "afterbegin":
                if (this.hasChildNodes()) {
                    this.insertBefore(n, this.childNodes[0]);
                } else {
                    this.appendChild(n);
                }
                break;
            case "beforeend":
                this.appendChild(n);
                break;
            case "afterend":
                (_b = this.parentNode) === null || _b === void 0 ? void 0 : _b.appendChild(n);
                break;
        }
    }
}
function cloneNode(isDeep = false) {
    const document2 = this.ownerDocument;
    let newNode;
    if (this.nodeType === 1) {
        newNode = document2.createElement(this.nodeName);
    } else if (this.nodeType === 3) {
        newNode = document2.createTextNode("");
    }
    for(const key in this){
        const value = this[key];
        if ([
            PROPS,
            DATASET
        ].includes(key) && typeof value === OBJECT) {
            newNode[key] = Object.assign({}, value);
        } else if (key === "_value") {
            newNode[key] = value;
        } else if (key === STYLE) {
            newNode.style._value = Object.assign({}, value._value);
            newNode.style._usedStyleProp = new Set(Array.from(value._usedStyleProp));
        }
    }
    if (isDeep) {
        newNode.childNodes = this.childNodes.map((node)=>node.cloneNode(true));
    }
    return newNode;
}
function contains(node) {
    let isContains = false;
    this.childNodes.some((childNode)=>{
        const { uid } = childNode;
        if (uid === node.uid || uid === node.id || childNode.contains(node)) {
            isContains = true;
            return true;
        }
    });
    return isContains;
}
if ("web" !== PLATFORM_TYPE.WEB && "web" !== PLATFORM_TYPE.HARMONY) {
    if (ENABLE_INNER_HTML) {
        TaroNode.extend("innerHTML", {
            set (html) {
                setInnerHTML.call(this, this, html);
            },
            get () {
                return "";
            }
        });
        if (ENABLE_ADJACENT_HTML) {
            TaroNode.extend("insertAdjacentHTML", insertAdjacentHTML);
        }
    }
    if (ENABLE_CLONE_NODE) {
        TaroNode.extend("cloneNode", cloneNode);
    }
    if (ENABLE_CONTAINS) {
        TaroNode.extend("contains", contains);
    }
    if (ENABLE_SIZE_APIS) {
        TaroElement.extend("getBoundingClientRect", getBoundingClientRectImpl);
    }
    if (ENABLE_TEMPLATE_CONTENT) {
        TaroElement.extend("content", {
            get () {
                return getTemplateContent(this);
            }
        });
    }
}
var TaroEvent = class {
    stopPropagation() {
        this._stop = true;
    }
    stopImmediatePropagation() {
        this._end = this._stop = true;
    }
    preventDefault() {
        this.defaultPrevented = true;
    }
    get target() {
        var _a1, _b, _c, _d, _e;
        const cacheTarget = this.cacheTarget;
        if (!cacheTarget) {
            const target = Object.create(((_a1 = this.mpEvent) === null || _a1 === void 0 ? void 0 : _a1.target) || null);
            const currentEle = env.document.getElementById(((_b = target.dataset) === null || _b === void 0 ? void 0 : _b.sid) || target.id || null);
            const element = env.document.getElementById(((_c = target.targetDataset) === null || _c === void 0 ? void 0 : _c.sid) || ((_d = target.dataset) === null || _d === void 0 ? void 0 : _d.sid) || target.id || null);
            target.dataset = Object.assign(Object.assign({}, currentEle !== null ? currentEle.dataset : EMPTY_OBJ), element !== null ? element.dataset : EMPTY_OBJ);
            for(const key in (_e = this.mpEvent) === null || _e === void 0 ? void 0 : _e.detail){
                target[key] = this.mpEvent.detail[key];
            }
            this.cacheTarget = target;
            return target;
        } else {
            return cacheTarget;
        }
    }
    get currentTarget() {
        var _a1, _b, _c, _d, _e, _f, _g, _h;
        const cacheCurrentTarget = this.cacheCurrentTarget;
        if (!cacheCurrentTarget) {
            const doc = env.document;
            const currentTarget = Object.create(((_a1 = this.mpEvent) === null || _a1 === void 0 ? void 0 : _a1.currentTarget) || null);
            const element = doc.getElementById(((_b = currentTarget.dataset) === null || _b === void 0 ? void 0 : _b.sid) || currentTarget.id || null);
            const targetElement = doc.getElementById(((_e = (_d = (_c = this.mpEvent) === null || _c === void 0 ? void 0 : _c.target) === null || _d === void 0 ? void 0 : _d.dataset) === null || _e === void 0 ? void 0 : _e.sid) || ((_g = (_f = this.mpEvent) === null || _f === void 0 ? void 0 : _f.target) === null || _g === void 0 ? void 0 : _g.id) || null);
            if (element === null || element && element === targetElement) {
                this.cacheCurrentTarget = this.target;
                return this.target;
            }
            currentTarget.dataset = element.dataset;
            for(const key in (_h = this.mpEvent) === null || _h === void 0 ? void 0 : _h.detail){
                currentTarget[key] = this.mpEvent.detail[key];
            }
            this.cacheCurrentTarget = currentTarget;
            return currentTarget;
        } else {
            return cacheCurrentTarget;
        }
    }
    constructor(type, opts, event){
        this._stop = false;
        this._end = false;
        this.defaultPrevented = false;
        this.button = 0;
        this.timeStamp = Date.now();
        this.type = type.toLowerCase();
        this.mpEvent = event;
        this.bubbles = Boolean(opts && opts.bubbles);
        this.cancelable = Boolean(opts && opts.cancelable);
    }
};
function createEvent(event, node) {
    if (typeof event === "string") {
        return new TaroEvent(event, {
            bubbles: true,
            cancelable: true
        });
    }
    const domEv = new TaroEvent(event.type, {
        bubbles: true,
        cancelable: true
    }, event);
    for(const key in event){
        if (key === CURRENT_TARGET || key === TARGET || key === TYPE || key === TIME_STAMP) {
            continue;
        } else {
            domEv[key] = event[key];
        }
    }
    if (domEv.type === CONFIRM && (node === null || node === void 0 ? void 0 : node.nodeName) === INPUT) {
        domEv[KEY_CODE] = 13;
    }
    return domEv;
}
var eventsBatch = {};
function getEventCBResult(event) {
    const result = event[EVENT_CALLBACK_RESULT];
    if (!isUndefined(result)) {
        delete event[EVENT_CALLBACK_RESULT];
    }
    return result;
}
function eventHandler(event) {
    var _a1, _b;
    event.type === void 0 && Object.defineProperty(event, "type", {
        value: event._type
    });
    event.detail === void 0 && Object.defineProperty(event, "detail", {
        value: event._detail || Object.assign({}, event)
    });
    event.currentTarget = event.currentTarget || event.target || Object.assign({}, event);
    hooks.call("modifyMpEventImpl", event);
    const currentTarget = event.currentTarget;
    const id = ((_a1 = currentTarget.dataset) === null || _a1 === void 0 ? void 0 : _a1.sid) || currentTarget.id || ((_b = event.detail) === null || _b === void 0 ? void 0 : _b.id) || "";
    const node = env.document.getElementById(id);
    if (node) {
        const dispatch = ()=>{
            const e = createEvent(event, node);
            hooks.call("modifyTaroEvent", e, node);
            hooks.call("dispatchTaroEvent", e, node);
            hooks.call("dispatchTaroEventFinish", e, node);
        };
        if (hooks.isExist("batchedEventUpdates")) {
            const type = event.type;
            if (!hooks.call("isBubbleEvents", type) || !isParentBound(node, type) || type === TOUCHMOVE && !!node.props.catchMove) {
                hooks.call("batchedEventUpdates", ()=>{
                    if (eventsBatch[type]) {
                        eventsBatch[type].forEach((fn)=>fn());
                        delete eventsBatch[type];
                    }
                    dispatch();
                });
                return getEventCBResult(event);
            } else {
                (eventsBatch[type] || (eventsBatch[type] = [])).push(dispatch);
            }
        } else {
            dispatch();
            return getEventCBResult(event);
        }
    }
}
var FormElement = class extends TaroElement {
    get type() {
        var _a1;
        return (_a1 = this.props[TYPE]) !== null && _a1 !== void 0 ? _a1 : "";
    }
    set type(val) {
        this.setAttribute(TYPE, val);
    }
    get value() {
        const val = this.props[VALUE];
        return val == null ? "" : val;
    }
    set value(val) {
        this.setAttribute(VALUE, val);
    }
    dispatchEvent(event) {
        if (event.mpEvent) {
            const val = event.mpEvent.detail.value;
            if (event.type === CHANGE) {
                this.props.value = val;
            } else if (event.type === INPUT) {
                this.value = val;
            }
        }
        return super.dispatchEvent(event);
    }
};
var _Performance_instances;
var _Performance_parseTime;
var Performance = class {
    start(id) {
        if (!options.debug) {
            return;
        }
        this.recorder.set(id, Date.now());
    }
    stop(id, now2 = Date.now()) {
        if (!options.debug) {
            return;
        }
        const prev = this.recorder.get(id);
        if (!(prev >= 0)) return;
        this.recorder.delete(id);
        const time = now2 - prev;
        console.log(`${id} \u65F6\u957F\uFF1A ${time}ms \u5F00\u59CB\u65F6\u95F4\uFF1A${__classPrivateFieldGet(this, _Performance_instances, "m", _Performance_parseTime).call(this, prev)} \u7ED3\u675F\u65F6\u95F4\uFF1A${__classPrivateFieldGet(this, _Performance_instances, "m", _Performance_parseTime).call(this, now2)}`);
    }
    delayStop(id, delay = 500) {
        if (!options.debug) {
            return;
        }
        return debounce((now2 = Date.now(), cb)=>{
            this.stop(id, now2);
            cb === null || cb === void 0 ? void 0 : cb();
        }, delay);
    }
    constructor(){
        _Performance_instances.add(this);
        this.recorder = /* @__PURE__ */ new Map();
    }
};
_Performance_instances = /* @__PURE__ */ new WeakSet(), _Performance_parseTime = function _Performance_parseTime2(time) {
    const d = new Date(time);
    return `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}.${`${d.getMilliseconds()}`.padStart(3, "0")}`;
};
var perf = new Performance();
function findCustomWrapper(root, dataPathArr) {
    const list = dataPathArr.slice(1);
    let currentData = root;
    let customWrapper;
    let splitedPath = "";
    list.some((item, i)=>{
        const key = item.replace(/^\[(.+)\]$/, "$1").replace(/\bcn\b/g, "childNodes");
        currentData = currentData[key];
        if (isArray(currentData)) {
            currentData = currentData.filter((el)=>!isComment(el));
        }
        if (isUndefined(currentData)) return true;
        if (currentData.nodeName === CUSTOM_WRAPPER) {
            const res = customWrapperCache.get(currentData.sid);
            if (res) {
                customWrapper = res;
                splitedPath = dataPathArr.slice(i + 2).join(".");
            }
        }
    });
    if (customWrapper) {
        return {
            customWrapper,
            splitedPath
        };
    }
}
var TaroRootElement = class extends TaroElement {
    get _path() {
        return ROOT_STR;
    }
    get _root() {
        return this;
    }
    scheduleTask(fn) {
        setTimeout(fn);
    }
    enqueueUpdate(payload) {
        this.updatePayloads.push(payload);
        if (!this.pendingUpdate && this.ctx) {
            this.performUpdate();
        }
    }
    performUpdate(initRender = false, prerender) {
        this.pendingUpdate = true;
        const ctx = hooks.call("proxyToRaw", this.ctx);
        this.scheduleTask(()=>{
            const setDataMark = `${SET_DATA} \u5F00\u59CB\u65F6\u95F4\u6233 ${Date.now()}`;
            perf.start(setDataMark);
            const data = /* @__PURE__ */ Object.create(null);
            const resetPaths = new Set(initRender ? [
                "root.cn.[0]",
                "root.cn[0]"
            ] : []);
            while(this.updatePayloads.length > 0){
                const { path, value } = this.updatePayloads.shift();
                if (path.endsWith("cn")) {
                    resetPaths.add(path);
                }
                data[path] = value;
            }
            for(const path in data){
                resetPaths.forEach((p)=>{
                    if (path.includes(p) && path !== p) {
                        delete data[path];
                    }
                });
                const value = data[path];
                if (isFunction(value)) {
                    data[path] = value();
                }
            }
            if (isFunction(prerender)) return prerender(data);
            this.pendingUpdate = false;
            let normalUpdate = {};
            const customWrapperMap = /* @__PURE__ */ new Map();
            if (initRender) {
                normalUpdate = data;
            } else {
                for(const p in data){
                    const dataPathArr = p.split(".");
                    const found = findCustomWrapper(this, dataPathArr);
                    if (found) {
                        const { customWrapper, splitedPath } = found;
                        customWrapperMap.set(customWrapper, Object.assign(Object.assign({}, customWrapperMap.get(customWrapper) || {}), {
                            [`i.${splitedPath}`]: data[p]
                        }));
                    } else {
                        normalUpdate[p] = data[p];
                    }
                }
            }
            const customWrapperCount = customWrapperMap.size;
            const isNeedNormalUpdate = Object.keys(normalUpdate).length > 0;
            const updateArrLen = customWrapperCount + (isNeedNormalUpdate ? 1 : 0);
            let executeTime = 0;
            const cb = ()=>{
                if (++executeTime === updateArrLen) {
                    perf.stop(setDataMark);
                    this.flushUpdateCallback();
                    initRender && perf.stop(PAGE_INIT);
                }
            };
            if (customWrapperCount) {
                customWrapperMap.forEach((data2, ctx2)=>{
                    if (options.debug) {
                        console.log("custom wrapper setData: ", data2);
                    }
                    ctx2.setData(data2, cb);
                });
            }
            if (isNeedNormalUpdate) {
                if (options.debug) {
                    console.log("page setData:", normalUpdate);
                }
                ctx.setData(normalUpdate, cb);
            }
        });
    }
    enqueueUpdateCallback(cb, ctx) {
        this.updateCallbacks.push(()=>{
            ctx ? cb.call(ctx) : cb();
        });
    }
    flushUpdateCallback() {
        const updateCallbacks = this.updateCallbacks;
        if (!updateCallbacks.length) return;
        const copies = updateCallbacks.slice(0);
        this.updateCallbacks.length = 0;
        for(let i = 0; i < copies.length; i++){
            copies[i]();
        }
    }
    constructor(){
        super();
        this.updatePayloads = [];
        this.updateCallbacks = [];
        this.pendingUpdate = false;
        this.ctx = null;
        this.nodeName = ROOT_STR;
        this.tagName = ROOT_STR.toUpperCase();
    }
};
var TaroText = class extends TaroNode {
    set textContent(text) {
        MutationObserver$1.record({
            target: this,
            type: "characterData",
            oldValue: this._value
        });
        this._value = text;
        this.enqueueUpdate({
            path: `${this._path}.${"v"}`,
            value: text
        });
    }
    get textContent() {
        return this._value;
    }
    set nodeValue(text) {
        this.textContent = text;
    }
    get nodeValue() {
        return this._value;
    }
    set data(text) {
        this.textContent = text;
    }
    get data() {
        return this._value;
    }
    constructor(value){
        super();
        this.nodeType = 3;
        this.nodeName = "#text";
        this._value = value;
    }
};
var taroDocumentProvider = true ? env.document : env.document = createDocument();
var SVGElement = class extends TaroElement {
};
var instances = /* @__PURE__ */ new Map();
var pageId = incrementId();
function injectPageInstance(inst, id) {
    hooks.call("mergePageInstance", instances.get(id), inst);
    instances.set(id, inst);
}
function getPageInstance(id) {
    return instances.get(id);
}
function removePageInstance(id) {
    instances.delete(id);
}
function safeExecute(path, lifecycle, ...args) {
    const instance = instances.get(path);
    if (instance == null) {
        return;
    }
    const func = hooks.call("getLifecycle", instance, lifecycle);
    if (isArray(func)) {
        const res = func.map((fn)=>fn.apply(instance, args));
        return res[0];
    }
    if (!isFunction(func)) {
        return;
    }
    return func.apply(instance, args);
}
function stringify(obj) {
    if (obj == null) {
        return "";
    }
    const path = Object.keys(obj).map((key)=>{
        return key + "=" + obj[key];
    }).join("&");
    return path === "" ? path : "?" + path;
}
function getPath(id, options2) {
    const idx = id.indexOf("?");
    if (true) {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify((options2 === null || options2 === void 0 ? void 0 : options2.stamp) ? {
            stamp: options2.stamp
        } : {})}`;
    } else {
        return `${idx > -1 ? id.substring(0, idx) : id}${stringify(options2)}`;
    }
}
function getOnReadyEventKey(path) {
    return path + "." + ON_READY;
}
function getOnShowEventKey(path) {
    return path + "." + ON_SHOW;
}
function getOnHideEventKey(path) {
    return path + "." + ON_HIDE;
}
function createPageConfig(component, pageName, data, pageConfig) {
    const id = pageName !== null && pageName !== void 0 ? pageName : `taro_page_${pageId()}`;
    const [ONLOAD, ONUNLOAD, ONREADY, ONSHOW, ONHIDE, LIFECYCLES, SIDE_EFFECT_LIFECYCLES] = hooks.call("getMiniLifecycleImpl").page;
    let pageElement = null;
    let unmounting = false;
    let prepareMountList = [];
    function setCurrentRouter(page) {
        const router = true ? page.$taroPath : page.route || page.__route__ || page.$taroPath;
        Current.router = {
            params: page.$taroParams,
            path: addLeadingSlash(router),
            $taroPath: page.$taroPath,
            onReady: getOnReadyEventKey(id),
            onShow: getOnShowEventKey(id),
            onHide: getOnHideEventKey(id)
        };
        if (!isUndefined(page.exitState)) {
            Current.router.exitState = page.exitState;
        }
    }
    let loadResolver;
    let hasLoaded;
    const config = {
        [ONLOAD] (options2 = {}, cb) {
            hasLoaded = new Promise((resolve)=>{
                loadResolver = resolve;
            });
            perf.start(PAGE_INIT);
            Current.page = this;
            this.config = pageConfig || {};
            const uniqueOptions = Object.assign({}, options2, {
                $taroTimestamp: Date.now()
            });
            const $taroPath = this.$taroPath = getPath(id, uniqueOptions);
            if (true) {
                config.path = $taroPath;
            }
            if (this.$taroParams == null) {
                this.$taroParams = uniqueOptions;
            }
            setCurrentRouter(this);
            if (false) {
                taroWindowProvider.trigger(CONTEXT_ACTIONS.INIT, $taroPath);
            }
            const mount = ()=>{
                Current.app.mount(component, $taroPath, ()=>{
                    pageElement = env.document.getElementById($taroPath);
                    ensure(pageElement !== null, "\u6CA1\u6709\u627E\u5230\u9875\u9762\u5B9E\u4F8B\u3002");
                    safeExecute($taroPath, ON_LOAD, this.$taroParams);
                    loadResolver();
                    if (false) {
                        pageElement.ctx = this;
                        pageElement.performUpdate(true, cb);
                    } else {
                        isFunction(cb) && cb();
                    }
                });
            };
            if (unmounting) {
                prepareMountList.push(mount);
            } else {
                mount();
            }
        },
        [ONUNLOAD] () {
            const $taroPath = this.$taroPath;
            if (false) {
                taroWindowProvider.trigger(CONTEXT_ACTIONS.DESTROY, $taroPath);
            }
            safeExecute($taroPath, ONUNLOAD);
            unmounting = true;
            Current.app.unmount($taroPath, ()=>{
                unmounting = false;
                instances.delete($taroPath);
                if (pageElement) {
                    pageElement.ctx = null;
                    pageElement = null;
                }
                if (prepareMountList.length) {
                    prepareMountList.forEach((fn)=>fn());
                    prepareMountList = [];
                }
            });
        },
        [ONREADY] () {
            hasLoaded.then(()=>{
                safeExecute(this.$taroPath, ON_READY);
                _raf(()=>eventCenter.trigger(getOnReadyEventKey(id)));
                this.onReady.called = true;
            });
        },
        [ONSHOW] (options2 = {}) {
            hasLoaded.then(()=>{
                Current.page = this;
                setCurrentRouter(this);
                if (false) {
                    taroWindowProvider.trigger(CONTEXT_ACTIONS.RECOVER, this.$taroPath);
                }
                safeExecute(this.$taroPath, ON_SHOW, options2);
                _raf(()=>eventCenter.trigger(getOnShowEventKey(id)));
            });
        },
        [ONHIDE] () {
            if (false) {
                taroWindowProvider.trigger(CONTEXT_ACTIONS.RESTORE, this.$taroPath);
            }
            if (Current.page === this) {
                Current.page = null;
                Current.router = null;
            }
            safeExecute(this.$taroPath, ON_HIDE);
            eventCenter.trigger(getOnHideEventKey(id));
        }
    };
    if (true) {
        config.getOpenerEventChannel = ()=>{
            return EventChannel.pageChannel;
        };
    }
    const isSWAN = false;
    LIFECYCLES.forEach((lifecycle)=>{
        let isDefer = false;
        let isEvent = false;
        lifecycle = lifecycle.replace(/^defer:/, ()=>{
            isDefer = true;
            return "";
        });
        lifecycle = lifecycle.replace(/^events:/, ()=>{
            isEvent = true;
            return "";
        });
        if (isEvent && false) {
            if (!config.events) config.events = {};
            config.events[lifecycle] = function() {
                return safeExecute(this.$taroPath, lifecycle, ...arguments);
            };
        } else {
            config[lifecycle] = function() {
                const exec = ()=>safeExecute(this.$taroPath, lifecycle, ...arguments);
                if (isSWAN) {
                    return exec();
                }
                if (isDefer) {
                    hasLoaded.then(exec);
                } else {
                    return exec();
                }
            };
        }
    });
    SIDE_EFFECT_LIFECYCLES.forEach((lifecycle)=>{
        var _a1;
        if (component[lifecycle] || ((_a1 = component.prototype) === null || _a1 === void 0 ? void 0 : _a1[lifecycle]) || component[lifecycle.replace(/^on/, "enable")] || (pageConfig === null || pageConfig === void 0 ? void 0 : pageConfig[lifecycle.replace(/^on/, "enable")])) {
            config[lifecycle] = function(...args) {
                var _a2;
                const target = (_a2 = args[0]) === null || _a2 === void 0 ? void 0 : _a2.target;
                if (target === null || target === void 0 ? void 0 : target.id) {
                    const id2 = target.id;
                    const element = env.document.getElementById(id2);
                    if (element) {
                        target.dataset = element.dataset;
                    }
                }
                return safeExecute(this.$taroPath, lifecycle, ...args);
            };
        }
    });
    config.eh = eventHandler;
    if (!isUndefined(data)) {
        config.data = data;
    }
    hooks.call("modifyPageObject", config);
    return config;
}
function createComponentConfig(component, componentName, data) {
    const id = componentName !== null && componentName !== void 0 ? componentName : `taro_component_${pageId()}`;
    let componentElement = null;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const config = {
        [ATTACHED] () {
            var _a1;
            perf.start(PAGE_INIT);
            this.pageIdCache = ((_a1 = this.getPageId) === null || _a1 === void 0 ? void 0 : _a1.call(this)) || pageId();
            const path = getPath(id, {
                id: this.pageIdCache
            });
            Current.app.mount(component, path, ()=>{
                componentElement = env.document.getElementById(path);
                ensure(componentElement !== null, "\u6CA1\u6709\u627E\u5230\u7EC4\u4EF6\u5B9E\u4F8B\u3002");
                this.$taroInstances = instances.get(path);
                safeExecute(path, ON_LOAD);
                if (false) {
                    componentElement.ctx = this;
                    componentElement.performUpdate(true);
                }
            });
        },
        [DETACHED] () {
            const path = getPath(id, {
                id: this.pageIdCache
            });
            Current.app.unmount(path, ()=>{
                instances.delete(path);
                if (componentElement) {
                    componentElement.ctx = null;
                }
            });
        },
        methods: {
            eh: eventHandler
        }
    };
    if (!isUndefined(data)) {
        config.data = data;
    }
    [
        OPTIONS,
        EXTERNAL_CLASSES,
        BEHAVIORS
    ].forEach((key)=>{
        var _a1;
        config[key] = (_a1 = component[key]) !== null && _a1 !== void 0 ? _a1 : EMPTY_OBJ;
    });
    return config;
}
function createRecursiveComponentConfig(componentName) {
    const isCustomWrapper = componentName === CUSTOM_WRAPPER;
    const [ATTACHED, DETACHED] = hooks.call("getMiniLifecycleImpl").component;
    const lifeCycles = isCustomWrapper ? {
        [ATTACHED] () {
            var _a1, _b;
            const componentId = ((_a1 = this.data.i) === null || _a1 === void 0 ? void 0 : _a1.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.set(componentId, this);
                const el = env.document.getElementById(componentId);
                if (el) {
                    el.ctx = this;
                }
            }
        },
        [DETACHED] () {
            var _a1, _b;
            const componentId = ((_a1 = this.data.i) === null || _a1 === void 0 ? void 0 : _a1.sid) || ((_b = this.props.i) === null || _b === void 0 ? void 0 : _b.sid);
            if (isString(componentId)) {
                customWrapperCache.delete(componentId);
                const el = env.document.getElementById(componentId);
                if (el) {
                    el.ctx = null;
                }
            }
        }
    } : EMPTY_OBJ;
    const extraOptions = {};
    if (false) {
        extraOptions.addGlobalClass = true;
    }
    return hooks.call("modifyRecursiveComponentConfig", Object.assign({
        properties: {
            i: {
                type: Object,
                value: {
                    ["nn"]: getComponentsAlias(internalComponents)[VIEW]._num
                }
            },
            l: {
                type: String,
                value: ""
            }
        },
        options: Object.assign(Object.assign({}, extraOptions), {
            virtualHost: !isCustomWrapper
        }),
        methods: {
            eh: eventHandler
        }
    }, lifeCycles), {
        isCustomWrapper
    });
}
var TIMEOUT = 100;
var nextTick = (cb, ctx)=>{
    const beginTime = Date.now();
    const router = Current.router;
    const timerFunc = ()=>{
        setTimeout(function() {
            ctx ? cb.call(ctx) : cb();
        }, 1);
    };
    if (router === null) return timerFunc();
    const path = router.$taroPath;
    function next() {
        var _a1, _b, _c;
        const pageElement = env.document.getElementById(path);
        if (pageElement === null || pageElement === void 0 ? void 0 : pageElement.pendingUpdate) {
            if (true) {
                (_c = (_b = (_a1 = pageElement.firstChild) === null || _a1 === void 0 ? void 0 : _a1["componentOnReady"]) === null || _b === void 0 ? void 0 : _b.call(_a1).then(()=>{
                    timerFunc();
                })) !== null && _c !== void 0 ? _c : timerFunc();
            } else {
                pageElement.enqueueUpdateCallback(cb, ctx);
            }
        } else if (Date.now() - beginTime > TIMEOUT) {
            timerFunc();
        } else {
            setTimeout(()=>next(), 20);
        }
    }
    next();
};
function handlePolyfill() {
    if (false) {
        handleObjectAssignPolyfill();
    }
    if (false) {
        handleObjectEntriesPolyfill();
    }
    if (false) {
        handleObjectDefinePropertyPolyfill();
    }
    if (false) {
        handleArrayFindPolyfill();
    }
    if (false) {
        handleArrayIncludesPolyfill();
    }
    if (isObject(window)) {
        if (false) {
            handleIntersectionObserverPolyfill();
        }
    }
}
if (false) {
    handlePolyfill();
}
export { Events, EventChannel, isUndefined, isObject, isFunction, isArray, hooks, EMPTY_OBJ, toKebabCase, ensure, __rest, __awaiter, PROPERTY_THRESHOLD, TARO_RUNTIME, HOOKS_APP_ID, SET_DATA, PAGE_INIT, ROOT_STR, HTML, HEAD, BODY, APP, CONTAINER, DOCUMENT_ELEMENT_NAME, DOCUMENT_FRAGMENT, ID, UID, CLASS, STYLE, FOCUS, VIEW, STATIC_VIEW, PURE_VIEW, CLICK_VIEW, PROPS, DATASET, OBJECT, VALUE, INPUT, CHANGE, CUSTOM_WRAPPER, TARGET, CURRENT_TARGET, TYPE, CONFIRM, TIME_STAMP, KEY_CODE, TOUCHMOVE, DATE, SET_TIMEOUT, COMPILE_MODE, CATCHMOVE, CATCH_VIEW, COMMENT, ON_LOAD, ON_READY, ON_SHOW, ON_HIDE, OPTIONS, EXTERNAL_CLASSES, EVENT_CALLBACK_RESULT, BEHAVIORS, A, CONTEXT_ACTIONS, MutationObserver$1, throttle, debounce, eventCenter, env, taroGetComputedStyleProvider, History, Current, getCurrentInstance, URLSearchParams, TaroURLProvider, parseUrl, Location, nav, now, _raf, _caf, taroWindowProvider, taroLocationProvider, taroHistoryProvider, addLeadingSlash, hasBasename, stripBasename, stripTrailing, stripSuffix, getHomePage, getCurrentPage, incrementId, isElement, isText, isComment, isHasExtractProp, isParentBound, shortcutAttr, customWrapperCache, extend, getComponentsAlias2 as getComponentsAlias, convertNumber2PX, eventSource, hydrate, TaroNode, Style, TaroElement, options, TaroEvent, createEvent, eventHandler, FormElement, perf, TaroRootElement, TaroText, taroDocumentProvider, SVGElement, injectPageInstance, getPageInstance, removePageInstance, safeExecute, stringify, getPath, getOnReadyEventKey, getOnShowEventKey, getOnHideEventKey, createPageConfig, createComponentConfig, createRecursiveComponentConfig, nextTick, handlePolyfill };
